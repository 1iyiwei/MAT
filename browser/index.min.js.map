{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloMat","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","default","./index","2","Object","defineProperty","value","smoothen_1","smoothen","find_mat_1","findMat","to_scale_axis_1","toScaleAxis","get_nodes_as_array_1","getNodesAsArray","mat_tree_1","MatTree","point_on_shape_1","PointOnShape","linked_loop_1","LinkedLoop","list_node_1","ListNode","mat_node_1","MatNode","path_curve_1","PathCurve","shape_1","Shape","circle_1","Circle","contact_point_1","ContactPoint","bezier_piece_1","BezierPiece","svg_1","Svg","./lib/geometry/classes/bezier-piece","./lib/geometry/classes/circle","./lib/geometry/classes/path-curve","./lib/geometry/classes/point-on-shape","./lib/geometry/classes/shape","./lib/linked-list/linked-loop","./lib/linked-list/list-node","./lib/mat/classes/contact-point","./lib/mat/classes/mat-node","./lib/mat/classes/mat-tree","./lib/mat/functions/find-mat","./lib/mat/functions/get-nodes-as-array","./lib/mat/functions/smoothen","./lib/mat/functions/to-scale-axis","./lib/svg/svg","3","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","mat_constants_1","flo_vector2d_1","flo_memoize_1","flo_bezier3_1","memoize","m1","bezierNode","type","order","order2","p","evaluate","item","bezier3","pathCurve","ps","κ","radius","maxOsculatingCircleRadius","Math","min","normal","circleCenter","shape","dullCornerHash","makeSimpleKey","pos","pointType","getOsculatingCircle","sharp","extreme","calcOsculatingCircle","compare","b","undefined","res","indx","isPointingStraightUp","circle","circleDirection","toUnitVector","fromTo","center","abs","setPointOrder","dullCorner","dullCornerAt","beziers","tan1pre","tangent","tan1","tan2","dot","toHumanString","typeToStr","../../mat-constants","./circle","flo-bezier3","flo-memoize","flo-vector2d","4","geometry_1","Arc","sinAngle1","cosAngle1","sinAngle2","cosAngle2","startpoint","endpoint","arc","x","y","translate","arco","pp","len","sin_pp","cos_pp","isAngleBetween","r_o_l","position","_asp","_aep","distanceBetween","asp","aep","d1","d2","ds","sqrt","squaredDistanceBetweenPointAndLineSegment","v","l1p2","lineLineIntersection","../geometry","5","tRange","6","c1","c2","d","squaredDistanceBetween","dr","7","Corner","tans","8","reverse","curve","newIndx","slice","9","10","_toConsumableArray","arr","Array","isArray","arr2","from","createSharpCornerCpLoops","sharpCornersArray","contactPointsPerLoop","comparator","k","sharpCorners","cpLoop","prevNode","cp","insert","mat_circle_1","create","prevOnCircle","nextOnCircle","push","orient","bezierLoops","map","isPathPositivelyOrientated","loop","reverseBeziersOrientation","bezierLoop","bezierArray","getAsArray","idx","acos","PI","createCoupledLoops","pointOnShapeArr","posLoop","getCurvatureAtInterface","pss","next","cosθ","sinθ","cross","θ","getTotalBy","node","head","total","get_contact_circles_at_bezier_bezier_interface_1","get_bezier_osculating_circles_1","bezierArrays","_this","skip2ProngHash","straightUpHash","holeClosers","_debug_","generated","timing","start","performance","now","array","extremes","getExtremes","sort","a_","b_","shapeBoundingBox","getLoopBounds","pointOnShapeArrPerLoop","getInterestingPointsOnShape","pointsOnShapePerLoop","_Shape$getPotential2P","getPotential2Prongs","for2ProngsArray","forEachPointOnShape","dull","dullCorners","after1Prongs","pointsOnShape","posNode","for2Prongs","allPointsArray","getInterestingPointsOnLoop","allPoints","pointsOnShape1","prev","apply","pointsOnShape2","standard","firstPoint","lastPoint","splice","atLeast1","_i","_node","_pos","cptree","cps","findBounds","data","max","root","getBoundaryBeziers","bezierPieces","forEach","bezierPiece","getTotalCurvature","totalCurvature","getTotalAbsoluteCurvature","totalAbsoluteCurvature","forAllBeziers","getBoundaryPieceBeziers","δ","keepStraight","arguments","cp0","cp1","goStraight","posThis","pointOnShape","posNext","_pos2","_bezierPiece","bezierNode0","bezierNode1","t1","ii","bNode","_bezierPiece2","_bezierPiece3","console","log","INF","Number","POSITIVE_INFINITY","extremeBeziers","boundingBox","getBoundingBox","j","m","_getLoopBounds","maxXBezierNode","ts","getBounds","tAtMaxX","tan","psNext","tanNext","_getLoopBounds2","../../geometry/classes/bezier-piece","../../geometry/classes/path-curve","../../geometry/classes/point-on-shape","../../linked-list/linked-loop","../../linked-list/list-node","../../mat/classes/contact-point","../../mat/classes/mat-circle","../functions/get-bezier-osculating-circles","../functions/get-contact-circles-at-bezier-bezier-interface","11","calcBezierCurvatureExtremaBrackets","_ps","_slicedToArray","_ps$","x0","y0","_ps$2","x1","y1","_ps$3","x2","y2","_ps$4","x3","y3","brackets","P_1x","P_1y","P_2x","P_2y","P_3x","P_3y","W_0x","W_1x","W_2x","W_0y","W_1y","W_2y","DELTA","atan_numer","atan_denom","atan_numer_squared","atan_denom_squared","radpre","rad","cos_theta","sin_theta","R_1x","R_1y","R_2x","R_2y","R_3x","R_3y","dif","mu","lambda","gamma1","gamma2","sigd_","deReParamBoundary","deReParameterizeBoundary","ssigd_","sda","sdb","NEGATIVE_INFINITY","clipBoundary","ksi_pre1","ksi_pre2","ksi1","ksi2","bound","b0","b1","deReParameterize","sigma","boundary","sliceIterator","_arr","_n","_d","_e","_s","Symbol","iterator","done","err","12","getBezierOsculatingCircles","calc_bezier_curvature_extrema_1","κPs","lenb","bracket","_root","lookForRoot","κAtMinsd","κAtMaxsd","_ref","_ref2","minsd","maxsd","dκMod","flo_poly_1","brent","./calc-bezier-curvature-extrema","flo-poly","13","getClosestBoundaryPointToPoint","bezierPieces_","point","touchedBezierNode","cullBezierPieces","bestDistance","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","closestPointOnBezier","Point_on_shape_1","return","bestSquaredDistance","getClosePoint","cullByLooseBoundingBox","cullByTightBoundingBox","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","evPs","p1","p2","candidateBezierPieces","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","getClosestSquareDistanceToRect","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tightBoundingBox","getBoundingBoxTight","closestSquaredDistanceToRotatedRect","_p","xp","yp","xx0","xx1","xx2","xx3","yy0","yy1","yy2","yy3","x00","x01","x02","x03","x11","x12","x13","x22","x23","x33","y00","y01","y02","y03","y11","y12","y13","y22","y23","y33","t5","t4","t3","t2","t0","poly","deflate","roots","allRoots","push0","push1","getClosest","bestd","p_","../classes/Point-on-shape","14","getContactCirclesAtBezierBezierInterface","bezierNodes","crossTangents","negDot","CROSS_TANGENT_LIMIT","corner_1","orders","DEGREES","0","0.25","15","16","../classes/corner","l1","l2","_l","_l$","p1x","p1y","_l$2","p2x","p2y","_l2","_l2$","p3x","p3y","_l2$2","p4x","p4y","v1x","v1y","v2x","v2y","getLineBoundaryIntersectionPoints","line","points","iPoints","getLineBezierIntersectionPoints","box","_box","_box$","_box$2","_d2","_d3","degAngleFromSinCos","toDeg","atan","arcFrom3Points","midPoint1","mean","midPoint2","chord1","chord2","perpendicular1","perpendicular2","sideVector1","midVector","sideVector2","sinθ1","cosθ1","sinθ2","cosθ2","arc_1","quadrant","isAngle1LargerOrEqual","q1","q2","θ1_larger_θ2","θ_larger_θ2","θ_larger_θ1","lineThroughPointAtRightAngleTo","lineLength","newPs","translateThenRotatePs","getY","Geometry","./classes/arc","./classes/circle","./classes/shape","flo_ll_rb_tree_1","items","addAllFromScratch","prev_","coupledNode","remove","nodes","advanceNSteps","./list-node","flo-ll-rb-tree","17","18","MAT_CONSTANTS","19","matCircle","equal","20","ThreeProngForDebugging","threeProng","deltas","bestIndx","candidateThreeProngs","deltasSimple","delta","../../../geometry/classes/point-on-shape","21","TwoProngForDebugging","z","xs","failed","holeClosing","22","HoleClosing2Prong","k1","k2","cpNodeA2","cpNodeA1","cpNodeB1","cpNodeB2","23","MatCircle","cpNodes","visited","24","branches","matNode","priorNode","newPriorNode","newNode","25","traverse_1","startNode","traverse","../../mat/functions/traverse","26","add2Prong","pos1","pos2","cp2","delta2","getNeighbouringPoints","cmp3","cmp4","newCp2Node","delta1","cmp1","cmp2","newCp1Node","posA1","posB2","copy","cpB2","newCpB2Node","posA2","posB1","cpB1","newCpB1Node","hole_closing_2_prong_1","prepForDebug","contactPoint","cpKey","cpHash","cpArr","arrIndx","cpHashDebugObj","visitedPointsArr","../../geometry/classes/shape","../classes/hole-closing-2-prong","27","add3Prong","delta3s","idxsPrev","idxsNext","28","buildMat","cpNodeStart","fromNode","fromCpNode","isRetry","visitedPoints","traverseShape","findAndAdd3Prong","createMatNode","_matNode2","cpBranches","cpNext","bm","prepDebugHashes","cpNode","visitedPoint","idxi","endP","startP","find_3_prong_1","_i2","add_3_prong_1","nodeHash","../../mat/classes/mat-node","./add-3-prong","./find-3-prong","29","copyMat","matTree","../classes/mat-tree","30","find2Prong","oCircle","shortestSquaredDistance","_bezierPieces","pieces","squaredError","get_closest_boundary_point_to_point_1","SQUARED_1PRONG_TOLERANCE","add1Prong","SQUARED_SEPERATION_TOLERANCE","nextX","findEquidistantPointOnLine","squaredDistance","SQUARED_ERROR_TOLERANCE","MAX_ITERATIONS","recordForDebugging","newCpNode","oneProngs","isNaN","oneProngsAtDullCorner","twoProngForDebugging","two_prong_for_debugging_1","twoProngs","rSquared","newPieces","rect","swapAxes","z1","z2","c","SEPERATION_TOLERANCE","_1PRONG_TOLERANCE","ERROR_TOLERANCE","../../geometry/classes/Point-on-shape","../../geometry/classes/circle","../../geometry/functions/get-closest-boundary-point-to-point","../../geometry/geometry","../classes/debug/two-prong-for-debugging","31","find3Prong","δs","bezierPiecess","smallestError","_find3ProngForDelta3s","find3ProngForDelta3s","error","_debug_2","threeProngForDebugging","three_prong_for_debugging_1","threeProngs","bezierPiece3s","circumCenter","calcInitial3ProngPoint","tolerance","getClosestPoints","vectorToZeroV","calcVectorToZeroV_StraightToIt","upds","calcBetterX","newX","V","newV","totalAngleError","vv","v1","rotate90Degrees","perps","angleError1Pre","angleError2Pre","angleError1","asin","angleError2","angleError","v2","closestDs","closestD","nu","better","shift","scale","newCircleCenter","newVectorToZeroV","twoProngCircleCenter","point1","meanPoints","isFinite","sames","whichNotSame","../classes/debug/three-prong-for-debugging","32","findAndAddHoleClosing2Prongs","findAndAdd2ProngsOnAllPaths","after2Prongs","contactPoints","cptest","branchForth","build_mat_1","branchBack","mat","after3Prongs","fixMat","twoProngInfo","find_2_prong_1","add_2_prong_1","findAndAdd2Prongs","index","indexLinear","firstRight","secondRight","./add-2-prong","./build-mat","./find-2-prong","33","./traverse","34","getNodesAsHash","35","getLinkedCps","prevCpNodes","currCpNodes","prevCpNode","currCpNode","lines","quads","cubes","currNode","getDirectionToNextMatCircle","isPrev","vDir","spanner","bezierNode2","rotate","toLength","prevMatCircle","prevCc","currMatCircle","currCc","_getLinkedCps","_getLinkedCps2","prevL","currL","mid","twisted","dot1","dot2","lp1","vv1","vvv1","lpp1","mid1","mid2","36","mat_","copy_mat_1","get_nodes_as_hash_1","biggest","biggestNode","tree","createSpacialTree","sat","cullHash","traverseSpacialTree","cullem","cullNodes","cullIt","cullTheNodes","afterSat","addToTree","coordinate","limits","depth","_calcGroups","calcGroups","groups","newLimits","group","Map","set","width","height","extraParams","getCullNodes","_key","helper","size","testNode","cullBranch5","branch","engulfsCircle","delete","_calcGroups2","_branch4","newCoordinate","_branch2","_branch3","satNode","anyNotCull","cullTheNode","cullNode","indexOf","limit","q","w","newLimit","qStart","floor","qEnd","qDiff","lowerLimit","_lowerLimit","otherCoordinate","./copy-mat","./get-nodes-as-hash","37","38","pathDataPolyFill","SVGPathElement","getPathData","setPathData","applyPolyFill","commandsMap","Z","M","L","C","Q","A","H","S","T","h","Source","string","_string","_currentIndex","_endIndex","_prevCommand","_skipOptionalSpaces","char","command","values","cmd","toUpperCase","_parseNumber","_parseArcFlag","hasMoreData","peekSegmentType","_isCurrentSpace","exponent","integer","frac","decimal","sign","expsign","startIndex","startIntPartIndex","scanIntPartIndex","multiplier","charAt","number","pow","_skipOptionalSpacesOrDelimiter","flag","flagChar","isIE","navigator","userAgent","parsePathDataString","source","pathData","initialCommandIsMoveTo","pathSeg","parseSegment","setAttribute","removeAttribute","$cachedPathData","$cachedNormalizedPathData","degToRad","degrees","angleRad","cos","sin","arcToCubicCurves","r1","r2","angle","largeArcFlag","sweepFlag","_recursive","f1","f2","cx","cy","params","r1Pow","r2Pow","left","right","toFixed","df","f2old","x2old","y2old","s1","s2","hx","hy","m2","m3","m4","concat","curveParams","params2","curves","param","clonePathData","seg","absolutizePathData","absolutizedPathData","currentX","currentY","subpathX","subpathY","reducePathData","lastType","lastControlX","lastControlY","reducedPathData","cx1","cy1","cx2","cy2","name","options","normalize","getAttribute","normalizedPathData","join","39","getBeziersFromSvgElem","elem","isCloseToOrigin","manhattanLength","isAlmostZeroLength","manhattanDistanceBetween","pushBezier","ps_","interpolate","path_data_polyfill_1","MUST_START_WITH_M","paths","dir","pathStarted","prev2ndCubicControlPoint","prev2ndQuadraticControlPoint","initialPoint","vals","_type","addX","addY","toLowerCase","prevType","_xInterval","_yInterval","_xInterval2","_yInterval2","_xInterval3","_yInterval3","QP0","QP1","QP2","_x3","_y","_QP","_QP2","_QP3","xInterval","yInterval","getPathStrFromBezierLoop","getPathStrFromBeziers","decimalPlaces","D","str","../geometry/classes/path-curve","./path-data-polyfill/path-data-polyfill","40","fromLine","evX","evY","_ps3","_ps3$","_ps3$2","evaluateX","evaluateY","dx","evDx","dy","evDy","ddx","evDdx","evDdy","evaluateDx","evaluateDy","evaluateDdx","evaluateDdy","κds","omt","_ps5","_ps5$","_ps5$2","_ps5$3","_ps5$4","tanPs","interval","flo_gauss_quadrature_1","_ps6","_ps6$","_ps6$2","_ps6$3","_ps6$4","evDs","getTAtLength","lenAtT","xPs","getX","yPs","dPs","getDx","getDy","ddPs","getDdx","getDdy","evaluateDddx","dddPs","getDddx","evaluateDddy","getDddy","getNormalizedBoundingBox","vectorToOrigin","transform","boundingPs","from0ToT","fromTTo1","_ps8","_ps8$","_ps8$2","_ps8$3","_ps8$4","s3","_ps9","_ps9$","_ps9$2","_ps9$3","_ps9$4","splitAt","_ps10","_ps10$","_ps10$2","_ps10$3","_ps10$4","ps1","factor","lineIntersection","tsAtY","tsAtX","toQuadratic","_ps12","_ps12$","_ps12$2","_ps12$3","_ps12$4","toHybridQuadratic","_ps13","_ps13$","_ps13$2","_ps13$3","_ps13$4","evaluateHybridQuadratic","hq","th","P0","P2","evaluateQuadratic","evaluateLinear","_ps14","_ps14$","_ps14$2","clone","_ps15","_ps15$","_ps15$2","_ps15$3","_ps15$4","_ps16","_ps16$","_ps16$2","_ps16$3","toCubic","_ps17","_ps17$","_ps17$2","_ps17$3","coincident","P","calcPointAndNeighbor","pp1","normalVector","pp2","bestT","bestP","bestD","_t2","_P","_Q","_calcPointAndNeighbor","tPQ0","dPQ0","_calcPointAndNeighbor2","tPQ1","dPQ1","_calcPointAndNeighbor3","tQP0","dQP0","_calcPointAndNeighbor4","tQP1","dQP1","tStartQ","tEndQ","tStartP","tEndP","count","tSpanP","_calcPointAndNeighbor5","bezier3Intersection","ps2","Δ","intersection","Q_","P_","qRange","pRange","cidx","_center","_center2","_Q_","_Q_2","Q0","Q3","_P_","_P_2","dQ","getDistanceToLineFunction","dQi","dQs","_dQs","dQ1","dQ2","dMin","dMax","_geoClip","geoClip","tMin","tMax","pSpan","qSpan","_ref3","_ref4","_span","tMinA","tMaxA","tMinB","tMaxB","B","span","tMin_","tMax_","pq","calcOtherT","tss","dPi","_dPs","dH0","dH2","dH10","dH11","dHmin","dHmax","DyMin","DyMax","errorBound","hornerErrorBound","DyMinMin","DyMinMax","DyMaxMin","DyMaxMax","rootsMinMin","rootsMinMax","rootsMaxMin","rootsMaxMax","_P2","_P3","P1","P3","_Q2","_Q3","Q1","Q2","lengthP","sdst","lengthQ","moveX","moveY","_pp","tqsh","tqsv","tqs","tq","δMin","EPSILON","getLineEquation","_l3","_l3$","_l3$2","_getLineEquation","_getLineEquation2","flo_graham_scan_1","_flo_vector2d_1$defau","rotatePs","translatePs","_ps2","_ps2$","_ps2$2","_ps2$3","differentiate","getBoundingHull","curvature","_ps7","_ps7$","_ps7$2","_ps7$3","_ps7$4","baseLength","p0x","p0y","axisAlignedBox","rotateThenTranslatePs","minX","maxX","minY","maxY","tMinX","tMinY","tMaxX","tMaxY","_t","Bezier3","flo-gauss-quadrature","flo-graham-scan","41","gaussQuadrature","_GAUSS_CONSTANTS$orde","GAUSS_CONSTANTS","weights","abscissas","_interval","result","42","FloGrahamScan","stableSort","indxArray","sorted","swap","temp","getSmallestIndxYThenX","smallest","smallestI","grahamScan","includeAllBoundaryPoints","_ps$splice","_ps$splice2","Vector","unshift","p3","ccw","FloVector2d","segSegIntersection","ab","cd","_ab","_cd","denom","rNumer","sNumer","doesSegSegIntersect","scaleFactor","lengthSquared","distanceBetweenPointAndLine","y2_y1","x2_x1","numerator","denominator","triangle","Sx","det3","squaredNorm","Sy","inCenter","l3","lengthSum","centroid","polygon","p0","_p2","_p3","add","sinAngle","cosAngle","reverseRotate","rotateBy90Degrees","rotateByNeg90Degrees","getClosestTo","translatePoints","rotatePoints","translateThenRotatePoints","rotateThenTranslatePoints","43","isRed","color","tree_node_color_1","RED","removeFromArray","otherDir","tree_node_direction_1","LEFT","RIGHT","parent","removeMin","moveRedLeft","fixUp","flipColor","BLACK","flipColors","moveRedRight","tree_node_1","LlRbTree","datas","replaceDups","getMinNode","getMinOrMaxNode","getMaxNode","setComparator","all","bounds","./src/tree-node","./src/tree-node-color","./src/tree-node-direction","44","TreeNodeColor","45","TreeNodeDirection","46","TreeNode","asArray","./tree-node-color","47","SUPPORTED","results","WeakMap","get","Memoize","48","core_operators_1","root_operators_1","root_bounds_1","all_roots_recursive_1","random_1","error_analysis_1","from_roots_1","FloPoly","multiply","assign","random","fromRoots","./src/all-roots-recursive","./src/core-operators","./src/error-analysis","./src/from-roots","./src/random","./src/root-bounds","./src/root-operators","49","clip0","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","rootsWithin","intervals","peval","prevRoot","evA","evB","_core_operators_1$def","_root_operators_1$def","toCasStr","_root_bounds_1$defaul","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","./core-operators","./root-bounds","./root-operators","50","Δd","Δd1","Δd2","subtract","negate","multiplyByConst","fill","degree","evaluateAt0","signChanges","prevSign","bs","invert","changeVariables","_j","acc","reflectAboutYAxis","sturmChain","pnext","clip","maxCoefficient","cStr","toString","coreOperators","51","conditionNumber","errorAnalysis","52","53","createArrFunction","seed","SEED","odds","predictiveRandom","RANGE","randomArray","vs","flatRoots","randArr","flatCoefficients","flatRootsArr","flatCoefficientsArr","./from-roots","54","maxAbs","ns","rootMagnitudeUpperBound_rouche","an","deg","timesUsed","ub","tempub","any","powres","POWERS","rootBounds","55","root1","root2","numRootsWithin","as","bisection","fa","fb","fc","mflag","fac","fab","fbc","b_c","s_b","c_d","fs","_temp","rootOperators","56","Vector2d","sqDst","sqLen","dst","_p4","rotateByθ","us","hUs"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloMat = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = _dereq_(\"./index\").default;\n\n},{\"./index\":2}],2:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar smoothen_1 = _dereq_(\"./lib/mat/functions/smoothen\");\nexports.smoothen = smoothen_1.default;\nvar find_mat_1 = _dereq_(\"./lib/mat/functions/find-mat\");\nexports.findMat = find_mat_1.default;\nvar to_scale_axis_1 = _dereq_(\"./lib/mat/functions/to-scale-axis\");\nexports.toScaleAxis = to_scale_axis_1.default;\nvar get_nodes_as_array_1 = _dereq_(\"./lib/mat/functions/get-nodes-as-array\");\nexports.getNodesAsArray = get_nodes_as_array_1.default;\nvar mat_tree_1 = _dereq_(\"./lib/mat/classes/mat-tree\");\nexports.MatTree = mat_tree_1.default;\nvar point_on_shape_1 = _dereq_(\"./lib/geometry/classes/point-on-shape\");\nexports.PointOnShape = point_on_shape_1.default;\nvar linked_loop_1 = _dereq_(\"./lib/linked-list/linked-loop\");\nexports.LinkedLoop = linked_loop_1.default;\nvar list_node_1 = _dereq_(\"./lib/linked-list/list-node\");\nexports.ListNode = list_node_1.default;\nvar mat_node_1 = _dereq_(\"./lib/mat/classes/mat-node\");\nexports.MatNode = mat_node_1.default;\nvar path_curve_1 = _dereq_(\"./lib/geometry/classes/path-curve\");\nexports.PathCurve = path_curve_1.default;\nvar shape_1 = _dereq_(\"./lib/geometry/classes/shape\");\nexports.Shape = shape_1.default;\nvar circle_1 = _dereq_(\"./lib/geometry/classes/circle\");\nexports.Circle = circle_1.default;\nvar contact_point_1 = _dereq_(\"./lib/mat/classes/contact-point\");\nexports.ContactPoint = contact_point_1.default;\nvar bezier_piece_1 = _dereq_(\"./lib/geometry/classes/bezier-piece\");\nexports.BezierPiece = bezier_piece_1.default;\nvar svg_1 = _dereq_(\"./lib/svg/svg\");\nexports.Svg = svg_1.default;\nvar FloMat = {\n    findMat: find_mat_1.default,\n    toScaleAxis: to_scale_axis_1.default,\n    smoothen: smoothen_1.default,\n    getNodesAsArray: get_nodes_as_array_1.default,\n    MatTree: mat_tree_1.default,\n    PointOnShape: point_on_shape_1.default,\n    LinkedLoop: linked_loop_1.default,\n    ListNode: list_node_1.default,\n    MatNode: mat_node_1.default,\n    PathCurve: path_curve_1.default,\n    Shape: shape_1.default,\n    Circle: circle_1.default,\n    ContactPoint: contact_point_1.default,\n    BezierPiece: bezier_piece_1.default,\n    Svg: svg_1.default\n};\nexports.default = FloMat;\n\n},{\"./lib/geometry/classes/bezier-piece\":5,\"./lib/geometry/classes/circle\":6,\"./lib/geometry/classes/path-curve\":8,\"./lib/geometry/classes/point-on-shape\":9,\"./lib/geometry/classes/shape\":10,\"./lib/linked-list/linked-loop\":16,\"./lib/linked-list/list-node\":17,\"./lib/mat/classes/contact-point\":19,\"./lib/mat/classes/mat-node\":24,\"./lib/mat/classes/mat-tree\":25,\"./lib/mat/functions/find-mat\":32,\"./lib/mat/functions/get-nodes-as-array\":33,\"./lib/mat/functions/smoothen\":35,\"./lib/mat/functions/to-scale-axis\":36,\"./lib/svg/svg\":39}],3:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"./circle\");\nvar memoize = flo_memoize_1.default.m1;\n/**\r\n * @constructor\r\n *\r\n * @param bezierNode\r\n * @param t - The bezier parameter value\r\n * @param type {MAT_CONSTANTS.pointType}\r\n *  'standard' : 0, // Not special,\r\n *  'sharp'    : 1, // Sharp corner,\r\n *  'dull'     : 2, // dull corner,\r\n * @param order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.\r\n * @param order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately.\r\n * @param circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\n\nvar PointOnShape = function () {\n    function PointOnShape(bezierNode, t, type, order, order2) {\n        _classCallCheck(this, PointOnShape);\n\n        this.bezierNode = bezierNode;\n        this.t = t;\n        this.type = type;\n        this.order = order;\n        this.order2 = order2;\n        //---- Cache\n        var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3, t);\n        this.p = p;\n        // Removing this cache will help in that if {PointOnShape} is \n        // called as a parameter (where a point is required) it will more \n        // likely result in monomorphic behaviour as opposed to polymorphic \n        // or megamorphic.\n        this[0] = p[0];\n        this[1] = p[1];\n    }\n    /**\r\n     * Calculates the osculating circle of the bezier at a\r\n     * specific t. If it is found to have negative or nearly zero radius\r\n     * it is clipped to have positive radius so it can point into the shape.\r\n     * @param pathCurve\r\n     * @param t\r\n     */\n\n\n    _createClass(PointOnShape, null, [{\n        key: \"calcOsculatingCircle\",\n        value: function calcOsculatingCircle(pathCurve, t) {\n            var ps = pathCurve.bezier3;\n            var κ = -flo_bezier3_1.default.κ(ps, t);\n            // If (κ > 0) { Bending inwards. }\n            var radius = void 0;\n            if (κ <= 1 / mat_constants_1.default.maxOsculatingCircleRadius) {\n                // Curving wrong way (or flat, or too big), but probably a \n                // significant point to put a 2-prong.\n                radius = mat_constants_1.default.maxOsculatingCircleRadius;\n            } else {\n                radius = Math.min(1 / κ, mat_constants_1.default.maxOsculatingCircleRadius);\n            }\n            var normal = flo_bezier3_1.default.normal(ps, t);\n            var p = flo_bezier3_1.default.evaluate(ps, t);\n            var circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n            return new circle_1.default(circleCenter, radius);\n        }\n    }, {\n        key: \"dullCornerAt\",\n        value: function dullCornerAt(shape, p) {\n            var dullCornerHash = shape.dullCornerHash;\n            var key = PointOnShape.makeSimpleKey(p);\n            return dullCornerHash[key] || null;\n        }\n        /**\r\n         * Clones the PointOnShape.\r\n         */\n        // TODO - rename to clone\n        // TODO - deep clone?\n\n    }, {\n        key: \"copy\",\n        value: function copy(pos) {\n            return new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n        }\n        /**\r\n         * Returns the PointOnShape type as a human-readable\r\n         * string.\r\n         * @param {number} type\r\n         * @returns {string}\r\n         */\n        // TODO - remove - use enum\n\n    }, {\n        key: \"typeToStr\",\n        value: function typeToStr(type) {\n            for (var key in mat_constants_1.default.pointType) {\n                if (mat_constants_1.default.pointType[key] === type) {\n                    return key;\n                }\n            }\n        }\n    }]);\n\n    return PointOnShape;\n}();\n\nPointOnShape.getOsculatingCircle = memoize(function (pos) {\n    if (pos.type === mat_constants_1.default.pointType.sharp) {\n        return new circle_1.default(pos.p, 0);\n    } else if (pos.type === mat_constants_1.default.pointType.extreme) {\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [pos.p[0], pos.p[1] - r];\n        return new circle_1.default(p, r);\n    }\n    return PointOnShape.calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n/**\r\n* Compares two PointOnShapes according to their position on the bezier loop.\r\n*/\nPointOnShape.compare = function (a, b) {\n    if (a === undefined || b === undefined) {\n        return undefined;\n    }\n    var res = void 0;\n    res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order - b.order;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order2 - b.order2;\n    return res;\n};\n/**\r\n* Returns true if its osculation circle is pointing straight upwards.\r\n*/\nPointOnShape.isPointingStraightUp = function (pos) {\n    var circle = PointOnShape.getOsculatingCircle(pos);\n    if (!circle) {\n        return false;\n    }\n    var circleDirection = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    // If not almost pointing straight up\n    if (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Sets the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n    var dullCorner = PointOnShape.dullCornerAt(shape, pos.p);\n    if (!dullCorner) {\n        return;\n    }\n    var ps = dullCorner.beziers[0];\n    var tan1pre = flo_bezier3_1.default.tangent(ps, 1);\n    var tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n    var tan2 = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    pos.order = -flo_vector2d_1.default.dot(tan1, tan2);\n    return pos.order;\n};\n/**\r\n * Creates a string key that only depends on the PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n    return '' + p[0] + ', ' + p[1];\n};\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n    return '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + PointOnShape.typeToStr(pos.type); // TODO - use enum\n};\nexports.default = PointOnShape;\n\n},{\"../../mat-constants\":18,\"./circle\":6,\"flo-bezier3\":40,\"flo-memoize\":47,\"flo-vector2d\":56}],4:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar circle_1 = _dereq_(\"./circle\");\nvar geometry_1 = _dereq_(\"../geometry\");\n\nvar Arc = function () {\n    /**\r\n     * Arc class.\r\n     * If circle === null then the arc degenerates into a line segment\r\n     * given by sinAngle1 and cosAngle2 which now represent points.\r\n     * The arc curve is always defined as the piece from angle1 -> angle2.\r\n     * Note: startpoint and endpoint is redundant\r\n     */\n    function Arc(circle, sinAngle1, cosAngle1, sinAngle2, cosAngle2, startpoint, endpoint) {\n        _classCallCheck(this, Arc);\n\n        // Intrinsic\n        this.circle = circle;\n        this.sinAngle1 = sinAngle1;\n        this.sinAngle2 = sinAngle2;\n        this.cosAngle1 = cosAngle1;\n        this.cosAngle2 = cosAngle2;\n        // Cache\n        this.startpoint = startpoint; // Redundant but useful\n        this.endpoint = endpoint; // Redundant but useful\n    }\n    /**\r\n     * Returns the closest point on the arc.\r\n     * NOTE: Not currently used.\r\n     * @private\r\n     */\n\n\n    _createClass(Arc, null, [{\n        key: \"closestPointOnArc\",\n        value: function closestPointOnArc(p, arc) {\n            if (arc.circle !== null) {\n                // First move arc circle onto origin\n                var x = arc.circle.center[0];\n                var y = arc.circle.center[1];\n                var translate = flo_vector2d_1.default.translate([-x, -y]);\n                var arco = new Arc(new circle_1.default([0, 0], arc.circle.radius), arc.sinAngle1, arc.cosAngle1, arc.sinAngle2, arc.cosAngle2, translate(arc.startpoint), translate(arc.endpoint));\n                var pp = translate(p);\n                var l = flo_vector2d_1.default.len(pp);\n                var sin_pp = -pp[1] / l;\n                var cos_pp = pp[0] / l;\n                if (geometry_1.default.isAngleBetween(sin_pp, cos_pp, arco.sinAngle1, arco.cosAngle1, arco.sinAngle2, arco.cosAngle2)) {\n                    var r_o_l = arco.circle.radius;\n                    var _res = { p: flo_vector2d_1.default.translate([x, y], [r_o_l * cos_pp, r_o_l * -sin_pp]), position: 0 };\n                    return _res;\n                } else {\n                    var _asp = arc.startpoint;\n                    var _aep = arc.endpoint;\n                    var _d = flo_vector2d_1.default.distanceBetween(_asp, p);\n                    var _d2 = flo_vector2d_1.default.distanceBetween(_aep, p);\n                    if (_d < _d2) {\n                        return { p: _asp, position: 1 };\n                    }\n                    return { p: _aep, position: 2 };\n                }\n            }\n            // Line degenerate case - this is exactly a routine for \n            // distance (and closest point) between point and line segment.\n            var asp = arc.startpoint;\n            var aep = arc.endpoint;\n            var d1 = flo_vector2d_1.default.distanceBetween(asp, p);\n            var d2 = flo_vector2d_1.default.distanceBetween(aep, p);\n            var ds = Math.sqrt(flo_vector2d_1.default.squaredDistanceBetweenPointAndLineSegment(p, [asp, aep]));\n            if (d1 <= d2 && d1 <= ds) {\n                return { p: asp, position: 1 };\n            } else if (d2 <= d1 && d2 <= ds) {\n                return { p: aep, position: 2 };\n            }\n            // else ds is shortest\n            var v = flo_vector2d_1.default.fromTo(asp, aep);\n            var l1p2 = [p[0] + v[1], p[1] + -v[0]];\n            var res = {\n                p: geometry_1.default.lineLineIntersection([p, l1p2], [asp, aep]),\n                position: 0\n            };\n            return res;\n        }\n    }]);\n\n    return Arc;\n}();\n\nexports.default = Arc;\n\n},{\"../geometry\":15,\"./circle\":6,\"flo-vector2d\":56}],5:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar BezierPiece =\n/**\r\n * @param bezierNode\r\n * @param tRange\r\n */\nfunction BezierPiece(bezierNode, tRange) {\n    _classCallCheck(this, BezierPiece);\n\n    this.bezierNode = bezierNode;\n    this.tRange = tRange;\n};\n\nexports.default = BezierPiece;\n\n},{}],6:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\n\nvar Circle = function () {\n    /**\r\n    * @param center\r\n    * @param radius\r\n    */\n    function Circle(center, radius) {\n        _classCallCheck(this, Circle);\n\n        this.center = center;\n        this.radius = radius;\n    }\n    /**\r\n     * Returns a scaled version of the given circle without\r\n     * changing its center position.\r\n     * @param circle\r\n     * @param s multiplier\r\n     */\n\n\n    _createClass(Circle, null, [{\n        key: \"scale\",\n        value: function scale(circle, s) {\n            return new Circle(circle.center, circle.radius * s);\n        }\n        /**\r\n         * Returns true if the first circle engulfs the second.\r\n         */\n\n    }, {\n        key: \"engulfsCircle\",\n        value: function engulfsCircle(c1, c2) {\n            if (c1.radius <= c2.radius) {\n                return false;\n            }\n            var d = flo_vector2d_1.default.squaredDistanceBetween(c1.center, c2.center);\n            var dr = c1.radius - c2.radius;\n            var δ = dr * dr;\n            return δ > d;\n        }\n        /**\r\n         * Returns a human-readable string description.\r\n         */\n\n    }, {\n        key: \"toString\",\n        value: function toString(circle) {\n            return 'c: ' + circle.center + ' radius: ' + circle.radius;\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;\n\n},{\"flo-vector2d\":56}],7:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar Corner = function Corner(beziers, tans) {\n    _classCallCheck(this, Corner);\n\n    this.beziers = beziers;\n    this.tans = tans;\n};\n\nexports.default = Corner;\n\n},{}],8:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar PathCurve =\n/**\r\n * An indexed cubic bezier curve.\r\n * @param indx\r\n * @param bezier3\r\n */\nfunction PathCurve(indx, bezier3) {\n    _classCallCheck(this, PathCurve);\n\n    this.indx = indx;\n    this.bezier3 = bezier3;\n};\n/**\r\n * Returns the reverse of the given bezier and assign the new given idx.\r\n * @param {PathCurve} curve - a path curve\r\n * @param {number} idx\r\n * @returns {Bezier3}\r\n */\n\n\nPathCurve.reverse = function (curve, newIndx) {\n    var ps = curve.bezier3.slice().reverse();\n    return new PathCurve(newIndx, ps);\n};\nexports.default = PathCurve;\n\n},{}],9:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"./circle\");\nvar memoize = flo_memoize_1.default.m1;\n/**\r\n * @constructor\r\n *\r\n * @param bezierNode\r\n * @param t - The bezier parameter value\r\n * @param type {MAT_CONSTANTS.pointType}\r\n *  'standard' : 0, // Not special,\r\n *  'sharp'    : 1, // Sharp corner,\r\n *  'dull'     : 2, // dull corner,\r\n * @param order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.\r\n * @param order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately.\r\n * @param circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\n\nvar PointOnShape = function () {\n    function PointOnShape(bezierNode, t, type, order, order2) {\n        _classCallCheck(this, PointOnShape);\n\n        this.bezierNode = bezierNode;\n        this.t = t;\n        this.type = type;\n        this.order = order;\n        this.order2 = order2;\n        //---- Cache\n        var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3, t);\n        this.p = p;\n        // Removing this cache will help in that if {PointOnShape} is \n        // called as a parameter (where a point is required) it will more \n        // likely result in monomorphic behaviour as opposed to polymorphic \n        // or megamorphic.\n        this[0] = p[0];\n        this[1] = p[1];\n    }\n    /**\r\n     * Calculates the osculating circle of the bezier at a\r\n     * specific t. If it is found to have negative or nearly zero radius\r\n     * it is clipped to have positive radius so it can point into the shape.\r\n     * @param pathCurve\r\n     * @param t\r\n     */\n\n\n    _createClass(PointOnShape, null, [{\n        key: \"calcOsculatingCircle\",\n        value: function calcOsculatingCircle(pathCurve, t) {\n            var ps = pathCurve.bezier3;\n            var κ = -flo_bezier3_1.default.κ(ps, t);\n            // If (κ > 0) { Bending inwards. }\n            var radius = void 0;\n            if (κ <= 1 / mat_constants_1.default.maxOsculatingCircleRadius) {\n                // Curving wrong way (or flat, or too big), but probably a \n                // significant point to put a 2-prong.\n                radius = mat_constants_1.default.maxOsculatingCircleRadius;\n            } else {\n                radius = Math.min(1 / κ, mat_constants_1.default.maxOsculatingCircleRadius);\n            }\n            var normal = flo_bezier3_1.default.normal(ps, t);\n            var p = flo_bezier3_1.default.evaluate(ps, t);\n            var circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n            return new circle_1.default(circleCenter, radius);\n        }\n    }, {\n        key: \"dullCornerAt\",\n        value: function dullCornerAt(shape, p) {\n            var dullCornerHash = shape.dullCornerHash;\n            var key = PointOnShape.makeSimpleKey(p);\n            return dullCornerHash[key] || null;\n        }\n        /**\r\n         * Clones the PointOnShape.\r\n         */\n        // TODO - rename to clone\n        // TODO - deep clone?\n\n    }, {\n        key: \"copy\",\n        value: function copy(pos) {\n            return new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n        }\n        /**\r\n         * Returns the PointOnShape type as a human-readable\r\n         * string.\r\n         * @param {number} type\r\n         * @returns {string}\r\n         */\n        // TODO - remove - use enum\n\n    }, {\n        key: \"typeToStr\",\n        value: function typeToStr(type) {\n            for (var key in mat_constants_1.default.pointType) {\n                if (mat_constants_1.default.pointType[key] === type) {\n                    return key;\n                }\n            }\n        }\n    }]);\n\n    return PointOnShape;\n}();\n\nPointOnShape.getOsculatingCircle = memoize(function (pos) {\n    if (pos.type === mat_constants_1.default.pointType.sharp) {\n        return new circle_1.default(pos.p, 0);\n    } else if (pos.type === mat_constants_1.default.pointType.extreme) {\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [pos.p[0], pos.p[1] - r];\n        return new circle_1.default(p, r);\n    }\n    return PointOnShape.calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n/**\r\n* Compares two PointOnShapes according to their position on the bezier loop.\r\n*/\nPointOnShape.compare = function (a, b) {\n    if (a === undefined || b === undefined) {\n        return undefined;\n    }\n    var res = void 0;\n    res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order - b.order;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order2 - b.order2;\n    return res;\n};\n/**\r\n* Returns true if its osculation circle is pointing straight upwards.\r\n*/\nPointOnShape.isPointingStraightUp = function (pos) {\n    var circle = PointOnShape.getOsculatingCircle(pos);\n    if (!circle) {\n        return false;\n    }\n    var circleDirection = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    // If not almost pointing straight up\n    if (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Sets the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n    var dullCorner = PointOnShape.dullCornerAt(shape, pos.p);\n    if (!dullCorner) {\n        return;\n    }\n    var ps = dullCorner.beziers[0];\n    var tan1pre = flo_bezier3_1.default.tangent(ps, 1);\n    var tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n    var tan2 = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    pos.order = -flo_vector2d_1.default.dot(tan1, tan2);\n    return pos.order;\n};\n/**\r\n * Creates a string key that only depends on the PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n    return '' + p[0] + ', ' + p[1];\n};\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n    return '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + PointOnShape.typeToStr(pos.type); // TODO - use enum\n};\nexports.default = PointOnShape;\n\n},{\"../../mat-constants\":18,\"./circle\":6,\"flo-bezier3\":40,\"flo-memoize\":47,\"flo-vector2d\":56}],10:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar path_curve_1 = _dereq_(\"../../geometry/classes/path-curve\");\nvar linked_loop_1 = _dereq_(\"../../linked-list/linked-loop\");\nvar list_node_1 = _dereq_(\"../../linked-list/list-node\");\nvar bezier_piece_1 = _dereq_(\"../../geometry/classes/bezier-piece\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar memoize = flo_memoize_1.default.m1;\n\nvar get_contact_circles_at_bezier_bezier_interface_1 = _dereq_(\"../functions/get-contact-circles-at-bezier-bezier-interface\");\nvar get_bezier_osculating_circles_1 = _dereq_(\"../functions/get-bezier-osculating-circles\");\n\nvar Shape = function () {\n    /**\r\n     * A Shape represents the loop of individual cubic bezier curves composing\r\n     * an SVG element. When constructed, some initial analysis is done.\r\n     * @param bezierArrays - An array (loop) of cubic bezier arrays. Each loop\r\n     * represents a closed path of the shape.\r\n     */\n    function Shape(bezierArrays) {\n        var _this = this;\n\n        _classCallCheck(this, Shape);\n\n        /** Hash of 2-prongs that need to be skipped in 2-prong procedure\r\n        since we already have a hole-closing 2-prong there. */\n        this.skip2ProngHash = {};\n        /** Hash of PointOnShapes that has a normal pointing straight up. */\n        this.straightUpHash = {};\n        /** A hash of all the dull corners (i.e. those with angle > 180 deg) */\n        this.dullCornerHash = {};\n        /** Hole closing 2-prongs that will be populated during find-mat */\n        this.holeClosers = [];\n        // TODO - check if this will run in node (due to window object)\n        if (typeof window !== 'undefined' && window._debug_) {\n            window._debug_.generated.timing.start = performance.now();\n        }\n        // The shape paths and sub-paths, a.k.a bezier loops.\n        var bezierLoops = bezierArrays.map(function (array, k) {\n            return new linked_loop_1.default(array, undefined, k);\n        });\n        // Orient the loops so that the outer loop is oriented positively - \n        // defined as anti-clockwise.  \n        this.bezierLoops = orient(bezierLoops);\n        this.extremes = this.bezierLoops.map(getExtremes);\n        // This is to find the topmost points on each loop.\n        this.extremes.sort(function (a, b) {\n            return a.p[1] - b.p[1];\n        });\n        this.bezierLoops.sort(function (a_, b_) {\n            var a = getExtremes(a_);\n            var b = getExtremes(b_);\n            return a.p[1] - b.p[1];\n        });\n        // Re-index after ordering.\n        for (var i = 0; i < this.bezierLoops.length; i++) {\n            this.bezierLoops[i].indx = i;\n        }\n        // Get metrics of the outer loop. ??\n        this.shapeBoundingBox = getLoopBounds(bezierLoops[0]).shapeBoundingBox;\n        // Gets interesting points on the shape, i.e. those that makes \n        // sense to use for the 2-prong procedure.\n        var pointOnShapeArrPerLoop = Shape.getInterestingPointsOnShape(this);\n        this.pointsOnShapePerLoop = pointOnShapeArrPerLoop.map(function (array, i) {\n            return createCoupledLoops(array, i);\n        });\n        // TODO Finish implementation. This is to space the points more\n        // evenly. \n        //respacePoints(this.contactPointsPerLoop, 30);\n\n        var _Shape$getPotential2P = Shape.getPotential2Prongs(this),\n            sharpCornersArray = _Shape$getPotential2P.sharpCornersArray,\n            for2ProngsArray = _Shape$getPotential2P.for2ProngsArray;\n\n        this.for2ProngsArray = for2ProngsArray;\n        // Take account of sharp and dull corners for debugging and update \n        // straightUpHash.\n        Shape.forEachPointOnShape(this, function (pos) {\n            if (pos.type === mat_constants_1.default.pointType.sharp) {\n                if (typeof window !== 'undefined' && window._debug_) {\n                    var _debug_ = window._debug_;\n                    _debug_.generated.sharpCorners.push({ pos: pos });\n                }\n            } else {\n                if (point_on_shape_1.default.isPointingStraightUp(pos)) {\n                    var key = point_on_shape_1.default.makeSimpleKey(pos.p);\n                    _this.straightUpHash[key] = pos;\n                }\n                if (typeof window !== 'undefined' && window._debug_) {\n                    if (pos.type === mat_constants_1.default.pointType.dull) {\n                        var _debug_2 = window._debug_;\n                        _debug_2.generated.dullCorners.push({ pos: pos });\n                    }\n                }\n            }\n        });\n        this.contactPointsPerLoop = createSharpCornerCpLoops(this, sharpCornersArray);\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            _debug_.generated.timing.after1Prongs = performance.now();\n        }\n    }\n    /**\r\n     * Applies f to each PointOnShape within the shape\r\n     * @param shape - The shape\r\n     * @param f - The function to call.\r\n     */\n\n\n    _createClass(Shape, null, [{\n        key: \"forEachPointOnShape\",\n        value: function forEachPointOnShape(shape, f) {\n            var pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n            for (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n                var pointsOnShape = pointsOnShapePerLoop[k];\n                var posNode = pointsOnShape.head;\n                do {\n                    var pos = posNode.item;\n                    f(pos);\n                    posNode = posNode.next;\n                } while (posNode !== pointsOnShape.head);\n            }\n        }\n        /**\r\n         * Get potential 2-prong points on shape.\r\n         * @param shape\r\n         */\n\n    }, {\n        key: \"getPotential2Prongs\",\n        value: function getPotential2Prongs(shape) {\n            var pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n            var sharpCornersArray = [];\n            var for2ProngsArray = [];\n            for (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n                var pointsOnShape = pointsOnShapePerLoop[k];\n                var sharpCorners = [];\n                var for2Prongs = [];\n                var posNode = pointsOnShape.head;\n                do {\n                    var pos = posNode.item;\n                    if (pos.type === mat_constants_1.default.pointType.sharp) {\n                        sharpCorners.push(pos);\n                    } else {\n                        for2Prongs.push(posNode);\n                    }\n                    posNode = posNode.next;\n                } while (posNode !== pointsOnShape.head);\n                sharpCornersArray.push(sharpCorners);\n                for2ProngsArray.push(for2Prongs);\n            }\n            return { sharpCornersArray: sharpCornersArray, for2ProngsArray: for2ProngsArray };\n        }\n        /**\r\n         * Get useful points on the shape - these incude osculating points and points at\r\n         * the bezier-bezier interfaces.\r\n         * @param shape\r\n         */\n\n    }, {\n        key: \"getInterestingPointsOnShape\",\n        value: function getInterestingPointsOnShape(shape) {\n            var bezierLoops = shape.bezierLoops;\n            var allPointsArray = [];\n            for (var k = 0; k < bezierLoops.length; k++) {\n                var bezierLoop = bezierLoops[k];\n                allPointsArray.push(Shape.getInterestingPointsOnLoop(shape, bezierLoop));\n            }\n            return allPointsArray;\n        }\n        /**\r\n         * TODO - uncomment and finish\r\n         * Get all points where shape intersect itself.\r\n         */\n        /*\r\n        function getSelfIntersections(shape: Shape) {\r\n            //aaa\r\n        }\r\n        */\n        /**\r\n         * @param shape\r\n         * @param bezierLoop\r\n         */\n\n    }, {\n        key: \"getInterestingPointsOnLoop\",\n        value: function getInterestingPointsOnLoop(shape, bezierLoop) {\n            var dullCornerHash = shape.dullCornerHash;\n            var points = [];\n            var allPoints = [];\n            var node = bezierLoop.head;\n            do {\n                //let bezier = node.item;\n                var pointsOnShape1 = get_contact_circles_at_bezier_bezier_interface_1.default([node.prev, node], dullCornerHash);\n                allPoints.push.apply(allPoints, _toConsumableArray(pointsOnShape1));\n                var pointsOnShape2 = get_bezier_osculating_circles_1.default(node);\n                allPoints.push.apply(allPoints, _toConsumableArray(pointsOnShape2));\n                // TODO - remove; experimenting\n                for (var i = 1; i < 2; i++) {\n                    var pos = new point_on_shape_1.default(node, i / 2, mat_constants_1.default.pointType.standard, 0, 0);\n                    allPoints.push(pos);\n                }\n                node = node.next;\n            } while (node !== bezierLoop.head);\n            // Ensure order - first point may be ordered last at this stage\n            // (due to bezier-bezier interface checking)\n            var firstPoint = allPoints[0];\n            var lastPoint = allPoints[allPoints.length - 1];\n            if (point_on_shape_1.default.compare(firstPoint, lastPoint) > 0) {\n                allPoints.push(firstPoint); // Add the first point to the end\n                allPoints.splice(0, 1); // ... and remove the front point.\n            }\n            allPoints.sort(point_on_shape_1.default.compare);\n            // Check if at least one 2-prong has been added. If not, add one.\n            var atLeast1 = false;\n            for (var _i = 0; _i < allPoints.length; _i++) {\n                if (allPoints[_i].type !== mat_constants_1.default.pointType.sharp) {\n                    atLeast1 = true;\n                    break;\n                }\n            }\n            //if (bezierLoop.indx === 0 && !atLeast1) {\n            if (!atLeast1) {\n                // Not a single potential 2-prong found on envelope. Add one \n                // to make the algorithm simpler from here on.\n                var _node = bezierLoop.head;\n                var _pos = new point_on_shape_1.default(_node, 0.4999995, // Can really be anything in the range (0,1)\n                mat_constants_1.default.pointType.standard, 0, 0);\n                allPoints.push(_pos);\n            }\n            return allPoints;\n        }\n        /**\r\n         * Returns the boundary piece that starts at the immediate previous point on\r\n         * the shape and ends at the immediate next point.\r\n         * Note: Uses a red-black tree to quickly find the required bounds\r\n         */\n\n    }, {\n        key: \"getNeighbouringPoints\",\n        value: function getNeighbouringPoints(shape, pos) {\n            var k = pos.bezierNode.loop.indx;\n            var cptree = shape.contactPointsPerLoop[k].cptree;\n            //let cps = cptree.findBounds({ item: new ContactPoint(pos) });\n            // TODO - ugly - improve code\n            var cps = cptree.findBounds(new list_node_1.default(undefined, new contact_point_1.default(pos, undefined), undefined, undefined));\n            if (!cps[0] && !cps[1]) {\n                // The tree is still empty\n                return [undefined, undefined];\n            }\n            if (!cps[0] || !cps[1]) {\n                // Smaller than all -> cptree.min() === cps[1].data OR\n                // Larger than all -> cptree.max() === cps[0].data\n                return [\n                //LlRbTree.max(cptree.root), \n                //LlRbTree.min(cptree.root)\n                cptree.max(cptree.root), cptree.min(cptree.root)];\n            }\n            return [cps[0].data, cps[1].data];\n        }\n    }]);\n\n    return Shape;\n}();\n/**\r\n * TODO - uncomment and finish implementation\r\n * Respace points so that the total absolute curvature between\r\n * consecutive points are very roughly equal.\r\n *\r\n * @param contactPointsPerLoop\r\n * @param maxAbsCurvatureInDegrees\r\n *\r\n * NOTES: Mutates contactPoints.\r\n */\n/*\r\nprivate static respacePoints(\r\n        contactPointsPerLoop: LinkedLoop<ContactPoint>[],\r\n        maxAbsCurvatureInDegrees: number) {\r\n    \r\n    for (let k=0; k<contactPointsPerLoop.length; k++) {\r\n        let contactPoints = contactPointsPerLoop[k];\r\n        \r\n        let cpNode = contactPoints.head;\r\n        let recheck;\r\n        do {\r\n            recheck = false;\r\n            \r\n            let totalCurvatures = [];\r\n            let denseCpNode = cpNode.coupledNode;\r\n            \r\n            do {\r\n                let c = getTotalAbsCurvatureBetweenCps(\r\n                        [denseCpNode.item, denseCpNode.next.item]\r\n                );\r\n                \r\n                totalCurvatures.push({cpNode: denseCpNode, c});\r\n                \r\n                denseCpNode = denseCpNode.next;\r\n            } while (denseCpNode.coupledNode !== cpNode.next);\r\n\r\n            let totalCurvature = sumCurvatures(totalCurvatures);\r\n            \r\n            cpNode.totalCurvatures = totalCurvatures;\r\n            cpNode.totalCurvature  = totalCurvature;\r\n            \r\n            \r\n            let totalInDegrees = totalCurvature * 180 / Math.PI;\r\n            // if (totalInDegrees > 180 || totalInDegrees < 5) { console.log(totalInDegrees); }\r\n            if (totalInDegrees > maxAbsCurvatureInDegrees) {\r\n                // Add a point\r\n                //console.log(totalCurvatures);\r\n                \r\n                let accumTot = 0;\r\n                let tc = cpNode.totalCurvature; // cache\r\n                let bestIndx = undefined;\r\n                let leftDenseIndx = 0;\r\n                let rightDenseIndx;\r\n                let accumTotAtLeft  = 0;\r\n                let accumTotAtRight = undefined;\r\n                let bestDiff = Number.POSITIVE_INFINITY;\r\n                for (let i=0; i<totalCurvatures.length; i++) {\r\n                    \r\n                    let c = totalCurvatures[i].c;\r\n                    let cTot = c.totalCurvature + c.totalTurn;\r\n                    accumTot += cTot;\r\n                    \r\n                    let cpn = totalCurvatures[i].cpNode;\r\n                    if (accumTot <= tc/2) {\r\n                        leftDenseIndx = i;\r\n                        accumTotAtLeft = accumTot;\r\n                    }\r\n\r\n                    if (!rightDenseIndx && accumTot > tc/2) {\r\n                        // This may be out of bounds but really means cpNode.next\r\n                        rightDenseIndx = i;\r\n                        accumTotAtRight = accumTot;\r\n                    }\r\n                \r\n                    let absDiff = Math.abs(tc/2 - accumTot);\r\n                    // TODO - We can also add a weight for point values here\r\n                    // such that for instance inverse curvature points\r\n                    // carry more weight than dull corners, etc.\r\n                    // TODO Make the 1/4 or 1/3 below a constant that can\r\n                    // be set.\r\n                    //if (accumTot > tc/3 && accumTot < 2*tc/3 &&\r\n                    if (accumTot > tc/4 && accumTot < 3*tc/4 &&\r\n                        bestDiff > absDiff) {\r\n                        // If within middle 1/3 and better\r\n                        \r\n                        bestIndx = i;\r\n                        bestDiff = absDiff;\r\n                    }\r\n                }\r\n\r\n                \r\n                // aaa console.log(leftDenseIndx, bestIndx, rightDenseIndx);\r\n                \r\n                if (bestIndx !== undefined) {\r\n                    // Reify the point\r\n                    let tcInfo = totalCurvatures[bestIndx];\r\n                    \r\n                    // Note that after the below insert cpNode.next will\r\n                    // equal the newly inserted cpNode.\r\n                    let newCpNode = LinkedLoop.insert(\r\n                            contactPoints,\r\n                            tcInfo.cpNode.next.item,\r\n                            cpNode,\r\n                            tcInfo.cpNode.next\r\n                    );\r\n                    tcInfo.cpNode.next.coupledNode = newCpNode;\r\n                    \r\n                    cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n                            0, bestIndx+1\r\n                    );\r\n                    cpNode.totalCurvature = sumCurvatures(\r\n                            cpNode.totalCurvatures\r\n                    );\r\n                    \r\n                    recheck = true; // Start again from same contact point.\r\n                } else {\r\n                    // We could not find an 'interesting' point to use, so\r\n                    // find some center point between the two contact\r\n                    // points.\r\n                    \r\n\r\n                    let leftTcInfo  = totalCurvatures[leftDenseIndx];\r\n                    let rightTcInfo = totalCurvatures[rightDenseIndx];\r\n                    \r\n                    let leftCpNode  = leftTcInfo. cpNode;\r\n                    let rightCpNode = rightTcInfo.cpNode;\r\n                    \r\n                    let leftC = leftTcInfo.c;\r\n                    \r\n                    let leftCp = leftTcInfo.cpNode.next;\r\n                    let rightCp = rightTcInfo.cpNode.next;\r\n                    \r\n                    //aaa console.log(accumTotAtLeft,\taccumTotAtRight, tc/2);\r\n                    \r\n                    \r\n                    let pos = getCPointBetweenCps(\r\n                            leftCpNode.item, rightCpNode.item,\r\n                            accumTotAtLeft,\taccumTotAtRight,\r\n                            tc/2\r\n                    );\r\n\r\n                    \r\n                    /*\r\n                    let newCp = new ContactPoint(pos, undefined);\r\n                    let newCpNode = LinkedLoop.insert(\r\n                            contactPoints,\r\n                            newCp,\r\n                            leftCpNode,\r\n                            undefined\r\n                    );\r\n                    \r\n                    let newDenseCpNode = LinkedLoop.insert(\r\n                            denseContactPoints,\r\n                            newCp,\r\n                            cpNode,\r\n                            undefined\r\n                    );\r\n                    \r\n                    newCpNode.coupledNode = newDenseCpNode;\r\n                    newDenseCpNode.coupledNode = newCpNode;\r\n                    \r\n                    \r\n                    aaa\r\n                    cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n                            0, bestIndx\r\n                    );\r\n                    cpNode.totalCurvature = sumCurvatures(\r\n                            cpNode.totalCurvatures\r\n                    );\r\n                    \r\n                    recheck = true; // Start again from same contact point.\r\n                    */ /*\r\n                       }\r\n                       } else if (totalInDegrees < 15) {\r\n                       // Remove a point\r\n                       //console.log(totalCurvatures);\r\n                       }\r\n                       if (!recheck) {\r\n                       cpNode = cpNode.next;\r\n                       }\r\n                       } while (cpNode !== contactPoints.head);\r\n                       }\r\n                       }*/\n/**\r\n *\r\n */\n\n\nShape.getBoundaryBeziers = function (shape, k) {\n    var bezierLoop = shape.bezierLoops[k];\n    var bezierPieces = [];\n    bezierLoop.forEach(function (bezierNode) {\n        var bezierPiece = new bezier_piece_1.default(bezierNode, [0, 1]);\n        bezierPieces.push(bezierPiece);\n    });\n    return bezierPieces;\n};\n/**\r\n *\r\n */\nShape.getTotalCurvature = getTotalBy(function (bezierNode) {\n    var bezierCurvature = flo_bezier3_1.default.totalCurvature(bezierNode.item.bezier3, [0, 1]);\n    var interfaceCurvature = getCurvatureAtInterface(bezierNode);\n    return bezierCurvature + interfaceCurvature;\n});\n/**\r\n *\r\n */\nShape.getTotalAbsoluteCurvature = getTotalBy(function (bezierNode) {\n    return flo_bezier3_1.default.totalAbsoluteCurvature(bezierNode.item.bezier3, [0, 1]) + Math.abs(getCurvatureAtInterface(bezierNode));\n});\n/**\r\n *\r\n */\nShape.forAllBeziers = function (f, shape) {\n    var bezierLoops = shape.bezierLoops;\n    for (var i = 0; i < bezierLoops.length; i++) {\n        var bezierLoop = bezierLoops[i];\n        var node = bezierLoop.head;\n        do {\n            var ps = node.item.bezier3;\n            f(ps);\n            node = node.next;\n        } while (node !== bezierLoop.head);\n    }\n};\n/**\r\n * Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n * from the given boundary piece.\r\n * @param δ - An ordered pair that represents the start and ending points of\r\n * the boundary piece\r\n * @param keepStraight - If true then don't go around any mat circles\r\n */\nShape.getBoundaryPieceBeziers = function (δ) {\n    var keepStraight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var cp0 = δ[0];\n    var cp1 = δ[1];\n    var bezierPieces = [];\n    // As opposed to going around the circle and taking the last exit\n    var goStraight = true;\n    do {\n        if (!goStraight && !keepStraight) {\n            goStraight = true;\n            // Actually, next, next, ..., i.e. take last exit\n            cp0 = cp0.prevOnCircle;\n            continue;\n        }\n        goStraight = false;\n        var posThis = cp0.item.pointOnShape;\n        var posNext = cp0.next.item.pointOnShape;\n        if (posNext.bezierNode === posThis.bezierNode && (posNext.t > posThis.t || posNext.t === posThis.t && posNext.order > posThis.order)) {\n            var pos = cp0.item.pointOnShape;\n            var bezierPiece = new bezier_piece_1.default(pos.bezierNode, [pos.t, posNext.t]);\n            bezierPieces.push(bezierPiece);\n        } else {\n            var _pos2 = cp0.item.pointOnShape;\n            var _bezierPiece = new bezier_piece_1.default(_pos2.bezierNode, [_pos2.t, 1]);\n            bezierPieces.push(_bezierPiece);\n            addSkippedBeziers(bezierPieces, posThis.bezierNode, posNext.bezierNode, posNext.t);\n        }\n        cp0 = cp0.next;\n    } while (cp0 !== cp1);\n    return bezierPieces;\n    /**\r\n     * Adds pieces of skipped beziers\r\n     */\n    function addSkippedBeziers(bezierPieces, bezierNode0, bezierNode1, t1) {\n        var ii = 0;\n        var bNode = bezierNode0;\n        do {\n            ii++;\n            bNode = bNode.next;\n            if (bNode === bezierNode1) {\n                var _bezierPiece2 = new bezier_piece_1.default(bNode, [0, t1]);\n                bezierPieces.push(_bezierPiece2);\n            } else {\n                var _bezierPiece3 = new bezier_piece_1.default(bNode, [0, 1]);\n                bezierPieces.push(_bezierPiece3);\n            }\n        } while (bNode !== bezierNode1 && ii < 100);\n        if (ii === 100) {\n            console.log('maxed');\n        }\n    }\n};\n/**\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornersArray\r\n */\nfunction createSharpCornerCpLoops(shape, sharpCornersArray) {\n    var contactPointsPerLoop = [];\n    var comparator = function comparator(a, b) {\n        return contact_point_1.default.compare(a.item, b.item);\n    };\n    for (var k = 0; k < sharpCornersArray.length; k++) {\n        var sharpCorners = sharpCornersArray[k];\n        var cpLoop = new linked_loop_1.default([], comparator, k);\n        var prevNode = undefined;\n        for (var i = 0; i < sharpCorners.length; i++) {\n            var pos = sharpCorners[i];\n            var cp = new contact_point_1.default(pos, undefined);\n            prevNode = cpLoop.insert(cp, prevNode, undefined);\n            var mCircle = mat_circle_1.default.create(point_on_shape_1.default.getOsculatingCircle(pos), [prevNode]);\n            prevNode.prevOnCircle = prevNode; // Trivial loop\n            prevNode.nextOnCircle = prevNode; // ...\n        }\n        contactPointsPerLoop.push(cpLoop);\n    }\n    return contactPointsPerLoop;\n}\n/**\r\n * Destructively orient the bezier loops so that the outermost loop is\r\n * positively oriented (i.e. counter-clockwise).\r\n */\nfunction orient(bezierLoops) {\n    var orientations = bezierLoops.map(isPathPositivelyOrientated);\n    //console.log(orientations)\n    if (!orientations[0]) {\n        return bezierLoops;\n    } else {\n        var loops = bezierLoops.map(function (loop, k) {\n            return reverseBeziersOrientation(loop, k);\n        });\n        return loops;\n    }\n}\n/**\r\n * Completely reverse the loop direction of the given bezier loop. Returns the\r\n * reversed loop.\r\n * @param bezierLoop\r\n * @param k\r\n */\nfunction reverseBeziersOrientation(bezierLoop, k) {\n    var beziers = [];\n    var bezierArray = bezierLoop.getAsArray();\n    var idx = 0;\n    for (var i = bezierArray.length - 1; i >= 0; i--) {\n        var curve = path_curve_1.default.reverse(bezierArray[i], idx);\n        idx++;\n        beziers.push(curve);\n    }\n    return new linked_loop_1.default(beziers, undefined, k);\n}\n/**\r\n * Returns the the top, left, bottom and right extreme points of the given\r\n * bezier loop, including the bezier nodes they belong to. If an extreme is at a\r\n * bezier-bezier interface the first bezier will always be used (at t=1).\r\n */\nvar getLoopBounds = memoize(function (bezierLoop) {\n    var INF = Number.POSITIVE_INFINITY;\n    var shapeBoundingBox = [[INF, INF], [-INF, -INF]];\n    var extremeBeziers = [[undefined, undefined], [undefined, undefined]];\n    bezierLoop.forEach(function (bezierNode) {\n        var ps = bezierNode.item.bezier3;\n        var boundingBox = flo_bezier3_1.default.getBoundingBox(ps);\n        //console.log(boundingBox)\n        for (var i = 0; i < 2; i++) {\n            for (var j = 0; j < 2; j++) {\n                var v = boundingBox[i][j];\n                var m = i === 0 ? 1 : -1;\n                if (m * v < m * shapeBoundingBox[i][j]) {\n                    shapeBoundingBox[i][j] = v;\n                    extremeBeziers[i][j] = bezierNode;\n                }\n            }\n        }\n    });\n    return { shapeBoundingBox: shapeBoundingBox, extremeBeziers: extremeBeziers };\n});\n/**\r\n * Returns true if the given beizer loop is positively orientated, false\r\n * otherwise.\r\n */\nvar isPathPositivelyOrientated = function isPathPositivelyOrientated(bezierLoop) {\n    var _getLoopBounds = getLoopBounds(bezierLoop),\n        extremeBeziers = _getLoopBounds.extremeBeziers;\n\n    var maxXBezierNode = extremeBeziers[1][0];\n    var ps = maxXBezierNode.item.bezier3;\n    var ts = flo_bezier3_1.default.getBounds(ps).ts;\n    var tAtMaxX = ts[1][0];\n    var tan = flo_bezier3_1.default.tangent(ps)(tAtMaxX);\n    if (tAtMaxX !== 1) {\n        // Not a sharp corner\n        return tan[1] > 0;\n    }\n    var psNext = maxXBezierNode.next.item.bezier3;\n    var tanNext = flo_bezier3_1.default.tangent(psNext)(0);\n    if (tan[1] * tanNext[1] > 0) {\n        // Both tangents points up or both points down.\n        return tan[1] > 0;\n    }\n    // One tangent points up and the other down.\n    return flo_vector2d_1.default.cross(tan, tanNext) > 0;\n    // We don't check for the very special case where the cross === 0. \n};\n/*\r\nclass LoopExtreme {\r\n    p: number[];\r\n    bezierNode: ListNode<number[][]>;\r\n    t: number;\r\n\r\n    constructor(p: number[], bezierNode: ListNode<number[][]>, t: number) {\r\n        this.p = p;\r\n        this.bezierNode = bezierNode;\r\n        this.t = t;\r\n    }\r\n}\r\n*/\n/**\r\n * Get topmost point, bezierNode and t-value of the given loop.\r\n */\nvar getExtremes = memoize(function (bezierLoop) {\n    var _getLoopBounds2 = getLoopBounds(bezierLoop),\n        extremeBeziers = _getLoopBounds2.extremeBeziers;\n\n    var bezierNode = extremeBeziers[0][1]; // Bezier at minimum y\n    var ts = flo_bezier3_1.default.getBounds(bezierNode.item.bezier3).ts;\n    var t = ts[0][1];\n    var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3)(t);\n    //return new LoopExtreme(p, bezierNode, t);\n    return { p: p, bezierNode: bezierNode, t: t };\n});\n/**\r\n * Returns true if bezier box is entirely outside circle box, false otherwise.\r\n *\r\n * Given a circle, bound it tightly by an axes-aligned box (i.e. circle\r\n * box). And given a bezier, bound tightly by a rectangle (not\r\n * necessarily axes aligned) (i.e. bezier box).\r\n */\nfunction isBezierBoxWhollyOutsideCircleBox(ps, circle) {\n    //---- Cache\n    var r = circle.radius;\n    var ox = circle.center[0];\n    var oy = circle.center[1];\n    var radius_2 = r * r;\n    //---- Translate bezier tight bounding box (4 point rectangle) so that circle center is at origin. \n    var boxTight = flo_vector2d_1.default.translatePs([-ox, -oy], flo_bezier3_1.default.getBoundingBoxTight(ps));\n    //---- Rotate circle and rectangle together so that box rectangle is aligned with axes.\n    var boxDiagonal = flo_vector2d_1.default.fromTo(boxTight[0], boxTight[1]);\n    var l = flo_vector2d_1.default.len(boxDiagonal);\n    var sinθ = boxDiagonal[1] / l;\n    var cosθ = boxDiagonal[0] / l;\n    var rotateByθ = flo_vector2d_1.default.rotate(sinθ, -cosθ);\n    var b0 = rotateByθ(boxTight[0]);\n    var b1 = rotateByθ(boxTight[2]);\n    var anyBoxVerticalInside = b0[0] > -r && b0[0] < r || b1[0] > -r && b1[0] < r;\n    var boxVerticalsCapture = b0[0] < -r && b1[0] > r || b1[0] < -r && b0[0] > r;\n    var anyBoxHorizontalInside = b0[1] > -r && b0[1] < r || b1[1] > -r && b1[1] < r;\n    var boxHorizontalsCapture = b0[1] < -r && b1[1] > r || b1[1] < -r && b0[1] > r;\n    if (anyBoxVerticalInside && (anyBoxHorizontalInside || boxHorizontalsCapture) || anyBoxHorizontalInside && (anyBoxVerticalInside || boxVerticalsCapture) || boxVerticalsCapture && boxHorizontalsCapture) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * Floating-point 'safer' version of acos. If x is larger than 1 (or smaller\r\n * than -1), still returns 0 (or Math.PI) instead of NAN.\r\n * @param x\r\n * @example\r\n * \t\tacos(1);  //=> 0\r\n *      acos(2);  //=> 0\r\n */\nfunction acos(x) {\n    if (x > 1) {\n        return 0;\n    } else if (x < -1) {\n        return Math.PI;\n    }\n    return Math.acos(x);\n}\n/**\r\n * TODO - finish implementation - the function below with the same name\r\n * is temporary.\r\n * @param contactPointArr\r\n */ /*\r\n    function createCoupledLoops(contactPointArr, k) {\r\n     let comparator = (a,b) => ContactPoint.compare(a.item, b.item);\r\n    let cpLoop = new LinkedLoop([], comparator, k);\r\n    \n    let denseContactPoints = new LinkedLoop([], undefined, k);\r\n    \n    let prevCpNode = undefined;\r\n    let prevCoupledCpNode = undefined;\r\n    for (let i=0; i<contactPointArr.length; i++) {\r\n       let cp = contactPointArr[i];\r\n       let pos = cp.pointOnShape;\r\n       \r\n       prevCoupledCpNode = LinkedLoop.insert(\r\n               denseContactPoints, cp, prevCoupledCpNode\r\n       );\r\n       // TODO !!!!\r\n       /*\r\n       if (pos.type === MAT_CONSTANTS.pointType.dull) {\r\n           if (acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n               prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n           }\r\n       } else if (pos.type === MAT_CONSTANTS.pointType.sharp) {\r\n           if (acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n               prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n           }\r\n       } else {*/ /*\r\n                  prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n                  //}\r\n                  prevCoupledCpNode.coupledNode = prevCpNode;\r\n                  }\r\n                  return cpLoop;\r\n                  }*/\nfunction createCoupledLoops(pointOnShapeArr, k) {\n    var posLoop = new linked_loop_1.default([], undefined, k);\n    var prevNode = undefined;\n    for (var i = 0; i < pointOnShapeArr.length; i++) {\n        var pos = pointOnShapeArr[i];\n        prevNode = posLoop.insert(pos, prevNode, undefined);\n    }\n    return posLoop;\n}\n/**\r\n * TODO - uncomment and finish\r\n * Finds a point on the shape between the given contact points which\r\n * is as close as possible to a point with accumalated abs curvature\r\n * (from accumAtLeft) equal to totAtMid.\r\n *\r\n * @param leftCp\r\n * @param rightCp\r\n * @param accumTotAtLeft\r\n * @param accumTotAtRight\r\n * @param totAtMid\r\n * @returns {PointOnShape}\r\n */\n/*\r\nfunction getCPointBetweenCps(\r\n        leftCp: ContactPoint,\r\n        rightCp: ContactPoint,\r\n        accumTotAtLeft: number,\r\n        accumTotAtRight: number,\r\n        totAtMid: number) {\r\n    \r\n    let accumTo = totAtMid - accumTotAtLeft;\r\n    \r\n    let posStart = leftCp .pointOnShape;\r\n    let posEnd   = rightCp.pointOnShape;\r\n    \r\n    let bezierNodeStart = posStart.bezierNode;\r\n    let bezierNodeEnd   = posEnd.  bezierNode;\r\n    \r\n    let bezierNode = bezierNodeStart;\r\n    \r\n    let totalTurn = 0;\r\n    let totalCurvature = 0;\r\n    do {\r\n        let turn;\r\n        if (bezierNode !== bezierNodeEnd) {\r\n            turn = Math.abs(getCurvatureAtInterface(bezierNode));\r\n        } else {\r\n            turn = 0;\r\n        }\r\n        \r\n        \r\n        let curvature;\r\n        let interval = [0,1];\r\n        if (bezierNode === bezierNodeStart) { interval[0] = posStart.t; }\r\n        if (bezierNode === bezierNodeEnd)   { interval[1] = posEnd.t; }\r\n        curvature = Bezier3.getTotalAbsoluteCurvature(bezierNode.item.bezier3)(interval);\r\n\r\n        \r\n        totalTurn += turn;\r\n        totalCurvature += curvature;\r\n        \r\n        let totalBoth = totalTurn + totalCurvature;\r\n        if (totalBoth >= accumTo) {\r\n            // aaa console.log('accumTo: ' + accumTo, 'totalBoth: ' + totalBoth);\r\n            break;\r\n        }\r\n        \r\n        bezierNode = bezierNode.next;\r\n    } while (bezierNode.prev !== bezierNodeEnd);\r\n\r\n    \r\n    //return { totalTurn, totalCurvature };\r\n}\r\n*/\n/**\r\n * TODO - uncomment and finish\r\n */\n/*\r\nfunction sumCurvatures(curvatures: number[]): number {\r\n    let total = 0;\r\n    \r\n    for (let i=0; i<curvatures.length; i++) {\r\n        let c = curvatures[i].c;\r\n        \r\n        total += c.totalTurn + c.totalCurvature;\r\n    }\r\n    \r\n    return total;\r\n}\r\n*/\n/**\r\n * TODO - uncomment and finish\r\n * Calculates and returns total absolute curvature between\r\n * the given contact points.\r\n * @param {ContactPoint[]}\r\n * @returns {Object}\r\n */\n/*\r\nfunction getTotalAbsCurvatureBetweenCps([cpStart, cpEnd]) {\r\n    let posStart = cpStart.pointOnShape;\r\n    let posEnd   = cpEnd.  pointOnShape;\r\n    \r\n    let bezierNodeStart = posStart.bezierNode;\r\n    let bezierNodeEnd   = posEnd.  bezierNode;\r\n    \r\n    let bezierNode = bezierNodeStart;\r\n    \r\n    let totalTurn = 0;\r\n    let totalCurvature = 0;\r\n    do {\r\n        let turn;\r\n        if (bezierNode !== bezierNodeEnd) {\r\n            turn = Math.abs(getCurvatureAtInterface(bezierNode));\r\n        } else {\r\n            turn = 0;\r\n        }\r\n        \r\n        \r\n        let curvature;\r\n        let interval = [0,1];\r\n        if (bezierNode === bezierNodeStart) { interval[0] = posStart.t; }\r\n        if (bezierNode === bezierNodeEnd)   { interval[1] = posEnd.t; }\r\n        curvature = Bezier3.getTotalAbsoluteCurvature(bezierNode.item.bezier3)(interval);\r\n\r\n        \r\n        totalTurn += turn;\r\n        totalCurvature += curvature;\r\n        \r\n        bezierNode = bezierNode.next;\r\n    } while (bezierNode.prev !== bezierNodeEnd);\r\n\r\n    \r\n    return { totalTurn, totalCurvature };\r\n}\r\n*/\n/**\r\n * Get the angle between the given bezier endpoint and the\r\n * startpoint of the next bezier.\r\n * @param bezierNode\r\n */\nfunction getCurvatureAtInterface(bezierNode) {\n    var ts = [1, 0];\n    var pss = [bezierNode.item.bezier3, bezierNode.next.item.bezier3];\n    var tans = [flo_bezier3_1.default.tangent(pss[0])(1), flo_bezier3_1.default.tangent(pss[0])(0)];\n    // The integral of a kind of Dirac Delta function.\n    var cosθ = flo_vector2d_1.default.dot(tans[0], tans[1]);\n    var sinθ = flo_vector2d_1.default.cross(tans[0], tans[1]);\n    var θ = acos(cosθ);\n    var result = sinθ >= 0 ? θ : -θ;\n    return result;\n}\n/**\r\n * @description Helper function.\r\n * @param f\r\n * @returns {Funtion}\r\n */\nfunction getTotalBy(f) {\n    return function (bezierLoop) {\n        var node = bezierLoop.head;\n        var total = 0;\n        do {\n            total += f(node);\n            node = node.next;\n        } while (node !== bezierLoop.head);\n        return total;\n    };\n}\nexports.default = Shape;\n\n},{\"../../geometry/classes/bezier-piece\":5,\"../../geometry/classes/path-curve\":8,\"../../geometry/classes/point-on-shape\":9,\"../../linked-list/linked-loop\":16,\"../../linked-list/list-node\":17,\"../../mat-constants\":18,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../functions/get-bezier-osculating-circles\":12,\"../functions/get-contact-circles-at-bezier-bezier-interface\":14,\"flo-bezier3\":40,\"flo-memoize\":47,\"flo-vector2d\":56}],11:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DELTA = 1e-6;\n/**\r\n * Calculates the curvature extrema brackets of the given\r\n * bezier.\r\n *\r\n * See the paper at: http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Note that naming conventions is roughly as in the paper above.\r\n */\nfunction calcBezierCurvatureExtremaBrackets(ps) {\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 2),\n        x0 = _ps$[0],\n        y0 = _ps$[1],\n        _ps$2 = _slicedToArray(_ps[1], 2),\n        x1 = _ps$2[0],\n        y1 = _ps$2[1],\n        _ps$3 = _slicedToArray(_ps[2], 2),\n        x2 = _ps$3[0],\n        y2 = _ps$3[1],\n        _ps$4 = _slicedToArray(_ps[3], 2),\n        x3 = _ps$4[0],\n        y3 = _ps$4[1];\n\n    var brackets = [];\n    // Bezier points translated to origin;\n    var P_1x = x1 - x0;\n    var P_1y = y1 - y0;\n    var P_2x = x2 - x0;\n    var P_2y = y2 - y0;\n    var P_3x = x3 - x0;\n    var P_3y = y3 - y0;\n    // Distance to consecutive points\n    var W_0x = P_1x;\n    var W_1x = P_2x - P_1x;\n    var W_2x = P_3x - P_2x;\n    var W_0y = P_1y;\n    var W_1y = P_2y - P_1y;\n    var W_2y = P_3y - P_2y;\n    // Check for degenerate case in which cubic curve becomes quadratic. \n    if (Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA && Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA) {}\n    // TODO - This case is simpler due to being quadratic but we're \n    // lazy now and will skip it for the moment. \n\n    // See : http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\n    var atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\n    var atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\n    var atan_numer_squared = atan_numer * atan_numer;\n    var atan_denom_squared = atan_denom * atan_denom;\n    var radpre = atan_numer_squared / atan_denom_squared + 1;\n    var rad = Math.sqrt(radpre);\n    var cos_theta = 1 / rad;\n    var sin_theta = void 0;\n    if (cos_theta === 0) {\n        sin_theta = 1;\n    } else {\n        sin_theta = atan_numer / (atan_denom * rad);\n    }\n    // For next rotated points see Maxima file bez5 - here we skip \n    // expensive trig evaluations\n    var R_0x = 0;\n    var R_0y = 0;\n    var R_1x = P_1x * cos_theta - P_1y * sin_theta;\n    var R_1y = P_1x * sin_theta + P_1y * cos_theta;\n    var R_2x = P_2x * cos_theta - P_2y * sin_theta;\n    var R_2y = P_2x * sin_theta + P_2y * cos_theta;\n    var R_3x = P_3x * cos_theta - P_3y * sin_theta;\n    var R_3y = P_3x * sin_theta + P_3y * cos_theta;\n    // Modify W_0x, etc. to be correct for new rotated curve \n    W_0x = R_1x;\n    W_1x = R_2x - R_1x;\n    W_2x = R_3x - R_2x;\n    W_0y = R_1y;\n    W_1y = R_2y - R_1y;\n    W_2y = R_3y - R_2y;\n    var a_ = 3 * (W_0y - 2 * W_1y + W_2y);\n    var dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\n    if (dif === 0) {\n        // Case 1 (special) - W_1x - W_0x === 0\n        // Degenerate to cubic function\t\n        if (W_0x !== 0) {\n            // TODO - FINISH!!!\n            // TODO - we also still need to check for degenerate cubic \n            // (see start of paper)\n        } else {\n            // We have a straight line x=0!\n            return [];\n        }\n    } else {\n        // Case 2 (usual) - W_1x - W_0x !== 0\n        if (dif < 0) {\n            // Reflect curve accross y-axis to make dif > 0\n            R_1x = -R_1x;\n            R_2x = -R_2x;\n            R_3x = -R_3x;\n            // Modify W_0x, etc. to be correct for new reflected \n            W_0x = -W_0x;\n            W_1x = -W_1x;\n            W_2x = -W_2x;\n            dif = -dif;\n        }\n        // From the paper:\n        // ---------------\n        // All curves has exactly one of 4 cases:\n        //\n        // 1. It has a single inflection point and exactly 2 curvature \n        //    maxima (symmetrically positioned about inflection point).\n        //    This is the case if dif === 0 in above code.\n        // 2. It has a single cusp - we ignore this case for now - but \n        //    we must still do it!\n        // 3. It has a point of self-intersection - occurs if d < 0 in \n        //    paper (in code d is called sigd_). \n        // 4. It has 2 inflection points, no cusps, no self-\n        //    intersections.\n        //    It can have either 3 or 5 curvature extrema\n        //    a. The case of 5 curvature extrema is ignored for now - \n        //       in the paper it is mentioned to even find such a curve \n        //       is difficult and it seems such curves have very sharp \n        //       curvature at one point which should not usually occur \n        //       in an SVG shape. \n        //       But this case should later be included or we'll miss \n        //       some points.\n        //    b. There are 3 curvature extrema:\n        //       Extrema occur in the range (-inf, -sqrt(d)), \n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \n        //       Since we dont know how to select -inf and inf we will \n        //       just choose them to be -10 and 11 (remember bezier runs \n        //       from t=0 to t=1). If Brent's method runs out of the \n        //       (0,1) interval we stop and use 0 or 1 as the extremum? \n        //       Remember extrema can also occur at t=0 and t=1!\n        //\n        // At the moment we only test for case 1 and 4b, but in future \n        // we can test and eliminate the other cases.\n        var mu = 6 * dif;\n        var lambda = 3 * a_ * W_0x / (mu * mu);\n        var gamma1 = 3 * a_ * W_0y / (mu * mu);\n        var gamma2 = 3 * (W_1y - W_0y) / mu;\n        // This d in the paper\n        var sigd_ = lambda * lambda - 2 * gamma2 * lambda + gamma1;\n        var b_ = 2 * (gamma2 - lambda);\n        var deReParamBoundary = deReParameterizeBoundary(lambda, mu, a_);\n        if (sigd_ > 0) {\n            var ssigd_ = Math.sqrt(sigd_);\n            //console.log(ssigd_);\n            // de-reparametize\n            // Note: the sda and sdb here are the inflection points for \n            // a case iv!! there are easier ways to calculate these\n            var sda = -ssigd_;\n            var sdb = ssigd_;\n            brackets = [[Number.NEGATIVE_INFINITY, sda], [sda, sdb], [sdb, Number.POSITIVE_INFINITY]].map(deReParamBoundary).map(clipBoundary);\n        } else if (sigd_ < 0) {\n            // Loop \n            // Note: The loop intersection may be outside t=[0,1]. \n            // In fact, for a well behaved shape this is always the \n            // case.\n            // But, curvature maxima may still occur inside t=[0,1] \n            // of course.\n            // There can be 1 or 3 maxima of curvature\n            var ksi_pre1 = 2 * b_ * b_ - 8 * sigd_ - 3;\n            if (ksi_pre1 < 0) {\n                brackets = [[0, Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n            } else {\n                var ksi_pre2 = Math.sqrt(5 * ksi_pre1);\n                var ksi1 = (-5 * b_ - ksi_pre2) / 10;\n                var ksi2 = (-5 * b_ + ksi_pre2) / 10;\n                brackets = [[Number.NEGATIVE_INFINITY, ksi1], [ksi1, Math.min(0, ksi2)], [Math.max(0, ksi2), Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n            }\n        } else if (sigd_ === 0) {\n            // TODO Cusp - ignore for now - lazy\n        }\n    }\n    return brackets;\n}\n/**\r\n * Clips to [0,1] or returns false if not within [0,1].\r\n * @private\r\n */\nfunction clipBoundary(bound) {\n    var b0 = bound[0];\n    var b1 = bound[1];\n    if (b0 < 0 && b1 < 0 || b0 > 1 && b1 > 1) {\n        return undefined;\n    }\n    if (b0 < 0) {\n        b0 = 0;\n    }\n    if (b0 > 1) {\n        b0 = 1;\n    }\n    if (b1 < 0) {\n        b1 = 0;\n    }\n    if (b1 > 1) {\n        b1 = 1;\n    }\n    return [b0, b1];\n}\n/**\r\n * @private\r\n */\nfunction deReParameterize(lambda, mu, a_) {\n    return function (sigma) {\n        return (sigma - lambda) * (mu / a_);\n    };\n}\n/**\r\n * @private\r\n */\nfunction deReParameterizeBoundary(lambda, mu, a_) {\n    return function (boundary) {\n        return boundary.map(deReParameterize(lambda, mu, a_));\n    };\n}\n;\nexports.default = calcBezierCurvatureExtremaBrackets;\n\n},{}],12:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar calc_bezier_curvature_extrema_1 = _dereq_(\"./calc-bezier-curvature-extrema\");\n/**\r\n * Finds the osculating circles for the given bezier.\r\n */\nfunction getBezierOsculatingCircles(bezierNode) {\n    var pointsOnShape = [];\n    var root = void 0;\n    var ps = bezierNode.item.bezier3;\n    var brackets = calc_bezier_curvature_extrema_1.default(ps);\n    var κPs = flo_bezier3_1.default.κ(ps);\n    var lenb = brackets.length;\n    for (var k = 0; k < lenb; k++) {\n        var bracket = brackets[k];\n        if (!bracket) {\n            continue;\n        }\n        var _root = lookForRoot(ps, bracket);\n        if (!_root) {\n            continue;\n        }\n        var κ = -κPs(_root);\n        // Check if local extrema is a maximum or minimum.\n        var κAtMinsd = -κPs(bracket[0]);\n        var κAtMaxsd = -κPs(bracket[1]);\n        if (κ > κAtMinsd && κ > κAtMaxsd) {\n            // maximum\n        } else if (κ <= κAtMinsd && κ <= κAtMaxsd) {\n            // minimum\n            continue;\n        }\n        var pos = new point_on_shape_1.default(bezierNode, _root, mat_constants_1.default.pointType.standard, 0, 0);\n        pointsOnShape.push(pos);\n    }\n    pointsOnShape.sort(point_on_shape_1.default.compare);\n    return pointsOnShape;\n}\nfunction lookForRoot(ps, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        minsd = _ref2[0],\n        maxsd = _ref2[1];\n\n    // At this point there can be exactly 0 or 1 roots within \n    // [minsd, maxsd]\n    var c0 = flo_bezier3_1.default.dκMod(ps)(minsd);\n    var c1 = flo_bezier3_1.default.dκMod(ps)(maxsd);\n    if (c0 * c1 >= 0) {\n        return;\n    }\n    // There is exactly one root in the interval.\n    var root = flo_poly_1.default.brent(flo_bezier3_1.default.dκMod(ps), minsd, maxsd);\n    return root;\n}\nexports.default = getBezierOsculatingCircles;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat-constants\":18,\"./calc-bezier-curvature-extrema\":11,\"flo-bezier3\":40,\"flo-poly\":48}],13:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar geometry_1 = _dereq_(\"../geometry\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar Point_on_shape_1 = _dereq_(\"../classes/Point-on-shape\");\n/**\r\n * Gets the closest boundary point to the given point, limited to the\r\n * given bezier pieces.\r\n *\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedBezierNode\r\n * @returns {PointOnShape} The closest point.\r\n */\nfunction getClosestBoundaryPointToPoint(bezierPieces_, point, touchedBezierNode, t) {\n    var bezierPieces = cullBezierPieces(bezierPieces_, point);\n    var bestDistance = Number.POSITIVE_INFINITY;\n    var pos = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var bezierPiece = _step.value;\n\n            //let bezier = bezierPiece.bezierNode.item;\n            var p = closestPointOnBezier(bezierPiece.bezierNode, point, bezierPiece.tRange, touchedBezierNode, t);\n            var d = p === undefined ? Number.POSITIVE_INFINITY : flo_vector2d_1.default.distanceBetween(p.p, point);\n            if (d < bestDistance) {\n                pos = new Point_on_shape_1.default(bezierPiece.bezierNode, p.t, mat_constants_1.default.pointType.standard, 0, 0);\n                bestDistance = d;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return pos;\n}\nfunction cullBezierPieces(bezierPieces, p) {\n    var CULL_THRESHOLD = 5; // TODO Put somewhere better.\n    var shortCircuit = bezierPieces.length > CULL_THRESHOLD;\n    if (shortCircuit) {\n        // First get an initial point such that the closest point can not be \n        // further than this point.\n        var bestSquaredDistance = getClosePoint(bezierPieces, p);\n        bezierPieces = cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\n        bezierPieces = cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\n    }\n    return bezierPieces;\n}\n/**\r\n * Finds an initial point such that the closest point can not be further than\r\n * this point.\r\n */\nfunction getClosePoint(bezierPieces, p) {\n    var bestSquaredDistance = Number.POSITIVE_INFINITY;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = bezierPieces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var bezierPiece = _step2.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var evPs = flo_bezier3_1.default.evaluate(ps);\n            var p1 = evPs(bezierPiece.tRange[0]);\n            var p2 = evPs(bezierPiece.tRange[1]);\n            var d1 = flo_vector2d_1.default.squaredDistanceBetween(p, p1);\n            var d2 = flo_vector2d_1.default.squaredDistanceBetween(p, p2);\n            var d = Math.min(d1, d2);\n            if (d < bestSquaredDistance) {\n                bestSquaredDistance = d;\n            }\n        }\n        // The extra bit is to account for floating point precision \n        // TODO change 0.01 below to more meaningfull value dependent on \n        // shape dimensions.\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    return bestSquaredDistance + 0.01;\n}\n/**\r\n * When checking distances, ignore all those with closest\r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    var candidateBezierPieces = [];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = bezierPieces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var bezierPiece = _step3.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var boundingBox = flo_bezier3_1.default.getBoundingBox(ps);\n            var d = geometry_1.default.getClosestSquareDistanceToRect(boundingBox, p);\n            if (d <= bestSquaredDistance) {\n                candidateBezierPieces.push(bezierPiece);\n            }\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    return candidateBezierPieces;\n}\n/**\r\n * When checking distances, ignore all those with closest\r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    var candidateBezierPieces = [];\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n        for (var _iterator4 = bezierPieces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var bezierPiece = _step4.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var tightBoundingBox = flo_bezier3_1.default.getBoundingBoxTight(ps);\n            var d = geometry_1.default.closestSquaredDistanceToRotatedRect(tightBoundingBox, p);\n            if (d <= bestSquaredDistance) {\n                candidateBezierPieces.push(bezierPiece);\n            }\n        }\n    } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n            }\n        } finally {\n            if (_didIteratorError4) {\n                throw _iteratorError4;\n            }\n        }\n    }\n\n    return candidateBezierPieces;\n}\n/**\r\n * @private\r\n * @param bezierNode - The bezier\r\n * @param p - The point from which to check\r\n * @param tRange - The allowed t range\r\n * @param touchedBezierNode - The bezier on which p is located\r\n * @param t - The t value of the bezier that locates p\r\n */\nfunction closestPointOnBezier(bezierNode, p, tRange, touchedBezierNode, t) {\n    var ps = bezierNode.item.bezier3;\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\n    // may hint at requiring much fewer assignments?\n\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 2),\n        x0 = _ps$[0],\n        y0 = _ps$[1],\n        _ps$2 = _slicedToArray(_ps[1], 2),\n        x1 = _ps$2[0],\n        y1 = _ps$2[1],\n        _ps$3 = _slicedToArray(_ps[2], 2),\n        x2 = _ps$3[0],\n        y2 = _ps$3[1],\n        _ps$4 = _slicedToArray(_ps[3], 2),\n        x3 = _ps$4[0],\n        y3 = _ps$4[1];\n\n    var _p = _slicedToArray(p, 2),\n        xp = _p[0],\n        yp = _p[1];\n\n    var xx0 = x0 - xp;\n    var xx1 = x1 - xp;\n    var xx2 = x2 - xp;\n    var xx3 = x3 - xp;\n    var yy0 = y0 - yp;\n    var yy1 = y1 - yp;\n    var yy2 = y2 - yp;\n    var yy3 = y3 - yp;\n    var x00 = xx0 * xx0;\n    var x01 = 6 * xx0 * xx1;\n    var x02 = 6 * xx0 * xx2;\n    var x03 = 2 * xx0 * xx3;\n    var x11 = 9 * xx1 * xx1;\n    var x12 = 18 * xx1 * xx2;\n    var x13 = 6 * xx1 * xx3;\n    var x22 = 9 * xx2 * xx2;\n    var x23 = 6 * xx2 * xx3;\n    var x33 = xx3 * xx3;\n    var y00 = yy0 * yy0;\n    var y01 = 6 * yy0 * yy1;\n    var y02 = 6 * yy0 * yy2;\n    var y03 = 2 * yy0 * yy3;\n    var y11 = 9 * yy1 * yy1;\n    var y12 = 18 * yy1 * yy2;\n    var y13 = 6 * yy1 * yy3;\n    var y22 = 9 * yy2 * yy2;\n    var y23 = 6 * yy2 * yy3;\n    var y33 = yy3 * yy3;\n    var t5 = 6 * (x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00 + (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\n    var t4 = 5 * (x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00 + (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\n    var t3 = 4 * (x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00 + (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\n    var t2 = 3 * (x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00 + (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\n    var t1 = 2 * (x02 + x11 - 5 * x01 + 15 * x00 + (y02 + y11 - 5 * y01 + 15 * y00));\n    var t0 = x01 - 6 * x00 + (y01 - 6 * y00);\n    var poly = [t5, t4, t3, t2, t1, t0];\n    if (bezierNode === touchedBezierNode) {\n        var deflatedPoly = flo_poly_1.default.deflate(poly, t);\n        poly = deflatedPoly;\n    }\n    var roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\n    var push0 = true;\n    var push1 = true;\n    if (t === 1 && bezierNode === touchedBezierNode.next || bezierNode === touchedBezierNode && t === 0) {\n        push0 = false;\n    }\n    if (t === 0 && bezierNode === touchedBezierNode.prev || bezierNode === touchedBezierNode && t === 1) {\n        push1 = false;\n    }\n    if (tRange[0] === 0) {\n        if (push0) {\n            roots.push(tRange[0]);\n        }\n    } else if (tRange[0] === 1) {\n        if (push1) {\n            roots.push(tRange[0]);\n        }\n    } else {\n        roots.push(tRange[0]);\n    }\n    if (tRange[1] === 0) {\n        if (push0) {\n            roots.push(tRange[1]);\n        }\n    } else if (tRange[1] === 1) {\n        if (push1) {\n            roots.push(tRange[1]);\n        }\n    } else {\n        roots.push(tRange[1]);\n    }\n    /*\r\n    let closestPs = roots.map(function(root) {\r\n        return Bezier3.evaluate(ps)(root);\r\n    });\r\n    let closestPoint = Vector.getClosestTo(p, closestPs);\r\n    */\n    var closestPs = roots.map(function (root) {\n        return { p: flo_bezier3_1.default.evaluate(ps)(root), t: root };\n    });\n    var closestPoint = getClosest(p, closestPs, function (p1, p2) {\n        return flo_vector2d_1.default.squaredDistanceBetween(p1, p2.p);\n    });\n    return closestPoint;\n}\nfunction getClosest(p, ps, f) {\n    var cp = undefined; // Closest Point\n    var bestd = Number.POSITIVE_INFINITY;\n    for (var i = 0; i < ps.length; i++) {\n        var p_ = ps[i];\n        var d = f(p, p_);\n        if (d < bestd) {\n            cp = p_;\n            bestd = d;\n        }\n    }\n    return cp;\n}\nexports.default = getClosestBoundaryPointToPoint;\n\n},{\"../../mat-constants\":18,\"../classes/Point-on-shape\":3,\"../geometry\":15,\"flo-bezier3\":40,\"flo-poly\":48,\"flo-vector2d\":56}],14:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar corner_1 = _dereq_(\"../classes/corner\");\n// Angle in degrees\nvar DEGREES = {\n    '0': 0.0000,\n    '0.25': 0.0050,\n    '1': 0.0167,\n    '4': 0.0698,\n    '15': 0.2588,\n    '16': 0.2756\n};\nvar CROSS_TANGENT_LIMIT = DEGREES[0.25];\n/**\r\n * Get the circles at the bezier-bezier interface points with circle\r\n * curvature coinciding with the bezier curvature at those points.\r\n *\r\n * @param bezierNodes - The two bezier nodes.\r\n **/\n// TODO dullCornerHash should not be modified inside the function\nfunction getContactCirclesAtBezierBezierInterface(bezierNodes, dullCornerHash) {\n    var ts = [1, 0];\n    var beziers = [0, 1].map(function (i) {\n        return bezierNodes[i].item.bezier3;\n    });\n    var tans = [0, 1].map(function (i) {\n        return flo_bezier3_1.default.tangent(beziers[i], ts[i]);\n    });\n    var crossTangents = +flo_vector2d_1.default.cross(tans[0], tans[1]);\n    var negDot = -flo_vector2d_1.default.dot(tans[0], tans[1]);\n    // The if below is important. Due to floating point approximation\n    // it sometimes happen that crossTangents !== 0 but\n    // negDot === -1. Remove the if and see what happens. :)\n    if (crossTangents === 0 || negDot === -1) {\n        // Too close to call \n        return [];\n    }\n    var p = beziers[0][3];\n    if (crossTangents < -CROSS_TANGENT_LIMIT) {\n        // Sharp corner\n        var pos = new point_on_shape_1.default(bezierNodes[0], 1, mat_constants_1.default.pointType.sharp, 0, 0);\n        return [pos];\n    }\n    if (crossTangents > 0) {\n        var key = point_on_shape_1.default.makeSimpleKey(p);\n        dullCornerHash[key] = new corner_1.default(beziers, tans);\n    }\n    if (crossTangents <= CROSS_TANGENT_LIMIT) {\n        // The interface is too straight, but put a point close-by.\n        // TODO - this point may be order wrong in the end causing \n        // disaster. Fix.\n        var _pos = new point_on_shape_1.default(bezierNodes[0], 0.9, mat_constants_1.default.pointType.standard, 0, 0);\n        return [_pos];\n    }\n    //---- Dull corner\n    var pointsOnShape = [];\n    var orders = [-1, negDot];\n    for (var i = 0; i < 2; i++) {\n        var _pos2 = new point_on_shape_1.default(bezierNodes[i], ts[i], mat_constants_1.default.pointType.dull, orders[i], 0);\n        pointsOnShape.push(_pos2);\n    }\n    return pointsOnShape;\n}\nexports.default = getContactCirclesAtBezierBezierInterface;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat-constants\":18,\"../classes/corner\":7,\"flo-bezier3\":40,\"flo-vector2d\":56}],15:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar circle_1 = _dereq_(\"./classes/circle\");\nvar shape_1 = _dereq_(\"./classes/shape\");\nvar arc_1 = _dereq_(\"./classes/arc\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or null if they don't intersect or are the same line.\r\n * @param l1 - The first line\r\n * @param l2 - The second line\r\n */\nfunction lineLineIntersection(l1, l2) {\n    var _l = _slicedToArray(l1, 2),\n        _l$ = _slicedToArray(_l[0], 2),\n        p1x = _l$[0],\n        p1y = _l$[1],\n        _l$2 = _slicedToArray(_l[1], 2),\n        p2x = _l$2[0],\n        p2y = _l$2[1];\n\n    var _l2 = _slicedToArray(l2, 2),\n        _l2$ = _slicedToArray(_l2[0], 2),\n        p3x = _l2$[0],\n        p3y = _l2$[1],\n        _l2$2 = _slicedToArray(_l2[1], 2),\n        p4x = _l2$2[0],\n        p4y = _l2$2[1];\n\n    var v1x = p2x - p1x;\n    var v1y = p2y - p1y;\n    var v2x = p4x - p3x;\n    var v2y = p4y - p3y;\n    var cross = v2x * v1y - v2y * v1x;\n    if (cross === 0) {\n        // parallel\n        return undefined;\n    }\n    var b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\n    return [p3x + b * v2x, p3y + b * v2y];\n}\n/**\r\n * Get line shape intersection points.\r\n *\r\n * @param line A line described by two points\r\n * @param δ A boundary piece described by start and end contact points\r\n *\r\n * Currently not used\r\n */\nfunction getLineBoundaryIntersectionPoints(line, δ) {\n    var points = [];\n    var bezierPieces = shape_1.default.getBoundaryPieceBeziers(δ);\n    for (var i = 0; i < bezierPieces.length; i++) {\n        var bezierPiece = bezierPieces[i];\n        var ps = bezierPiece.bezierNode.item.bezier3;\n        var iPoints = getLineBezierIntersectionPoints(line, ps, bezierPiece.tRange);\n        for (var j = 0; j < iPoints.length; j++) {\n            points.push(iPoints[j].p);\n        }\n    }\n    return points;\n}\n/**\r\n * @description .\r\n */\nfunction closestSquaredDistanceToRotatedRect(ps, p) {\n    var tightBoundingBox = ps;\n    var ds = [0, 1, 2, 3].map(function (i) {\n        return flo_vector2d_1.default.squaredDistanceBetweenPointAndLineSegment(p, [tightBoundingBox[i], tightBoundingBox[(i + 1) % 4]]);\n    });\n    return Math.min.apply(Math, _toConsumableArray(ds));\n}\n/**\r\n * .\r\n */\nfunction getClosestSquareDistanceToRect(box, p) {\n    var _box = _slicedToArray(box, 2),\n        _box$ = _slicedToArray(_box[0], 2),\n        x0 = _box$[0],\n        y0 = _box$[1],\n        _box$2 = _slicedToArray(_box[1], 2),\n        x1 = _box$2[0],\n        y1 = _box$2[1];\n\n    var _p = _slicedToArray(p, 2),\n        xp = _p[0],\n        yp = _p[1];\n\n    if (xp < x0) {\n        if (yp < y0) {\n            return flo_vector2d_1.default.squaredDistanceBetween(box[0], p);\n        } else if (yp > y1) {\n            return flo_vector2d_1.default.squaredDistanceBetween([x0, y1], p);\n        } else {\n            var d = x0 - xp;\n            return d * d;\n        }\n    } else if (xp > x1) {\n        if (yp < y0) {\n            return flo_vector2d_1.default.squaredDistanceBetween([x1, y0], p);\n        } else if (yp > y1) {\n            return flo_vector2d_1.default.squaredDistanceBetween(box[1], p);\n        } else {\n            var _d = xp - x1;\n            return _d * _d;\n        }\n    } else {\n        if (yp < y0) {\n            var _d2 = y0 - yp;\n            return _d2 * _d2;\n        } else if (yp > y1) {\n            var _d3 = yp - y1;\n            return _d3 * _d3;\n        } else {\n            return 0;\n        }\n    }\n}\n/**\r\n * Returns the angle (in degrees) given the sine and the cosine of an angle.\r\n * @private\r\n */\nfunction degAngleFromSinCos(sinθ, cosθ) {\n    var toDeg = function toDeg(θ) {\n        return θ * (180 / Math.PI);\n    };\n    if (cosθ === 0) {\n        if (sinθ > 0) {\n            return 90;\n        }\n        return 270;\n    }\n    if (cosθ > 0) {\n        return toDeg(Math.atan(sinθ / cosθ));\n    }\n    return 180 + toDeg(Math.atan(sinθ / cosθ));\n}\n/**\r\n * Returns a directional arc from 3 ordered points.\r\n */\nfunction arcFrom3Points(ps) {\n    var midPoint1 = flo_vector2d_1.default.mean([ps[0], ps[1]]);\n    var midPoint2 = flo_vector2d_1.default.mean([ps[1], ps[2]]);\n    var chord1 = flo_vector2d_1.default.fromTo(ps[0], ps[1]);\n    var chord2 = flo_vector2d_1.default.fromTo(ps[1], ps[2]);\n    var perpendicular1 = [chord1[1], -chord1[0]];\n    var perpendicular2 = [chord2[1], -chord2[0]];\n    var l1 = [midPoint1, flo_vector2d_1.default.translate(perpendicular1, midPoint1)];\n    var l2 = [midPoint2, flo_vector2d_1.default.translate(perpendicular2, midPoint2)];\n    var circleCenter = lineLineIntersection(l1, l2);\n    var arc = void 0;\n    if (!circleCenter) {\n        // TODO - not right - fix\n        /*\r\n        // The circle is in effect a line segment.\r\n        if (Vector.equal(ps[0], ps[2])) {\r\n            return null;\r\n        }\r\n        arc = new Arc(null, ps[0], ps[2]);\r\n        return arc;\r\n        */\n        return undefined;\n    }\n    var sideVector1 = flo_vector2d_1.default.fromTo(circleCenter, ps[0]);\n    var midVector = flo_vector2d_1.default.fromTo(circleCenter, ps[1]);\n    var sideVector2 = flo_vector2d_1.default.fromTo(circleCenter, ps[2]);\n    var radius = flo_vector2d_1.default.len(sideVector1);\n    var sinθ1 = -sideVector1[1] / radius;\n    var cosθ1 = sideVector1[0] / radius;\n    var sinθ2 = -sideVector2[1] / radius;\n    var cosθ2 = sideVector2[0] / radius;\n    var sin_midangle = -midVector[1] / radius;\n    var cos_midangle = midVector[0] / radius;\n    if (isAngleBetween(sin_midangle, cos_midangle, sinθ1, cosθ1, sinθ2, cosθ2)) {\n        arc = new arc_1.default(new circle_1.default(circleCenter, radius), sinθ1, cosθ1, sinθ2, cosθ2, ps[0], ps[2]);\n    } else {\n        arc = new arc_1.default(new circle_1.default(circleCenter, radius), sinθ2, cosθ2, sinθ1, cosθ1, ps[2], ps[0]);\n    }\n    return arc;\n}\n/**\r\n * @description .\r\n */\nfunction quadrant(sinθ, cosθ) {\n    if (sinθ >= 0) {\n        if (cosθ >= 0) {\n            return 1;\n        }\n        return 2;\n    }\n    if (cosθ >= 0) {\n        return 4;\n    }\n    return 3;\n}\n/**\r\n * @description .\r\n */\nfunction isAngle1LargerOrEqual(sinθ1, cosθ1, sinθ2, cosθ2) {\n    var q1 = quadrant(sinθ1, cosθ1);\n    var q2 = quadrant(sinθ2, cosθ2);\n    if (q1 > q2) {\n        return true;\n    }\n    if (q1 < q2) {\n        return false;\n    }\n    // Same quadrant\n    if (q1 === 1 || q1 === 4) {\n        return sinθ1 >= sinθ2;\n    }\n    return sinθ1 <= sinθ2;\n}\n/**\r\n * Returns true if angle1 < angle < angle2 in the non-trivial sense.\r\n */\nfunction isAngleBetween(sinθ, cosθ, sinθ1, cosθ1, sinθ2, cosθ2) {\n    var θ1_larger_θ2 = isAngle1LargerOrEqual(sinθ1, cosθ1, sinθ2, cosθ2);\n    var θ_larger_θ2 = isAngle1LargerOrEqual(sinθ, cosθ, sinθ2, cosθ2);\n    var θ_larger_θ1 = isAngle1LargerOrEqual(sinθ, cosθ, sinθ1, cosθ1);\n    return θ1_larger_θ2 ? θ_larger_θ1 || !θ_larger_θ2 : θ_larger_θ1 && !θ_larger_θ2;\n}\n/**\r\n *\r\n */\nfunction lineThroughPointAtRightAngleTo(p, v) {\n    var u = [-v[1], v[0]];\n    var p20 = p[0] + u[0];\n    var p21 = p[1] + u[1];\n    return [p, [p20, p21]];\n}\n/**\r\n * Get all intersection points between a line and a bezier within a certain t\r\n * range.\r\n */\nfunction getLineBezierIntersectionPoints(line, ps, tRange) {\n    var t = [-line[0][0], -line[0][1]];\n    var p = [line[1][0] + t[0], line[1][1] + t[1]];\n    // Cache\n    var lineLength = flo_vector2d_1.default.len(p);\n    var sinθ = -p[1] / lineLength;\n    var cosθ = p[0] / lineLength;\n    var newPs = flo_vector2d_1.default.translateThenRotatePs(t, sinθ, cosθ, ps);\n    var roots = flo_poly_1.default.allRoots(flo_bezier3_1.default.getY(newPs), 0, 1);\n    return roots.map(function (t) {\n        return { p: flo_bezier3_1.default.evaluate(ps)(t), t: t };\n    });\n}\nvar Geometry = {\n    lineLineIntersection: lineLineIntersection,\n    getLineBoundaryIntersectionPoints: getLineBoundaryIntersectionPoints,\n    closestSquaredDistanceToRotatedRect: closestSquaredDistanceToRotatedRect,\n    getClosestSquareDistanceToRect: getClosestSquareDistanceToRect,\n    degAngleFromSinCos: degAngleFromSinCos,\n    arcFrom3Points: arcFrom3Points,\n    quadrant: quadrant,\n    isAngle1LargerOrEqual: isAngle1LargerOrEqual,\n    isAngleBetween: isAngleBetween,\n    lineThroughPointAtRightAngleTo: lineThroughPointAtRightAngleTo,\n    getLineBezierIntersectionPoints: getLineBezierIntersectionPoints\n};\nexports.default = Geometry;\n\n},{\"./classes/arc\":4,\"./classes/circle\":6,\"./classes/shape\":10,\"flo-bezier3\":40,\"flo-poly\":48,\"flo-vector2d\":56}],16:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_ll_rb_tree_1 = _dereq_(\"flo-ll-rb-tree\");\nvar list_node_1 = _dereq_(\"./list-node\");\n/**\r\n * Represents a destructive (i.e. not functional) two-way linked loop.\r\n * @param items - A pre-ordered array of items to add initially; it is\r\n * faster to add items initially than to add them in a loop with insert.\r\n * @param comparator - Tree item comparator\r\n * @param indx - Loop identifier.\r\n */\n\nvar LinkedLoop = function () {\n    function LinkedLoop(items, comparator, indx) {\n        _classCallCheck(this, LinkedLoop);\n\n        if (comparator) {\n            this.cptree = new flo_ll_rb_tree_1.default(comparator, [], true);\n        }\n        this.indx = indx;\n        this.addAllFromScratch(items || []);\n    }\n    /**\r\n     * Adds all given items from scratch onto the empty LinkedLoop.\r\n     */\n\n\n    _createClass(LinkedLoop, [{\n        key: \"addAllFromScratch\",\n        value: function addAllFromScratch(arr) {\n            if (arr.length === 0) {\n                return;\n            }\n            var head = void 0;\n            var prevNode = null;\n            var node = void 0;\n            for (var i = 0; i < arr.length; i++) {\n                node = new list_node_1.default(this, arr[i], prevNode, null);\n                if (prevNode) {\n                    prevNode.next = node;\n                }\n                prevNode = node;\n                if (i === 0) {\n                    head = node;\n                }\n                if (this.cptree) {\n                    this.cptree.insert(node);\n                }\n                ;\n            }\n            // Close loop\n            head.prev = node;\n            node.next = head;\n            this.head = head;\n        }\n        /**\r\n         * Insert an item into the linked loop after the specified point.\r\n         * @param item - Item to insert\r\n         * @param prev - Inserts the new item right after this item\r\n         * @param coupledNode - A node coupled to this one\r\n         */\n\n    }, {\n        key: \"insert\",\n        value: function insert(item, prev_) {\n            var coupledNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n            var loop = this;\n            var node = new list_node_1.default(loop, item, undefined, undefined);\n            var prev = void 0;\n            var next = void 0;\n            if (!loop.head) {\n                prev = node;\n                next = node;\n                loop.head = node;\n            } else {\n                prev = prev_;\n                next = prev.next;\n            }\n            next.prev = node;\n            prev.next = node;\n            node.prev = prev;\n            node.next = next;\n            node.coupledNode = coupledNode;\n            if (loop.cptree) {\n                loop.cptree.insert(node);\n            }\n            ;\n            return node;\n        }\n        /**\r\n         * Removes a node from the linked loop.\r\n         */\n\n    }, {\n        key: \"remove\",\n        value: function remove(node) {\n            var loop = this;\n            var prev = node.prev;\n            var next = node.next;\n            if (node === loop.head) {\n                loop.head = next;\n            }\n            prev.next = next;\n            next.prev = prev;\n            if (loop.cptree) {\n                loop.cptree.remove(node, false); // TODO, make the second parameter default\n            }\n            ;\n        }\n        /**\r\n         *\r\n         */\n\n    }, {\n        key: \"getAsArray\",\n        value: function getAsArray() {\n            var loop = this;\n            var nodes = [];\n            var node = loop.head;\n            do {\n                nodes.push(node.item);\n                node = node.next;\n            } while (node !== loop.head);\n            return nodes;\n        }\n        /**\r\n         *\r\n         */\n\n    }, {\n        key: \"forEach\",\n        value: function forEach(f) {\n            var loop = this;\n            var node = loop.head;\n            do {\n                f(node);\n                node = node.next;\n            } while (node !== loop.head);\n        }\n        /**\r\n         * Returns the item at the specified index position.\r\n         * @note This is slow ( O(n) ); use in debugging code only.\r\n         */\n\n    }, {\n        key: \"getByIndx\",\n        value: function getByIndx(n) {\n            var loop = this;\n            return list_node_1.default.advanceNSteps(loop.head, n);\n        }\n    }]);\n\n    return LinkedLoop;\n}();\n\nexports.default = LinkedLoop;\n\n},{\"./list-node\":17,\"flo-ll-rb-tree\":43}],17:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Representation of a linked loop vertex (i.e. node) having various edges, two\r\n * of which enforce an ordering on the nodes, i.e. 'prev' and 'next'.\r\n * @param loop - The linked loop this node belongs to.\r\n * @param item - The actual item stored at a node.\r\n * @param prev - The previous item.\r\n * @param next - The next item.\r\n */\n\nvar ListNode = function () {\n    function ListNode(loop, item, prev, next) {\n        _classCallCheck(this, ListNode);\n\n        // TODO - we should really subclass linked-loop and/or list-node as the \n        // below only applies to the segregated shape pieces\n        this.prevOnCircle = undefined;\n        this.nextOnCircle = undefined;\n        this.loop = loop;\n        this.item = item;\n        this.prev = prev;\n        this.next = next;\n    }\n    /**\r\n     * Advances the node by the given number of steps. This is slow ( O(n) );\r\n     * use mostly for debugging.\r\n     * @param node - Node to start counting from\r\n     * @param n - Number of steps to advance\r\n     */\n\n\n    _createClass(ListNode, null, [{\n        key: \"advanceNSteps\",\n        value: function advanceNSteps(node, n) {\n            for (var i = 0; i < n; i++) {\n                node = node.next;\n            }\n            return node;\n        }\n    }]);\n\n    return ListNode;\n}();\n\nexports.default = ListNode;\n\n},{}],18:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAT_CONSTANTS = {\n    // TODO - should be dynamic and of order of shape dimensions.\n    maxOsculatingCircleRadius: 800,\n    pointType: {\n        'standard': 0,\n        'sharp': 1,\n        'dull': 2,\n        'extreme': 3\n    }\n};\nexports.default = MAT_CONSTANTS;\n\n},{}],19:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\n/**\r\n * Class representing a single contact point of a MatCircle.\r\n *\r\n * @param pointOnShape\r\n * @param {MatCircle} matCircle\r\n */\n\nvar ContactPoint = function () {\n    function ContactPoint(pointOnShape, matCircle) {\n        _classCallCheck(this, ContactPoint);\n\n        this.pointOnShape = pointOnShape;\n        this.matCircle = matCircle;\n        this.key = point_on_shape_1.default.toHumanString(pointOnShape); // TODO - remove\n        // TODO - remove from cache?\n        this[0] = pointOnShape[0]; // Shortcut\n        this[1] = pointOnShape[1]; // ...\n    }\n\n    _createClass(ContactPoint, null, [{\n        key: \"compare\",\n        value: function compare(a, b) {\n            return point_on_shape_1.default.compare(a.pointOnShape, b.pointOnShape);\n        }\n    }, {\n        key: \"equal\",\n        value: function equal(a, b) {\n            return flo_vector2d_1.default.equal(a.pointOnShape.p, b.pointOnShape.p);\n        }\n    }]);\n\n    return ContactPoint;\n}();\n\nexports.default = ContactPoint;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"flo-vector2d\":56}],20:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_on_shape_1 = _dereq_(\"../../../geometry/classes/point-on-shape\");\n\nvar ThreeProngForDebugging = function ThreeProngForDebugging(threeProng, deltas, bestIndx, candidateThreeProngs) {\n    _classCallCheck(this, ThreeProngForDebugging);\n\n    this.threeProng = threeProng;\n    this.deltas = deltas;\n    this.bestIndx = bestIndx;\n    this.candidateThreeProngs = candidateThreeProngs;\n    this.deltasSimple = deltas.map(function (delta) {\n        return [point_on_shape_1.default.toHumanString(delta[0].item.pointOnShape), point_on_shape_1.default.toHumanString(delta[1].item.pointOnShape)];\n    });\n};\n\nexports.default = ThreeProngForDebugging;\n\n},{\"../../../geometry/classes/point-on-shape\":9}],21:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar TwoProngForDebugging = function TwoProngForDebugging(pos, δ, y, z, x, circle, xs, failed, holeClosing) {\n    _classCallCheck(this, TwoProngForDebugging);\n\n    this.pos = pos;\n    this.δ = δ;\n    this.y = y;\n    this.z = z;\n    this.x = x;\n    this.circle = circle;\n    this.xs = xs;\n    this.failed = failed;\n    this.holeClosing = holeClosing;\n};\n\nexports.default = TwoProngForDebugging;\n\n},{}],22:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar HoleClosing2Prong = function HoleClosing2Prong(k1, k2, cpNodeA2, cpNodeA1, cpNodeB1, cpNodeB2) {\n    _classCallCheck(this, HoleClosing2Prong);\n\n    this.k1 = k1;\n    this.k2 = k2;\n    this.cpNodeA2 = cpNodeA2;\n    this.cpNodeA1 = cpNodeA1;\n    this.cpNodeB1 = cpNodeB1;\n    this.cpNodeB2 = cpNodeB2;\n};\n\nexports.default = HoleClosing2Prong;\n\n},{}],23:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Medial (or Scale) Axis Transform (MAT) maximal contact circle class,\r\n * i.e. a representative data point of the MAT.\r\n *\r\n * @constructor\r\n * @param {Circle} circle\r\n * @param {ListNode[]} cpNodes - The contact points of this circle on the shape.\r\n * @note Do not do 'new MatCircle', rather use 'MatCircle.create'.\r\n */\n\nvar MatCircle = function () {\n    function MatCircle(circle, cpNodes) {\n        _classCallCheck(this, MatCircle);\n\n        this.circle = circle;\n        this.cpNodes = cpNodes;\n        this.visited = 0; // TODO - does not belong inside the class\n    }\n    /**\r\n     * MatCircle creator.\r\n     * @param {Circle} circle\r\n     * @param {ListNode[]} cpNodes An array of 'orphaned'\r\n     *        (i.e. without belonging to a MatCircle) contact points.\r\n     * Notes: Due to the mutual dependency between the matCircle and\r\n     * contactPoints fields, a normal constructor can not instantiate a\r\n     * MatCircle in one step - hence this creator.\r\n     */\n\n\n    _createClass(MatCircle, null, [{\n        key: \"create\",\n        value: function create(circle, cpNodes) {\n            var matCircle = new MatCircle(circle, undefined);\n            for (var i = 0; i < cpNodes.length; i++) {\n                cpNodes[i].item.matCircle = matCircle;\n            }\n            matCircle.cpNodes = cpNodes;\n            return matCircle;\n        }\n    }]);\n\n    return MatCircle;\n}();\n\nexports.default = MatCircle;\n\n},{}],24:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Representation of a node in the MAT structure.\r\n * @param matCircle\r\n * @param branches\r\n */\n\nvar MatNode = function () {\n    function MatNode(matCircle, branches) {\n        _classCallCheck(this, MatNode);\n\n        this.matCircle = matCircle;\n        this.branches = branches;\n    }\n\n    _createClass(MatNode, null, [{\n        key: \"copy\",\n        value: function copy(node) {\n            return f(node);\n            function f(matNode, priorNode, newPriorNode) {\n                var branches = [];\n                var newNode = new MatNode(matNode.matCircle, branches);\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var _node = _step.value;\n\n                        if (_node === priorNode) {\n                            // Don't go back in tracks.\n                            branches.push(newPriorNode);\n                            continue;\n                        }\n                        branches.push(f(_node, matNode, newNode));\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                return newNode;\n            }\n        }\n    }]);\n\n    return MatNode;\n}();\n\nexports.default = MatNode;\n\n},{}],25:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_1 = _dereq_(\"../../mat/functions/traverse\");\n/**\r\n * The Medial Axis Transform. It is defined recursively as a rooted tree with\r\n * each node containing a point, a radius and 1, 2 or 3 branches.\r\n * @param node - A handle on the MAT tree structure.\r\n */\n\nvar MatTree = function MatTree(node) {\n    _classCallCheck(this, MatTree);\n\n    this.startNode = node;\n};\n\nMatTree.traverse = traverse_1.default;\nexports.default = MatTree;\n\n},{\"../../mat/functions/traverse\":37}],26:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar hole_closing_2_prong_1 = _dereq_(\"../classes/hole-closing-2-prong\");\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n *\r\n * @param shape Shape to add the 2-prong to\r\n * @param circle Circle containing the 2 contact points\r\n * @param pos1 - First point on shape\r\n * @param pos2 - Second point on shape\r\n * @param delta The boundary piece within which the new contact point should be\r\n * placed\r\n */\nfunction add2Prong(shape, circle, pos1, pos2, holeClosing) {\n    if (holeClosing) {\n        pos1.order2 = 1;\n        pos2.order2 = -1;\n    }\n    var cp2 = new contact_point_1.default(pos2, undefined);\n    var delta2 = shape_1.default.getNeighbouringPoints(shape, pos2);\n    var cmp3 = delta2[0] === undefined ? undefined : contact_point_1.default.compare(delta2[0].item, cp2);\n    var cmp4 = delta2[1] === undefined ? undefined : contact_point_1.default.compare(cp2, delta2[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp3 > 0 || cmp4 > 0) {\n            //console.log(`2-PRONG 2 Order is wrong 2: ${cmp3}, ${cmp4}`);\n        }\n    }\n    if (cmp3 === 0 || cmp4 === 0) {\n        // Should not really be possible with hole-closing 2-prongs.\n        return undefined;\n    }\n    var k2 = pos2.bezierNode.loop.indx;\n    var newCp2Node = shape.contactPointsPerLoop[k2].insert(cp2, delta2[0]);\n    var cp1 = new contact_point_1.default(pos1, undefined);\n    var delta1 = shape_1.default.getNeighbouringPoints(shape, pos1);\n    var cmp1 = delta1[0] === undefined ? undefined : contact_point_1.default.compare(delta1[0].item, cp1);\n    var cmp2 = delta1[1] === undefined ? undefined : contact_point_1.default.compare(cp1, delta1[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp1 > 0 || cmp2 > 0) {\n            //console.log(`2-PRONG 1 Order is wrong 2: ${cmp1}, ${cmp2}`);\n        }\n    }\n    // If they are so close together, don't add it - there's already 1\n    if (cmp1 === 0 || cmp2 === 0) {\n        // Should not be possible with hole-closing 2-prongs.\n        shape.contactPointsPerLoop[k2].remove(newCp2Node);\n        return undefined;\n    }\n    var k1 = pos1.bezierNode.loop.indx;\n    var newCp1Node = shape.contactPointsPerLoop[k1].insert(cp1, delta1[0]);\n    var matCircle = mat_circle_1.default.create(circle, [newCp1Node, newCp2Node]);\n    newCp1Node.prevOnCircle = newCp2Node;\n    newCp1Node.nextOnCircle = newCp2Node;\n    newCp2Node.prevOnCircle = newCp1Node;\n    newCp2Node.nextOnCircle = newCp1Node;\n    if (holeClosing) {\n        // If hole-closing then we duplicate the 2 contact points\n        // so that we can 'split the loop'.\n        var posA1 = pos2;\n        var posB2 = point_on_shape_1.default.copy(posA1);\n        posB2.order2 = 1;\n        var cpB2 = new contact_point_1.default(posB2, undefined);\n        var newCpB2Node = shape.contactPointsPerLoop[k2].insert(cpB2, newCp2Node);\n        var posA2 = pos1;\n        var posB1 = point_on_shape_1.default.copy(posA2);\n        posB1.order2 = -1;\n        var cpB1 = new contact_point_1.default(posB1, undefined);\n        var newCpB1Node = shape.contactPointsPerLoop[k1].insert(cpB1, newCp1Node.prev);\n        mat_circle_1.default.create(circle, [newCpB1Node, newCpB2Node]);\n        newCpB1Node.prevOnCircle = newCpB2Node;\n        newCpB1Node.nextOnCircle = newCpB2Node;\n        newCpB2Node.prevOnCircle = newCpB1Node;\n        newCpB2Node.nextOnCircle = newCpB1Node;\n        newCp2Node.next = newCp1Node;\n        newCp1Node.prev = newCp2Node;\n        newCpB1Node.next = newCpB2Node;\n        newCpB2Node.prev = newCpB1Node;\n        shape.holeClosers.push(new hole_closing_2_prong_1.default(k1, k2, newCp1Node, newCp2Node, newCpB1Node, newCpB2Node));\n    }\n    if (typeof window !== 'undefined' && window._debug_) {\n        // Add points so when we alt-click shape point is logged.\n        var _debug_ = window._debug_;\n        prepForDebug(newCp1Node, _debug_);\n        prepForDebug(newCp2Node, _debug_);\n    }\n    return;\n}\nfunction prepForDebug(contactPoint, _debug_) {\n    //---- Prepare debug info for the ContactPoint\n    var cpKey = point_on_shape_1.default.makeSimpleKey(contactPoint.item.pointOnShape.p);\n    var cpHash = _debug_.generated.cpHash;\n    var cpArr = _debug_.generated.cpArr;\n    if (!cpHash[cpKey]) {\n        cpHash[cpKey] = {\n            cp: contactPoint,\n            arrIndx: cpArr.length\n        };\n        cpArr.push(contactPoint);\n    }\n    var cpHashDebugObj = cpHash[cpKey];\n    cpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\nexports.default = add2Prong;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../geometry/classes/shape\":10,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../classes/hole-closing-2-prong\":22}],27:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given\r\n * (previously calculated) points on the shape.\r\n *\r\n * @param shape\r\n * @param circle\r\n * @param [p1,p2,p3]\r\n * @param deltas\r\n * @returns {MatCircle} matCircle\r\n */\nfunction add3Prong(shape, threeProng) {\n    var circle = threeProng.circle,\n        ps = threeProng.ps,\n        delta3s = threeProng.delta3s;\n\n    var cps = [0, 1, 2].map(function (i) {\n        return new contact_point_1.default(ps[i], undefined);\n    });\n    if (typeof window !== 'undefined' && window._debug_) {\n        // Keep for possible future debugging.\n        /*\r\n        for (let i=0; i<3; i++) {\r\n            let cmpBef = ContactPoint.compare(delta3s[i][0].item, cps[i]);\r\n            let cmpAft = ContactPoint.compare(delta3s[i][1].item, cps[i]);\r\n              let len = FloMat._debug_.generated.threeProngs.length-1; // Used by debug functions to reference a particular three-prong\r\n            if (cmpBef > 0) {\r\n                console.log(`3-PRONG Order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log(`3-PRONG Order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n            }\r\n        }\r\n        */\n    }\n    var cpNodes = [];\n    for (var i = 0; i < 3; i++) {\n        var pos = ps[i];\n        var k = pos.bezierNode.loop.indx;\n        cpNodes.push(shape.contactPointsPerLoop[k].insert(cps[i], delta3s[i][0]));\n    }\n    var matCircle = mat_circle_1.default.create(circle, cpNodes);\n    var idxsPrev = [2, 0, 1];\n    var idxsNext = [1, 2, 0];\n    for (var _i = 0; _i < 3; _i++) {\n        cpNodes[_i].prevOnCircle = cpNodes[idxsPrev[_i]];\n        cpNodes[_i].nextOnCircle = cpNodes[idxsNext[_i]];\n    }\n    return matCircle;\n}\nexports.default = add3Prong;\n\n},{\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23}],28:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar find_3_prong_1 = _dereq_(\"./find-3-prong\");\nvar add_3_prong_1 = _dereq_(\"./add-3-prong\");\nvar mat_node_1 = _dereq_(\"../../mat/classes/mat-node\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\n/**\r\n * Recursively builds the MAT tree.\r\n *\r\n * @param {ListNode} cpNodeStart\r\n * @returns {MatNode}\r\n */\nfunction buildMat(shape, cpNodeStart, fromNode, fromCpNode, isRetry) {\n    var visitedPoints = void 0;\n    do {\n        visitedPoints = traverseShape(cpNodeStart);\n        if (typeof window !== 'undefined' && window._debug_) {\n            // Oops - fix\n            // cpHashDebugObj.visitedPointsArr.push(visitedPoints);\n        }\n        if (visitedPoints.length > 2) {\n            findAndAdd3Prong(shape, visitedPoints);\n        }\n    } while (visitedPoints.length > 2);\n    if (cpNodeStart.item.matCircle.cpNodes.length === 1) /*&&\r\n                                                         (fromCpNode.nextOnCircle === cpNodeStart.next)*/{\n            //console.log('terminal 1-prong');\n            var matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n            return matNode;\n        }\n    if (visitedPoints.length === 1) {\n        // Terminating 2-prong - should mostly have been eliminated\n        // by osculating circles and points, but can still occur\n        // due to floating point incaccuracies.\n        // console.log('terminal 2-prong');\n        var _matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n        return _matNode;\n    } else if (visitedPoints.length === 2) {\n        var branches = fromNode ? [fromNode] : [];\n        var _matNode2 = createMatNode(cpNodeStart, branches);\n        var cpBranches = cpNodeStart;\n        var i = 0;\n        while (cpBranches.nextOnCircle !== cpNodeStart && cpBranches.next !== cpBranches.nextOnCircle) {\n            i++;\n            var cpNext = void 0;\n            if (i === 1) {\n                cpNext = cpBranches.next;\n                cpNodeStart.item.matCircle.visited++;\n            } else if (i === 2) {\n                // TODO - instead of the commented line below working\n                // perfectly, we must call the few lines below it and\n                // then later call fixMat. WHY!!!??? does the line\n                // below not simply work?\n                // cpNext = cpBranches.next;\n                cpNext = cpBranches;\n                if (cpBranches.item.matCircle.visited !== 1) {\n                    break;\n                }\n            }\n            var bm = buildMat(shape, cpNext, _matNode2, cpBranches, false);\n            branches.push(bm);\n            cpBranches = cpBranches.nextOnCircle;\n        }\n        return _matNode2;\n    }\n}\nfunction createMatNode(cp, branches) {\n    var matNode = new mat_node_1.default(cp.item.matCircle, branches);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        prepDebugHashes(cp, matNode, _debug_);\n    }\n    return matNode;\n}\nfunction traverseShape(cpNodeStart) {\n    var visitedPoints = void 0;\n    var cpNode = cpNodeStart;\n    visitedPoints = [];\n    do {\n        //if ()\n        visitedPoints.push(cpNode);\n        var next = cpNode.next;\n        cpNode = next.prevOnCircle; // Take last exit\n    } while (cpNode !== cpNodeStart);\n    return visitedPoints;\n}\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape. Modifies shape.\r\n *\r\n * @param shape\r\n * @param visitedPoints\r\n */\nfunction findAndAdd3Prong(shape, visitedPoints) {\n    /*\r\n     * visitedPoints.sort(function(a,b) { return\r\n     * PointOnShape.compare(a.item.pointOnShape,b.item.pointOnShape); });\r\n     */\n    var deltas = [];\n    for (var i = 0; i < visitedPoints.length; i++) {\n        var visitedPoint = visitedPoints[i];\n        deltas.push([visitedPoint, visitedPoint.next]);\n    }\n    // Check if any deltas are continuous (they should rather be\n    // disjoint). It should be quite safe to consider points 'equal'\n    // if they are within a certain threshold of each other, but is it\n    // necessary? Maybe not.\n    var continuous = false;\n    for (var _i = 0; _i < deltas.length; _i++) {\n        var idxi = _i + 1;\n        if (idxi === deltas.length) {\n            idxi = 0;\n        }\n        var endP = deltas[_i][1].item;\n        var startP = deltas[idxi][0].item;\n        if (contact_point_1.default.equal(endP, startP)) {\n            continuous = true;\n            break;\n        }\n    }\n    if (continuous) {\n        // aaa\n    }\n    var threeProng = find_3_prong_1.default(shape, deltas);\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n        point_on_shape_1.default.setPointOrder(shape, threeProng.circle, threeProng.ps[_i2]);\n    }\n    add_3_prong_1.default(shape, threeProng);\n}\nfunction prepDebugHashes(cpNodeStart, matNode, _debug_) {\n    // ---- Prepare debug info for the MatCircle\n    var circle = cpNodeStart.item.matCircle.circle;\n    var key = point_on_shape_1.default.makeSimpleKey(circle.center);\n    var nodeHash = _debug_.generated.nodeHash;\n    nodeHash[key] = nodeHash[key] || {};\n    nodeHash[key].matNode = matNode;\n    // ---- Prepare debug info for the ContactPoint\n    var cpKey = point_on_shape_1.default.makeSimpleKey(cpNodeStart.item.pointOnShape.p);\n    var cpHash = _debug_.generated.cpHash;\n    var cpArr = _debug_.generated.cpArr;\n    if (!cpHash[cpKey]) {\n        cpHash[cpKey] = {\n            cp: cpNodeStart,\n            arrIndx: cpArr.length\n        };\n        cpArr.push(cpNodeStart);\n    }\n    var cpHashDebugObj = cpHash[cpKey];\n    cpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\nexports.default = buildMat;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-node\":24,\"./add-3-prong\":27,\"./find-3-prong\":31}],29:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_node_1 = _dereq_(\"../../mat/classes/mat-node\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\nfunction copyMat(matTree) {\n    return new mat_tree_1.default(mat_node_1.default.copy(matTree.startNode));\n}\nexports.default = copyMat;\n\n},{\"../../mat/classes/mat-node\":24,\"../classes/mat-tree\":25}],30:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAX_ITERATIONS = 50;\n//TODO Change tolerances to take shape dimension into \n// account, e.g. shapeDim / 10000 for SEPERATION_TOLERANCE;\n//CONST SEPERATION_TOLERANCE = 1e-3;\nvar SEPERATION_TOLERANCE = 1e-3;\nvar SQUARED_SEPERATION_TOLERANCE = SEPERATION_TOLERANCE * SEPERATION_TOLERANCE;\nvar _1PRONG_TOLERANCE = 1e-4;\nvar SQUARED_1PRONG_TOLERANCE = _1PRONG_TOLERANCE * _1PRONG_TOLERANCE;\n//const ERROR_TOLERANCE = 1e-3;\nvar ERROR_TOLERANCE = SEPERATION_TOLERANCE / 10;\nvar SQUARED_ERROR_TOLERANCE = ERROR_TOLERANCE * ERROR_TOLERANCE;\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar geometry_1 = _dereq_(\"../../geometry/geometry\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar Point_on_shape_1 = _dereq_(\"../../geometry/classes/Point-on-shape\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar get_closest_boundary_point_to_point_1 = _dereq_(\"../../geometry/functions/get-closest-boundary-point-to-point\");\nvar two_prong_for_debugging_1 = _dereq_(\"../classes/debug/two-prong-for-debugging\");\n/**\r\n * Adds a 2-prong to the MAT. The first point is given and the second one is\r\n * found by the algorithm.\r\n *\r\n * A 2-prong is a MAT circle that touches the shape at exactly 2 points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle\r\n *    Br(x) centered at an interior point x which contains two boundary\r\n *    portions c and d of d-Omega as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n *\r\n * @param shape\r\n * @param y - The first point of the 2-prong.\r\n */\nfunction find2Prong(shape, y, holeClosing) {\n    /* The failed flag is set if a 2-prong cannot be found. This occurs\r\n     * when the 2 points are too close together and the 2-prong\r\n     * becomes, in the limit, a 1-prong. We do not want these 2-prongs\r\n     * as they push the floating point precision limits when finding\r\n     * their circle center causing too much inaccuracy. Of course, our\r\n     * entire algorithm's precision is limited by floating point\r\n     * doubles.\r\n     */\n    var failed = false;\n    // The first point on the shape of the 2-prong.\n    //let y = pos;\n    var bezierNode = y.bezierNode;\n    var t = y.t;\n    var oCircle = Point_on_shape_1.default.getOsculatingCircle(y);\n    var x = oCircle.center;\n    /*\r\n     * The shortest distance so far between the first contact point and\r\n     * the circle center - we require this to get shorter on each\r\n     * iteration as convergence occurs. If it does not, oscillation\r\n     * of the algorithm has occured due to floating point inaccuracy\r\n     * and the algorithm must terminate.\r\n     */\n    var radius = oCircle.radius;\n    var shortestSquaredDistance = radius * radius;\n    /* The boundary piece that should contain the other point of\r\n     * the 2-prong circle. (Defined by start and end points).\r\n     */\n    var δ = void 0;\n    var bezierPieces = void 0;\n    var k = y.bezierNode.loop.indx;\n    if (holeClosing) {\n        bezierPieces = [];\n        for (var k2 = 0; k2 < k; k2++) {\n            var _bezierPieces;\n\n            var pieces = shape_1.default.getBoundaryBeziers(shape, k2);\n            (_bezierPieces = bezierPieces).push.apply(_bezierPieces, _toConsumableArray(pieces));\n        }\n    } else {\n        // TODO - getNeighbouringPoints *can* be eliminated (as with 3-prongs)\n        // by keeping track of boundary piece in which it is being searched \n        // - not sure if same can be done with hole-closing 2-prongs.\n        var ps = shape_1.default.getNeighbouringPoints(shape, y);\n        δ = [ps[0], ps[0]];\n        if (!ps[0]) {\n            bezierPieces = shape_1.default.getBoundaryBeziers(shape, k);\n        } else {\n            bezierPieces = shape_1.default.getBoundaryPieceBeziers(δ);\n        }\n    }\n    var xs = []; // Trace the convergence.\n    var z = void 0;\n    var squaredError = void 0;\n    var i = 0;\n    do {\n        i++;\n        var r = flo_vector2d_1.default.squaredDistanceBetween(x, y.p);\n        bezierPieces = cullBezierPieces(bezierPieces, x, r);\n        z = get_closest_boundary_point_to_point_1.default(bezierPieces, x, bezierNode, t);\n        if (typeof window !== 'undefined' && window._debug_) {\n            xs.push({ x: x, y: y, z: z, t: t });\n        }\n        var d = flo_vector2d_1.default.squaredDistanceBetween(x, z.p);\n        if (i === 1 && d + SQUARED_1PRONG_TOLERANCE >= r) {\n            // It is a 1-prong.\n            add1Prong(shape, y);\n            return undefined;\n        }\n        var squaredChordDistance = flo_vector2d_1.default.squaredDistanceBetween(y.p, z.p);\n        if (squaredChordDistance <= SQUARED_SEPERATION_TOLERANCE) {\n            failed = true;\n            break;\n        }\n        /*\r\n         * Find the point on the line connecting y with x that is\r\n         * equidistant from y and z. This will be our next x.\r\n         */\n        var nextX = findEquidistantPointOnLine(x, y.p, z.p);\n        squaredError = flo_vector2d_1.default.squaredDistanceBetween(x, nextX);\n        /*\r\n         * Prevent oscillation of calculated x (due to floating point\r\n         * inaccuracies). See comment above decleration of\r\n         * shortestSquaredDistance.\r\n         */\n        var squaredDistance = flo_vector2d_1.default.squaredDistanceBetween(y.p, nextX);\n        if (squaredDistance < shortestSquaredDistance) {\n            shortestSquaredDistance = squaredDistance;\n        } else {\n            //failed = true;\n            //break;\n        }\n        x = nextX;\n    } while (squaredError > SQUARED_ERROR_TOLERANCE && i < MAX_ITERATIONS);\n    if (typeof window !== 'undefined' && window._debug_) {\n        xs.push({ x: x, y: y, z: z, t: t });\n    }\n    if (i === MAX_ITERATIONS) {\n        // This is simply a case of convergence being too slow. The\n        // gecko, for example, takes a max of 21 iterations.\n        //console.log('max')\n        failed = true;\n    }\n    var circle = new circle_1.default(x, flo_vector2d_1.default.distanceBetween(x, z.p));\n    Point_on_shape_1.default.setPointOrder(shape, circle, y);\n    Point_on_shape_1.default.setPointOrder(shape, circle, z);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        recordForDebugging(failed, y, circle, y.p, z.p, δ, xs, holeClosing, _debug_);\n    }\n    if (failed) {\n        //console.log('failed');\n        return undefined;\n    }\n    return { circle: circle, z: z };\n}\nfunction add1Prong(shape, pos) {\n    if (pos.type === mat_constants_1.default.pointType.dull) {\n        // This is a 1-prong at a dull corner.\n        /* TODO IMPORTANT remove this line, uncomment piece below\r\n         * it and implement the following strategy to find the\r\n         * 3-prongs: if deltas are conjoined due to dull corner,\r\n         * split the conjoinment by inserting successively closer\r\n         * (binary division) 2-prongs. If a 2-prong actually fails,\r\n         * simply remove the 1-prong at the dull corner.\r\n         *\r\n         * In this way **all** terminal points are found, e.g.\r\n         * zoom in on top left leg of ant.\r\n         */\n        //console.log(posNode);\n        //toRemove.push(posNode); /* this */\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            // TODO - why would it be NaN in some cases?\n            var oCircle = Point_on_shape_1.default.getOsculatingCircle(pos);\n            if (!Number.isNaN(oCircle.center[0])) {\n                _debug_.generated.oneProngsAtDullCorner.push({ pos: pos });\n            }\n        }\n        return;\n    }\n    var cp = new contact_point_1.default(pos, undefined);\n    var delta = shape_1.default.getNeighbouringPoints(shape, pos);\n    //let cmp1 = ContactPoint.compare(delta[0].item, cp);\n    //let cmp2 = ContactPoint.compare(cp, delta[1].item);\n    var cmp1 = delta[0] === undefined ? undefined : contact_point_1.default.compare(delta[0].item, cp);\n    var cmp2 = delta[1] === undefined ? undefined : contact_point_1.default.compare(cp, delta[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp1 > 0 || cmp2 > 0) {\n            //console.log(`1-PRONG Order is wrong: ${cmp1}, ${cmp2}`);\n        }\n    }\n    // If they are so close together, don't add it - there's already 1\n    if (cmp1 === 0 || cmp2 === 0) {\n        return;\n    }\n    var k = pos.bezierNode.loop.indx;\n    var newCpNode = shape.contactPointsPerLoop[k].insert(cp, delta[0]);\n    var matCircle = mat_circle_1.default.create(\n    //pos.osculatingCircle,\n    Point_on_shape_1.default.getOsculatingCircle(pos), [newCpNode]);\n    newCpNode.prevOnCircle = newCpNode; // Trivial loop\n    newCpNode.nextOnCircle = newCpNode; // ...\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.oneProngs.push({ pos: pos });\n    }\n    return;\n}\nfunction recordForDebugging(failed, pos, circle, y, z, δ, xs, holeClosing, _debug_) {\n    var twoProngForDebugging = new two_prong_for_debugging_1.default(pos, δ, y, z, circle.center, circle, xs, failed, holeClosing);\n    _debug_.generated.twoProngs.push(twoProngForDebugging);\n}\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n *\r\n * @param {BezierPieces[]} bezierPieces\r\n * @param {number[]} p\r\n * @param {number} r\r\n * @returns {BezierPieces[]}\r\n */\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\n    var CULL_THRESHOLD = 5;\n    if (bezierPieces.length <= CULL_THRESHOLD) {\n        return bezierPieces;\n    }\n    var newPieces = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var bezierPiece = _step.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var rect = flo_bezier3_1.default.getBoundingBox(ps);\n            var bd = geometry_1.default.getClosestSquareDistanceToRect(rect, p);\n            if (bd <= rSquared + 0.1 /* Make this in relation to shape extents! <- No! Do proper error analysis */) {\n                    newPieces.push(bezierPiece);\n                }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return newPieces;\n}\n/**\r\n *\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from\r\n *          y and z.\r\n *\r\n * Notes: It is important that this function is numerically stable,\r\n * but this has not been investigated properly yet.\r\n */\nfunction findEquidistantPointOnLine(x, y, z) {\n    // Some basic algebra (not shown) finds the required point.\n    // Swap axis if x and y are more aligned to y-axis than to x-axis.\n    var swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\n    // Cache\n    var x1 = void 0,\n        x2 = void 0,\n        y1 = void 0,\n        y2 = void 0,\n        z1 = void 0,\n        z2 = void 0;\n    if (swapAxes) {\n        x1 = x[1];\n        x2 = x[0];\n        y1 = y[1];\n        y2 = y[0];\n        z1 = z[1];\n        z2 = z[0];\n    } else {\n        x1 = x[0];\n        x2 = x[1];\n        y1 = y[0];\n        y2 = y[1];\n        z1 = z[0];\n        z2 = z[1];\n    }\n    // a <= 1 (due to swapped axes)\n    var a = (x2 - y2) / (x1 - y1);\n    var b = y2 - a * y1;\n    var c = y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2 + 2 * b * (z2 - y2);\n    var d = y1 - z1 + a * (y2 - z2);\n    var t1 = c / (2 * d);\n    var t2 = a * t1 + b;\n    return swapAxes ? [t2, t1] : [t1, t2];\n}\nexports.default = find2Prong;\n\n},{\"../../geometry/classes/Point-on-shape\":3,\"../../geometry/classes/circle\":6,\"../../geometry/classes/shape\":10,\"../../geometry/functions/get-closest-boundary-point-to-point\":13,\"../../geometry/geometry\":15,\"../../mat-constants\":18,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../classes/debug/two-prong-for-debugging\":21,\"flo-bezier3\":40,\"flo-vector2d\":56}],31:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar get_closest_boundary_point_to_point_1 = _dereq_(\"../../geometry/functions/get-closest-boundary-point-to-point\");\nvar three_prong_for_debugging_1 = _dereq_(\"../classes/debug/three-prong-for-debugging\");\n/**\r\n * Look for a 3-prong from the given walked boundary piece.\r\n *\r\n * @param shape\r\n * @param δs\r\n *\r\n */\nfunction find3Prong(shape, δs) {\n    var bezierPiecess = δs.map(function (δ) {\n        return shape_1.default.getBoundaryPieceBeziers(δ);\n    });\n    var candidateThreeProngs = [];\n    // The best candidate amongst the different 'permutations' of the given δs.\n    var threeProng = void 0;\n    var bestIndx = undefined;\n    var smallestError = Number.POSITIVE_INFINITY;\n    for (var i = 1; i < δs.length - 1; i++) {\n        var _find3ProngForDelta3s = find3ProngForDelta3s(shape, δs, i, bezierPiecess),\n            circle = _find3ProngForDelta3s.circle,\n            ps = _find3ProngForDelta3s.ps,\n            error = _find3ProngForDelta3s.error;\n\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            candidateThreeProngs.push({ circle: circle, ps: ps });\n        }\n        if (error < smallestError) {\n            smallestError = error;\n            bestIndx = i - 1;\n            threeProng = { circle: circle, ps: ps, delta3s: undefined };\n        }\n    }\n    //-------------------------------------\n    //---- Add some additional properties\n    //-------------------------------------\n    var delta3s = [δs[0], δs[bestIndx + 1], δs[δs.length - 1]];\n    threeProng.delta3s = delta3s;\n    //-------------------------------------\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        var threeProngForDebugging = new three_prong_for_debugging_1.default(threeProng, δs, bestIndx, candidateThreeProngs);\n        _debug_2.generated.threeProngs.push(threeProngForDebugging);\n    }\n    return threeProng;\n}\n/**\r\n * Finds a 3-prong using only the 3 given delta's.\r\n *\r\n * @param i - Specific delta indx.\r\n * @returns {Object}\r\n */\nfunction find3ProngForDelta3s(shape, deltas, idx, bezierPiecess) {\n    // TODO - Choose a tolerance relative to shape size.\n    var TOLERANCE = 1e-7;\n    var delta3s = [deltas[0], deltas[idx], deltas[deltas.length - 1]];\n    var bezierPiece3s = [bezierPiecess[0], bezierPiecess[idx], bezierPiecess[deltas.length - 1]];\n    var ps = void 0;\n    var circumCenter = void 0;\n    var ii = 0; // Safeguard\n    var x = calcInitial3ProngPoint(shape, delta3s, bezierPiece3s);\n    var tolerance = Number.POSITIVE_INFINITY;\n    // TODO 10 below is magic, fix or add somewhere as a constant\n    while (tolerance > TOLERANCE && ii < 10) {\n        ii++;\n        ps = getClosestPoints(x, bezierPiece3s);\n        circumCenter = flo_vector2d_1.default.circumCenter(ps.map(function (x) {\n            return x.p;\n        }));\n        var vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter);\n        var upds = calcBetterX(bezierPiece3s, x, vectorToZeroV);\n        x = upds.newX;\n        var V = flo_vector2d_1.default.len(vectorToZeroV);\n        ps = upds.newPs;\n        tolerance = Math.abs(V - upds.newV);\n    }\n    var radius = (flo_vector2d_1.default.distanceBetween(x, ps[0].p) + flo_vector2d_1.default.distanceBetween(x, ps[1].p) + flo_vector2d_1.default.distanceBetween(x, ps[2].p)) / 3;\n    var circle = new circle_1.default(x, radius);\n    //-----------------------------------------------------------------\n    // Calculate the unit tangent vector at 3-prong circle points -\n    // they should be very close to tangent to the boundary piece \n    // tangents at those points (up to sign). Sharp corners are a\n    // common special case.\n    //-----------------------------------------------------------------\n    var totalAngleError = 0;\n    for (var i = 0; i < 3; i++) {\n        var p = ps[i];\n        //----------------------------\n        // Tangent of circle at point\n        //----------------------------\n        var vv = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(p.p, x));\n        var v1 = flo_vector2d_1.default.rotate90Degrees(vv);\n        //-----------------------------------\n        // Check if point is on dull crorner\n        //-----------------------------------\n        var key = point_on_shape_1.default.makeSimpleKey(p.p);\n        var dullCorner = shape.dullCornerHash[key];\n        if (dullCorner) {\n            //if (FloMat._debug_ && FloMat._debug_.log) { console.log(dullCorner); }\n            var tans = dullCorner.tans;\n            var perps = tans.map(flo_vector2d_1.default.rotate90Degrees);\n            if (typeof window !== 'undefined' && window._debug_) {\n                var _debug_ = window._debug_;\n                if (_debug_.log) {\n                    /*\r\n                    FloMat._debug_.fs.draw.line(\r\n                            [p, Vector.translate(p, perps[0])],\r\n                            'thin10 red'\r\n                    );\r\n                    FloMat._debug_.fs.draw.line(\r\n                            [p, Vector.translate(p, perps[1])],\r\n                            'thin10 red'\r\n                    );\r\n                    */\n                    // The below must be elem [0,1].\n                    //console.log(Vector.cross( perps[0], perps[1] )); \n                }\n            }\n            var angleError1Pre = flo_vector2d_1.default.cross(perps[0], vv);\n            var angleError2Pre = flo_vector2d_1.default.cross(vv, perps[1]);\n            var angleError1 = Math.asin(angleError1Pre);\n            var angleError2 = Math.asin(angleError2Pre);\n            var angleError = 0;\n            if (angleError1 > 0) {\n                angleError += angleError1;\n            }\n            if (angleError2 > 0) {\n                angleError += angleError2;\n            }\n            totalAngleError += angleError;\n        } else {\n            //---------------------------\n            // Tangent of curve at point\n            //---------------------------\n            var _ps = p.bezierNode.item.bezier3;\n            var v2 = flo_vector2d_1.default.toUnitVector(flo_bezier3_1.default.tangent(_ps)(p.t));\n            // Cross is more numerically stable than Vector.dot at angles\n            // a multiple of Math.PI **and** is close to the actual angle\n            // value and can thus just be added to cone method of looking\n            // at tolerance.\n            // Should be close to zero and is close to the actual angle.\n            var cross = Math.abs(Math.asin(flo_vector2d_1.default.cross(v1, v2)));\n            totalAngleError += cross;\n        }\n    }\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log(totalAngleError); }\n    //-----------------------------------------------------------------\n    // Calculate radiusDelta, the difference between the radius and \n    // the closest point to the 3-prong. It should be around 0. If not,\n    // this is not a good candidate for the 3-prong.\n    //-----------------------------------------------------------------\n    var closestDs = [];\n    for (var _i = 0; _i < bezierPiecess.length; _i++) {\n        var _p = get_closest_boundary_point_to_point_1.default(bezierPiecess[_i], x, undefined, undefined // TODO - bug: we must provide a t value and the\n        // parameter order of the last 2 parameters of this function\n        // should be swapped. Consider the consequences of leaving this\n        // bug unchecked.\n        );\n        closestDs.push(flo_vector2d_1.default.distanceBetween(_p.p, x));\n    }\n    var closestD = Math.min.apply(Math, closestDs);\n    var radiusDelta = Math.abs(radius - closestD);\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log(radiusDelta); }\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log('---------------------'); }\n    //-----------------------------------------------------------------\n    // TODO Weights still need to be determined\n    var W1 = 1;\n    var W2 = 1;\n    var error = W1 * radiusDelta + W2 * totalAngleError;\n    return { ps: ps, circle: circle, error: error };\n}\nvar calcVectorToZeroV_StraightToIt = flo_vector2d_1.default.fromTo;\n// This function is currently unused\n/*\r\nfunction calcVectorToZeroV_AlongMedial(\r\n        circleCenter: number[],\r\n        ps: number[][]) {\r\n\r\n    let v1 = Vector.fromTo(ps[0], ps[2]);\r\n    let v2 = [-v1[1], v1[0]]; // Rotate by 90 degrees\r\n    let l1 = Vector.len(Vector.fromTo(x, circleCenter));\r\n    let v3 = Vector.toUnitVector(v2);\r\n    let v4 = Vector.scale(v3, l1);\r\n    /*\r\n    if (typeof FloMat !== 'undefined' && FloMat._debug_ && !FloMat._debug_.config.isTiming) {\r\n        FloMat._debug_.fs.draw.line([x, Vector.translate(x,vectorToZeroV)], 'thin10 red');\r\n        FloMat._debug_.fs.draw.line([x, Vector.translate(x,v4)], 'thin10 blue');\r\n    }\r\n    */ /*\r\n       return v4;\r\n       }\r\n       */\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong\r\n * circle.\r\n *\r\n * The potential function, V, is defined as the distance to the\r\n * actual 3 prong circle center.\r\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\n    var V = flo_vector2d_1.default.len(vectorToZeroV);\n    var nu = 1;\n    var better = void 0;\n    var newX = void 0;\n    var newPs = void 0;\n    var newV = void 0;\n    var i = 0; // Safeguard\n    do {\n        var shift = flo_vector2d_1.default.scale(vectorToZeroV, nu);\n        newX = flo_vector2d_1.default.translate(shift, x);\n        newPs = getClosestPoints(newX, bezierPiece3s);\n        // Point of zero V\n        var newCircleCenter = flo_vector2d_1.default.circumCenter(newPs.map(function (x) {\n            return x.p;\n        }));\n        var newVectorToZeroV = flo_vector2d_1.default.fromTo(newX, newCircleCenter);\n        newV = flo_vector2d_1.default.len(newVectorToZeroV);\n        better = newV < V;\n        nu = nu / 2;\n        i++;\n    } while (!better && i < 3);\n    return { newX: newX, newV: newV, newPs: newPs };\n}\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate.\r\n * The point must be within the shape.\r\n *\r\n * @param delta3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n */\nfunction calcInitial3ProngPoint(shape, delta3s, bezierPiece3s) {\n    // TODO - No need to calculate, we already have this info somewhere.\n    var twoProngCircleCenter = flo_vector2d_1.default.mean([delta3s[0][0].item.pointOnShape.p, delta3s[2][1].item.pointOnShape.p]);\n    var point1 = get_closest_boundary_point_to_point_1.default(bezierPiece3s[1], twoProngCircleCenter, undefined, // bezierNode\n    undefined // t\n    );\n    var meanPoints = [delta3s[0][0].item.pointOnShape.p,\n    //Vector.mean([delta3s[1][0].item, delta3s[1][1].item]),\n    point1.p, delta3s[2][1].item.pointOnShape.p];\n    var p = void 0;\n    if (delta3s[0][0].item.pointOnShape.type === mat_constants_1.default.pointType.sharp) {\n        // delta3s start and end at sharp corner. If delta3s start at a sharp \n        // corner it will end there also so no need to check for end point as \n        // well.\n        p = flo_vector2d_1.default.mean([meanPoints[0], meanPoints[1]]);\n    } else {\n        p = flo_vector2d_1.default.circumCenter(meanPoints);\n    }\n    if (!Number.isFinite(p[0])) {\n        if (typeof window !== 'undefined' && window._debug_) {\n            // TODO - check why this actuall happens sometimes\n            //console.log(FloMat._debug_.pointsToNiceStr(meanPoints));\n            //console.log(FloMat._debug_.deltasToNiceStr(delta3s));\n            //console.log(p, meanPoints);\n        }\n    }\n    if (!Number.isFinite(p[0])) {\n        var sames = whichNotSame(meanPoints);\n        return flo_vector2d_1.default.mean([meanPoints[sames[0]], meanPoints[sames[1]]]);\n    }\n    return p;\n}\nfunction whichNotSame(ps) {\n    if (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\n        return [0, 2];\n    } else if (ps[1][0] === ps[2][0] && ps[1][1] === ps[2][1]) {\n        return [0, 2];\n    } else if (ps[2][0] === ps[0][0] && ps[2][1] === ps[0][1]) {\n        return [1, 2];\n    }\n    ;\n    return [];\n}\nfunction getClosestPoints(x, bezierPiece3s) {\n    return bezierPiece3s.map(function (bezierPieces) {\n        var p = get_closest_boundary_point_to_point_1.default(bezierPieces, x, undefined, // bezierNode\n        undefined // t\n        );\n        return p;\n    });\n}\nexports.default = find3Prong;\n\n},{\"../../geometry/classes/circle\":6,\"../../geometry/classes/point-on-shape\":9,\"../../geometry/classes/shape\":10,\"../../geometry/functions/get-closest-boundary-point-to-point\":13,\"../../mat-constants\":18,\"../classes/debug/three-prong-for-debugging\":20,\"flo-bezier3\":40,\"flo-vector2d\":56}],32:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar Point_on_shape_1 = _dereq_(\"../../geometry/classes/Point-on-shape\");\nvar add_2_prong_1 = _dereq_(\"./add-2-prong\");\nvar find_2_prong_1 = _dereq_(\"./find-2-prong\");\nvar build_mat_1 = _dereq_(\"./build-mat\");\n/**\r\n * Find the MAT from the given Shape.\r\n * @param shape\r\n */\nfunction findMat(shape) {\n    findAndAddHoleClosing2Prongs(shape);\n    findAndAdd2ProngsOnAllPaths(shape);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        _debug_.generated.timing.after2Prongs = performance.now();\n    }\n    //---- Connect the n-prong centers and add the 3-prongs.\n    var contactPoints = shape.contactPointsPerLoop[0];\n    var cpNode = contactPoints.head;\n    do {\n        if (cpNode.item.matCircle.cpNodes.length === 2 && !(cpNode.next.prevOnCircle === cpNode)) {\n            break;\n        }\n        cpNode = cpNode.next;\n    } while (cpNode !== contactPoints.head);\n    var cptest = cpNode.prevOnCircle;\n    var branchForth = build_mat_1.default(shape, cptest, undefined, undefined, false);\n    var branchBack = build_mat_1.default(shape, cptest.prevOnCircle, undefined, undefined, false);\n    branchForth.branches.push(branchBack.branches[0]);\n    branchBack.branches[0].branches[0] = branchForth;\n    var mat = new mat_tree_1.default(branchForth);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.timing.after3Prongs = performance.now();\n    }\n    return fixMat(mat);\n}\n/**\r\n * Finds and adds two-prongs that removes any holes in the shape.\r\n * @param {Shape} shape\r\n * @returns {undefined}\r\n */\nfunction findAndAddHoleClosing2Prongs(shape) {\n    var extremes = shape.extremes;\n    for (var k = 1; k < extremes.length; k++) {\n        var extreme = extremes[k];\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [extreme.p[0], extreme.p[1] - r];\n        var osculatingCircle = new circle_1.default(p, r);\n        var posA2 = new Point_on_shape_1.default(extreme.bezierNode, extreme.t, mat_constants_1.default.pointType.extreme, 0, //order \n        0);\n        // A normal traversal should give (cyclically) A1->A2->B1->B2\n        var twoProngInfo = find_2_prong_1.default(shape, posA2, true);\n        var circle = twoProngInfo.circle,\n            z = twoProngInfo.z;\n\n        var posA1 = z;\n        var key = Point_on_shape_1.default.makeSimpleKey(posA2.p);\n        if (shape.straightUpHash[key]) {\n            // Skip these when doing normal 2-prong procedure.\n            shape.skip2ProngHash[key] = posA2;\n        }\n        add_2_prong_1.default(shape, circle, posA2, posA1, true);\n    }\n}\n/**\r\n * Add 2 prongs.\r\n *\r\n * See comments on the add2Prong function.\r\n */\nfunction findAndAdd2ProngsOnAllPaths(shape) {\n    var for2ProngsArray = shape.for2ProngsArray;\n    for (var k = 0; k < for2ProngsArray.length; k++) {\n        var for2Prongs = for2ProngsArray[k];\n        findAndAdd2Prongs(shape, k, for2Prongs);\n    }\n}\nfunction findAndAdd2Prongs(shape, k, for2Prongs) {\n    var len = for2Prongs.length;\n    //let index = indexInterlaced(len); // Keep for debuggin.\n    var index = indexLinear(len);\n    for (var i = 0; i < len; i++) {\n        var posNode = for2Prongs[index[i]];\n        var pos = posNode.item;\n        var key = Point_on_shape_1.default.makeSimpleKey(pos.p);\n        if (shape.skip2ProngHash[key]) {\n            continue;\n        }\n        var twoProngInfo = find_2_prong_1.default(shape, pos, false);\n        if (twoProngInfo) {\n            var circle = twoProngInfo.circle,\n                z = twoProngInfo.z;\n\n            add_2_prong_1.default(shape, circle, pos, z, false);\n        } else {\n            // failed\n        }\n    }\n    /*\r\n     * Don't delete - keep for future debugging.\r\n     * Check if point orders follow each other - they absolutely must.\r\n     */\n    /*\r\n    if (typeof FloMat !== 'undefined' && FloMat._debug_) {\r\n        let contactPoints = shape.contactPointsPerLoop[k];\r\n        let cpNode = contactPoints.head;\r\n        let first = true;\r\n        let prev = undefined;\r\n        do {\r\n            if (first) {\r\n                first = false;\r\n                prev = cpNode.item;\r\n                cpNode = cpNode.next;\r\n                continue;\r\n            }\r\n        \r\n            let cmp = ContactPoint.compare(prev, cpNode.item);\r\n            if (cmp >= 0) {\r\n                console.log(cmp);\r\n            }\r\n            \r\n            prev = cpNode.item;\r\n            cpNode = cpNode.next;\r\n        } while (cpNode !== contactPoints.head);\r\n    }\r\n    */\n}\n/**\r\n * This is unfortunately currently required since I can't get the buildMat\r\n * recursive algorithm right on the first pass.\r\n * @param mat\r\n */\nfunction fixMat(mat) {\n    f(mat.startNode, undefined);\n    function f(matNode, priorNode) {\n        if (matNode.branches.length === 3 && matNode.branches[2].matCircle === matNode.matCircle) {\n            var firstRight = matNode.branches[2];\n            var secondRight = firstRight.branches[1];\n            matNode.branches[2] = secondRight;\n            secondRight.branches[0] = matNode;\n        }\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var node = _step.value;\n\n                if (node === priorNode) {\n                    // Don't go back in tracks.\n                    continue;\n                }\n                f(node, matNode);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return mat;\n}\n/**\r\n * Creates a kind of interlaced index vector, e.g. TODO\r\n *\r\n * @param n\r\n * @returns {number[]}\r\n */\n/*\r\nfunction indexInterlaced(n) {\r\n    \r\n    let arr = [];\r\n    helper(0, n, arr);\r\n    \r\n    return arr;\r\n    \r\n    function helper(start, end) {\r\n        \r\n        if (end === start) {\r\n            return;\r\n        }\r\n        \r\n        if ((end - start) === 1) {\r\n            arr.push(start);\r\n            return;\r\n        }\r\n        \r\n        \r\n        let halfway = start + Math.floor((end-start) / 2);\r\n        \r\n        arr.push(halfway);\r\n        helper(start, halfway);\r\n        helper(halfway+1, end);\r\n    }\r\n}\r\n*/\nfunction indexInterlaced(n) {\n    var source = {};\n    var arr = [];\n    // l <=> the lowest power of 2 so that 2^l > n\n    var l = Math.pow(2, Math.floor(Math.log2(n)));\n    while (l >= 1) {\n        var k = 0;\n        while (k < n) {\n            if (!source[k]) {\n                arr.push(k);\n                source[k] = true;\n            }\n            k = k + l;\n        }\n        l = l / 2;\n    }\n    return arr;\n}\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n * @returns {number[]}\r\n */\nfunction indexLinear(n) {\n    var arr = [];\n    for (var i = 0; i < n; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\nexports.default = findMat;\n\n},{\"../../geometry/classes/Point-on-shape\":3,\"../../geometry/classes/circle\":6,\"../../mat-constants\":18,\"../classes/mat-tree\":25,\"./add-2-prong\":26,\"./build-mat\":28,\"./find-2-prong\":30}],33:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_1 = _dereq_(\"./traverse\");\n/**\r\n * Returns all the calculated MAT nodes as an array.\r\n */\nfunction getNodesAsArray(mat) {\n    var nodes = [];\n    traverse_1.default(mat, function (node) {\n        nodes.push(node);\n    });\n    return nodes;\n}\nexports.default = getNodesAsArray;\n\n},{\"./traverse\":37}],34:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar traverse_1 = _dereq_(\"./traverse\");\nfunction getNodesAsHash(mat) {\n    var nodes = {};\n    traverse_1.default(mat, function (node) {\n        var key = point_on_shape_1.default.makeSimpleKey(node.matCircle.circle.center);\n        nodes[key] = node;\n    });\n    return nodes;\n}\nexports.default = getNodesAsHash;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"./traverse\":37}],35:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar geometry_1 = _dereq_(\"../../geometry/geometry\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\n/**\r\n * Smoothens the given MAT by fitting consecutive node links by\r\n * lines, quadratic or cubic beziers.\r\n */\nfunction smoothen(mat) {\n    /**\r\n     * Get the linked contact points. TODO This information to be\r\n     * stored in the MatCircle in the future then there is no need\r\n     * to actually search for it!\r\n     */\n    function getLinkedCps(prevCpNodes, currCpNodes) {\n        for (var i = 0; i < prevCpNodes.length; i++) {\n            var prevCpNode = prevCpNodes[i];\n            for (var j = 0; j < currCpNodes.length; j++) {\n                var currCpNode = currCpNodes[j];\n                if (prevCpNode.next === currCpNode) {\n                    return [prevCpNode, currCpNode];\n                }\n            }\n        }\n    }\n    var lines = [];\n    var quads = [];\n    var cubes = [];\n    mat_tree_1.default.traverse(mat, function (currNode, prevNode) {\n        if (!prevNode) {\n            return;\n        }\n        var prevMatCircle = prevNode.matCircle;\n        var prevCc = prevMatCircle.circle.center;\n        var prevCpNodes = prevMatCircle.cpNodes;\n        var currMatCircle = currNode.matCircle;\n        var currCc = currMatCircle.circle.center;\n        var currCpNodes = currMatCircle.cpNodes;\n\n        var _getLinkedCps = getLinkedCps(prevCpNodes, currCpNodes),\n            _getLinkedCps2 = _slicedToArray(_getLinkedCps, 2),\n            prevCpNode = _getLinkedCps2[0],\n            currCpNode = _getLinkedCps2[1];\n\n        var prevL = getDirectionToNextMatCircle(prevCpNode, prevCc, true);\n        var currL = getDirectionToNextMatCircle(currCpNode, currCc, false);\n        function getDirectionToNextMatCircle(cpNode, circleCenter, isPrev) {\n            var cp1 = cpNode.item;\n            var cp2 = isPrev ? cpNode.nextOnCircle.item : cpNode.prevOnCircle.item;\n            var vDir = void 0;\n            if (cp1 !== cp2) {\n                // Not a 1-prong.\n                var spanner = flo_vector2d_1.default.fromTo(cp1.pointOnShape.p, cp2.pointOnShape.p);\n                vDir = flo_vector2d_1.default.rotate90Degrees(spanner);\n            } else {\n                if (cp1.pointOnShape.type === mat_constants_1.default.pointType.sharp) {\n                    var bezierNode1 = void 0;\n                    var bezierNode2 = void 0;\n                    if (cp1.pointOnShape.t === 0) {\n                        bezierNode1 = cp1.pointOnShape.bezierNode;\n                        bezierNode2 = cp1.pointOnShape.bezierNode.prev;\n                    } else if (cp1.pointOnShape.t === 1) {\n                        bezierNode1 = cp1.pointOnShape.bezierNode.next;\n                        bezierNode2 = cp1.pointOnShape.bezierNode;\n                    }\n                    var tan1 = flo_bezier3_1.default.tangent(bezierNode1.item.bezier3)(0);\n                    var tan2 = flo_vector2d_1.default.reverse(flo_bezier3_1.default.tangent(bezierNode2.item.bezier3)(1));\n                    var x = flo_vector2d_1.default.dot(tan1, tan2);\n                    // Recall the identities sin(acos(x)) = sqrt(1-x^2),\n                    // etc. Also recall the half angle formulas. Then \n                    // the rotation matrix, R, can be calculated.\n                    var cosθ = Math.sqrt((1 + x) / 2);\n                    var sinθ = Math.sqrt((1 - x) / 2);\n                    vDir = flo_vector2d_1.default.rotate(sinθ, cosθ, tan2);\n                } else {\n                    vDir = flo_vector2d_1.default.fromTo(cp1.pointOnShape.p, circleCenter);\n                }\n            }\n            var v = flo_vector2d_1.default.translate(flo_vector2d_1.default.toLength(vDir, 1), circleCenter);\n            var l = [circleCenter, v];\n            return l;\n        }\n        var mid = geometry_1.default.lineLineIntersection(prevL, currL);\n        var twisted = void 0;\n        if (mid) {\n            var a = flo_vector2d_1.default.fromTo(prevCc, mid);\n            var b = flo_vector2d_1.default.fromTo(currCc, mid);\n            var c = flo_vector2d_1.default.fromTo(prevCc, currCc);\n            var dot1 = flo_vector2d_1.default.dot(a, c);\n            var dot2 = flo_vector2d_1.default.dot(b, c);\n            twisted = dot1 < 0 || dot2 > 0;\n        }\n        if (!mid) {\n            lines.push([prevCc, currCc]);\n        } else if (twisted) {\n            var lp1 = flo_vector2d_1.default.mean([prevCc, currCc]);\n            var vv1 = flo_vector2d_1.default.fromTo(prevCc, currCc);\n            var vvv1 = flo_vector2d_1.default.rotate90Degrees(vv1);\n            var lpp1 = flo_vector2d_1.default.translate(vvv1, lp1);\n            var l = [lp1, lpp1];\n            var mid1 = geometry_1.default.lineLineIntersection(prevL, l);\n            var mid2 = geometry_1.default.lineLineIntersection(currL, l);\n            cubes.push([prevCc, mid1, mid2, currCc]);\n        } else {\n            //console.log(prevCc, mid, currCc);\n            quads.push([prevCc, mid, currCc]);\n        }\n    });\n    return {\n        lines: lines,\n        quads: quads,\n        cubes: cubes\n    };\n}\nexports.default = smoothen;\n\n},{\"../../geometry/geometry\":15,\"../../mat-constants\":18,\"../classes/mat-tree\":25,\"flo-bezier3\":40,\"flo-vector2d\":56}],36:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar copy_mat_1 = _dereq_(\"./copy-mat\");\nvar get_nodes_as_hash_1 = _dereq_(\"./get-nodes-as-hash\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\n// TODO - fix highly convoluted typescript typings by modifiying code so that \n// a tree node (i.e. TTree type) does not use type union\nvar width = 1620; // TODO change to actual shape coordinates\nvar height = 1560; // ...\n/**\r\n * Apply the Scale Axis Transform (SAT) to the MAT.\r\n *\r\n * @param mat_ - The Medial Axis Transform (MAT) on which to apply the SAT.\r\n * @param s - The scale factor >= 1 (e.g. 1.3)\r\n * @returns {MatTree}\r\n */\nfunction toScaleAxis(mat_, s) {\n    // TODO\n    // This algorithm might be made somewhat faster by building tree to a depth \n    // where there is say less than 4 other circles and then only split the \n    // branch once this threshold has been exceeded.\n    // \n    // Also, when searching, search only in relevant branches even when circle \n    // overlaps more than one group.\n    var mat = copy_mat_1.default(mat_);\n    // Start with the biggest circle (since it is the most likely to eclipse \n    // other circles), multiply its radius by s and see which circles are fully \n    // contained in it and trim it away in the MAT tree.\n    var nodeHash = get_nodes_as_hash_1.default(mat);\n    var biggest = -Number.POSITIVE_INFINITY;\n    var biggestNode = void 0;\n    for (var key in nodeHash) {\n        var node = nodeHash[key];\n        var r = node.matCircle.circle.radius;\n        if (r > biggest) {\n            biggestNode = node;\n            biggest = r;\n        }\n    }\n    var tree = createSpacialTree(s, nodeHash);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        /*\r\n        if (FloMat._debug_.shouldDrawSATTree) {\r\n            FloMat._debug_.drawSATTree(tree);\r\n        }\r\n        */\n        _debug_.generated.sat.tree = tree;\n    }\n    // Grab the MAT tree at its biggest node.\n    var sat = new mat_tree_1.default(biggestNode);\n    var cullHash = {};\n    // Look at circles in roughly order of size for each tree branch,\n    // e.g. circles in branch 5 are always larger than in branches 0\n    // to 4.\n    traverseSpacialTree(tree, cullem, { s: s, tree: tree, cullHash: cullHash });\n    // We now walk the MAT tree and keep all non-culled nodes and any\n    // nodes that have a non-culled node further down the line toward\n    // the tree leaves.\n    var cullNodes = [];\n    cullIt(cullHash, cullNodes, sat.startNode);\n    cullTheNodes(cullNodes);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.timing.afterSat = performance.now();\n    }\n    return sat;\n}\nfunction addToTree(s, tree, coordinate, limits, node, key, depth) {\n    // DEPTH_LIMIT can be anything from 1 to 16, but from 2 to 6 seem \n    // to be the fastest.\n    var DEPTH_LIMIT = 6;\n    var circle = node.matCircle.circle;\n\n    var _calcGroups = calcGroups(s, coordinate, limits, circle),\n        groups = _calcGroups.groups,\n        newLimits = _calcGroups.newLimits;\n    // Create new branch if it does not exist yet.\n\n\n    if (groups.length === 1 && depth !== DEPTH_LIMIT) {\n        var group = groups[0];\n        if (!tree[group]) {\n            tree[group] = {};\n        }\n        var _branch = tree[group];\n        // Flip coordinates\n        var newCoordinate = coordinate ? 0 : 1;\n        addToTree(s, _branch, newCoordinate, newLimits, node, key, depth + 1);\n        return;\n    }\n    if (!tree[5]) {\n        tree[5] = new Map();\n    }\n    var branch = tree[5];\n    branch.set(key, node);\n}\nfunction createSpacialTree(s, nodeHash) {\n    var coordinate = 0;\n    var limits = [[0, width], [0, height]];\n    var tree = {};\n    for (var key in nodeHash) {\n        var node = nodeHash[key];\n        addToTree(s, tree, coordinate, limits, node, key, 0);\n    }\n    return tree;\n}\nfunction cullem(node, key, extraParams) {\n    var s = extraParams.s,\n        tree = extraParams.tree,\n        cullHash = extraParams.cullHash;\n\n    if (node.matCircle.circle.radius === 0) {\n        return;\n    }\n    if (cullHash[key]) {\n        return;\n    }\n    var cullNodes = getCullNodes(s, tree, node);\n    for (var _key in cullNodes) {\n        if (!cullHash[_key]) {\n            cullHash[_key] = node;\n        }\n    }\n}\nfunction traverseSpacialTree(tree, f, extraParams) {\n    function helper(tree) {\n        if (!tree) {\n            return;\n        }\n        if (tree.size) {\n            tree.forEach(function (node, key) {\n                f(node, key, extraParams);\n            });\n            return; // Leaf reached \n        }\n        if (tree[5]) {\n            helper(tree[5]);\n        }\n        if (tree[0]) {\n            helper(tree[0]);\n        }\n        if (tree[2]) {\n            helper(tree[2]);\n        }\n        if (tree[4]) {\n            helper(tree[4]);\n        }\n        if (tree[1]) {\n            helper(tree[1]);\n        }\n        if (tree[3]) {\n            helper(tree[3]);\n        }\n    }\n    helper(tree);\n}\nfunction getCullNodes(s, tree, testNode) {\n    var c1 = circle_1.default.scale(testNode.matCircle.circle, s);\n    var cullNodes = {};\n    var limits = [[0, width], [0, height]];\n    var circle = testNode.matCircle.circle;\n    helper(tree, 0, limits, 0);\n    return cullNodes;\n    function cullBranch5(tree) {\n        var branch = tree[5];\n        if (!branch) {\n            return;\n        }\n        branch.forEach(function (node, key) {\n            var c2 = circle_1.default.scale(node.matCircle.circle, s);\n            if (circle_1.default.engulfsCircle(c1, c2)) {\n                cullNodes[key] = node;\n                branch.delete(key);\n            }\n        });\n    }\n    function helper(tree, coordinate, limits, depth) {\n        if (limits === null) {\n            // If we already reached a circle which spans multiple groups \n            // previously, then check all circles in the tree.\n            cullBranch5(tree);\n            for (var i = 0; i <= 4; i++) {\n                var branch = tree[i];\n                if (branch) {\n                    helper(branch, 0, null, depth + 1);\n                }\n            }\n            return;\n        }\n\n        var _calcGroups2 = calcGroups(s, coordinate, limits, circle),\n            groups = _calcGroups2.groups,\n            newLimits = _calcGroups2.newLimits;\n\n        if (groups.length === 1) {\n            cullBranch5(tree);\n            var group = groups[0];\n            var newCoordinate = coordinate ? 0 : 1;\n            if (group === 1 || group === 3) {\n                // One of the higher priority left/top or \n                // right/bottom half groups.\n                var _branch2 = tree[group];\n                if (_branch2) {\n                    helper(_branch2, newCoordinate, newLimits, depth + 1);\n                }\n            } else {\n                // One of the lower priority even \n                // groups (0,2 or 4).\n                var branches = [];\n                branches.push(tree[group]);\n                if (group > 0) {\n                    branches.push(tree[group - 1]);\n                }\n                if (group < 4) {\n                    branches.push(tree[group + 1]);\n                }\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var _branch3 = _step.value;\n\n                        if (_branch3) {\n                            helper(_branch3, newCoordinate, newLimits, depth + 1);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            }\n            return;\n        }\n        cullBranch5(tree);\n        // Circle spans multiple groups at this level of the \n        // tree. Check all circles in all branches.\n        for (var _i = 0; _i <= 4; _i++) {\n            var _branch4 = tree[_i];\n            if (_branch4) {\n                helper(_branch4, 0, null, depth + 1);\n            }\n        }\n    }\n}\n/**\r\n * Modifies cullNodes by adding nodes that potentially need to be called.\r\n * Returns true if a node should NOT be culled, false otherwise.\r\n */\nfunction cullIt(cullHash, cullNodes, satNode, priorNode) {\n    var key = point_on_shape_1.default.makeSimpleKey(satNode.matCircle.circle.center);\n    var anyNotCull = !cullHash[key];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = satNode.branches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var node = _step2.value;\n\n            if (node === priorNode) {\n                continue;\n            }\n            if (cullIt(cullHash, cullNodes, node, satNode)) {\n                anyNotCull = true;\n            }\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    if (anyNotCull) {\n        return true; // Don't cull me\n    }\n    cullNodes.push({ satNode: satNode, priorNode: priorNode });\n    return false;\n}\nfunction cullTheNode(cullNode) {\n    var satNode = cullNode.satNode,\n        priorNode = cullNode.priorNode;\n\n    var idx = priorNode.branches.indexOf(satNode);\n    if (idx >= 0) {\n        priorNode.branches.splice(idx, 1);\n    }\n}\nfunction cullTheNodes(cullNodes) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = cullNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var node = _step3.value;\n\n            cullTheNode(node);\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n}\n/**\r\n * Spacially divide into 5 special groups as follows:\r\n *\r\n *   *******||*******|*******|*******|*******||*******\r\n * 0 <--------------->\r\n * 1         <--------------->\r\n * 2                 <--------------->\r\n * 3                         <--------------->\r\n * 4                                 <--------------->\r\n * 5 - If the circle does not fall in any of above 5 groups.\r\n *\r\n * Note: In the above, the double pipes denote the limits for\r\n *       a coordinate, so as can be seen groups 0 and 4 go outside\r\n *       the limits. Also, groups 1 and 3 are preferred and checked\r\n *       first.\r\n *\r\n * @param s Scale parameter, e.g. 1.1\r\n * @param coordinate - 0 -> horizontal or 1 -> vertical.\r\n * @param limits - The limits within which the circle bounds can fall.\r\n * @param circle - The circle to categorize into a group.\r\n */\nfunction calcGroups(s, coordinate, limits, circle) {\n    var limit = limits[coordinate];\n    var l1 = limit[0];\n    var l2 = limit[1];\n    // Relevant cut-off lines.\n    var q = (l2 - l1) / 4;\n    var w = q + q;\n    // Shift origin\n    var r = circle.radius;\n    var x = circle.center[coordinate] - l1;\n    var x0 = x - r * s;\n    var x1 = x + r * s;\n    var newLimit = [,];\n    var groups = []; // Group to which circle belongs;\n    /* This was the old method to get groups and newLimit, but it\r\n     * seems to be only slightly slower so could also be used\r\n    let is = [1,3,0,2,4]; // Groups 1 and 3 takes priority.\r\n    for (let i=0; i<=4; i++) {\r\n        let q0 = q*(is[i]-1);\r\n        let q1 = q0 + w;\r\n        if (x0 > q0 && x1 <= q1) {\r\n            groups.push(is[i]);\r\n            newLimit = [l1 + q0, l1 + q1];\r\n            break;\r\n        }\r\n    }*/\n    var qStart = Math.floor(x0 / q);\n    var qEnd = Math.floor(x1 / q) + 1;\n    var qDiff = qEnd - qStart;\n    var group = void 0;\n    if (qDiff === 1) {\n        // If contained in sliver.\n        group = 2 * Math.floor(qStart / 2) + 1;\n        groups.push(group);\n        var lowerLimit = l1 + q * (group - 1);\n        newLimit = [lowerLimit, lowerLimit + w];\n    } else if (qDiff === 2) {\n        group = qStart + 1;\n        groups.push(group);\n        var _lowerLimit = l1 + q * (group - 1);\n        newLimit = [_lowerLimit, _lowerLimit + w];\n    }\n    var newLimits = [,];\n    if (groups.length === 1) {\n        var otherCoordinate = coordinate ? 0 : 1;\n        newLimits[otherCoordinate] = limits[otherCoordinate];\n        newLimits[coordinate] = newLimit;\n    }\n    return { groups: groups, newLimits: newLimits };\n}\nexports.default = toScaleAxis;\n\n},{\"../../geometry/classes/circle\":6,\"../../geometry/classes/point-on-shape\":9,\"../classes/mat-tree\":25,\"./copy-mat\":29,\"./get-nodes-as-hash\":34}],37:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Traverses the MAT tree and calls a function on each node. This\r\n * function must have side effects to be useful.\r\n *\r\n * @param mat\r\n */\nfunction traverse(mat, f) {\n    g(mat.startNode);\n    function g(matNode, priorNode) {\n        f(matNode, priorNode);\n        //for (let node of matNode.branches) {\n        for (var i = 0; i < matNode.branches.length; i++) {\n            var node = matNode.branches[i];\n            if (node === priorNode) {\n                // Don't go back in tracks.\n                continue;\n            }\n            g(node, matNode);\n        }\n    }\n}\nexports.default = traverse;\n\n},{}],38:[function(_dereq_,module,exports){\n\"use strict\";\n// @info\n//   Polyfill for SVG 2 getPathData() and setPathData() methods. Based on:\n//   - SVGPathSeg polyfill by Philip Rogers (MIT License)\n//     https://github.com/progers/pathseg\n//   - SVGPathNormalizer by Tadahisa Motooka (MIT License)\n//     https://github.com/motooka/SVGPathNormalizer/tree/master/src\n//   - arcToCubicCurves() by Dmitry Baranovskiy (MIT License)\n//     https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/raphael.core.js#L1837\n// @author\n//   Jarosław Foksa\n// @license\n//   MIT License\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction pathDataPolyFill() {\n    if (!SVGPathElement.prototype.getPathData || !SVGPathElement.prototype.setPathData) {\n        applyPolyFill();\n    }\n}\nfunction applyPolyFill() {\n    // TODO - \n    var commandsMap = {\n        \"Z\": \"Z\", \"M\": \"M\", \"L\": \"L\", \"C\": \"C\", \"Q\": \"Q\", \"A\": \"A\", \"H\": \"H\", \"V\": \"V\", \"S\": \"S\", \"T\": \"T\",\n        \"z\": \"Z\", \"m\": \"m\", \"l\": \"l\", \"c\": \"c\", \"q\": \"q\", \"a\": \"a\", \"h\": \"h\", \"v\": \"v\", \"s\": \"s\", \"t\": \"t\"\n    };\n\n    var Source = function () {\n        function Source(string) {\n            _classCallCheck(this, Source);\n\n            this._string = string;\n            this._currentIndex = 0;\n            this._endIndex = this._string.length;\n            this._prevCommand = null;\n            this._skipOptionalSpaces();\n        }\n\n        _createClass(Source, [{\n            key: \"parseSegment\",\n            value: function parseSegment() {\n                var char = this._string[this._currentIndex];\n                var command = commandsMap[char] ? commandsMap[char] : null;\n                if (command === null) {\n                    // Possibly an implicit command. Not allowed if this is the first command.\n                    if (this._prevCommand === null) {\n                        return null;\n                    }\n                    // Check for remaining coordinates in the current command.\n                    if ((char === \"+\" || char === \"-\" || char === \".\" || char >= \"0\" && char <= \"9\") && this._prevCommand !== \"Z\") {\n                        if (this._prevCommand === \"M\") {\n                            command = \"L\";\n                        } else if (this._prevCommand === \"m\") {\n                            command = \"l\";\n                        } else {\n                            command = this._prevCommand;\n                        }\n                    } else {\n                        command = null;\n                    }\n                    if (command === null) {\n                        return null;\n                    }\n                } else {\n                    this._currentIndex += 1;\n                }\n                this._prevCommand = command;\n                var values = null;\n                var cmd = command.toUpperCase();\n                if (cmd === \"H\" || cmd === \"V\") {\n                    values = [this._parseNumber()];\n                } else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n                    values = [this._parseNumber(), this._parseNumber()];\n                } else if (cmd === \"S\" || cmd === \"Q\") {\n                    values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n                } else if (cmd === \"C\") {\n                    values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n                } else if (cmd === \"A\") {\n                    values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseArcFlag(), this._parseArcFlag(), this._parseNumber(), this._parseNumber()];\n                } else if (cmd === \"Z\") {\n                    this._skipOptionalSpaces();\n                    values = [];\n                }\n                if (values === null || values.indexOf(null) >= 0) {\n                    // Unknown command or known command with invalid values\n                    return null;\n                } else {\n                    return { type: command, values: values };\n                }\n            }\n        }, {\n            key: \"hasMoreData\",\n            value: function hasMoreData() {\n                return this._currentIndex < this._endIndex;\n            }\n        }, {\n            key: \"peekSegmentType\",\n            value: function peekSegmentType() {\n                var char = this._string[this._currentIndex];\n                return commandsMap[char] ? commandsMap[char] : null;\n            }\n        }, {\n            key: \"initialCommandIsMoveTo\",\n            value: function initialCommandIsMoveTo() {\n                // If the path is empty it is still valid, so return true.\n                if (!this.hasMoreData()) {\n                    return true;\n                }\n                var command = this.peekSegmentType();\n                // Path must start with moveTo.\n                return command === \"M\" || command === \"m\";\n            }\n        }, {\n            key: \"_isCurrentSpace\",\n            value: function _isCurrentSpace() {\n                var char = this._string[this._currentIndex];\n                return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n            }\n        }, {\n            key: \"_skipOptionalSpaces\",\n            value: function _skipOptionalSpaces() {\n                while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n                    this._currentIndex += 1;\n                }\n                return this._currentIndex < this._endIndex;\n            }\n        }, {\n            key: \"_skipOptionalSpacesOrDelimiter\",\n            value: function _skipOptionalSpacesOrDelimiter() {\n                if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string[this._currentIndex] !== \",\") {\n                    return false;\n                }\n                if (this._skipOptionalSpaces()) {\n                    if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n                        this._currentIndex += 1;\n                        this._skipOptionalSpaces();\n                    }\n                }\n                return this._currentIndex < this._endIndex;\n            }\n            // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n            // Source/core/svg/SVGParserUtilities.cpp.\n            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n\n        }, {\n            key: \"_parseNumber\",\n            value: function _parseNumber() {\n                var exponent = 0;\n                var integer = 0;\n                var frac = 1;\n                var decimal = 0;\n                var sign = 1;\n                var expsign = 1;\n                var startIndex = this._currentIndex;\n                this._skipOptionalSpaces();\n                // Read the sign.\n                if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"+\") {\n                    this._currentIndex += 1;\n                } else if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"-\") {\n                    this._currentIndex += 1;\n                    sign = -1;\n                }\n                if (this._currentIndex === this._endIndex || (this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") && this._string[this._currentIndex] !== \".\") {\n                    // The first character of a number must be one of [0-9+-.].\n                    return null;\n                }\n                // Read the integer part, build right-to-left.\n                var startIntPartIndex = this._currentIndex;\n                while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n                    this._currentIndex += 1; // Advance to first non-digit.\n                }\n                if (this._currentIndex !== startIntPartIndex) {\n                    var scanIntPartIndex = this._currentIndex - 1;\n                    var multiplier = 1;\n                    while (scanIntPartIndex >= startIntPartIndex) {\n                        integer += multiplier * (Number(this._string[scanIntPartIndex]) - 0);\n                        scanIntPartIndex -= 1;\n                        multiplier *= 10;\n                    }\n                }\n                // Read the decimals.\n                if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \".\") {\n                    this._currentIndex += 1;\n                    // There must be a least one digit following the .\n                    if (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n                        return null;\n                    }\n                    while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n                        frac *= 10;\n                        decimal += Number(this._string.charAt(this._currentIndex)) / frac;\n                        this._currentIndex += 1;\n                    }\n                }\n                // Read the exponent part.\n                if (this._currentIndex !== startIndex && this._currentIndex + 1 < this._endIndex && (this._string[this._currentIndex] === \"e\" || this._string[this._currentIndex] === \"E\") && this._string[this._currentIndex + 1] !== \"x\" && this._string[this._currentIndex + 1] !== \"m\") {\n                    this._currentIndex += 1;\n                    // Read the sign of the exponent.\n                    if (this._string[this._currentIndex] === \"+\") {\n                        this._currentIndex += 1;\n                    } else if (this._string[this._currentIndex] === \"-\") {\n                        this._currentIndex += 1;\n                        expsign = -1;\n                    }\n                    // There must be an exponent.\n                    if (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n                        return null;\n                    }\n                    while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n                        exponent *= 10;\n                        exponent += Number(this._string[this._currentIndex]);\n                        this._currentIndex += 1;\n                    }\n                }\n                var number = integer + decimal;\n                number *= sign;\n                if (exponent) {\n                    number *= Math.pow(10, expsign * exponent);\n                }\n                if (startIndex === this._currentIndex) {\n                    return null;\n                }\n                this._skipOptionalSpacesOrDelimiter();\n                return number;\n            }\n        }, {\n            key: \"_parseArcFlag\",\n            value: function _parseArcFlag() {\n                if (this._currentIndex >= this._endIndex) {\n                    return null;\n                }\n                var flag = null;\n                var flagChar = this._string[this._currentIndex];\n                this._currentIndex += 1;\n                if (flagChar === \"0\") {\n                    flag = 0;\n                } else if (flagChar === \"1\") {\n                    flag = 1;\n                } else {\n                    return null;\n                }\n                this._skipOptionalSpacesOrDelimiter();\n                return flag;\n            }\n        }]);\n\n        return Source;\n    }();\n\n    var isIE = window.navigator.userAgent.indexOf(\"MSIE \") !== -1;\n    var parsePathDataString = function parsePathDataString(string) {\n        if (!string || string.length === 0) return [];\n        var source = new Source(string);\n        var pathData = [];\n        if (source.initialCommandIsMoveTo()) {\n            while (source.hasMoreData()) {\n                var pathSeg = source.parseSegment();\n                if (pathSeg === null) {\n                    break;\n                } else {\n                    pathData.push(pathSeg);\n                }\n            }\n        }\n        return pathData;\n    };\n    var setAttribute = SVGPathElement.prototype.setAttribute;\n    var removeAttribute = SVGPathElement.prototype.removeAttribute;\n    var $cachedPathData = Symbol();\n    var $cachedNormalizedPathData = Symbol();\n    var degToRad = function degToRad(degrees) {\n        return Math.PI * degrees / 180;\n    };\n    var rotate = function rotate(x, y, angleRad) {\n        var X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n        var Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n        return { x: X, y: Y };\n    };\n    // @info\n    //   Get an array of corresponding cubic bezier curve parameters for given arc curve paramters.\n    var arcToCubicCurves = function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, _recursive) {\n        var angleRad = degToRad(angle);\n        var params = [];\n        var f1, f2, cx, cy;\n        if (_recursive) {\n            f1 = _recursive[0];\n            f2 = _recursive[1];\n            cx = _recursive[2];\n            cy = _recursive[3];\n        } else {\n            var p1 = rotate(x1, y1, -angleRad);\n            x1 = p1.x;\n            y1 = p1.y;\n            var p2 = rotate(x2, y2, -angleRad);\n            x2 = p2.x;\n            y2 = p2.y;\n            var x = (x1 - x2) / 2;\n            var y = (y1 - y2) / 2;\n            var h = x * x / (r1 * r1) + y * y / (r2 * r2);\n            if (h > 1) {\n                h = Math.sqrt(h);\n                r1 = h * r1;\n                r2 = h * r2;\n            }\n            var sign;\n            if (largeArcFlag === sweepFlag) {\n                sign = -1;\n            } else {\n                sign = 1;\n            }\n            var r1Pow = r1 * r1;\n            var r2Pow = r2 * r2;\n            var left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n            var right = r1Pow * y * y + r2Pow * x * x;\n            var k = sign * Math.sqrt(Math.abs(left / right));\n            cx = k * r1 * y / r2 + (x1 + x2) / 2;\n            cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n            f1 = Math.asin(Number(((y1 - cy) / r2).toFixed(9)));\n            f2 = Math.asin(Number(((y2 - cy) / r2).toFixed(9)));\n            if (x1 < cx) {\n                f1 = Math.PI - f1;\n            }\n            if (x2 < cx) {\n                f2 = Math.PI - f2;\n            }\n            if (f1 < 0) {\n                f1 = Math.PI * 2 + f1;\n            }\n            if (f2 < 0) {\n                f2 = Math.PI * 2 + f2;\n            }\n            if (sweepFlag && f1 > f2) {\n                f1 = f1 - Math.PI * 2;\n            }\n            if (!sweepFlag && f2 > f1) {\n                f2 = f2 - Math.PI * 2;\n            }\n        }\n        var df = f2 - f1;\n        if (Math.abs(df) > Math.PI * 120 / 180) {\n            var f2old = f2;\n            var x2old = x2;\n            var y2old = y2;\n            if (sweepFlag && f2 > f1) {\n                f2 = f1 + Math.PI * 120 / 180 * 1;\n            } else {\n                f2 = f1 + Math.PI * 120 / 180 * -1;\n            }\n            x2 = cx + r1 * Math.cos(f2);\n            y2 = cy + r2 * Math.sin(f2);\n            params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = Math.cos(f1);\n        var s1 = Math.sin(f1);\n        var c2 = Math.cos(f2);\n        var s2 = Math.sin(f2);\n        var t = Math.tan(df / 4);\n        var hx = 4 / 3 * r1 * t;\n        var hy = 4 / 3 * r2 * t;\n        var m1 = [x1, y1];\n        var m2 = [x1 + hx * s1, y1 - hy * c1];\n        var m3 = [x2 + hx * s2, y2 - hy * c2];\n        var m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (_recursive) {\n            //return [m2, m3, m4].concat(params);\n            return [m2, m3, m4].concat(_toConsumableArray(params));\n        } else {\n            var _ref;\n\n            //params = [m2, m3, m4].concat(params).join().split(\",\");\n            var params2 = (_ref = []).concat.apply(_ref, [m2, m3, m4].concat(_toConsumableArray(params)));\n            var curves = [];\n            var curveParams;\n            params2.forEach(function (param, i) {\n                if (i % 2) {\n                    curveParams.push(rotate(params2[i - 1], params2[i], angleRad).y);\n                } else {\n                    curveParams.push(rotate(params2[i], params2[i + 1], angleRad).x);\n                }\n                if (curveParams.length === 6) {\n                    curves.push(curveParams);\n                    curveParams = [];\n                }\n            });\n            return curves;\n        }\n    };\n    var clonePathData = function clonePathData(pathData) {\n        return pathData.map(function (seg) {\n            //return {type: seg.type, values: Array.prototype.slice.call(seg.values)}\n            return { type: seg.type, values: seg.values.slice() };\n        });\n    };\n    // @info\n    //   Takes any path data, returns path data that consists only from absolute commands.\n    var absolutizePathData = function absolutizePathData(pathData) {\n        var absolutizedPathData = [];\n        var currentX = null;\n        var currentY = null;\n        var subpathX = null;\n        var subpathY = null;\n        pathData.forEach(function (seg) {\n            var type = seg.type;\n            if (type === \"M\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                absolutizedPathData.push({ type: \"M\", values: [x, y] });\n                subpathX = x;\n                subpathY = y;\n                currentX = x;\n                currentY = y;\n            } else if (type === \"m\") {\n                var x = currentX + seg.values[0];\n                var y = currentY + seg.values[1];\n                absolutizedPathData.push({ type: \"M\", values: [x, y] });\n                subpathX = x;\n                subpathY = y;\n                currentX = x;\n                currentY = y;\n            } else if (type === \"L\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                absolutizedPathData.push({ type: \"L\", values: [x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"l\") {\n                var x = currentX + seg.values[0];\n                var y = currentY + seg.values[1];\n                absolutizedPathData.push({ type: \"L\", values: [x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"C\") {\n                var x1 = seg.values[0];\n                var y1 = seg.values[1];\n                var x2 = seg.values[2];\n                var y2 = seg.values[3];\n                var x = seg.values[4];\n                var y = seg.values[5];\n                absolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"c\") {\n                var x1 = currentX + seg.values[0];\n                var y1 = currentY + seg.values[1];\n                var x2 = currentX + seg.values[2];\n                var y2 = currentY + seg.values[3];\n                var x = currentX + seg.values[4];\n                var y = currentY + seg.values[5];\n                absolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"Q\") {\n                var x1 = seg.values[0];\n                var y1 = seg.values[1];\n                var x = seg.values[2];\n                var y = seg.values[3];\n                absolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"q\") {\n                var x1 = currentX + seg.values[0];\n                var y1 = currentY + seg.values[1];\n                var x = currentX + seg.values[2];\n                var y = currentY + seg.values[3];\n                absolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"A\") {\n                var x = seg.values[5];\n                var y = seg.values[6];\n                absolutizedPathData.push({\n                    type: \"A\",\n                    values: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n                });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"a\") {\n                var x = currentX + seg.values[5];\n                var y = currentY + seg.values[6];\n                absolutizedPathData.push({\n                    type: \"A\",\n                    values: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n                });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"H\") {\n                var x = seg.values[0];\n                absolutizedPathData.push({ type: \"H\", values: [x] });\n                currentX = x;\n            } else if (type === \"h\") {\n                var x = currentX + seg.values[0];\n                absolutizedPathData.push({ type: \"H\", values: [x] });\n                currentX = x;\n            } else if (type === \"V\") {\n                var y = seg.values[0];\n                absolutizedPathData.push({ type: \"V\", values: [y] });\n                currentY = y;\n            } else if (type === \"v\") {\n                var y = currentY + seg.values[0];\n                absolutizedPathData.push({ type: \"V\", values: [y] });\n                currentY = y;\n            } else if (type === \"S\") {\n                var x2 = seg.values[0];\n                var y2 = seg.values[1];\n                var x = seg.values[2];\n                var y = seg.values[3];\n                absolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"s\") {\n                var x2 = currentX + seg.values[0];\n                var y2 = currentY + seg.values[1];\n                var x = currentX + seg.values[2];\n                var y = currentY + seg.values[3];\n                absolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"T\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                absolutizedPathData.push({ type: \"T\", values: [x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"t\") {\n                var x = currentX + seg.values[0];\n                var y = currentY + seg.values[1];\n                absolutizedPathData.push({ type: \"T\", values: [x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (type === \"Z\" || type === \"z\") {\n                absolutizedPathData.push({ type: \"Z\", values: [] });\n                currentX = subpathX;\n                currentY = subpathY;\n            }\n        });\n        return absolutizedPathData;\n    };\n    // @info\n    //   Takes path data that consists only from absolute commands, returns path data that consists only from\n    //   \"M\", \"L\", \"C\" and \"Z\" commands.\n    var reducePathData = function reducePathData(pathData) {\n        var reducedPathData = [];\n        var lastType;\n        var lastControlX;\n        var lastControlY;\n        var currentX;\n        var currentY;\n        var subpathX;\n        var subpathY;\n        pathData.forEach(function (seg) {\n            if (seg.type === \"M\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                reducedPathData.push({ type: \"M\", values: [x, y] });\n                subpathX = x;\n                subpathY = y;\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"C\") {\n                var x1 = seg.values[0];\n                var y1 = seg.values[1];\n                var x2 = seg.values[2];\n                var y2 = seg.values[3];\n                var x = seg.values[4];\n                var y = seg.values[5];\n                reducedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n                lastControlX = x2;\n                lastControlY = y2;\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"L\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                reducedPathData.push({ type: \"L\", values: [x, y] });\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"H\") {\n                var x = seg.values[0];\n                reducedPathData.push({ type: \"L\", values: [x, currentY] });\n                currentX = x;\n            } else if (seg.type === \"V\") {\n                var y = seg.values[0];\n                reducedPathData.push({ type: \"L\", values: [currentX, y] });\n                currentY = y;\n            } else if (seg.type === \"S\") {\n                var x2 = seg.values[0];\n                var y2 = seg.values[1];\n                var x = seg.values[2];\n                var y = seg.values[3];\n                var cx1;\n                var cy1;\n                if (lastType === \"C\" || lastType === \"S\") {\n                    cx1 = currentX + (currentX - lastControlX);\n                    cy1 = currentY + (currentY - lastControlY);\n                } else {\n                    cx1 = currentX;\n                    cy1 = currentY;\n                }\n                reducedPathData.push({ type: \"C\", values: [cx1, cy1, x2, y2, x, y] });\n                lastControlX = x2;\n                lastControlY = y2;\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"T\") {\n                var x = seg.values[0];\n                var y = seg.values[1];\n                var x1;\n                var y1;\n                if (lastType === \"Q\" || lastType === \"T\") {\n                    x1 = currentX + (currentX - lastControlX);\n                    y1 = currentY + (currentY - lastControlY);\n                } else {\n                    x1 = currentX;\n                    y1 = currentY;\n                }\n                var cx1 = currentX + 2 * (x1 - currentX) / 3;\n                var cy1 = currentY + 2 * (y1 - currentY) / 3;\n                var cx2 = x + 2 * (x1 - x) / 3;\n                var cy2 = y + 2 * (y1 - y) / 3;\n                reducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n                lastControlX = x1;\n                lastControlY = y1;\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"Q\") {\n                var x1 = seg.values[0];\n                var y1 = seg.values[1];\n                var x = seg.values[2];\n                var y = seg.values[3];\n                var cx1 = currentX + 2 * (x1 - currentX) / 3;\n                var cy1 = currentY + 2 * (y1 - currentY) / 3;\n                var cx2 = x + 2 * (x1 - x) / 3;\n                var cy2 = y + 2 * (y1 - y) / 3;\n                reducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n                lastControlX = x1;\n                lastControlY = y1;\n                currentX = x;\n                currentY = y;\n            } else if (seg.type === \"A\") {\n                var r1 = seg.values[0];\n                var r2 = seg.values[1];\n                var angle = seg.values[2];\n                var largeArcFlag = seg.values[3];\n                var sweepFlag = seg.values[4];\n                var x = seg.values[5];\n                var y = seg.values[6];\n                if (r1 === 0 || r2 === 0) {\n                    reducedPathData.push({ type: \"C\", values: [currentX, currentY, x, y, x, y] });\n                    currentX = x;\n                    currentY = y;\n                } else {\n                    if (currentX !== x || currentY !== y) {\n                        var curves = arcToCubicCurves(currentX, currentY, x, y, r1, r2, angle, largeArcFlag, sweepFlag, undefined);\n                        curves.forEach(function (curve) {\n                            reducedPathData.push({ type: \"C\", values: curve });\n                            currentX = x;\n                            currentY = y;\n                        });\n                    }\n                }\n            } else if (seg.type === \"Z\") {\n                reducedPathData.push(seg);\n                currentX = subpathX;\n                currentY = subpathY;\n            }\n            lastType = seg.type;\n        });\n        return reducedPathData;\n    };\n    SVGPathElement.prototype.setAttribute = function (name, value) {\n        if (name === \"d\") {\n            this[$cachedPathData] = null;\n            this[$cachedNormalizedPathData] = null;\n        }\n        setAttribute.call(this, name, value);\n    };\n    SVGPathElement.prototype.removeAttribute = function (name) {\n        if (name === \"d\") {\n            this[$cachedPathData] = null;\n            this[$cachedNormalizedPathData] = null;\n        }\n        removeAttribute.call(this, name);\n    };\n    SVGPathElement.prototype.getPathData = function (options) {\n        if (options && options.normalize) {\n            if (this[$cachedNormalizedPathData]) {\n                return clonePathData(this[$cachedNormalizedPathData]);\n            } else {\n                var pathData;\n                if (this[$cachedPathData]) {\n                    pathData = clonePathData(this[$cachedPathData]);\n                } else {\n                    pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n                    this[$cachedPathData] = clonePathData(pathData);\n                }\n                var normalizedPathData = reducePathData(absolutizePathData(pathData));\n                this[$cachedNormalizedPathData] = clonePathData(normalizedPathData);\n                return normalizedPathData;\n            }\n        } else {\n            if (this[$cachedPathData]) {\n                return clonePathData(this[$cachedPathData]);\n            } else {\n                var pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n                this[$cachedPathData] = clonePathData(pathData);\n                return pathData;\n            }\n        }\n    };\n    SVGPathElement.prototype.setPathData = function (pathData) {\n        if (pathData.length === 0) {\n            if (isIE) {\n                // @bugfix https://github.com/mbostock/d3/issues/1737\n                this.setAttribute(\"d\", \"\");\n            } else {\n                this.removeAttribute(\"d\");\n            }\n        } else {\n            var d = \"\";\n            for (var i = 0, l = pathData.length; i < l; i += 1) {\n                var seg = pathData[i];\n                if (i > 0) {\n                    d += \" \";\n                }\n                d += seg.type;\n                if (seg.values && seg.values.length > 0) {\n                    d += \" \" + seg.values.join(\" \");\n                }\n            }\n            this.setAttribute(\"d\", d);\n        }\n    };\n}\nexports.default = pathDataPolyFill;\n\n},{}],39:[function(_dereq_,module,exports){\n\"use strict\";\n// TODO - move later out of mat module\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar path_curve_1 = _dereq_(\"../geometry/classes/path-curve\");\nvar path_data_polyfill_1 = _dereq_(\"./path-data-polyfill/path-data-polyfill\");\n//\t\t'./path-data-polyfill/path-data-polyfill.js';\nvar DELTA = 1e-6; // TODO - must be replaced with value relative to image size.\n/**\r\n * Get the cubic beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C\", i.e. if it is not an absolute cubic bezier\r\n * coordinate then it is converted into one.\r\n * @param elem - An SVG element\r\n * @returns aaa\r\n */\nfunction getBeziersFromSvgElem(elem) {\n    path_data_polyfill_1.default(); // Ensure polyfill has been applied\n    /**\r\n     * Returns true if the given point is close to the origin (by Manhattan\r\n     * distance), fale otherwise.\r\n     * @private\r\n     * @param p - a point\r\n     * @param delta - a tolerance - defaults to 1e-6;\r\n     */\n    function isCloseToOrigin(p) {\n        var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA;\n\n        return flo_vector2d_1.default.manhattanLength(p) < delta;\n    }\n    /**\r\n     * Returns true if distance between consecutive points are all less than\r\n     * some delta, false otherwise.\r\n     * @private\r\n     * @param ps - an array of points\r\n     * @param {number} [delta] - a tolerance - defaults to 1e-6;\r\n     * @returns {boolean}\r\n     */\n    function isAlmostZeroLength(ps) {\n        var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA;\n\n        for (var i = 1; i < ps.length; i++) {\n            var p1 = ps[i - 1];\n            var p2 = ps[i];\n            if (flo_vector2d_1.default.manhattanDistanceBetween(p1, p2) > DELTA) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function pushBezier(arr, ps_, j) {\n        // TODO \n        // We check if any of the ps are coincident and thus\n        // that the bezier is degenerate in some sense. If that is the\n        // case we apply a heuristic to get a new similar bezier by \n        // respacing the points. This entire function is very \n        // convoluted.\n        // We should investigate a better mathematical solution.\n        // Currently if the bezier degenerates more or less into a point\n        // we make the next bezier start at the previous bezier's end\n        // point else we adjust the bezier to be less pathological.\n        //console.log(Vector)\n        var ds = [[0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[1]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[2]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[0]), 0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[2]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[0]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[1]), 0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[0]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[1]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[2]), 0]];\n        var ps = ps_;\n        var SHIFT = 0.1;\n        // Check if first or last 3 points are coincident\n        if (ds[0][1] < DELTA && ds[1][2] < DELTA || ds[1][2] < DELTA && ds[2][3] < DELTA) {\n            ps = [ps_[0], flo_vector2d_1.default.interpolate(ps_[0], ps_[3], 1 / 3), flo_vector2d_1.default.interpolate(ps_[0], ps_[3], 2 / 3), ps_[3]];\n        }\n        // Check if first 2 points are coincident\n        if (ds[0][1] < DELTA) {\n            ps[1] = flo_vector2d_1.default.interpolate(ps_[0], ps_[2], SHIFT);\n        }\n        // Check if last 2 points are coincident\n        if (ds[2][3] < DELTA) {\n            ps[2] = flo_vector2d_1.default.interpolate(ps_[1], ps_[3], 1 - SHIFT);\n        }\n        // Check if middle 2 points are coincident\n        if (ds[1][2] < DELTA) {\n            ps[1] = flo_vector2d_1.default.interpolate(ps_[0], ps_[1], 1 - SHIFT);\n            ps[2] = flo_vector2d_1.default.interpolate(ps_[2], ps_[3], SHIFT);\n        }\n        arr.push(new path_curve_1.default(j, ps));\n    }\n    var MUST_START_WITH_M = 'Invalid SVG - every new path must start with an M or m.';\n    var INVALID_COMMAND = 'Invalid SVG - command not recognized.';\n    //pathDataPolyFill(); // Ensure polyfill is applied.\n    var paths = elem.getPathData();\n    // TODO - must still implement handling of multiple <path>s\n    console.dir(elem);\n    //let paths = elem.getElementsByTagName('path');\n    //let path = paths[0];\n    //let pathSegs = path.pathSegList;\n    if (paths.length < 2) {\n        // A shape is not described   \n        return [];\n    }\n    var pathStarted = false;\n    // Used in conjunction with \"S\" and \"s\"\n    var prev2ndCubicControlPoint = undefined;\n    var prev2ndQuadraticControlPoint = undefined;\n    var bezierArrays = [];\n    var bezierArray = [];\n    var j = void 0;\n    var type = undefined;\n    var initialPoint = undefined;\n    var x0 = void 0;\n    var y0 = void 0;\n    /*\r\n    let pathSeg: {\r\n        type: string/*,\r\n        values: number[]*/ /*\r\n                           };*/\n    for (var i = 0; i < paths.length; i++) {\n        var pathSeg = paths[i];\n        var vals = pathSeg.values;\n        //pathSeg.type = pathSeg_.pathSegTypeAsLetter;\n        var _type = pathSeg.type;\n        var addX = 0;\n        var addY = 0;\n        if (_type == _type.toLowerCase()) {\n            addX = x0;\n            addY = y0;\n        }\n        var prevType = _type;\n        _type = _type.toUpperCase();\n        // TODO - massively simplify this code by using SVGPathSegCurvetoCubicAbs ??????\n        var ps = void 0;\n        switch (_type) {\n            /*\r\n             * M and m: (from www.w3.org)\r\n             * --------------------------\r\n             * Start a new sub-path at the given (x,y) coordinate.\r\n             * M (uppercase) indicates that absolute coordinates will\r\n             * follow; m (lowercase) indicates that relative coordinates\r\n             * will follow. If a moveto is followed by multiple pairs of\r\n             * coordinates, the subsequent pairs are treated as implicit\r\n             * lineto commands. Hence, implicit lineto commands will be\r\n             * relative if the moveto is relative, and absolute if the\r\n             * moveto is absolute. If a relative moveto (m) appears as the\r\n             * first element of the path, then it is treated as a pair of\r\n             * absolute coordinates. In this case, subsequent pairs of\r\n             * coordinates are treated as relative even though the initial\r\n             * moveto is interpreted as an absolute moveto.\r\n             */\n            case 'M':\n                {\n                    // Note: A valid SVG path must start with \"M\" or \"m\".\n                    //let path = (pathSeg as SVGPathSegMovetoAbs);\n                    //let vals = [path.x, path.y];\n                    if (pathStarted) {\n                        // This is a subpath, close as if a Z or z was the\n                        // previous command.\n                        if (prevType !== 'Z') {\n                            var _xInterval = (vals[0] + addX - x0) / 3;\n                            var _yInterval = (vals[1] + addY - y0) / 3;\n                            ps = [[x0, y0], [x0 + _xInterval * 1, y0 + _yInterval * 1], [x0 + _xInterval * 2, y0 + _yInterval * 2], [x0 + _xInterval * 3, y0 + _yInterval * 3]];\n                            prev2ndCubicControlPoint = undefined;\n                            prev2ndQuadraticControlPoint = undefined;\n                            if (!isCloseToOrigin([_xInterval, _yInterval])) {\n                                pushBezier(bezierArray, ps, j++);\n                            }\n                        }\n                    }\n                    if (bezierArray.length) {\n                        bezierArrays.push(bezierArray);\n                        bezierArray = [];\n                    }\n                    pathStarted = true;\n                    // Update current point\n                    x0 = vals[0];\n                    y0 = vals[1];\n                    // Update initial point of current path/sub-path.\n                    initialPoint = [x0, y0];\n                    j = 0;\n                    break;\n                }\n            /*\r\n             * C and c: (from www.w3.org)\r\n             * params: x1 y1 x2 y2 x y\r\n             * --------------------------\r\n             * Draws a cubic Bézier curve from the current point to (x,y)\r\n             * using (x1,y1) as the control point at the beginning of the\r\n             * curve and (x2,y2) as the control point at the end of the\r\n             * curve. C (uppercase) indicates that absolute coordinates\r\n             * will follow; c (lowercase) indicates that relative\r\n             * coordinates will follow. Multiple sets of coordinates may\r\n             * be specified to draw a polybézier. At the end of the\r\n             * command, the new current point becomes the final (x,y)\r\n             * coordinate pair used in the polybézier.\r\n             */\n            case 'C':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegCurvetoCubicAbs);\n                    //let vals = [path.x, path.y, path.x1, path.y1, path.x2, path.y2];\n                    ps = [[x0, y0], [addX + vals[0], addY + vals[1]], [addX + vals[2], addY + vals[3]], [addX + vals[4], addY + vals[5]]];\n                    prev2ndCubicControlPoint = ps[2];\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * S and s: (from www.w3.org)\r\n             * params: x2 y2 x y\r\n             * --------------------------\r\n             * Draws a cubic Bézier curve from the current point to\r\n             * (x,y). The first control point is assumed to be the\r\n             * reflection of the second control point on the previous\r\n             * command relative to the current point. (If there is no\r\n             * previous command or if the previous command was not an\r\n             * C, c, S or s, assume the first control point is\r\n             * coincident with the current point.) (x2,y2) is the\r\n             * second control point (i.e., the control point at the end\r\n             * of the curve). S (uppercase) indicates that absolute\r\n             * coordinates will follow; s (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple sets of\r\n             * coordinates may be specified to draw a polybézier.\r\n             * At the end of the command, the new current point becomes\r\n             * the final (x,y) coordinate pair used in the polybézier.\r\n             */\n            case 'S':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegCurvetoCubicSmoothAbs);\n                    //let vals = [path.x, path.y, path.x2, path.y2];\n                    var x1 = void 0;\n                    var y1 = void 0;\n                    if (prev2ndCubicControlPoint) {\n                        x1 = x0 - prev2ndCubicControlPoint[0] + x0;\n                        y1 = y0 - prev2ndCubicControlPoint[1] + y0;\n                    } else {\n                        x1 = x0;\n                        y1 = y0;\n                    }\n                    ps = [[x0, y0], [x1, y1], [addX + vals[0], addY + vals[1]], [addX + vals[2], addY + vals[3]]];\n                    prev2ndCubicControlPoint = ps[2];\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * L and l: (from www.w3.org)\r\n             * params: x y\r\n             * --------------------------\r\n             * Draw a line from the current point to the given (x,y)\r\n             * coordinate which becomes the new current point. L\r\n             * (uppercase) indicates that absolute coordinates will\r\n             * follow; l (lowercase) indicates that relative\r\n             * coordinates will follow. A number of coordinates pairs\r\n             * may be specified to draw a polyline. At the end of the\r\n             * command, the new current point is set to the final set\r\n             * of coordinates provided.\r\n             */\n            case 'L':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegLinetoAbs);\n                    //let vals = [path.x, path.y];\n                    var _xInterval2 = (vals[0] + addX - x0) / 3;\n                    var _yInterval2 = (vals[1] + addY - y0) / 3;\n                    ps = [[x0, y0], [x0 + _xInterval2 * 1, y0 + _yInterval2 * 1], [x0 + _xInterval2 * 2, y0 + _yInterval2 * 2], [x0 + _xInterval2 * 3, y0 + _yInterval2 * 3]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isCloseToOrigin([_xInterval2, _yInterval2])) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * H and h: (from www.w3.org)\r\n             * params: x\r\n             * --------------------------\r\n             * Draws a horizontal line from the current point (cpx, cpy)\r\n             * to (x, cpy). H (uppercase) indicates that absolute\r\n             * coordinates will follow; h (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple x values can\r\n             * be provided (although usually this doesn't make sense).\r\n             * At the end of the command, the new current point becomes\r\n             * (x, cpy) for the final value of x.\r\n             */\n            case 'H':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegLinetoHorizontalAbs);\n                    //let vals = [path.x];\n                    var _xInterval3 = (vals[0] + addX - x0) / 3;\n                    ps = [[x0, y0], [x0 + _xInterval3 * 1, y0], [x0 + _xInterval3 * 2, y0], [x0 + _xInterval3 * 3, y0]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (Math.abs(_xInterval3) > DELTA) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * V and v: (from www.w3.org)\r\n             * params: y\r\n             * --------------------------\r\n             * Draws a vertical line from the current point (cpx, cpy)\r\n             * to (cpx, y). V (uppercase) indicates that absolute\r\n             * coordinates will follow; v (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple y values can\r\n             * be provided (although usually this doesn't make sense).\r\n             * At the end of the command, the new current point becomes\r\n             * (cpx, y) for the final value of y.\r\n             */\n            case 'V':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegLinetoVerticalAbs);\n                    //let vals = [path.y];\n                    //let yInterval = (vals[1] + addY - y0)/3;\n                    var _yInterval3 = (vals[0] + addY - y0) / 3;\n                    ps = [[x0, y0], [x0, y0 + _yInterval3 * 1], [x0, y0 + _yInterval3 * 2], [x0, y0 + _yInterval3 * 3]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (Math.abs(_yInterval3) > DELTA) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * Q and q: (from www.w3.org)\r\n             * params: x1 y1 x y\r\n             * --------------------------\r\n             * Draws a quadratic Bézier curve from the current point to\r\n             * (x,y) using (x1,y1) as the control point. Q (uppercase)\r\n             * indicates that absolute coordinates will follow; q\r\n             * (lowercase) indicates that relative coordinates will\r\n             * follow. Multiple sets of coordinates may be specified\r\n             * to draw a polybézier. At the end of the command, the new\r\n             * current point becomes the final (x,y) coordinate pair\r\n             * used in the polybézier.\r\n             */\n            case 'Q':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegCurvetoQuadraticAbs);\n                    //let vals = [path.x, path.y, path.x1, path.y1];\n                    //---------------------------------------------------\n                    // Convert quadratic to cubic\n                    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n                    //---------------------------------------------------\n                    var QP0 = [x0, y0];\n                    var QP1 = [addX + vals[0], addY + vals[1]];\n                    var QP2 = [addX + vals[2], addY + vals[3]];\n                    // Endpoints stay the same\n                    var CP0 = QP0;\n                    var CP3 = QP2;\n                    // CP1 = QP0 + 2/3 *(QP1-QP0)\n                    var CP1 = [QP0[0] + 2 / 3 * (QP1[0] - QP0[0]), QP0[1] + 2 / 3 * (QP1[1] - QP0[1])];\n                    // CP2 = QP2 + 2/3 *(QP1-QP2)\n                    var CP2 = [QP2[0] + 2 / 3 * (QP1[0] - QP2[0]), QP2[1] + 2 / 3 * (QP1[1] - QP2[1])];\n                    ps = [CP0, CP1, CP2, CP3];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = QP1;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * T and t: (from www.w3.org)\r\n             * params: x y\r\n             * --------------------------\r\n             * Draws a quadratic Bézier curve from the current point to\r\n             * (x,y). The control point is assumed to be the reflection\r\n             * of the control point on the previous command relative to\r\n             * the current point. (If there is no previous command or if\r\n             * the previous command was not a Q, q, T or t, assume the\r\n             * control point is coincident with the current point.) T\r\n             * (uppercase) indicates that absolute coordinates will\r\n             * follow; t (lowercase) indicates that relative coordinates\r\n             * will follow. At the end of the command, the new current\r\n             * point becomes the final (x,y) coordinate pair used in the\r\n             * polybézier.\r\n             */\n            case 'T':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    //let path = (pathSeg as SVGPathSegCurvetoQuadraticSmoothAbs);\n                    //let vals = [path.x, path.y];\n                    var _x3 = void 0;\n                    var _y = void 0;\n                    if (prev2ndQuadraticControlPoint) {\n                        _x3 = x0 - prev2ndQuadraticControlPoint[0] + x0;\n                        _y = y0 - prev2ndQuadraticControlPoint[1] + y0;\n                    } else {\n                        _x3 = x0;\n                        _y = y0;\n                    }\n                    //---------------------------------------------------\n                    // Convert quadratic to cubic\n                    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n                    //---------------------------------------------------\n                    var _QP = [x0, y0];\n                    var _QP2 = [_x3, _y];\n                    var _QP3 = [addX + vals[0], addY + vals[1]];\n                    // Endpoints stay the same\n                    var _CP = _QP;\n                    var _CP2 = _QP3;\n                    // CP1 = QP0 + 2/3 *(QP1-QP0)\n                    var _CP3 = [_QP[0] + 2 / 3 * (_QP2[0] - _QP[0]), _QP[1] + 2 / 3 * (_QP2[1] - _QP[1])];\n                    // CP2 = QP2 + 2/3 *(QP1-QP2)\n                    var _CP4 = [_QP3[0] + 2 / 3 * (_QP2[0] - _QP3[0]), _QP3[1] + 2 / 3 * (_QP2[1] - _QP3[1])];\n                    ps = [_CP, _CP3, _CP4, _CP2];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = _QP2;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * A and a: (from www.w3.org)\r\n             * params: rx ry x-axis-rotation large-arc-flag\r\n             *         sweep-flag x y\r\n             * --------------------------------------------\r\n             * Draws an elliptical arc from the current point to (x, y).\r\n             * The size and orientation of the ellipse are defined by\r\n             * two radii (rx, ry) and an x-axis-rotation, which\r\n             * indicates how the ellipse as a whole is rotated relative\r\n             * to the current coordinate system. The center (cx, cy) of\r\n             * the ellipse is calculated automatically to satisfy the\r\n             * constraints imposed by the other parameters.\r\n             * large-arc-flag and sweep-flag contribute to the automatic\r\n             * calculations and help determine how the arc is drawn.\r\n             */\n            case 'A':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    //x0 = ? ps[3][0]; \n                    //y0 = ? ps[3][1];\n                    pushBezier(bezierArray, ps, j++);\n                    break;\n                }\n            /*\r\n             * Z and z: (from www.w3.org)\r\n             * params: (none)\r\n             * --------------------------\r\n             * Close the current subpath by drawing a straight line\r\n             * from the current point to current subpath's initial\r\n             * point. Since the Z and z commands take no parameters,\r\n             * they have an identical effect.\r\n             */\n            case 'Z':\n                if (!pathStarted) {\n                    throw new Error(MUST_START_WITH_M);\n                }\n                var xInterval = (initialPoint[0] + addX - x0) / 3;\n                var yInterval = (initialPoint[1] + addY - y0) / 3;\n                ps = [[x0, y0], [x0 + xInterval * 1, y0 + yInterval * 1], [x0 + xInterval * 2, y0 + yInterval * 2], [x0 + xInterval * 3, y0 + yInterval * 3]];\n                prev2ndCubicControlPoint = undefined;\n                prev2ndQuadraticControlPoint = undefined;\n                // Update current point\n                x0 = ps[3][0];\n                y0 = ps[3][1];\n                if (!isCloseToOrigin([xInterval, yInterval])) {\n                    pushBezier(bezierArray, ps, j++);\n                }\n                break;\n            default:\n                throw new Error(INVALID_COMMAND);\n        }\n    }\n    if (bezierArray.length) {\n        bezierArrays.push(bezierArray);\n        bezierArray = [];\n    }\n    return bezierArrays;\n}\n/**\r\n * Returns a string representation of the given beziers linked loop.\r\n * @param beziers - A linked loop of cubic beziers.\r\n */\nfunction getPathStrFromBezierLoop(bezierLoop) {\n    var beziers = bezierLoop.getAsArray().map(function (x) {\n        return x.item;\n    });\n    return Svg.getPathStrFromBeziers(beziers);\n}\n/**\r\n * Returns a string representation of the given array of beziers.\r\n * @param {number[][][]} beziers - An array of cubic beziers.\r\n * @returns {string}\r\n */\nfunction getPathStrFromBeziers(beziers) {\n    var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    var D = decimalPlaces;\n    var str = '';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = beziers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var ps = _step.value;\n\n            if (ps === beziers[0]) {\n                str = 'M ' + ps[0][0].toFixed(D) + ' ' + ps[0][1].toFixed(D) + '\\n';\n            }\n            str += 'C ' + ps[1][0].toFixed(D) + ' ' + ps[1][1].toFixed(D) + ' ' + ps[2][0].toFixed(D) + ' ' + ps[2][1].toFixed(D) + ' ' + ps[3][0].toFixed(D) + ' ' + ps[3][1].toFixed(D) + ' ' + '\\n';\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return str;\n}\nvar Svg = {\n    getBeziersFromSvgElem: getBeziersFromSvgElem,\n    getPathStrFromBezierLoop: getPathStrFromBezierLoop,\n    getPathStrFromBeziers: getPathStrFromBeziers\n};\nexports.default = Svg;\n\n},{\"../geometry/classes/path-curve\":8,\"./path-data-polyfill/path-data-polyfill\":38,\"flo-vector2d\":56}],40:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_gauss_quadrature_1 = _dereq_(\"flo-gauss-quadrature\");\nvar flo_graham_scan_1 = _dereq_(\"flo-graham-scan\");\nvar DELTA = 1e-10;\nvar _flo_vector2d_1$defau = flo_vector2d_1.default,\n    rotate = _flo_vector2d_1$defau.rotatePs,\n    translate = _flo_vector2d_1$defau.translatePs;\n\nvar memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's x-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The power basis polynomial from highest power to lowest,\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\n */\nvar getX = memoize(function (ps) {\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 1),\n        x0 = _ps$[0],\n        _ps$2 = _slicedToArray(_ps[1], 1),\n        x1 = _ps$2[0],\n        _ps$3 = _slicedToArray(_ps[2], 1),\n        x2 = _ps$3[0],\n        _ps$4 = _slicedToArray(_ps[3], 1),\n        x3 = _ps$4[0];\n\n    return [x3 - 3 * x2 + 3 * x1 - x0, 3 * x2 - 6 * x1 + 3 * x0, 3 * x1 - 3 * x0, x0];\n});\n/**\n * Returns the power basis representation of the bezier's y-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nvar getY = memoize(function (ps) {\n    var _ps2 = _slicedToArray(ps, 4),\n        _ps2$ = _slicedToArray(_ps2[0], 2),\n        y0 = _ps2$[1],\n        _ps2$2 = _slicedToArray(_ps2[1], 2),\n        y1 = _ps2$2[1],\n        _ps2$3 = _slicedToArray(_ps2[2], 2),\n        y2 = _ps2$3[1],\n        _ps2$4 = _slicedToArray(_ps2[3], 2),\n        y3 = _ps2$4[1];\n\n    return [y3 - 3 * y2 + 3 * y1 - y0, 3 * y2 - 6 * y1 + 3 * y0, 3 * y1 - 3 * y0, y0];\n});\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * x-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nvar getDx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getX(ps));\n});\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * y-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The differentiated power basis polynomial from highest\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\n */\nvar getDy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getY(ps));\n});\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nvar getDdx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDx(ps));\n});\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nvar getDdy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDy(ps));\n});\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nvar getDddx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDdx(ps));\n});\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nvar getDddy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDdy(ps));\n});\n/**\n * Returns the convex hull of a bezier's control points. This hull bounds the\n * bezier curve. This function is memoized.\n *\n * The tolerance at which the cross product of two nearly collinear lines of the\n * hull are considered collinear is 1e-12.\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns An ordered array of convex hull points.\n */\nvar getBoundingHull = memoize(flo_graham_scan_1.default);\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n * @param l - a 2d line represented by two points\n * @returns Control points of the cubic bezier.\n */\nfunction fromLine(l) {\n    var _l = _slicedToArray(l, 2),\n        _l$ = _slicedToArray(_l[0], 2),\n        x0 = _l$[0],\n        y0 = _l$[1],\n        _l$2 = _slicedToArray(_l[1], 2),\n        x1 = _l$2[0],\n        y1 = _l$2[1];\n\n    var xInterval = (x1 - x0) / 3;\n    var yInterval = (y1 - y0) / 3;\n    return [[x0, y0], [x0 + xInterval, y0 + yInterval], [x0 + xInterval * 2, y0 + yInterval * 2], [x1, y1]];\n}\nfunction evaluate(ps, t) {\n    var _ps3 = _slicedToArray(ps, 4),\n        _ps3$ = _slicedToArray(_ps3[0], 2),\n        x0 = _ps3$[0],\n        y0 = _ps3$[1],\n        _ps3$2 = _slicedToArray(_ps3[3], 2),\n        x3 = _ps3$2[0],\n        y3 = _ps3$2[1];\n\n    var evX = evaluateX(ps);\n    var evY = evaluateY(ps);\n    function f(t) {\n        if (t === 0) {\n            return [x0, y0];\n        } else if (t === 1) {\n            return [x3, y3];\n        }\n        return [evX(t), evY(t)];\n    }\n    return t === undefined ? f : f(t);\n}\n/**\n * Returns the given bezier's inflection points.\n **/\nfunction findBezierInflectionPoints(ps) {\n    var _ps4 = _slicedToArray(ps, 4),\n        _ps4$ = _slicedToArray(_ps4[0], 2),\n        x0 = _ps4$[0],\n        y0 = _ps4$[1],\n        _ps4$2 = _slicedToArray(_ps4[1], 2),\n        x1 = _ps4$2[0],\n        y1 = _ps4$2[1],\n        _ps4$3 = _slicedToArray(_ps4[2], 2),\n        x2 = _ps4$3[0],\n        y2 = _ps4$3[1],\n        _ps4$4 = _slicedToArray(_ps4[3], 2),\n        x3 = _ps4$4[0],\n        y3 = _ps4$4[1];\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n\n\n    var ax = x1 - x0;\n    var ay = y1 - y0;\n    var bx = x2 - x1 - ax;\n    var by = y2 - y1 - ay;\n    var cx = x3 - x2 - ax - 2 * bx;\n    var cy = y3 - y2 - ay - 2 * by;\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\n    var a = bx * cy - by * cx;\n    var b = ax * cy - ay * cx;\n    var c = ax * by - ay * bx;\n    var inflectionTimes = flo_poly_1.default.allRoots([a, b, c], 0, 1);\n    var evPs = evaluate(ps);\n    return inflectionTimes.map(evPs);\n}\nfunction κ(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    var evDdx = evaluateDdx(ps);\n    var evDdy = evaluateDdy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var ddx = evDdx(t);\n        var ddy = evDdy(t);\n        var a = dx * ddy - dy * ddx;\n        var b = Math.sqrt(Math.pow(dx * dx + dy * dy, 3));\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\n/**\n * Alias of κ.\n */\nvar curvature = κ;\nfunction κds(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    var evDdx = evaluateDdx(ps);\n    var evDdy = evaluateDdy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var ddx = evDdx(t);\n        var ddy = evDdy(t);\n        var a = dx * ddy - dy * ddx;\n        var b = dx * dx + dy * dy;\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction dκMod(ps, t) {\n    var _ps5 = _slicedToArray(ps, 4),\n        _ps5$ = _slicedToArray(_ps5[0], 2),\n        x0 = _ps5$[0],\n        y0 = _ps5$[1],\n        _ps5$2 = _slicedToArray(_ps5[1], 2),\n        x1 = _ps5$2[0],\n        y1 = _ps5$2[1],\n        _ps5$3 = _slicedToArray(_ps5[2], 2),\n        x2 = _ps5$3[0],\n        y2 = _ps5$3[1],\n        _ps5$4 = _slicedToArray(_ps5[3], 2),\n        x3 = _ps5$4[0],\n        y3 = _ps5$4[1];\n\n    function f(t) {\n        var ts = t * t;\n        var omt = 1 - t;\n        var a = ts * x3;\n        var b = ts * y3;\n        var c = 2 * t - 3 * ts;\n        var d = (3 * t - 1) * omt;\n        var e = omt * omt;\n        var f = 3 * (a + c * x2 - d * x1 - e * x0);\n        var g = 3 * (b + c * y2 - d * y1 - e * y0);\n        var h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n        var i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n        var j = Math.sqrt(f * f + g * g);\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) - g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) - (f * h - b * g) * (2 * h * g + 2 * b * f) * j;\n    }\n    return t === undefined ? f : f(t);\n}\nfunction tangent(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var d = Math.sqrt(dx * dx + dy * dy);\n        return [dx / d, dy / d];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction normal(ps, t) {\n    var tanPs = tangent(ps);\n    function f(t) {\n        var v = tanPs(t);\n        return [v[1], -v[0]];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\n/**\n * <p>\n * Categorizes the given cubic bezier curve according to whether it has a loop,\n * a cusp, or zero, one or two inflection points all of which are mutually\n * exclusive.\n * </p>\n * <p>\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\n * this</a> paper.\n * </p>\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns {string} A value of 'L', 'C', '0', '1', or '2' depending on whether\n * the curve has a loop, a cusp, or zero, one or two inflection points.\n */\nfunction categorize(ps) {\n    // TODO - finish\n}\nfunction totalCurvature(ps, interval) {\n    var tanPs = tangent(ps);\n    function f(interval) {\n        return flo_gauss_quadrature_1.default(κds(ps), interval);\n        // TODO\n        /*\n        let [a,b] = interval;\n        let tangentA = tanPs(a);\n        let tangentB = tanPs(b);\n        let sinθ = Vector.cross(tanA, tanB)\n        */\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nfunction totalAbsoluteCurvature(ps, interval) {\n    function f() {\n        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 1];\n\n        // Numerically integrate the absolute curvature\n        var result = flo_gauss_quadrature_1.default(function (t) {\n            return Math.abs(κds(ps)(t));\n        }, interval);\n        return result;\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nfunction len(interval, ps) {\n    function f(ps) {\n        if (interval[0] === interval[1]) {\n            return 0;\n        }\n\n        var _ps6 = _slicedToArray(ps, 4),\n            _ps6$ = _slicedToArray(_ps6[0], 2),\n            x0 = _ps6$[0],\n            y0 = _ps6$[1],\n            _ps6$2 = _slicedToArray(_ps6[1], 2),\n            x1 = _ps6$2[0],\n            y1 = _ps6$2[1],\n            _ps6$3 = _slicedToArray(_ps6[2], 2),\n            x2 = _ps6$3[0],\n            y2 = _ps6$3[1],\n            _ps6$4 = _slicedToArray(_ps6[3], 2),\n            x3 = _ps6$4[0],\n            y3 = _ps6$4[1];\n        // Keep line below to ensure zero length curve returns zero!\n\n\n        if (x0 === x1 && x1 === x2 && x2 === x3 && y0 === y1 && y1 === y2 && y2 === y3) {\n            return 0;\n        }\n        var evDs = ds(ps);\n        return flo_gauss_quadrature_1.default(evDs, interval);\n    }\n    // Curry\n    return ps === undefined ? f : f(ps);\n}\nfunction getTAtLength(ps, s) {\n    var lenAtT = function lenAtT(t) {\n        return len([0, t], ps);\n    };\n    function f(s) {\n        return flo_poly_1.default.brent(function (t) {\n            return lenAtT(t) - s;\n        }, 0, 1);\n    }\n    // Curry\n    return s === undefined ? f : f(s);\n}\nfunction ds(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction evaluateX(ps, t) {\n    var xPs = getX(ps); // Speed optimizing cache\n    var evPs = flo_poly_1.default.evaluate(xPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][0];\n        }\n        if (t === 1) {\n            return ps[3][0];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateY(ps, t) {\n    var yPs = getY(ps); // Speed optimizing cache\n    var evPs = flo_poly_1.default.evaluate(yPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][1];\n        }\n        if (t === 1) {\n            return ps[3][1];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDx(ps, t) {\n    var dPs = getDx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDy(ps, t) {\n    var dPs = getDy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDdx(ps, t) {\n    var ddPs = getDdx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDdy(ps, t) {\n    var ddPs = getDdy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDddx(ps, t) {\n    var dddPs = getDddx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDddy(ps, t) {\n    var dddPs = getDddy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\n// TODO - refactor getBounds, getBoundingBox, etc.\n/**\n * Helper function. Returns the bounding box of the normalized (i.e. first point\n * moved to origin and rotated so that last point lies on x-axis) given cubic\n * bezier.\n * @ignore\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param sinθ - Sine of angle made by line from first bezier point to\n * last with x-axis.\n * @param cosθ - Cosine of angle made by line from first bezier point\n * to last with x-axis.\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n    var vectorToOrigin = flo_vector2d_1.default.transform(ps[0], function (x) {\n        return -x;\n    });\n    var boundingPs = flo_vector2d_1.default.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\n    return getBoundingBox(boundingPs);\n}\n/**\n * Returns the tight bounding box of the given cubic bezier.\n * @returns The tight bounding box of the bezier as four ordered\n * points of a rotated rectangle.\n * TODO - test case of baseLength === 0\n */\nvar getBoundingBoxTight = memoize(function (ps) {\n    var _ps7 = _slicedToArray(ps, 4),\n        _ps7$ = _slicedToArray(_ps7[0], 2),\n        x0 = _ps7$[0],\n        y0 = _ps7$[1],\n        _ps7$2 = _slicedToArray(_ps7[1], 2),\n        x1 = _ps7$2[0],\n        y1 = _ps7$2[1],\n        _ps7$3 = _slicedToArray(_ps7[2], 2),\n        x2 = _ps7$3[0],\n        y2 = _ps7$3[1],\n        _ps7$4 = _slicedToArray(_ps7[3], 2),\n        x3 = _ps7$4[0],\n        y3 = _ps7$4[1];\n\n    var baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n    var sinθ = (y3 - y0) / baseLength;\n    var cosθ = (x3 - x0) / baseLength;\n    var box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n\n    var _box = _slicedToArray(box, 2),\n        _box$ = _slicedToArray(_box[0], 2),\n        p0x = _box$[0],\n        p0y = _box$[1],\n        _box$2 = _slicedToArray(_box[1], 2),\n        p1x = _box$2[0],\n        p1y = _box$2[1];\n\n    var axisAlignedBox = [box[0], [p1x, p0y], box[1], [p0x, p1y]];\n    return flo_vector2d_1.default.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\n});\n/**\n * Returns the axis-aligned bounding box of a given bezier.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns the axis-aligned bounding box in the form\n * [[minx, miny], [maxx,maxy]\n */\nvar getBoundingBox = memoize(function (ps) {\n    return getBounds(ps).box;\n});\n/**\n * Calculates and returns general bezier bounds.\n * @returns {object} The axis-aligned bounding box together with the t values\n * where the bounds on the bezier are reached.\n */\nvar getBounds = memoize(function (ps) {\n    // Roots of derivative\n    var roots = [getDx(ps), getDy(ps)].map(function (poly) {\n        return flo_poly_1.default.allRoots(poly, 0, 1);\n    });\n    // Endpoints\n    roots[0].push(0, 1);\n    roots[1].push(0, 1);\n    var minX = Number.POSITIVE_INFINITY;\n    var maxX = Number.NEGATIVE_INFINITY;\n    var minY = Number.POSITIVE_INFINITY;\n    var maxY = Number.NEGATIVE_INFINITY;\n    var tMinX = undefined;\n    var tMinY = undefined;\n    var tMaxX = undefined;\n    var tMaxY = undefined;\n    // Test points\n    for (var i = 0; i < roots[0].length; i++) {\n        var t = roots[0][i];\n        var x = evaluateX(ps, t);\n        if (x < minX) {\n            minX = x;\n            tMinX = t;\n        }\n        if (x > maxX) {\n            maxX = x;\n            tMaxX = t;\n        }\n    }\n    for (var _i = 0; _i < roots[1].length; _i++) {\n        var _t = roots[1][_i];\n        var y = evaluateY(ps, _t);\n        if (y < minY) {\n            minY = y;\n            tMinY = _t;\n        }\n        if (y > maxY) {\n            maxY = y;\n            tMaxY = _t;\n        }\n    }\n    var ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n    var box = [[minX, minY], [maxX, maxY]];\n    return { ts: ts, box: box };\n});\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given curve and ends at the\n * given t parameter. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t1 - The t parameter where the resultant bezier should start\n * @param t2 - The t parameter where the resultant bezier should end\n * @returns {number[][]}\n */\nfunction fromTo(ps) {\n    return function (t1, t2) {\n        if (t1 === t2) {\n            // Degenerate case\n            var p = evaluate(ps, t1);\n            return [p, p, p, p];\n        }\n        var t = fromTTo1(ps, t1);\n        return from0ToT(t, (t2 - t1) / (1 - t1));\n    };\n}\n;\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given curve's t=0 and ends\n * at the given t parameter. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should end\n */\nfunction from0ToT(ps, t) {\n    var _ps8 = _slicedToArray(ps, 4),\n        _ps8$ = _slicedToArray(_ps8[0], 2),\n        x0 = _ps8$[0],\n        y0 = _ps8$[1],\n        _ps8$2 = _slicedToArray(_ps8[1], 2),\n        x1 = _ps8$2[0],\n        y1 = _ps8$2[1],\n        _ps8$3 = _slicedToArray(_ps8[2], 2),\n        x2 = _ps8$3[0],\n        y2 = _ps8$3[1],\n        _ps8$4 = _slicedToArray(_ps8[3], 2),\n        x3 = _ps8$4[0],\n        y3 = _ps8$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    return [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n}\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given t parameter and\n * ends at t=1. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should start\n */\nfunction fromTTo1(ps, t) {\n    var _ps9 = _slicedToArray(ps, 4),\n        _ps9$ = _slicedToArray(_ps9[0], 2),\n        x0 = _ps9$[0],\n        y0 = _ps9$[1],\n        _ps9$2 = _slicedToArray(_ps9[1], 2),\n        x1 = _ps9$2[0],\n        y1 = _ps9$2[1],\n        _ps9$3 = _slicedToArray(_ps9[2], 2),\n        x2 = _ps9$3[0],\n        y2 = _ps9$3[1],\n        _ps9$4 = _slicedToArray(_ps9[3], 2),\n        x3 = _ps9$4[0],\n        y3 = _ps9$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    return [[t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n}\n/**\n * <p>\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the curve should be split\n * @returns {number[][]}\n */\nfunction splitAt(ps, t) {\n    var _ps10 = _slicedToArray(ps, 4),\n        _ps10$ = _slicedToArray(_ps10[0], 2),\n        x0 = _ps10$[0],\n        y0 = _ps10$[1],\n        _ps10$2 = _slicedToArray(_ps10[1], 2),\n        x1 = _ps10$2[0],\n        y1 = _ps10$2[1],\n        _ps10$3 = _slicedToArray(_ps10[2], 2),\n        x2 = _ps10$3[0],\n        y2 = _ps10$3[1],\n        _ps10$4 = _slicedToArray(_ps10[3], 2),\n        x3 = _ps10$4[0],\n        y3 = _ps10$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    var ps1 = [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n    var ps2 = [ps1[3], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n    return [ps1, ps2];\n}\n/**\n * Returns a human readable string representation of the given bezier.\n * @param ps - A bezier curve\n * @returns {string}\n */\nfunction toString(ps) {\n    var _ps11 = _slicedToArray(ps, 4),\n        _ps11$ = _slicedToArray(_ps11[0], 2),\n        x0 = _ps11$[0],\n        y0 = _ps11$[1],\n        _ps11$2 = _slicedToArray(_ps11[1], 2),\n        x1 = _ps11$2[0],\n        y1 = _ps11$2[1],\n        _ps11$3 = _slicedToArray(_ps11[2], 2),\n        x2 = _ps11$3[0],\n        y2 = _ps11$3[1],\n        _ps11$4 = _slicedToArray(_ps11[3], 2),\n        x3 = _ps11$4[0],\n        y3 = _ps11$4[1];\n\n    return \"[[\" + x0 + \",\" + y0 + \"],[\" + x1 + \",\" + y1 + \"],[\" + x2 + \",\" + y2 + \"],[\" + x3 + \",\" + y3 + \"]]\";\n}\n/**\n * Scales all control points of the given bezier by the given factor.\n * @param ps - A bezier curve\n * @param factor - The scale factor\n * @returns {number[][]}\n */\nfunction scale(ps, factor) {\n    return ps.map(function (x) {\n        return [x[0] * factor, x[1] * factor];\n    });\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given line.\n * @param ps - The bezier curve\n * @param l - The line given as a start and end point\n * @returns {number[]}\n */\nfunction lineIntersection(ps, l) {\n    var _l2 = _slicedToArray(l, 2),\n        _l2$ = _slicedToArray(_l2[0], 2),\n        x0 = _l2$[0],\n        y0 = _l2$[1],\n        _l2$2 = _slicedToArray(_l2[1], 2),\n        x1 = _l2$2[0],\n        y1 = _l2$2[1];\n\n    var x = x1 - x0,\n        y = y1 - y0;\n\n    if (x === 0 && y === 0) {\n        return [];\n    }\n    // Move the line and the bezier together so the line's first point is on the\n    // origin.\n    ps = translate([-x0, -y0], ps);\n    // Rotate the bezier and line together so the line is y=0.\n    var len = Math.sqrt(x * x + y * y);\n    var sinθ = y / len;\n    var cosθ = x / len;\n    ps = rotate(-sinθ, cosθ, ps);\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getY(ps), 0, 1);\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given horizontal line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtY(ps, y) {\n    // Translate ps so that y = 0.\n    ps = ps.map(function (p) {\n        return [p[0], p[1] - y];\n    });\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getY(ps), 0, 1);\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given vertical line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtX(ps, x) {\n    // Translate ps so that x = 0.\n    ps = ps.map(function (p) {\n        return [p[0] - x, p[1]];\n    });\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getX(ps), 0, 1);\n}\n/**\n * Returns the best least squares quadratic bezier approximation to the given\n * cubic bezier. Note that the two bezier endpoints differ in general.\n * @param ps - A cubic bezier curve.\n * @returns {number[][]}\n */\nfunction toQuadratic(ps) {\n    var _ps12 = _slicedToArray(ps, 4),\n        _ps12$ = _slicedToArray(_ps12[0], 2),\n        x0 = _ps12$[0],\n        y0 = _ps12$[1],\n        _ps12$2 = _slicedToArray(_ps12[1], 2),\n        x1 = _ps12$2[0],\n        y1 = _ps12$2[1],\n        _ps12$3 = _slicedToArray(_ps12[2], 2),\n        x2 = _ps12$3[0],\n        y2 = _ps12$3[1],\n        _ps12$4 = _slicedToArray(_ps12[3], 2),\n        x3 = _ps12$4[0],\n        y3 = _ps12$4[1];\n\n    return [[19 / 20 * x0 + 3 / 20 * x1 + -3 / 20 * x2 + 1 / 20 * x3, 19 / 20 * y0 + 3 / 20 * y1 + -3 / 20 * y2 + 1 / 20 * y3], [-1 / 4 * x0 + 3 / 4 * x1 + 3 / 4 * x2 + -1 / 4 * x3, -1 / 4 * y0 + 3 / 4 * y1 + 3 / 4 * y2 + -1 / 4 * y3], [1 / 20 * x0 + -3 / 20 * x1 + 3 / 20 * x2 + 19 / 20 * x3, 1 / 20 * y0 + -3 / 20 * y1 + 3 / 20 * y2 + 19 / 20 * y3]];\n}\n/**\n * Returns the hybrid quadratic version of the given cubic bezier. For a\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\n * this paper</a>.\n * @param ps - A cubic bezier curve.\n * @returns {object[]} An array of three quadratic bezier points where the\n * middle point is a 'hybrid' point represented as a line (itself represented\n * by two points (a linear bezier curve)) which can be evaluated at a different\n * t value (call it th). If evaluated at the same t value the result is the same\n * as evaluating the original cubic bezier at t. The set generated by evaluating\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\n * bound around the orginal cubic bezier curve. The length of the linear bezier\n * curve mentioned above is a measure of how closely the cubic can be\n * represented as a quadratic bezier curve.\n */\nfunction toHybridQuadratic(ps) {\n    var _ps13 = _slicedToArray(ps, 4),\n        _ps13$ = _slicedToArray(_ps13[0], 2),\n        x0 = _ps13$[0],\n        y0 = _ps13$[1],\n        _ps13$2 = _slicedToArray(_ps13[1], 2),\n        x1 = _ps13$2[0],\n        y1 = _ps13$2[1],\n        _ps13$3 = _slicedToArray(_ps13[2], 2),\n        x2 = _ps13$3[0],\n        y2 = _ps13$3[1],\n        _ps13$4 = _slicedToArray(_ps13[3], 2),\n        x3 = _ps13$4[0],\n        y3 = _ps13$4[1];\n\n    return [[x0, y0], [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2], [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]], [x3, y3] // evaluated at t\n    ];\n}\n/**\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\n * toHybridQuadratic for details).\n * @param hq - A hybrid quadratic\n * @param t - The bezier parameter value\n * @param th - The parameter value for the hybrid quadratic point.\n */\nfunction evaluateHybridQuadratic(hq, t, th) {\n    var P0 = hq[0];\n    var P1_ = hq[1];\n    var P2 = hq[2];\n    var P1 = evaluateLinear(hq[1], th);\n    return evaluateQuadratic([P0, P1, P2], t);\n}\n/**\n * Evaluates the given linear bezier (line) at a specific t value.\n * @param ps - A linear bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateLinear(ps, t) {\n    var _ps14 = _slicedToArray(ps, 2),\n        _ps14$ = _slicedToArray(_ps14[0], 2),\n        x0 = _ps14$[0],\n        y0 = _ps14$[1],\n        _ps14$2 = _slicedToArray(_ps14[1], 2),\n        x1 = _ps14$2[0],\n        y1 = _ps14$2[1];\n\n    var x = x0 * (1 - t) + x1 * t;\n    var y = y0 * (1 - t) + y1 * t;\n    return [x, y];\n}\n/**\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\n * spirit of functional programming.\n * @param ps - A cubic bezier given by its array of control points\n */\nfunction clone(ps) {\n    var _ps15 = _slicedToArray(ps, 4),\n        _ps15$ = _slicedToArray(_ps15[0], 2),\n        x0 = _ps15$[0],\n        y0 = _ps15$[1],\n        _ps15$2 = _slicedToArray(_ps15[1], 2),\n        x1 = _ps15$2[0],\n        y1 = _ps15$2[1],\n        _ps15$3 = _slicedToArray(_ps15[2], 2),\n        x2 = _ps15$3[0],\n        y2 = _ps15$3[1],\n        _ps15$4 = _slicedToArray(_ps15[3], 2),\n        x3 = _ps15$4[0],\n        y3 = _ps15$4[1];\n\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\n/**\n * Evaluates the given quadratic bezier at a specific t value.\n * @param ps - A quadratic bezier curve.\n * @param t - The value where the bezier should be evaluated\n * @returns {number[]}\n */\nfunction evaluateQuadratic(ps, t) {\n    var _ps16 = _slicedToArray(ps, 3),\n        _ps16$ = _slicedToArray(_ps16[0], 2),\n        x0 = _ps16$[0],\n        y0 = _ps16$[1],\n        _ps16$2 = _slicedToArray(_ps16[1], 2),\n        x1 = _ps16$2[0],\n        y1 = _ps16$2[1],\n        _ps16$3 = _slicedToArray(_ps16[2], 2),\n        x2 = _ps16$3[0],\n        y2 = _ps16$3[1];\n\n    var x = x0 * Math.pow(1 - t, 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\n    var y = y0 * Math.pow(1 - t, 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\n    return [x, y];\n}\n/**\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\n * bezier curves can always be represented by cubics - the converse is false.\n * @param ps - A quadratic bezier curve.\n * @returns {number[][]}\n */\nfunction toCubic(ps) {\n    var _ps17 = _slicedToArray(ps, 3),\n        _ps17$ = _slicedToArray(_ps17[0], 2),\n        x0 = _ps17$[0],\n        y0 = _ps17$[1],\n        _ps17$2 = _slicedToArray(_ps17[1], 2),\n        x1 = _ps17$2[0],\n        y1 = _ps17$2[1],\n        _ps17$3 = _slicedToArray(_ps17[2], 2),\n        x2 = _ps17$3[0],\n        y2 = _ps17$3[1];\n\n    return [[x0, y0], [1 / 3 * x0 + 2 / 3 * x1, 1 / 3 * y0 + 2 / 3 * y1], [2 / 3 * x1 + 1 / 3 * x2, 2 / 3 * y1 + 1 / 3 * y2], [x2, y2]];\n}\n/**\n * Check if the two given cubic beziers are nearly coincident everywhere and\n * returns the coincident stretch (if any), otherwise returns undefined.\n * @param P - A cubic bezier curve.\n * @param Q - Another cubic bezier curve.\n * @param δ - An indication of how closely the curves should stay to\n * each other before considered coincident.\n * @returns\n */\nfunction coincident(P, Q) {\n    var δ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-6;\n\n    var _P = _slicedToArray(P, 4),\n        P0 = _P[0],\n        P1 = _P[1],\n        P2 = _P[2],\n        P3 = _P[3];\n\n    var _Q = _slicedToArray(Q, 4),\n        Q0 = _Q[0],\n        Q1 = _Q[1],\n        Q2 = _Q[2],\n        Q3 = _Q[3];\n\n    var _calcPointAndNeighbor = calcPointAndNeighbor(P, Q, 0),\n        pP0 = _calcPointAndNeighbor.pp,\n        tPQ0 = _calcPointAndNeighbor.t,\n        pPQ0 = _calcPointAndNeighbor.p,\n        dPQ0 = _calcPointAndNeighbor.d;\n\n    var _calcPointAndNeighbor2 = calcPointAndNeighbor(P, Q, 1),\n        pP1 = _calcPointAndNeighbor2.pp,\n        tPQ1 = _calcPointAndNeighbor2.t,\n        pPQ1 = _calcPointAndNeighbor2.p,\n        dPQ1 = _calcPointAndNeighbor2.d;\n\n    var _calcPointAndNeighbor3 = calcPointAndNeighbor(Q, P, 0),\n        pQ0 = _calcPointAndNeighbor3.pp,\n        tQP0 = _calcPointAndNeighbor3.t,\n        pQP0 = _calcPointAndNeighbor3.p,\n        dQP0 = _calcPointAndNeighbor3.d;\n\n    var _calcPointAndNeighbor4 = calcPointAndNeighbor(Q, P, 1),\n        pQ1 = _calcPointAndNeighbor4.pp,\n        tQP1 = _calcPointAndNeighbor4.t,\n        pQP1 = _calcPointAndNeighbor4.p,\n        dQP1 = _calcPointAndNeighbor4.d;\n    // Check for start and end points coincident.\n\n\n    var tStartQ = 0;\n    var tEndQ = 1;\n    var tStartP = 0;\n    var tEndP = 1;\n    var count = 0;\n    if (dPQ0 <= δ) {\n        tStartQ = tPQ0;\n        count++;\n    }\n    if (dPQ1 <= δ) {\n        tEndQ = tPQ1;\n        count++;\n    }\n    if (dQP0 <= δ) {\n        tStartP = tQP0;\n        count++;\n    }\n    if (dQP1 <= δ) {\n        tEndP = tQP1;\n        count++;\n    }\n    // At least 2 endpoints must be coincident.\n    if (count < 2) {\n        return undefined;\n    }\n    if (tStartP > tEndP) {\n        var _ref = [tEndP, tStartP];\n        tStartP = _ref[0];\n        tEndP = _ref[1];\n    }\n    if (tStartQ > tEndQ) {\n        var _ref2 = [tEndQ, tStartQ];\n        tStartQ = _ref2[0];\n        tEndQ = _ref2[1];\n    }\n    var tSpanP = tEndP - tStartP;\n    var tSpanQ = tEndQ - tStartQ;\n    // We must check at least 8 additional points to ensure entire curve\n    // is coincident, otherwise we may simply have found intersection \n    // points.\n    // TODO - Change so that we cut the curves to be about equal and check the\n    // other two control points for closeness.\n    var res = true;\n    for (var i = 1; i < 10; i++) {\n        var t = tStartP + tSpanP * (i / 10);\n\n        var _calcPointAndNeighbor5 = calcPointAndNeighbor(P, Q, t),\n            pp = _calcPointAndNeighbor5.pp,\n            tt = _calcPointAndNeighbor5.t,\n            pq = _calcPointAndNeighbor5.p,\n            d = _calcPointAndNeighbor5.d;\n\n        if (d > δ) {\n            return undefined;\n        }\n    }\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\n    function calcPointAndNeighbor(P, Q, t) {\n        // TODO - must also check crossing of normals - for if two curves open\n        // at endpoints and stop essentially at same point.\n        var pp1 = evaluate(P)(t);\n        var normalVector = normal(P)(0);\n        var pp2 = flo_vector2d_1.default.translate(pp1, normalVector);\n        var ts = lineIntersection(Q, [pp1, pp2]);\n        var bestT = undefined;\n        var bestP = undefined;\n        var bestD = Number.POSITIVE_INFINITY;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = ts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _t2 = _step.value;\n\n                var p = evaluate(Q)(_t2);\n                var _d = flo_vector2d_1.default.distanceBetween(p, pp1);\n                if (_d < bestD) {\n                    bestT = _t2;\n                    bestP = p;\n                    bestD = _d;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return { pp: pp1, t: bestT, p: bestP, d: bestD };\n    }\n}\n/**\n * Robust, extremely accurate and extremely fast (cubically convergent in\n * general with fast iteration steps) algorithm that returns the intersections\n * between two cubic beziers.\n *\n * At stretches where the two curves run extremely close to (or on top of) each\n * other and curve the same direction an interval is returned instead of a\n * point.\n *\n * The algorithm is based on a <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">paper</a>\n * that finds the intersection of a fat line and a so-called geometric interval\n * making it faster and more accurate than the standard fat-line intersection\n * algorithm. The algorithm has been modified to prevent run-away recursion\n * by checking for coincident pieces at subdivision steps.\n *\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * @param [δ] - An optional tolerance to within which the t parameter\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\n * approximately 5e-15. Note that it might not make sense to set this to as\n * large as say 1e-5 since only a single iteration later the maximum accuracy\n * will be attained and not much speed will be gained anyway. Similarly if δ is\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\n * being cubically convergent (usually converging in about 4 to 8 iterations for\n * typical intersections).\n * @param [Δ] - A tolerance that indicates how closely a stretch of the\n * beziers can run together before being considered coincident. Defaults to the\n * minimum possible value of 1e-6 if not specified.\n * @returns An array that contains the t-value pairs at intersection\n * of the first and second beziers respectively. The array can also contain t\n * range pairs for coincident pieces that can be either used or ignored\n * depending on the application, e.g. the return value might be [[0.1,0.2],\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\n * the second bezier.\n */\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\n    var dst = flo_vector2d_1.default.distanceBetween;\n    var sdst = flo_vector2d_1.default.squaredDistanceBetween;\n    // The minimum value Δ can be. If it is too small the algorithm may take too\n    // long in cases where the two curves run extremely close to each other for\n    // their entire length and curve the same direction.\n    var ΔMin = 1e-6;\n    // This is an estimate of the relative floating point error during clipping.\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\n    var δMin = 24 * Number.EPSILON;\n    // Maximum error - limited to take rounding error into account.\n    if (δ === undefined) {\n        δ = 0;\n    }\n    δ = Math.max(δ, δMin);\n    if (Δ === undefined) {\n        Δ = ΔMin;\n    }\n    Δ = Math.max(Δ, ΔMin);\n    // Intersection t values for both beziers\n    var tss = [];\n    //let iterations = 0;\n    intersection(ps1, ps2, [0, 1], [0, 1], 1);\n    //console.log(iterations);\n    return tss;\n    // Helper function\n    function intersection(Q_, P_, qRange, pRange, idx) {\n        //iterations++;\n        var cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\n        // Move intersection toward the origin to prevent serious floating point \n        // issues that are introduced specifically by the getLineEquation \n        // function. This allows us to get a relative error in the final \n        // result usually in the 10 ULPS or less range.\n\n        var _center = center(P_, Q_);\n\n        var _center2 = _slicedToArray(_center, 2);\n\n        P_ = _center2[0];\n        Q_ = _center2[1];\n\n        var _Q_ = Q_,\n            _Q_2 = _slicedToArray(_Q_, 4),\n            Q0 = _Q_2[0],\n            Q1 = _Q_2[1],\n            Q2 = _Q_2[2],\n            Q3 = _Q_2[3];\n\n        var _P_ = P_,\n            _P_2 = _slicedToArray(_P_, 4),\n            P0 = _P_2[0],\n            P1 = _P_2[1],\n            P2 = _P_2[2],\n            P3 = _P_2[3];\n        // Get the implict line equation for the line from the first to the last\n        // control point of Q. This equation gives the distance between any \n        // point and the line.\n\n\n        var dQ = getDistanceToLineFunction([Q0, Q3]);\n        // Calculate the distance from the control points of Q to the line \n        // [Q0,Q3].\n        var dQi = function dQi(i) {\n            return dQ(Q_[i]);\n        };\n        var dQs = [1, 2].map(dQi);\n\n        var _dQs = _slicedToArray(dQs, 2),\n            dQ1 = _dQs[0],\n            dQ2 = _dQs[1];\n        // Calculate the fat line of Q.\n\n\n        var C = dQ1 * dQ2 > 0 ? 3 / 4 : 4 / 9;\n        var dMin = C * Math.min(0, dQ1, dQ2);\n        var dMax = C * Math.max(0, dQ1, dQ2);\n\n        var _geoClip = geoClip(P_, dQ, dMin, dMax),\n            tMin = _geoClip.tMin,\n            tMax = _geoClip.tMax;\n\n        if (tMin === Number.POSITIVE_INFINITY) {\n            return; // No intersection\n        }\n        // The paper calls for a heuristic that if less than 30% will be\n        // clipped, rather split the longest curve and find intersections in the\n        // two halfs seperately.\n        if (tMax - tMin > 0.7) {\n            // Some length measure\n            var pSpan = pRange[1] - pRange[0];\n            var qSpan = qRange[1] - qRange[0];\n            if (coincident(P_, Q_) !== undefined) {\n                return;\n            }\n            // Split the curve in half\n            if (pSpan <= qSpan) {\n                cidx = idx;\n                var _ref3 = [Q_, P_];\n                P_ = _ref3[0];\n                Q_ = _ref3[1];\n                var _ref4 = [qRange, pRange];\n                pRange = _ref4[0];\n                qRange = _ref4[1];\n            }\n            // Update t range.\n            var _span = pRange[1] - pRange[0];\n            // 1st half\n            var tMinA = pRange[0];\n            var tMaxA = tMinA + _span / 2;\n            // 2nd half\n            var tMinB = tMaxA;\n            var tMaxB = pRange[1];\n            var A = fromTo(P_)(0, 0.5);\n            var B = fromTo(P_)(0.5, 1);\n            intersection(A, Q_, [tMinA, tMaxA], qRange, cidx);\n            intersection(B, Q_, [tMinB, tMaxB], qRange, cidx);\n            return;\n        }\n        // Update t range.\n        var span = pRange[1] - pRange[0];\n        var tMin_ = tMin * span + pRange[0];\n        var tMax_ = tMax * span + pRange[0];\n        // Clip\n        P_ = fromTo(P_)(tMin, tMax);\n        if (Math.abs(tMax_ - tMin_) < δ) {\n            var t1 = (tMax_ + tMin_) / 2;\n            var pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\n            var t2 = calcOtherT(t1, pq[0], pq[1]);\n            if (t2 === undefined) {\n                return undefined;\n            }\n            var ts = idx === 0 ? [t2, t1] : [t1, t2];\n            tss.push(ts);\n            return;\n        }\n        // Swap Q and P and iterate.\n        intersection(P_, Q_, [tMin_, tMax_], qRange, cidx);\n    }\n    function geoClip(P, dQ, dMin, dMax) {\n        var dPi = function dPi(i) {\n            return dQ(P[i]);\n        };\n        var dPs = [0, 1, 2, 3].map(dPi);\n\n        var _dPs = _slicedToArray(dPs, 4),\n            dP0 = _dPs[0],\n            dP1 = _dPs[1],\n            dP2 = _dPs[2],\n            dP3 = _dPs[3];\n\n        var hq = toHybridQuadratic(P);\n        var dH0 = dQ(hq[0]);\n        var dH2 = dQ(hq[2]);\n        var dH10 = dQ(hq[1][0]);\n        var dH11 = dQ(hq[1][1]);\n        var dHmin = Math.min(dH10, dH11);\n        var dHmax = Math.max(dH10, dH11);\n        var DyMin = [dH0 - 2 * dHmin + dH2, -2 * dH0 + 2 * dHmin, dH0];\n        var DyMax = [dH0 - 2 * dHmax + dH2, -2 * dH0 + 2 * dHmax, dH0];\n        var errorBound = 2 * Math.max(flo_poly_1.default.hornerErrorBound(DyMin, 1), flo_poly_1.default.hornerErrorBound(DyMax, 1));\n        dMin = dMin - errorBound;\n        dMax = dMax + errorBound;\n        var DyMinMin = DyMin.slice();\n        DyMinMin[2] = DyMinMin[2] - dMin;\n        var DyMinMax = DyMin.slice();\n        DyMinMax[2] = DyMinMax[2] - dMax;\n        var DyMaxMin = DyMax.slice();\n        DyMaxMin[2] = DyMaxMin[2] - dMin;\n        var DyMaxMax = DyMax.slice();\n        DyMaxMax[2] = DyMaxMax[2] - dMax;\n        var tMin = Number.POSITIVE_INFINITY;\n        var tMax = Number.NEGATIVE_INFINITY;\n        var rootsMinMin = flo_poly_1.default.allRoots(DyMinMin, 0, 1);\n        var rootsMinMax = flo_poly_1.default.allRoots(DyMinMax, 0, 1);\n        var rootsMaxMin = flo_poly_1.default.allRoots(DyMaxMin, 0, 1);\n        var rootsMaxMax = flo_poly_1.default.allRoots(DyMaxMax, 0, 1);\n        tMin = Math.min.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n        tMax = Math.max.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n        if (dH0 >= dMin && dH0 <= dMax) {\n            tMin = 0;\n        }\n        if (dH2 >= dMin && dH2 <= dMax) {\n            tMax = 1;\n        }\n        if (tMin < 0) {\n            tMin = 0;\n        }\n        if (tMax > 1) {\n            tMax = 1;\n        }\n        return { tMin: tMin, tMax: tMax };\n    }\n    /**\n     * Return the given two beziers but translated such that the shorter (by\n     * some length measure) is closer to the origin.\n     * @private\n     * @param P\n     * @param Q\n     */\n    function center(P, Q) {\n        var _P2 = P,\n            _P3 = _slicedToArray(_P2, 4),\n            P0 = _P3[0],\n            P1 = _P3[1],\n            P2 = _P3[2],\n            P3 = _P3[3];\n\n        var _Q2 = Q,\n            _Q3 = _slicedToArray(_Q2, 4),\n            Q0 = _Q3[0],\n            Q1 = _Q3[1],\n            Q2 = _Q3[2],\n            Q3 = _Q3[3];\n\n        var lengthP = sdst(P0, P1) + sdst(P1, P2) + sdst(P2, P3);\n        var lengthQ = sdst(Q0, Q1) + sdst(Q1, Q2) + sdst(Q2, Q3);\n        var moveX = void 0;\n        var moveY = void 0;\n        if (lengthQ < lengthP) {\n            moveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\n            moveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\n        } else {\n            moveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\n            moveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\n        }\n        P = P.map(function (x) {\n            return [x[0] - moveX, x[1] - moveY];\n        });\n        Q = Q.map(function (x) {\n            return [x[0] - moveX, x[1] - moveY];\n        });\n        return [P, Q];\n    }\n    /**\n     * Calculates the t-value of the closest point on Q to P(t).\n     * @ignore\n     * @param {number}\n     * @param Q\n     * @param P\n     */\n    function calcOtherT(t, P, Q) {\n        var pp = evaluate(P)(t);\n\n        var _pp = _slicedToArray(pp, 2),\n            x = _pp[0],\n            y = _pp[1];\n\n        var tqsh = tsAtY(Q, y);\n        var tqsv = tsAtX(Q, x);\n        if (!tqsh.length && !tqsv.length) {\n            return undefined;\n        }\n        var tqs = [].concat(_toConsumableArray(tqsh), _toConsumableArray(tqsv));\n        var bestT = undefined;\n        var bestD = Number.POSITIVE_INFINITY;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n            for (var _iterator2 = tqs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var tq = _step2.value;\n\n                var pq = evaluate(Q)(tq);\n                var d = sdst(pp, pq);\n                if (d < bestD) {\n                    bestD = d;\n                    bestT = tq;\n                }\n            }\n        } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                }\n            } finally {\n                if (_didIteratorError2) {\n                    throw _iteratorError2;\n                }\n            }\n        }\n\n        return bestT;\n    }\n}\n/**\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\n * returned as the array [a,b,c].\n * @ignore\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\n * @returns {number[]}\n */\nfunction getLineEquation(l) {\n    var _l3 = _slicedToArray(l, 2),\n        _l3$ = _slicedToArray(_l3[0], 2),\n        x1 = _l3$[0],\n        y1 = _l3$[1],\n        _l3$2 = _slicedToArray(_l3[1], 2),\n        x2 = _l3$2[0],\n        y2 = _l3$2[1];\n\n    var a = y1 - y2;\n    var b = x2 - x1;\n    var c = x1 * y2 - x2 * y1;\n    return [a, b, c];\n}\n/**\n * @private\n * @param l\n */\nfunction getDistanceToLineFunction(l) {\n    var _getLineEquation = getLineEquation(l),\n        _getLineEquation2 = _slicedToArray(_getLineEquation, 3),\n        a = _getLineEquation2[0],\n        b = _getLineEquation2[1],\n        c = _getLineEquation2[2];\n\n    return function (p) {\n        return a * p[0] + b * p[1] + c;\n    };\n}\n/**\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\n * where a^2 + b^2 = 1 returned as the array [a,b,c].\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\n * @example\n * getNormalizedLineEquation([[1,0],[5,3]]); //=> [-0.6, 0.8, 0.6]\n */\nfunction getNormalizedLineEquation(l) {\n    var _l4 = _slicedToArray(l, 2),\n        _l4$ = _slicedToArray(_l4[0], 2),\n        x1 = _l4$[0],\n        y1 = _l4$[1],\n        _l4$2 = _slicedToArray(_l4[1], 2),\n        x2 = _l4$2[0],\n        y2 = _l4$2[1];\n\n    var a = y1 - y2;\n    var b = x2 - x1;\n    var c = x1 * y2 - x2 * y1;\n    var norm = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    // Normalize it\n    a = a / norm;\n    b = b / norm;\n    c = c / norm;\n    return [a, b, c];\n}\n/**\n * Returns the given points (e.g. bezier) in reverse order.\n * @param ps\n * @returns {number[][]}\n */\nfunction reverse(ps) {\n    return ps.slice().reverse();\n}\n/**\n * <p>\n * Purely functional cubic bezier library, including robust\n * cubic-cubic bezier intersection.\n * </p>\n * <p>\n * A cubic bezier is represented as an array of points, i.e.\n * [p0, p1, p2, p3] where each point is an ordered pair, e.g.\n * [[0,0],[1,1],[2,1],[3,0]].\n * </p>\n */\nvar Bezier3 = {\n    rotate: rotate,\n    getX: getX,\n    getY: getY,\n    getDx: getDx,\n    getDy: getDy,\n    getDdx: getDdx,\n    getDdy: getDdy,\n    getDddx: getDddx,\n    getDddy: getDddy,\n    getBounds: getBounds,\n    bezier3Intersection: bezier3Intersection,\n    lineIntersection: lineIntersection,\n    tsAtX: tsAtX,\n    tsAtY: tsAtY,\n    getBoundingHull: getBoundingHull,\n    fromLine: fromLine,\n    translate: translate,\n    evaluate: evaluate,\n    κ: κ,\n    dκMod: dκMod,\n    curvature: curvature,\n    tangent: tangent,\n    normal: normal,\n    totalCurvature: totalCurvature,\n    totalAbsoluteCurvature: totalAbsoluteCurvature,\n    len: len,\n    getTAtLength: getTAtLength,\n    evaluateX: evaluateX,\n    evaluateY: evaluateY,\n    evaluateDx: evaluateDx,\n    evaluateDy: evaluateDy,\n    evaluateDdx: evaluateDdx,\n    evaluateDdy: evaluateDdy,\n    evaluateDddx: evaluateDddx,\n    evaluateDddy: evaluateDddy,\n    getBoundingBoxTight: getBoundingBoxTight,\n    getBoundingBox: getBoundingBox,\n    fromTo: fromTo,\n    splitAt: splitAt,\n    scale: scale,\n    toCubic: toCubic,\n    toQuadratic: toQuadratic,\n    toHybridQuadratic: toHybridQuadratic,\n    evaluateHybridQuadratic: evaluateHybridQuadratic,\n    evaluateQuadratic: evaluateQuadratic,\n    evaluateLinear: evaluateLinear,\n    coincident: coincident,\n    from0ToT: from0ToT,\n    fromTTo1: fromTTo1,\n    clone: clone,\n    reverse: reverse\n};\nexports.default = Bezier3;\n\n},{\"flo-gauss-quadrature\":41,\"flo-graham-scan\":42,\"flo-memoize\":47,\"flo-poly\":48,\"flo-vector2d\":56}],41:[function(_dereq_,module,exports){\n\"use strict\";\n// TODO A future improvement can be to use the Gauss–Kronrod rules\n// to estimate the error and thus choose a number of constants based\n// on the error.\n// TODO In future, the constants can be calculated and cached so we can\n// chooce any value for the order.\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * <p>\n * Integrates the given function using the Gaussian Quadrature method.\n * </p>\n * <p>\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\n * </p>\n * <p>\n * See http://pomax.github.io/bezierinfo/#arclength\n * </p>\n * @param f - The univariate function to be integrated\n * @param interval - The integration interval\n * @param order - Can be 2, 4, 8, or 16. Higher values give\n * more accurate results but is slower - defaults to 16.\n */\nfunction gaussQuadrature(f, interval) {\n    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n\n    if (interval[0] === interval[1]) {\n        return 0;\n    }\n    var _GAUSS_CONSTANTS$orde = GAUSS_CONSTANTS[order],\n        weights = _GAUSS_CONSTANTS$orde.weights,\n        abscissas = _GAUSS_CONSTANTS$orde.abscissas;\n\n    var _interval = _slicedToArray(interval, 2),\n        a = _interval[0],\n        b = _interval[1];\n\n    var result = 0;\n    var m1 = (b - a) / 2;\n    var m2 = (b + a) / 2;\n    for (var i = 0; i <= order - 1; i++) {\n        result += weights[i] * f(m1 * abscissas[i] + m2);\n    }\n    return m1 * result;\n}\n// The Gaussian Legendre Quadrature method constants. \nvar GAUSS_CONSTANTS = {\n    2: {\n        weights: [1, 1],\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\n    },\n    4: {\n        weights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538],\n        abscissas: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526]\n    },\n    8: {\n        weights: [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763],\n        abscissas: [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363]\n    },\n    // Taken from http://keisan.casio.com/exec/system/1330940731\n    16: {\n        abscissas: [-0.989400934991649932596, -0.944575023073232576078, -0.86563120238783174388, -0.7554044083550030338951, -0.6178762444026437484467, -0.4580167776572273863424, -0.28160355077925891323, -0.0950125098376374401853, 0.0950125098376374401853, 0.28160355077925891323, 0.4580167776572273863424, 0.617876244402643748447, 0.755404408355003033895, 0.8656312023878317438805, 0.944575023073232576078, 0.989400934991649932596],\n        weights: [0.0271524594117540948518, 0.062253523938647892863, 0.0951585116824927848099, 0.1246289712555338720525, 0.1495959888165767320815, 0.169156519395002538189, 0.182603415044923588867, 0.189450610455068496285, 0.1894506104550684962854, 0.182603415044923588867, 0.1691565193950025381893, 0.149595988816576732081, 0.124628971255533872053, 0.095158511682492784809, 0.062253523938647892863, 0.027152459411754094852]\n    }\n};\nexports.default = gaussQuadrature;\n\n},{}],42:[function(_dereq_,module,exports){\n(function (global){\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloGrahamScan = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Vector = _dereq_('flo-vector2d');\n\nvar DELTA = 1e-10;\n\n/**\r\n * Performs a functional stable sort on the given array and \r\n * returns the newly sorted array.\r\n * @ignore\r\n */\nfunction stableSort(arr, f) {\n\tvar indxArray = [];\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tindxArray.push(i);\n\t}\n\n\tindxArray.sort(function (a, b) {\n\t\tvar res = f(arr[a], arr[b]);\n\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a - b;\n\t});\n\n\tvar sorted = [];\n\tfor (var _i = 0; _i < arr.length; _i++) {\n\t\tsorted.push(arr[indxArray[_i]]);\n\t}\n\n\treturn sorted;\n}\n\n/**\r\n * In-place swap two elements in the given array.\r\n * @ignore\r\n */\nfunction swap(arr, a, b) {\n\tif (a === b) {\n\t\treturn;\n\t}\n\n\tvar temp = arr[a];\n\tarr[a] = arr[b];\n\tarr[b] = temp;\n}\n\n/**\r\n * @ignore\r\n */\nfunction getSmallestIndxYThenX(ps) {\n\tvar smallest = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n\tvar smallestI = void 0;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar y = ps[i][1];\n\t\tif (y < smallest[1] || y === smallest[1] && ps[i][0] < smallest[0]) {\n\t\t\tsmallestI = i;\n\t\t\tsmallest = ps[i];\n\t\t}\n\t}\n\n\treturn smallestI;\n}\n\n/** \r\n * <p>\r\n * Finds the convex hull of the given set of 2d points using the   \r\n * Graham Scan algorithm and returns the hull as an array of points. \r\n * </p>\r\n * <p>\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n * </p>\r\n * @param {number[][]} ps_ - A set of points\r\n * @param {boolean} includeAllBoundaryPoints - Set this to true to if all boundary points\r\n * should be returned, even redundant ones\r\n * @param {number} delta - Tolerance at which three points are considered collinear -\r\n * defaults to 1e-10\r\n * @returns {number[][]}\r\n */\nfunction grahamScan(ps_, includeAllBoundaryPoints, delta) {\n\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tfunction fail(p1, p2, p3) {\n\t\tvar res = Vector.ccw(p1, p2, p3, delta);\n\t\tif (includeAllBoundaryPoints) {\n\t\t\treturn res < 0;\n\t\t}\n\t\treturn res <= 0;\n\t}\n\n\tvar ps = ps_.slice();\n\tvar n = ps.length;\n\n\tvar idx = getSmallestIndxYThenX(ps);\n\n\tvar _ps$splice = ps.splice(idx, 1),\n\t    _ps$splice2 = _slicedToArray(_ps$splice, 1),\n\t    p = _ps$splice2[0];\n\n\tps = stableSort(ps, function (a, b) {\n\t\tvar res = Vector.cross(Vector.fromTo(p, b), Vector.fromTo(p, a));\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\tres = a[1] - b[1];\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a[0] - b[0];\n\t});\n\n\tps.unshift(p);\n\n\tvar m = 1;\n\tfor (var i = 2; i < n; i++) {\n\t\twhile (fail(ps[m - 1], ps[m], ps[i])) {\n\t\t\tif (m > 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tcontinue;\n\t\t\t} else if (i === n - 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\n\t\tm += 1;\n\t\tswap(ps, m, i);\n\t}\n\n\treturn ps.slice(0, m + 1);\n}\n\nmodule.exports = grahamScan;\n\n},{\"flo-vector2d\":2}],2:[function(_dereq_,module,exports){\n(function (global){\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloVector2d = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar DELTA = 1e-10;\n\n/*\r\n * Purely functional 2d vector utilities.\r\n */\nvar Vector = {\n\tdot: dot,\n\tcross: cross,\n\tccw: ccw,\n\tsegSegIntersection: segSegIntersection,\n\tdoesSegSegIntersect: doesSegSegIntersect,\n\tsquaredDistanceBetween: squaredDistanceBetween,\n\tscale: scale,\n\treverse: reverse,\n\ttoUnitVector: toUnitVector,\n\ttoLength: toLength,\n\tfromTo: fromTo,\n\tinterpolate: interpolate,\n\tmean: mean,\n\tdistanceBetween: distanceBetween,\n\tlength: length,\n\tlengthSquared: lengthSquared,\n\tmanhattanDistanceBetween: manhattanDistanceBetween,\n\tmanhattanLength: manhattanLength,\n\tdistanceBetweenPointAndLine: distanceBetweenPointAndLine,\n\tsquaredDistanceBetweenPointAndLineSegment: squaredDistanceBetweenPointAndLineSegment,\n\tcircumCenter: circumCenter,\n\tinCenter: inCenter,\n\tcentroid: centroid,\n\tequal: equal,\n\trotate: rotate,\n\treverseRotate: reverseRotate,\n\trotateBy90Degrees: rotateBy90Degrees,\n\trotateByNeg90Degrees: rotateByNeg90Degrees,\n\ttransform: transform,\n\tgetClosestTo: getClosestTo,\n\ttranslatePoints: translatePoints,\n\trotatePoints: rotatePoints,\n\ttranslateThenRotatePoints: translateThenRotatePoints,\n\trotateThenTranslatePoints: rotateThenTranslatePoints\n\n\t/** \r\n  * Returns the dot (inner) product between two 2-vectors. \r\n  * @param {number} a - The first vector\r\n  * @param {number} b - The second vector\r\n  * @returns {number}\r\n  */\n};function dot(a, b) {\n\treturn a[0] * b[0] + a[1] * b[1];\n}\n\n/** \r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param {number} a - The first vector\r\n * @param {number} b - The second vector\r\n * @returns {number}\r\n */\nfunction cross(a, b) {\n\treturn a[0] * b[1] - a[1] * b[0];\n}\n\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, \r\n * clockwise if ccw < 0, and colinear if ccw = 0 because ccw is a \r\n * determinant that gives twice the signed area of the triangle formed \r\n * by p1, p2 and p3.\r\n * @param {number[]} p1 - The first point\r\n * @param {number[]} p2 - The second point\r\n * @param {number[]} p3 - The third point\r\n * @param {number} delta - The tolerance at which the three points are \r\n * considered colinear - defaults to 1e-10\r\n * @returns {number}\r\n */\nfunction ccw(p1, p2, p3, delta) {\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tvar res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n\n\treturn Math.abs(res) <= delta ? 0 : res;\n}\n\n/**\r\n * <p>\r\n * Finds the point where two 2d line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p> \r\n * @param {number[][]} ab - The first line \r\n * @param {number[][]} cd - The second line\r\n * @param {number} delta - The tolerance at which the lines are considered \r\n * parallel - defaults to 1e-10\r\n * @returns {number[]} The point where the two line segments intersect  \r\n * or undefined if they don't intersect or a line if they intersect at \r\n * infinitely many points. \r\n */\nfunction segSegIntersection(ab, cd, delta) {\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tvar _ab = _slicedToArray(ab, 2),\n\t    a = _ab[0],\n\t    b = _ab[1];\n\n\tvar _cd = _slicedToArray(cd, 2),\n\t    c = _cd[0],\n\t    d = _cd[1];\n\n\tvar denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n\tvar rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n\tvar sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n\n\tif (Math.abs(denom) <= delta) {\n\t\t// parallel\n\t\tif (Math.abs(rNumer) <= delta) {\n\t\t\t// colinear\n\t\t\t// TODO Check if x-projections and y-projections intersect\n\t\t\t// and return the line of intersection if they do.\n\t\t\treturn undefined;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tvar r = rNumer / denom;\n\tvar s = sNumer / denom;\n\n\tif (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n\t\treturn [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n\t}\n\n\treturn undefined;\n}\n\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n * @param {number[][]} a - A line segment\r\n * @param {number[][]} b - Another line segment\r\n * @returns {boolean}\r\n */\nfunction doesSegSegIntersect(a, b) {\n\tif (ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) > 0) {\n\t\treturn false;\n\t}\n\tif (ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) > 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/** \r\n * Returns the squared distance between two 2d points.\r\n * @param {number[]} p1 - A point\r\n * @param {number[]} p2 - Another point\r\n * @returns {number}\r\n */\nfunction squaredDistanceBetween(p1, p2) {\n\tvar x = p2[0] - p1[0];\n\tvar y = p2[1] - p1[1];\n\n\treturn x * x + y * y;\n}\n\n/**\r\n * Returns a scaled version of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @param {number} factor - A scale factor\r\n * @returns {number[]}\r\n */\nfunction scale(p, factor) {\n\treturn [p[0] * factor, p[1] * factor];\n}\n\n/**\r\n * Returns the 2-vector reversed.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction reverse(p) {\n\treturn [-p[0], -p[1]];\n}\n\n/**\r\n * Returns the given 2-vector scaled to a length of one.\r\n * @param {number[]} p\r\n * @returns {number[]}\r\n */\nfunction toUnitVector(p) {\n\tvar scaleFactor = 1 / length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n}\n\n/**\r\n * Returns the given 2-vector scaled to the given length.\r\n * @param {number[]} p \r\n * @param {number} length \r\n * @returns {number[]}\r\n */\nfunction toLength(p, length) {\n\tvar scaleFactor = length / length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n}\n\n/** \r\n * Returns the second 2-vector minus the first.\r\n * @param {number[]} p1 - The first vector\r\n * @param {number[]} p2 - The second vector\r\n * @returns {number[]}\r\n */\nfunction fromTo(p1, p2) {\n\treturn [p2[0] - p1[0], p2[1] - p1[1]];\n}\n\n/**\r\n * Performs linear interpolation between two 2d points and returns the resultant point.\r\n * @param {number[]} p1 - The first point.\r\n * @param {number[]} p2 - The second point.\r\n * @param {number} t - The interpolation fraction (usually in [0,1]).  \r\n * @returns {number[]}\r\n */\nfunction interpolate(p1, p2, t) {\n\treturn [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];\n}\n\n/**\r\n * Returns the mean point value of the provided array of two 2d points. \r\n * @param {number[][]} ps - The two points\r\n * @returns {number[]}\r\n */\nfunction mean(ps) {\n\tvar p1 = ps[0];\n\tvar p2 = ps[1];\n\n\treturn [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n}\n\n/** \r\n * Returns the distance between two 2d points.\r\n * @param {number[]} p1 - A point.\r\n * @param {number[]} p2 - Another point.\r\n * @returns {number}\r\n */\nfunction distanceBetween(p1, p2) {\n\treturn Math.sqrt(squaredDistanceBetween(p1, p2));\n}\n\n/** \r\n * Returns the length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction length(p) {\n\treturn Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n}\n\n/**\r\n * Returns the squared length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction lengthSquared(v) {\n\treturn v[0] * v[0] + v[1] * v[1];\n}\n\n/** \r\n * Returns the Manhattan distance between two 2d points.\r\n * @param {number[]} p1 - A point.\r\n * @param {number[]} p2 - Another point.\r\n * @returns {number}\r\n */\nfunction manhattanDistanceBetween(p1, p2) {\n\treturn Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n}\n\n/** \r\n * Returns the Manhattan length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction manhattanLength(p) {\n\treturn Math.abs(p[0]) + Math.abs(p[1]);\n}\n\n/**\r\n * <p>\r\n * Returns the distance between the given point and line. \r\n * </p>\r\n * <p>\r\n * See https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points \r\n * </p>\r\n * @param {number[]} p - A point\r\n * @param {number[][]} l - A line\r\n * @returns {number}\r\n */\nfunction distanceBetweenPointAndLine(p, l) {\n\tvar x0 = p[0];\n\tvar y0 = p[1];\n\tvar x1 = l[0][0];\n\tvar y1 = l[0][1];\n\tvar x2 = l[1][0];\n\tvar y2 = l[1][1];\n\n\tvar y2_y1 = y2 - y1;\n\tvar x2_x1 = x2 - x1;\n\n\tvar numerator = y2_y1 * x0 - x2_x1 * y0 + x2 * y1 - y2 * x1;\n\tvar denominator = Math.sqrt(y2_y1 * y2_y1 + x2_x1 * x2_x1);\n\n\treturn Math.abs(numerator / denominator);\n}\n\n/**\r\n * Return the squared distance between the given point and line segment. \r\n * @param {number[]} p - A point\r\n * @param {number[][]} l - A line\r\n * @returns {number}\r\n */\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\n\tvar v = l[0];\n\tvar w = l[1];\n\n\tvar l2 = squaredDistanceBetween(v, w);\n\tif (l2 == 0) {\n\t\treturn squaredDistanceBetween(p, v);\n\t}\n\n\tvar t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n\tt = Math.max(0, Math.min(1, t));\n\n\tvar d2 = squaredDistanceBetween(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n\n\treturn d2;\n}\n\n/**\r\n * Returns the circumcenter of the given 2d triangle (given as three 2d points).\r\n * @param {number[][]} triangle \r\n * @returns {number[]}\r\n */\nfunction circumCenter(triangle) {\n\t// See wikipedia\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar Sx = 0.5 * det3([squaredNorm(p1), p1[1], 1], [squaredNorm(p2), p2[1], 1], [squaredNorm(p3), p3[1], 1]);\n\n\tvar Sy = 0.5 * det3([p1[0], squaredNorm(p1), 1], [p2[0], squaredNorm(p2), 1], [p3[0], squaredNorm(p3), 1]);\n\n\tvar a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n\n\tvar b = det3([p1[0], p1[1], squaredNorm(p1)], [p2[0], p2[1], squaredNorm(p2)], [p3[0], p3[1], squaredNorm(p3)]);\n\n\treturn [Sx / a, Sy / a];\n}\n\n/** \r\n * <p>\r\n * Returns the incenter of the given triangle.\r\n * </p>\r\n * <p>\r\n * See Wikipedia - https://en.wikipedia.org/wiki/Incenter \r\n * </p>\r\n * @param {number[][]} triangle \r\n * @returns {number[]}\r\n */\nfunction inCenter(triangle) {\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar l1 = distanceBetween(p2, p3);\n\tvar l2 = distanceBetween(p1, p3);\n\tvar l3 = distanceBetween(p1, p2);\n\tvar lengthSum = l1 + l2 + l3;\n\treturn [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n}\n\n/**\r\n * Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n * must be simple, i.e. not self-intersecting.\r\n * @param {number[][]} polygon \r\n * @returns {number[]}\r\n */\nfunction centroid(polygon) {\n\tif (polygon.length === 3) {\n\t\tvar p1 = polygon[0];\n\t\tvar p2 = polygon[1];\n\t\tvar p3 = polygon[2];\n\n\t\tvar x = p1[0] + p2[0] + p3[0];\n\t\tvar y = p1[1] + p2[1] + p3[1];\n\n\t\treturn [x / 3, y / 3];\n\t}\n\n\t// polygon.length assumed > 3 and assumed to be non-self-intersecting\n\t// See wikipedia\n\n\t// First calculate the area, A, of the polygon\n\tvar A = 0;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar p0 = polygon[i];\n\t\tvar _p = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n\t\tA = A + (p0[0] * _p[1] - _p[0] * p0[1]);\n\t}\n\tA = A / 2;\n\n\tvar C = [0, 0];\n\tfor (var _i = 0; _i < polygon.length; _i++) {\n\t\tvar _p2 = polygon[_i];\n\t\tvar _p3 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n\n\t\tC[0] = C[0] + (_p2[0] + _p3[0]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t\tC[1] = C[1] + (_p2[1] + _p3[1]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t}\n\n\treturn [C[0] / (6 * A), C[1] / (6 * A)];\n}\n\n/**\r\n * Calculate the determinant of three 3-vectors, i.e. 3x3 matrix\r\n * @param {number[]} x \r\n * @param {number[]} y\r\n * @param {number[]} z\r\n * @returns {number}\r\n */\nfunction det3(x, y, z) {\n\treturn x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n}\n\n/**\r\n * Returns the result of adding two 2-vectors.\r\n * @param {number[]} a - A vector\r\n * @param {number[]} b - Another vector\r\n * @param {number[]}\r\n */\nfunction add(a, b) {\n\treturn [a[0] + b[0], a[1] + b[1]];\n}\n\n/**\r\n * Returns true if two 2-vectors are identical, false otherwise.\r\n * @param {number[]} a\r\n * @param {number[]} b\r\n * @returns {boolean}\r\n */\nfunction equal(a, b) {\n\treturn a[0] === b[0] && a[1] === b[1];\n}\n\n/**\r\n * Returns a rotated version of the given 2-vector given the sine and cosine of the angle.\r\n * @param {number[]} p \r\n * @param {number} sinAngle \r\n * @param {number} cosAngle \r\n * @returns {number[]}\r\n */\nfunction rotate(p, sinAngle, cosAngle) {\n\treturn [p[0] * cosAngle - p[1] * sinAngle, p[0] * sinAngle + p[1] * cosAngle];\n}\n\n/**\r\n * Returns a anti-clockwise rotated version of the given 2-vector given the sine and cosine of the angle.\r\n * @param {number[]} p \r\n * @param {number} sinθ\r\n * @param {number} cosθ\r\n * @returns {number[]}\r\n */\nfunction reverseRotate(p, sinθ, cosθ) {\n\treturn [+p[0] * cosθ + p[1] * sinθ, -p[0] * sinθ + p[1] * cosθ];\n}\n\n/**\r\n * Returns a 90 degrees rotated version of the given 2-vector.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction rotateBy90Degrees(p) {\n\treturn [-p[1], p[0]];\n}\n\n/**\r\n * Returns a negative 90 degrees rotated version of the given 2-vector.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction rotateByNeg90Degrees(p) {\n\treturn [p[1], -p[0]];\n}\n\n/**\r\n * Transforms the given 2-vector by applying the given function to each coordinate.\r\n * @param {number[]} p \r\n * @param {function} f \r\n * @returns {*[]}\r\n */\nfunction transform(p, f) {\n\treturn [f(p[0]), f(p[1])];\n}\n\n/**\r\n * Returns the closest point to the array of 2d points, optionally providing a distance function.\r\n * @param {number[]} p\r\n * @param {number[][]} ps\r\n * @param {function} f - Distance function - if undefined uses squaredDistanceBetween\r\n */\nfunction getClosestTo(p, ps, f) {\n\tf = f === undefined ? squaredDistanceBetween : f;\n\n\tvar cp = undefined; // Closest Point\n\tvar bestd = Number.POSITIVE_INFINITY;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar p_ = ps[i];\n\n\t\tvar d = f(p, p_);\n\t\tif (d < bestd) {\n\t\t\tcp = p_;\n\t\t\tbestd = d;\n\t\t}\n\t}\n\n\treturn cp;\n}\n\n/**\r\n * Return the given 2d points translated by the given 2d vector.\r\n * @param {number[][]} ps \r\n * @param {number[]} v \r\n * @returns {number[][]}\r\n */\nfunction translatePoints(ps, v) {\n\t// SLOW!\n\t/*return ps.map(function(p) {\r\n \t//return add(p, v);\r\n \treturn [p[0]+v[0], p[1]+v[1]]; \r\n });*/\n\n\t// FAST! (at least on V8, BUT WHY?!)\n\tvar result = [];\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tresult.push([ps[i][0] + v[0], ps[i][1] + v[1]]);\n\t}\n\n\treturn result;\n}\n\n/**\r\n * Returns the given points rotated by a given angle given as the sine and cosine of the angle.\r\n * @param {number[][]} ps \r\n * @param {number} sinθ \r\n * @param {number} cosθ\r\n * @returns {number[][]}\r\n */\nfunction rotatePoints(ps, sinθ, cosθ) {\n\treturn ps.map(function (p) {\n\t\treturn rotate(p, sinθ, cosθ);\n\t});\n}\n\n/** \r\n * Returns an array of points by applying a translation and then rotation to the given points.\r\n * @param {number[][]} ps - The input points\r\n * @param {number[]} t - The translation vector\r\n * @param {number} sinθ \r\n * @param {number} cosθ\r\n * @returns {number[][]}\r\n **/\nfunction translateThenRotatePoints(ps, t, sinθ, cosθ) {\n\treturn ps.map(function (p) {\n\t\treturn rotate(add(p, t), sinθ, cosθ);\n\t});\n}\n\n/** \r\n * Returns an array of points by applying a rotation and then translation to the given points.\r\n * @param {number[][]} ps - The input points\r\n * @param {number[]} t - The translation vector\r\n * @param {number} sinθ \r\n * @param {number} cosθ\r\n * @returns {number[][]}\r\n **/\nfunction rotateThenTranslatePoints(ps, t, sinθ, cosθ) {\n\treturn ps.map(function (p) {\n\t\treturn add(rotate(p, sinθ, cosθ), t);\n\t});\n}\n\nmodule.exports = Vector;\n\n},{}]},{},[1])(1)\n});\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}]},{},[1])(1)\n});\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"flo-vector2d\":56}],43:[function(_dereq_,module,exports){\n\"use strict\";\n/*\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tree_node_1 = _dereq_(\"./src/tree-node\");\nvar tree_node_color_1 = _dereq_(\"./src/tree-node-color\");\nvar tree_node_direction_1 = _dereq_(\"./src/tree-node-direction\");\nfunction isRed(node) {\n    return node && node.color === tree_node_color_1.default.RED;\n}\n/**\n * @param compare\n * @param datas\n * @param replaceDups - If true then if a duplicate is\n * inserted (as per the equivalence relation induced by the compare)\n * then replace it. If false then keep an array of values at the relevant\n * node.\n */\n\nvar LlRbTree = function () {\n    function LlRbTree(compare, datas, replaceDups) {\n        _classCallCheck(this, LlRbTree);\n\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\n        var tree = this;\n        tree.setComparator(compare, replaceDups);\n        tree.replaceDups = replaceDups;\n        tree.root = null;\n        if (!datas) {\n            return;\n        }\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = datas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var data = _step.value;\n\n                tree.insert(data);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    /**\n     * Destructively sets the tree compare. This function can be used for for e.g.\n     * the Bentley Ottmann algorithm.\n     */\n\n\n    _createClass(LlRbTree, [{\n        key: \"setComparator\",\n        value: function setComparator(compare, replaceDups) {\n            if (replaceDups) {\n                this.compare = compare;\n            } else {\n                this.compare = function (a, b) {\n                    return compare(a, b[0]);\n                };\n            }\n        }\n    }, {\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return !this.root;\n        }\n        /**\n         * Find the node in the tree with the given data using the tree compare\n         * function.\n         * @returns {Node} node or null if not found.\n         */\n\n    }, {\n        key: \"find\",\n        value: function find(data) {\n            var tree = this;\n            var node = this.root;\n            while (node) {\n                var c = tree.compare(data, node.data);\n                if (c === 0) {\n                    return node;\n                } else {\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return null;\n        }\n        /**\n         * .\n         */\n\n    }, {\n        key: \"toArrayInOrder\",\n        value: function toArrayInOrder() {\n            var nodes = [];\n            f(this.root);\n            function f(node) {\n                if (!node) {\n                    return;\n                }\n                f(node[tree_node_direction_1.default.LEFT]);\n                nodes.push(node);\n                f(node[tree_node_direction_1.default.RIGHT]);\n            }\n            return nodes;\n        }\n        /**\n         * Inserts a node with the given data into the tree.\n         */\n\n    }, {\n        key: \"insert\",\n        value: function insert(data) {\n            var tree = this;\n            tree.root = f(tree.root, data);\n            tree.root.color = tree_node_color_1.default.BLACK;\n            tree.root.parent = undefined;\n            function f(h, data) {\n                if (!h) {\n                    return new tree_node_1.default(data, !tree.replaceDups);\n                }\n                var c = tree.compare(data, h.data);\n                if (c === 0) {\n                    if (tree.replaceDups) {\n                        h.data = data;\n                    } else {\n                        h.data.push(data);\n                    }\n                } else {\n                    var dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\n                    h[dir] = f(h[dir], data);\n                    h[dir].parent = h;\n                }\n                if (isRed(h[tree_node_direction_1.default.RIGHT]) && !isRed(h[tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.LEFT, h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.RIGHT, h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.RIGHT])) {\n                    flipColors(h);\n                }\n                return h;\n            }\n        }\n        /**\n         * Removes an item from the tree based on the given data.\n         * @param {LlRbTree} tree\n         * @param {*} data\n         * @param {boolean} all - If the data is an array, remove all.\n         */\n\n    }, {\n        key: \"remove\",\n        value: function remove(data, all) {\n            var tree = this;\n            tree.root = f(tree.root, data);\n            if (tree.root) {\n                tree.root.color = tree_node_color_1.default.BLACK;\n                tree.root.parent = undefined;\n            }\n            function f(h, data) {\n                //let h = h_;\n                var c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n                if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                    return h;\n                }\n                if (c < 0) {\n                    if (!isRed(h[tree_node_direction_1.default.LEFT]) && !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                        h = moveRedLeft(h);\n                    }\n                    h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\n                    if (h[tree_node_direction_1.default.LEFT]) {\n                        h[tree_node_direction_1.default.LEFT].parent = h;\n                    }\n                    return fixUp(h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.RIGHT, h);\n                    c = tree.compare(data, h.data);\n                    if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                        removeFromArray(data, h.data);\n                        return h;\n                    }\n                }\n                if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                    return null;\n                }\n                if (!isRed(h[tree_node_direction_1.default.RIGHT]) && !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n                    h = moveRedRight(h);\n                    c = tree.compare(data, h.data);\n                    if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                        removeFromArray(data, h.data);\n                        return h;\n                    }\n                }\n                if (c === 0) {\n                    h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\n                    h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\n                } else {\n                    h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\n                }\n                if (h[tree_node_direction_1.default.RIGHT]) {\n                    h[tree_node_direction_1.default.RIGHT].parent = h;\n                }\n                return fixUp(h);\n            }\n        }\n        /**\n         * Returns the two ordered nodes bounding the data. If the\n         * data falls on a node, that node and the next (to the right) is\n         * returned.\n         * @returns {Node[]}\n         */\n\n    }, {\n        key: \"findBounds\",\n        value: function findBounds(data) {\n            var tree = this;\n            var node = tree.root;\n            var bounds = [undefined, undefined];\n            if (node === null) {\n                return bounds;\n            }\n            while (node) {\n                var c = tree.compare(data, node.data);\n                if (c >= 0) {\n                    bounds[0] = node;\n                } else {\n                    bounds[1] = node;\n                }\n                node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n            return bounds;\n        }\n        /**\n         * @param {LlRbTree} tree\n         * @param {*} data\n         * @returns {Node[]} The two ordered nodes bounding the data. If the\n         * data falls on a node, returns the nodes before and after this one.\n         */\n\n    }, {\n        key: \"findBoundsExcl\",\n        value: function findBoundsExcl(data) {\n            var tree = this;\n            var node = tree.root;\n            var bounds = [undefined, undefined];\n            if (node === null) {\n                return bounds;\n            }\n            f(node);\n            function f(node) {\n                while (node) {\n                    var c = tree.compare(data, node.data);\n                    if (c === 0) {\n                        // Search on both sides\n                        f(node[tree_node_direction_1.default.LEFT]);\n                        f(node[tree_node_direction_1.default.RIGHT]);\n                        return;\n                    }\n                    if (c > 0) {\n                        bounds[0] = node;\n                    } else if (c < 0) {\n                        bounds[1] = node;\n                    }\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return bounds;\n        }\n        /**\n         *\n         */\n\n    }, {\n        key: \"findAllInOrder\",\n        value: function findAllInOrder(data) {\n            var tree = this;\n            var nodes = [];\n            f(tree.root);\n            function f(node) {\n                while (node) {\n                    var c = tree.compare(data, node.data);\n                    if (c === 0) {\n                        f(node[tree_node_direction_1.default.LEFT]);\n                        nodes.push(node);\n                        f(node[tree_node_direction_1.default.RIGHT]);\n                        return;\n                    }\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return nodes;\n        }\n    }, {\n        key: \"getMinOrMaxNode\",\n        value: function getMinOrMaxNode(dir) {\n            return function (node) {\n                if (!node) {\n                    return undefined;\n                }\n                while (node[dir]) {\n                    node = node[dir];\n                }\n                return node;\n            };\n        }\n    }, {\n        key: \"min\",\n        value: function min(node) {\n            return this.getMinNode(node).data;\n        }\n    }, {\n        key: \"max\",\n        value: function max(node) {\n            return this.getMaxNode(node).data;\n        }\n    }]);\n\n    return LlRbTree;\n}();\n/**\n * Removes the data from the tuple using ===.\n * Note this function uses === and not the compare function!\n */\n\n\nfunction removeFromArray(elem, arr) {\n    var index = arr.indexOf(elem);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n/**\n * Destructively rotates the given node, say h, in the\n * given direction as far as tree rotations go.\n * @param {boolean} dir true -> right, false -> left\n * @param {Node} h\n * @returns The node that is at the top after the rotation.\n */\nfunction rotate(dir, h) {\n    var otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\n    var x = h[otherDir];\n    h[otherDir] = x[dir];\n    if (x[dir]) {\n        x[dir].parent = h;\n    }\n    x[dir] = h;\n    h.parent = x;\n    x.color = h.color;\n    h.color = tree_node_color_1.default.RED;\n    return x;\n}\nfunction removeMin(h) {\n    if (!h[tree_node_direction_1.default.LEFT]) {\n        return null;\n    }\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) && !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = moveRedLeft(h);\n    }\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\n    if (h[tree_node_direction_1.default.LEFT]) {\n        h[tree_node_direction_1.default.LEFT].parent = h;\n    }\n    return fixUp(h);\n}\nfunction flipColor(color) {\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\n}\n/**\n * Destructively flips the color of the given node and both\n * it's childrens' colors.\n * @param {Node} h\n */\nfunction flipColors(h) {\n    h.color = flipColor(h.color);\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedLeft(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n        var a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\n        h[tree_node_direction_1.default.RIGHT] = a;\n        a.parent = h;\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedRight(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description Fix right-leaning red nodes.\n * @returns The node that is at the top after the fix.\n */\nfunction fixUp(h) {\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n    }\n    if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n    }\n    // Split 4-nodes.\n    if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.RIGHT])) {\n        flipColors(h);\n    }\n    return h;\n}\nexports.default = LlRbTree;\n\n},{\"./src/tree-node\":46,\"./src/tree-node-color\":44,\"./src/tree-node-direction\":45}],44:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeColor;\n(function (TreeNodeColor) {\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\n})(TreeNodeColor || (TreeNodeColor = {}));\nexports.default = TreeNodeColor;\n\n},{}],45:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeDirection;\n(function (TreeNodeDirection) {\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(TreeNodeDirection || (TreeNodeDirection = {}));\nexports.default = TreeNodeDirection;\n\n},{}],46:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tree_node_color_1 = _dereq_(\"./tree-node-color\");\n/**\n * Red Black Tree node.\n * @constructor\n * @param {*} data\n */\n\nvar TreeNode = function TreeNode(data, asArray) {\n    _classCallCheck(this, TreeNode);\n\n    if (asArray) {\n        this.data = [data];\n    } else {\n        this.data = data;\n    }\n    this.color = tree_node_color_1.default.RED;\n};\n\nexports.default = TreeNode;\n\n},{\"./tree-node-color\":44}],47:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SUPPORTED = typeof WeakMap === 'function';\n/**\n * Memoize the given arity 1 function.\n */\nfunction m1(f) {\n    if (!SUPPORTED) {\n        return f;\n    }\n    var results = new WeakMap();\n    return function (a) {\n        var result = results.get(a);\n        if (result !== undefined) {\n            //console.log('cache hit');\n            return result;\n        }\n        //console.log('cache miss');\n        result = f(a);\n        results.set(a, result);\n        return result;\n    };\n}\nvar Memoize = { m1: m1 };\nexports.default = Memoize;\n\n},{}],48:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./src/core-operators\");\nvar root_operators_1 = _dereq_(\"./src/root-operators\");\nvar root_bounds_1 = _dereq_(\"./src/root-bounds\");\nvar all_roots_recursive_1 = _dereq_(\"./src/all-roots-recursive\");\nvar random_1 = _dereq_(\"./src/random\");\nvar error_analysis_1 = _dereq_(\"./src/error-analysis\");\nvar from_roots_1 = _dereq_(\"./src/from-roots\");\nvar multiply = core_operators_1.default.multiply;\n/**\n* Simple & fast practical library functions for functional univariate\n* polynomials over the reals (actually ECMAScript numbers, i.e. double\n* floats).\n*\n* All polinomials are represented as a simple array starting with the\n* highest non-zero power, e.g.\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\n*\n* @ignore\n*/\nvar FloPoly = Object.assign({}, core_operators_1.default, root_operators_1.default, root_bounds_1.default, error_analysis_1.default, { random: random_1.default,\n    fromRoots: from_roots_1.default,\n    allRoots: all_roots_recursive_1.default });\nexports.default = FloPoly;\n\n},{\"./src/all-roots-recursive\":49,\"./src/core-operators\":50,\"./src/error-analysis\":51,\"./src/from-roots\":52,\"./src/random\":53,\"./src/root-bounds\":54,\"./src/root-operators\":55}],49:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar root_operators_1 = _dereq_(\"./root-operators\");\nvar root_bounds_1 = _dereq_(\"./root-bounds\");\nvar _core_operators_1$def = core_operators_1.default,\n    clip0 = _core_operators_1$def.clip0,\n    evaluate = _core_operators_1$def.evaluate,\n    differentiate = _core_operators_1$def.differentiate,\n    toCasStr = _core_operators_1$def.toCasStr;\nvar _root_operators_1$def = root_operators_1.default,\n    brent = _root_operators_1$def.brent,\n    quadraticRoots = _root_operators_1$def.quadraticRoots;\nvar _root_bounds_1$defaul = root_bounds_1.default,\n    rootMagnitudeUpperBound_fujiwara = _root_bounds_1$defaul.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = _root_bounds_1$defaul.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = _root_bounds_1$defaul.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = _root_bounds_1$defaul.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = _root_bounds_1$defaul.negativeRootLowerBound_LMQ;\n\nvar INF = Number.POSITIVE_INFINITY;\n/**\n * <p>Finds a near optimal approximation to the real roots (or those\n * within a range) of the input polynomial.\n * </p>\n * <p>\n * Only multiple roots of even order that is very close together may be\n * missed. (This is rarely a problem in practice - in a geometrical\n * application, for instance, this may mean two objects are barely\n * touching and returning either, all, or none of the repeated even\n * roots should not break the algorithm).\n * </p>\n * @param p - The polynomial\n * @param a - Lower limit of root values that should be returned -\n * defaults to -∞\n * @param b - Upper limit of root values that should be returned -\n * defaults to +∞\n * @example\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\n */\nfunction allRoots(p) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -INF;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +INF;\n\n    p = clip0(p);\n    var d = p.length - 1;\n    var rangeFilter = inRange(a, b);\n    if (d === 2) {\n        return quadraticRoots(p).filter(rangeFilter);\n        // Investigate if any numerically stable algorithm could be as fast\n        // as this algorithm (i.e by finding cubic roots within quadratic\n        // root demarcated intervals via Brent's method. The cubicRoots \n        // algoritm below has been removed since it was numerically \n        // unstable.\n        /*} else if (d === 3) {\n            return cubicRoots(p)\n                .filter(rangeFilter)\n                .sort((a,b) => a-b)\n        } else if (d > 3) {*/\n    } else if (d > 2) {\n        // TODO The root bounding function below might have an impact on \n        // performance - it would probably be better to use \n        // positiveRootUpperBound_LMQ or (possibly) even better, the \n        // linear version of it (see paper of Viglas, Akritas and \n        // Strzebonski) and re-calculate bounds on every iteration.\n        var lowerBound = void 0;\n        var upperBound = void 0;\n        if (a === -INF || b === +INF) {\n            //let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n            //lowerBound = a === -INF ? -magnitudeBound : a;\n            //upperBound = b === +INF ? +magnitudeBound : b;\n            if (a === -INF) {\n                lowerBound = negativeRootLowerBound_LMQ(p);\n            } else {\n                lowerBound = a;\n            }\n            if (b === +INF) {\n                upperBound = positiveRootUpperBound_LMQ(p);\n            } else {\n                upperBound = b;\n            }\n        } else {\n            lowerBound = a;\n            upperBound = b;\n        }\n        // If the roots of the differentiated polynomial is out of range \n        // then the roots of the polynomial itself will also be out of \n        // range.\n        var dp = differentiate(p);\n        var roots = allRoots(dp, lowerBound, upperBound).filter(rangeFilter);\n        if (roots[0] !== lowerBound) {\n            // For code coverage to cover the 'else' case we would need\n            // to find a case where the lower bound actually matches the\n            // root which would be very rare - needs further \n            // investigation.\n            // Not an actual root.\n            roots.unshift(lowerBound);\n        }\n        if (roots[roots.length - 1] !== upperBound) {\n            // Not an actual root.\n            roots.push(upperBound);\n        }\n        return rootsWithin(p, roots);\n    } else if (d === 1) {\n        // Less likely so put near bottom (micro optimization)\n        return [-p[1] / p[0]].filter(rangeFilter);\n    } else if (d === 0) {\n        return []; // y = c -> no roots\t\n    }\n    // Least likely so put at bottom (micro optimization)\n    // d === -1\n    // y = 0 -> infinite number of roots\n    return [];\n}\n/**\n * Returns a function that returns true if x is in the range [a,b].\n * @param a\n * @param b\n * @private\n */\nfunction inRange(a, b) {\n    return function (x) {\n        return x >= a && x <= b;\n    };\n}\n/**\n * Finds all roots of the given polynomial within the given intervals.\n * @private\n * @param p\n * @param intervals\n */\nfunction rootsWithin(p, intervals) {\n    var roots = [];\n    var peval = evaluate(p);\n    var prevRoot = void 0;\n    var a = intervals[0];\n    for (var i = 1; i < intervals.length; i++) {\n        var root = void 0;\n        var b = intervals[i];\n        var evA = peval(a);\n        var evB = peval(b);\n        var k = evA * evB;\n        if (k === 0) {\n            if (evA === 0) {\n                root = a;\n            } else if (evB === 0 && i === intervals.length - 1) {\n                root = b;\n            }\n        } else if (evA * evB < 0) {\n            root = brent(peval, a, b);\n        }\n        // Add root if it exists and suppress exact duplicates\n        if (root !== undefined && root !== prevRoot) {\n            roots.push(root);\n            prevRoot = root;\n        }\n        a = b;\n    }\n    return roots;\n}\nexports.default = allRoots;\n\n},{\"./core-operators\":50,\"./root-bounds\":54,\"./root-operators\":55}],50:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if two polynomials are exactly equal by comparing\n * coefficients.\n * @param p1 - A polynomial\n * @param p2 - Another polynomial\n * @example\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\n */\nfunction equal(p1, p2) {\n    if (p1.length !== p2.length) {\n        return false;\n    }\n    for (var i = 0; i < p1.length; i++) {\n        if (p1[i] !== p2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Adds two polynomials.\n * @param p1 - The first polynomial\n * @param p2 - The second polynomial\n * @example\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\n */\nfunction add(p1, p2) {\n    // Initialize result array  \n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var Δd = d1 - d2;\n    var Δd1 = 0;\n    var Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    } else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    var d = Math.max(d1, d2);\n    // Add coefficients\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        var c1 = p1[i + Δd1];\n        var c2 = p2[i + Δd2];\n        result.push((c1 || 0) + (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Subtracts the second polynomial from first (p1 - p2).\n * @param p1 - The polynomial from which will be subtracted\n * @param p2 - The polynomial that will be subtracted\n * @example\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\n */\nfunction subtract(p1, p2) {\n    // Initialize result array  \n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var Δd = d1 - d2;\n    var Δd1 = 0;\n    var Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    } else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    var d = Math.max(d1, d2);\n    // Add coefficients\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        var c1 = p1[i + Δd1];\n        var c2 = p2[i + Δd2];\n        result.push((c1 || 0) - (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Negate the given polynomial (p -> -p).\n * @param p - The polynomial\n * @example\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\n */\nfunction negate(p) {\n    return multiplyByConst(-1, p);\n}\n/**\n * Differentiates the given polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\n */\nfunction differentiate(p) {\n    var result = [];\n    var d = p.length - 1;\n    for (var i = 0; i < d; i++) {\n        result.push((d - i) * p[i]);\n    }\n    return result;\n}\n/**\n * <p>\n * Multiplies the two given polynomials and returns the result.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\n * </p>\n * <p>\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\n * </p>\n * @param p1 - The one polynomial.\n * @param p2 - The other polynomial.\n * @example\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\n */\nfunction multiply(p1, p2) {\n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var d = d1 + d2;\n    var result = new Array(d + 1).fill(0);\n    for (var i = 0; i < d1 + 1; i++) {\n        for (var j = 0; j < d2 + 1; j++) {\n            result[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n        }\n    }\n    return clip0(result);\n}\n/**\n * Multiplies 2 polynomials by a constant.\n * @param c - The constant\n * @param p - The polynomial\n * @example\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\n */\nfunction multiplyByConst(c, p) {\n    if (c === 0) {\n        return [];\n    }\n    var d = p.length - 1;\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        result.push(c * p[i]);\n    }\n    // We have to clip due to possible floating point underflow\n    return clip0(result);\n}\n/**\n * Returns the degree of the polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\n */\nfunction degree(p) {\n    return p.length - 1;\n}\nfunction evaluate(p, a) {\n    function f(a) {\n        //if p.length === 0 { return 0; }\n        var result = p[0];\n        for (var i = 1; i < p.length; i++) {\n            result = p[i] + result * a;\n        }\n        return result;\n    }\n    // Curry the function\n    return a === undefined ? f : f(a);\n}\n/**\n * Evaluates the given polynomial at 0 - it is much faster than at an\n * arbitrary point.\n * @param p - The polynomial\n * @example\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\n */\nfunction evaluateAt0(p) {\n    return p[p.length - 1];\n}\n;\n/**\n * <p>\n * Returns the number of sign changes in the polynomial coefficents\n * when ordered in descending order; zeros are ignored.\n * </p>\n * <p>\n * Descartes' rule of signs states (quoted from Wikipedia):\n * \"if the terms of a polynomial are ordered by descending variable\n * exponent, then the number of positive roots of the polynomial is\n * either equal to the number of sign differences between consecutive\n * nonzero coefficients, or is less than it by an even number. Multiple\n * roots of the same value are counted separately.\"\n * </p>\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\n * @param p - The polynomial\n * @example\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\n */\nfunction signChanges(p) {\n    var d = p.length - 1;\n    var result = 0;\n    var prevSign = Math.sign(p[0]);\n    for (var i = 1; i < d + 1; i++) {\n        var sign = Math.sign(p[i]);\n        if (sign !== prevSign && sign !== 0) {\n            result++;\n            prevSign = sign;\n        }\n    }\n    return result;\n}\n/**\n * Deflates the given polynomial by removing a factor (x - r), where\n * r is a root of the polynomial.\n * @param p - The polynomial\n * @param root - A pre-calculated root of the polynomial.\n * @example\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1]\n * FloPoly.deflate([1, -1], 1);        //=> [1]\n */\nfunction deflate(p, root) {\n    var d = p.length - 1;\n    var bs = [p[0]];\n    for (var i = 1; i < d; i++) {\n        bs.push(p[i] + root * bs[i - 1]);\n    }\n    return bs;\n}\n/**\n * Inverts the given polynomial by reversing the order of the\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\n * @param p - The polynomial\n * @example\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\n */\nfunction invert(p) {\n    return p.slice().reverse();\n}\n/**\n * <p>\n * Performs a change of variables of the form: p(x) <- p(ax + b).\n * </p>\n * <p>\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\n * </p>\n * @param p - The polynomial\n * @param a\n * @param b\n * @example\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\n */\nfunction changeVariables(p, a, b) {\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \n    // code below. \n    // d_i is calculated as d = T*c, where c are the original \n    // coefficients.\n    var d = p.length - 1;\n    // Initialize a zero matrix\n    var t = [];\n    for (var i = 0; i < d + 1; i++) {\n        t.push(new Array(d + 1).fill(0));\n    }\n    // Calculate the triangular matrix T\n    t[0][0] = 1;\n    for (var j = 1; j <= d; j++) {\n        t[0][j] = b * t[0][j - 1];\n        for (var _i = 1; _i <= j; _i++) {\n            t[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n        }\n    }\n    // Multiply\n    var res = new Array(d + 1).fill(0);\n    for (var _i2 = 0; _i2 <= d; _i2++) {\n        res[d - _i2] = 0;\n        for (var _j = _i2; _j <= d; _j++) {\n            var acc = t[_i2][_j] * p[d - _j];\n            res[d - _i2] += acc;\n        }\n    }\n    return res;\n}\n/**\n * Reflects the given polynomial about the Y-axis, i.e. perform the\n * change of variables: p(x) <- p(-x).\n * @param p - The polynomial to reflect\n * @example\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\n */\nfunction reflectAboutYAxis(p) {\n    var d = p.length - 1;\n    var result = p.slice();\n    for (var i = 0; i < d + 1; i++) {\n        if (i % 2) {\n            result[i] = -result[i];\n        }\n    }\n    return result;\n}\n/**\n * Generates a sturm chain for the given polynomial.\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n * @param p - The polynomial\n * @example\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\n */\nfunction sturmChain(p) {\n    /**\n     * Returns the negative of the remainder when dividing the first\n     * polynomial (the dividend) by the second (the divisor) provided\n     * that deg(p1) - deg(p2) === 1.\n     * @private\n     * @param p1 - The first polynomial (dividend)\n     * @param p2 - The second polynomial (divisor)\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n     */\n    function negRemainder(p1, p2) {\n        var d1 = p1.length - 1;\n        var d2 = p2.length - 1;\n        var d = d1 - d2;\n        var a = p1[1] / p1[0] - p2[1] / p2[0];\n        var b = p1[0] / p2[0];\n        var p3 = multiply(multiplyByConst(b, p2), [1, a]);\n        return subtract(p3, p1);\n    }\n    var m = []; // Sturm chain\n    m.push(p);\n    m.push(differentiate(p));\n    //const δ = 10 * Number.EPSILON;\n    var i = 1;\n    while (m[i].length - 1 > 0) {\n        var pnext = negRemainder(m[i - 1], m[i]);\n        //pnext = clip(pnext, δ);\n        // If the polynomial degree was not reduced due to roundoff\n        // such that the first 1 or more terms are very small.\n        while (m[i].length - pnext.length < 1) {\n            pnext.shift();\n        }\n        /*\n        if (pnext.length === 0) {\n            break;\n        }\n        */\n        m.push(pnext);\n        i++;\n    }\n    return m;\n}\n/**\n * If the highest power coefficient is small in the sense that the\n * highest power term has a negligible contribution (compared to the\n * other terms) at x = 1 then clip() can be called to remove all such\n * highest terms. A contribution of less than Number.EPSILON of the\n * highest coefficient will be considered negligible by default.\n * @param p - The polynomial to be clipped.\n * @param δ - The optional contribution tolerence else\n *        Number.EPSILON will be used by default.\n * @example\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip(p, δ) {\n    δ = δ === undefined ? Number.EPSILON : δ;\n    var c = maxCoefficient(p);\n    if (c === 0) {\n        return [];\n    }\n    if (Math.abs(p[0]) > δ * c) {\n        return p;\n    }\n    var p_ = p.slice(1);\n    while (Math.abs(p_[0]) < δ * c) {\n        p_ = p_.slice(1);\n    }\n    return clip(p_, δ);\n}\n/**\n * If the highest power coefficient is 0 then clip() can be called to\n * remove all such highest terms so that the array is a valid\n * presentation of a polynomial.\n * @param p - The polynomial to be clipped.\n * @example\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip0(p) {\n    return p[0] !== 0 ? p : clip0(p.slice(1));\n}\n/**\n * Returns the absolute value of the highest coefficient of the polynomial.\n * @param p - The polynomial.\n * @example\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\n */\nfunction maxCoefficient(p) {\n    var max = 0;\n    for (var i = 0; i < p.length; i++) {\n        var c = Math.abs(p[i]);\n        if (c > max) {\n            max = c;\n        }\n    }\n    return max;\n}\n/**\n * Returns a string representing the given polynomial that is readable\n * by a human or a CAS (Computer Algebra System).\n * @param p - The polynomial\n * @example\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\n */\nfunction toCasStr(p) {\n    var d = p.length - 1;\n    var str = '';\n    for (var i = 0; i < d + 1; i++) {\n        var cStr = p[i].toString();\n        if (i === d) {\n            str += cStr;\n        } else if (i === d - 1) {\n            str += 'x*' + cStr + ' + ';\n        } else {\n            str += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n        }\n    }\n    return str;\n}\nvar coreOperators = {\n    equal: equal,\n    add: add,\n    subtract: subtract,\n    multiplyByConst: multiplyByConst,\n    negate: negate,\n    differentiate: differentiate,\n    multiply: multiply,\n    degree: degree,\n    evaluate: evaluate,\n    evaluateAt0: evaluateAt0,\n    signChanges: signChanges,\n    invert: invert,\n    changeVariables: changeVariables,\n    reflectAboutYAxis: reflectAboutYAxis,\n    sturmChain: sturmChain,\n    clip: clip,\n    clip0: clip0,\n    deflate: deflate,\n    maxCoefficient: maxCoefficient,\n    toCasStr: toCasStr\n};\nexports.default = coreOperators;\n\n},{}],51:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar evaluate = core_operators_1.default.evaluate;\n/**\n * <p>\n * Approximate condition number for polynomial evaluation multiplied by the\n * exact value of the polynomial evaluation.\n * </p>\n * <p>\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\n * </p>\n * @ignore\n * @param p - The polynomial\n * @param x - The evaluation point\n */\n\nfunction conditionNumber(p, x) {\n    var d = p.length - 1;\n    var res = 0;\n    for (var i = 0; i < d; i++) {\n        res += Math.abs(p[i] * Math.pow(x, d - i));\n    }\n    return res;\n}\n/**\n * <p>\n * Classic rule of thumb approximate error bound when using Horner's\n * method to evaluate polynomials.\n * </p>\n * <p>\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\n * </p>\n * @param p - The polynomial\n * @param x - Value at which polynomial is evaluated.\n  * @example\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15\n */\nfunction hornerErrorBound(p, x) {\n    var δ = Number.EPSILON;\n    var d = p.length - 1;\n    return 2 * d * δ * conditionNumber(p, x);\n}\nvar errorAnalysis = {\n    hornerErrorBound: hornerErrorBound\n};\nexports.default = errorAnalysis;\n\n},{\"./core-operators\":50}],52:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar multiply = core_operators_1.default.multiply;\n/**\n * <p>\n * Constructs a polynomial from the given roots by multiplying out the\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\n * will not have any complex roots.\n * </p>\n * <p>\n * Mostly provided for testing purposes. Note that the real roots of the\n * constructed polynomial may not be exactly the same as the roots that\n * the polynomial has been constructed from due to floating-point\n * round-off.\n * </p>\n *\n * @param roots - The roots\n * @example\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\n */\n\nfunction fromRoots(roots) {\n    var p = [1];\n    for (var i = 0; i < roots.length; i++) {\n        p = multiply(p, [1, -roots[i]]);\n    }\n    return p;\n}\nexports.default = fromRoots;\n\n},{\"./core-operators\":50}],53:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar from_roots_1 = _dereq_(\"./from-roots\");\n/**\n * Some seed value for the simple random number generator.\n * @ignore\n */\nvar SEED = 123456789;\n/**\n * The range for the simple random number generator, i.e. the generated\n * numbers will be in [0,RANGE].\n * @ignore\n */\nvar RANGE = 4294967296;\n/**\n * Creates a function from the given function with parameters similar\n * to flatRoots but with an extra parameter in the beginning indicating\n * the length of the array generated by the original function.\n * @private\n * @param {function} f\n * @returns {function}\n */\nfunction createArrFunction(f) {\n    return function (n, d, a, b) {\n        var seed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : SEED;\n        var odds = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n        var res = [];\n        for (var i = 0; i < n; i++) {\n            var v = f(d, a, b, seed, odds);\n            var p = v.p;\n            seed = v.seed;\n            res.push(p);\n        }\n        return res;\n    };\n}\n/**\n * Generates an array of random polynomials with parameters as specified\n * by flatRoots. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n/**\n * Generates an array of random polynomials as specified by\n * flatCoefficients. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n *\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @returns {number[][]} The array of random polynomials.\n * @example\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n/**\n * Returns a quasi-random number to be used as the next input to this function.\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\n * @private\n * @param seed\n */\nfunction predictiveRandom(seed) {\n    var a = 134775813;\n    return (a * seed + 1) % RANGE;\n}\n/**\n * Generates a random array of numbers picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values.\n *\n * @ignore\n * @param n - The number of values to generate.\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n */\nfunction randomArray(n, a, b) {\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n    var odds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    var vs = [];\n    for (var i = 0; i < n; i++) {\n        seed = predictiveRandom(seed);\n        var v = seed / RANGE * (b - a) + a;\n        seed = push(seed, vs, v, odds);\n    }\n    vs = vs.slice(0, n);\n    return { vs: vs, seed: seed };\n}\n/**\n * Helper function that will add more numbers to the passed array - modifies the\n * values parameter.\n * @private\n * @param seed\n * @param values - An existing array of values - will be modified!\n * @param x - The number that will be added (possibly multiple times)\n * @param odds - The odds that the number will be added again (recursively).\n */\nfunction push(seed, values, x, odds) {\n    seed = predictiveRandom(seed);\n    values.push(x);\n    if (seed / RANGE < odds) {\n        seed = push(seed, values, x, odds);\n    }\n    return seed;\n}\n/**\n * Generates a random polynomial with roots picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values. Note that the resulting polynomial\n * won't have any complex roots.\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\n */\nfunction flatRoots(d) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n    var odds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    var randArr = randomArray(d, a, b, seed, odds);\n    seed = randArr.seed;\n    var p = from_roots_1.default(randArr.vs);\n    return { p: p, seed: seed };\n}\n/**\n * Generates a random polynomial with coefficients picked from a bounded\n * flat distribution (i.e. a rectangular distribution).\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults to -1\n * @param b - The upper bound of the distribution - defaults to 1\n * @param seed - A seed value for generating random values (so that the results\n * are reproducable)\n * @example\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\n */\nfunction flatCoefficients(d) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +1;\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n\n    a = a === undefined ? -1 : a;\n    b = b === undefined ? +1 : b;\n    seed = seed === undefined ? SEED : seed;\n    var randArr = randomArray(d, a, b, seed);\n    seed = randArr.seed;\n    var p = randArr.vs;\n    return { p: p, seed: seed };\n}\nvar random = {\n    flatRoots: flatRoots,\n    flatRootsArr: flatRootsArr,\n    flatCoefficients: flatCoefficients,\n    flatCoefficientsArr: flatCoefficientsArr\n};\nexports.default = random;\n\n},{\"./from-roots\":52}],54:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar _core_operators_1$def = core_operators_1.default,\n    invert = _core_operators_1$def.invert,\n    negate = _core_operators_1$def.negate,\n    reflectAboutYAxis = _core_operators_1$def.reflectAboutYAxis;\n/**\n * Returns the maximum magnitude value within the supplied array of numbers.\n * @private\n */\n\nfunction maxAbs(ns) {\n    return Math.max.apply(Math, _toConsumableArray(ns.map(function (n) {\n        return Math.abs(n);\n    })));\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * (including complex roots) of the given polynomial using Rouche's\n * Theorem with k = n. This function is fast but the bound is not tight.\n * @param p - The polynomial.\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n    var d = p.length - 1;\n    var R = 1 + 1 / p[0] * maxAbs(p.slice(1));\n    return R;\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * of the given polynomial using the near-optimal Fujiwara bound. Note\n * that the bound includes complex roots. The bound is tight but slow\n * due to usage of Math.pow().\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\n * @param p - The polynomial.\n * @example\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n    var d = p.length - 1;\n    var an = p[0];\n    var bs = [];\n    for (var i = 1; i < d; i++) {\n        var b = Math.pow(Math.abs(p[i] / an), 1 / i);\n        bs.push(b);\n    }\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n    return 2 * Math.max.apply(undefined, bs);\n}\nvar POWERS = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152];\n/**\n * <p>\n * Returns an upper bound for the positive real roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootUpperBound_LMQ(p) {\n    var deg = p.length - 1;\n    if (deg < 1) {\n        return 0;\n    }\n    if (p[0] < 0) {\n        p = negate(p);\n    }\n    var timesUsed = [];\n    for (var i = 0; i < deg; i++) {\n        timesUsed.push(1);\n    }\n    var ub = 0;\n    for (var m = 0; m <= deg; m++) {\n        if (p[m] >= 0) continue;\n        var tempub = Number.POSITIVE_INFINITY;\n        var any = false;\n        for (var k = 0; k < m; k++) {\n            if (p[k] <= 0) {\n                continue;\n            }\n            // Table lookup is about 70% faster but both are\n            // extemely fast anyway. \n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n            var pow = timesUsed[k];\n            var powres = void 0;\n            if (pow > 20) {\n                powres = Math.pow(2, pow);\n            } else {\n                powres = POWERS[pow];\n            }\n            var temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n            timesUsed[k]++;\n            if (tempub > temp) {\n                tempub = temp;\n            }\n            any = true;\n        }\n        if (any && ub < tempub) ub = tempub;\n    }\n    return ub;\n}\n/**\n * <p>\n * Calculates a lower bound for the positive roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootLowerBound_LMQ(p) {\n    var ub = positiveRootUpperBound_LMQ(invert(p));\n    if (ub === 0) {\n        return 0;\n    }\n    return 1 / ub;\n}\n/**\n * See positiveRootUpperBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} An upper bound.\n */\nfunction negativeRootUpperBound_LMQ(p) {\n    return -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n/**\n * See positiveRootLowerBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} A lower bound.\n */\nfunction negativeRootLowerBound_LMQ(p) {\n    return -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\nvar rootBounds = {\n    rootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,\n    rootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche\n};\nexports.default = rootBounds;\n\n},{\"./core-operators\":50}],55:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar _core_operators_1$def = core_operators_1.default,\n    sturmChain = _core_operators_1$def.sturmChain,\n    evaluate = _core_operators_1$def.evaluate,\n    signChanges = _core_operators_1$def.signChanges;\n/**\n * <p>\n * Floating-point-stably calculates and returns the ordered quadratic\n * roots of the given quadratic polynomial.\n * </p>\n * <p>\n * This function is included only because it might be slightly faster\n * than calling allRoots due to allRoots first checking if the\n * polynomial is quadratic and checking if the roots are within the\n * given range.\n * </p>\n * @param p - The 2nd order polynomial\n * @example\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\n */\n\nfunction quadraticRoots(p) {\n    var _p = _slicedToArray(p, 3),\n        a = _p[0],\n        b = _p[1],\n        c = _p[2];\n\n    var delta = b * b - 4 * a * c;\n    if (delta < 0) {\n        // No real roots;\n        return [];\n    }\n    if (delta === 0) {\n        return [-b / (2 * a)];\n    }\n    delta = Math.sqrt(delta);\n    var root1 = void 0;\n    var root2 = void 0;\n    if (b >= 0) {\n        root1 = (-b - delta) / (2 * a);\n        root2 = 2 * c / (-b - delta);\n    } else {\n        root1 = 2 * c / (-b + delta);\n        root2 = (-b + delta) / (2 * a);\n    }\n    if (root1 < root2) {\n        return [root1, root2];\n    }\n    return [root2, root1];\n}\n/**\n * Calculates the roots of the given cubic polynomial.\n *\n * This code is mostly from the Pomax guide found at\n * https://pomax.github.io/bezierinfo/#extremities\n *\n * @param p - A cubic polynomial.\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\nfunction cubicRoots(p) {\n\r\n    function cuberoot(v) {\n        return v < 0\n            ? -Math.pow(-v, 1/3)\n            : +Math.pow(v, 1/3);\n    }\n    \r\n    let cbrt = Math.cbrt || cuberoot;\n    \r\n    let d = p[0];\n    let a = p[1] / d;\n    let b = p[2] / d;\n    let c = p[3] / d;\n    \r\n    let s  = (3*b - a*a) / 9;\n    let q  = (2*a*a*a - 9*a*b + 27*c) / 54;\n    \r\n    let s3 = s*s*s;\n    let q2 = q*q;\n    \r\n    let discriminant = q2 + s3;\n\r\n    if (!Number.isFinite(discriminant)) {\n        \r\n        // Overflow occured - in which case one root will be very large.\n        // We might want to report such large roots as positive or\n        // negative infinity but since they are rarely of interest we\n        // report only the smaller roots.\n        \r\n        // Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\n        // and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\n        \r\n        return quadraticRoots(p.slice(1));\n    }\n    \r\n    if (discriminant < 0) {\n        // three real roots\n        \r\n        let r = Math.sqrt(-s3);\n        let t = -q / r;\n        \r\n        let cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\n        let phi    = Math.acos(cosphi);\n        let\tt1     = 2*cbrt(r);\n        \r\n        let ao3 = a/3;\n        \r\n        return [\n            t1*Math.cos((phi            )/3) - ao3,\n            t1*Math.cos((phi + 2*Math.PI)/3) - ao3,\n            t1*Math.cos((phi + 4*Math.PI)/3) - ao3\n        ]\n    } else if (discriminant === 0) {\n        // three real roots, but two of them are equal\n        \r\n        let u1 = q < 0 ? cbrt(-q) : -cbrt(q);\n        let ao3 = a/3;\n        \r\n        return [\n            2*u1 - ao3,\n            -u1 - ao3\n        ];\n    } else {\n        // one real root, two complex roots\n        \r\n        let sd = Math.sqrt(discriminant);\n        let u1 = cbrt(sd - q);\n        let v1 = cbrt(sd + q);\n        \r\n        return [u1 - v1 - a/3];\n    }\n}\n*/\n/**\n * Returns the number of real roots in the interval (a,b) of the given\n * polynomial.\n * @param p - The polynomial\n * @param a - The lower bound\n * @param b - The upper bound\n * @example\n * let p = [1, 1, -64, 236, -240];\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\n */\nfunction numRootsWithin(p, a, b) {\n    var ps = sturmChain(p);\n    var ev = evaluate(p);\n    var as = ps.map(function (p) {\n        return evaluate(p)(a);\n    });\n    var bs = ps.map(function (p) {\n        return evaluate(p)(b);\n    });\n    return signChanges(as) - signChanges(bs);\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Bisection\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Note: This function has no advantages above the Brent method except\n * for its simpler implementation and can be much slower. Use brent\n * instead.\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.bisection(f,2.2,3.8); //=> 3\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\n */\nfunction bisection(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    } else if (b < a) {\n        // Swap a and b \n        var _ref = [b, a];\n        a = _ref[0];\n        b = _ref[1];\n    }\n    var fa = f(a);\n    var fb = f(b);\n    if (fa === 0) {\n        return a;\n    }\n    if (fb === 0) {\n        return b;\n    }\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    while (true) {\n        var c = a + (b - a) / 2; // Take midpoint\n        var fc = f(c);\n        if (fc === 0) {\n            return c;\n        }\n        if (fa * fc < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n        // We don't add Number.EPSILON in the line below because we want\n        // accuracy to improve even below 1.\n        var δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n    }\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Brent's\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Brent's Method is an excellent root-finding choice since it is\n * (1) guaranteed to converge (unlike the Newton and other so-called\n * single-point methods), (2) converges in a reasonable number of\n * iterations even for highly contrived functions (unlike Dekker's\n * Method) and (3) nearly always converges extremely fast, i.e. super-\n * linearly (unlike the Secant and Regula-Falsi methods).\n * </p>\n * <p>\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\n * after each iteration where b is the max of the current 2 best\n * guesses.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\n * </p>\n * <p>\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * about 1e-15 multiplied by the root magnitued).\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\n */\nfunction brent(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n    var fa = f(a);\n    var fb = f(b);\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    var c = void 0; // Value of previous guess - set to a initially \n    if (Math.abs(fa) < Math.abs(fb)) {\n        // Swap a,b\n        c = a;\n        a = b;\n        b = c;\n        // Swap fa,fb\n        var temp = fa;\n        fa = fb;\n        fb = temp;\n    }\n    c = a;\n    var mflag = true;\n    var d = void 0; // Value of guess before previous guess\n    while (true) {\n        var δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n        var fc = f(c);\n        // Calculate provisional interpolation value\n        var s = void 0;\n        if (fa !== fc && fb !== fc) {\n            // 3 points available - inverse quadratic interpolation\n            var fac = fa - fc;\n            var fab = fa - fb;\n            var fbc = fb - fc;\n            // The below has been multiplied out to speed up the algorithm.\n            /*s = ((a * fb * fc) / ( fab * fac)) +\n                  ((b * fa * fc) / (-fab * fbc)) +\n                  ((c * fa * fb) / ( fac * fbc));*/\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n        } else {\n            // only 2 points available - secant method\n            s = b - fb * ((b - a) / (fb - fa));\n        }\n        var t1 = (3 * a + b) / 4;\n        var b_c = Math.abs(b - c);\n        var s_b = Math.abs(s - b);\n        var c_d = Math.abs(c - d);\n        if (!(s > t1 && s < b || s < t1 && s > b) || mflag && (\n        // condition 2\n        s_b >= b_c / 2 ||\n        // condition 4\n        b_c < δ) || !mflag && (\n        // condition 3\n        s_b >= c_d / 2 ||\n        // condition 5\n        c_d < δ)) {\n            // Bisection\n            s = (a + b) / 2;\n            mflag = true;\n        } else {\n            mflag = false;\n        }\n        var fs = f(s);\n        d = c;\n        c = b;\n        if (fa * fs < 0) {\n            b = s;\n        } else {\n            a = s;\n        }\n        if (Math.abs(fa) < Math.abs(fb)) {\n            // Swap a,b\n            var _temp = a;\n            a = b;\n            b = _temp;\n        }\n        if (fb === 0) {\n            return b;\n        }\n        if (fs === 0) {\n            return s;\n        }\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n        fa = f(a);\n        fb = f(b);\n    }\n}\nvar rootOperators = {\n    quadraticRoots: quadraticRoots,\n    numRootsWithin: numRootsWithin,\n    brent: brent,\n    bisection: bisection\n};\nexports.default = rootOperators;\n\n},{\"./core-operators\":50}],56:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DELTA = 1e-10;\n/**\n * Curry the given arity two function.\n * @param f - A function\n */\nfunction curry2(f) {\n    function g(t, u) {\n        return u === undefined ? function (u) {\n            return f(t, u);\n        } : f(t, u);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity two function.\n* @private\n*/\nfunction mapCurry2(f) {\n    function g(t, us) {\n        var h = f(t);\n        var hUs = function hUs(us) {\n            return us.map(h);\n        };\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity 3 curried function (keeping the first two parameters uncurried).\n* @private\n*/\nfunction specialMapCurry(f) {\n    function g(s, t, us) {\n        var h = f(s, t);\n        var hUs = function hUs(us) {\n            return us.map(h);\n        };\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n\nvar Vector2d = function () {\n    function Vector2d() {\n        _classCallCheck(this, Vector2d);\n    }\n\n    _createClass(Vector2d, null, [{\n        key: \"dot\",\n\n        /**\n         * Returns the dot (inner) product between two 2-vectors.\n         * @param a - The first vector\n         * @param b - The second vector\n         */\n        value: function dot(a, b) {\n            return a[0] * b[0] + a[1] * b[1];\n        }\n        /**\n         * Returns the cross product signed magnitude between two 2-vectors.\n         * @param a - The first vector\n         * @param b - The second vector\n         */\n\n    }, {\n        key: \"cross\",\n        value: function cross(a, b) {\n            return a[0] * b[1] - a[1] * b[0];\n        }\n        /**\n         * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\n         * ccw < 0, and colinear if ccw = 0 because ccw is a determinant that gives\n         * twice the signed area of the triangle formed by p1, p2 and p3.\n         * @param p1 - The first point\n         * @param p2 - The second point\n         * @param p3 - The third point\n         * @param delta - The tolerance at which the three points are considered\n         * collinear - defaults to 1e-10.\n         */\n\n    }, {\n        key: \"ccw\",\n        value: function ccw(p1, p2, p3) {\n            var delta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DELTA;\n\n            var res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n            return Math.abs(res) <= delta ? 0 : res;\n        }\n        /**\n        * <p>\n        * Returns the point where two line segments intersect or undefined if they\n        * don't intersect or a line if they intersect at infinitely many points.\n        * </p>\n        * <p>\n        * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\n        * </p>\n        * @param ab - The first line\n        * @param cd - The second line\n        * @param delta - The tolerance at which the lines are considered parallel -\n        * defaults to 1e-10.\n        */\n\n    }, {\n        key: \"segSegIntersection\",\n        value: function segSegIntersection(ab, cd) {\n            var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DELTA;\n\n            var _ab = _slicedToArray(ab, 2),\n                a = _ab[0],\n                b = _ab[1];\n\n            var _cd = _slicedToArray(cd, 2),\n                c = _cd[0],\n                d = _cd[1];\n\n            var denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n            var rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n            var sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n            if (Math.abs(denom) <= delta) {\n                // parallel\n                if (Math.abs(rNumer) <= delta) {\n                    // colinear\n                    // TODO Check if x-projections and y-projections intersect\n                    // and return the line of intersection if they do.\n                    return undefined;\n                }\n                return undefined;\n            }\n            var r = rNumer / denom;\n            var s = sNumer / denom;\n            if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n                return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n            }\n            return undefined;\n        }\n        /**\n        * Returns true if the two given 2d line segments intersect, false otherwise.\n        * @param a - A line segment\n        * @param b - Another line segment\n        */\n\n    }, {\n        key: \"doesSegSegIntersect\",\n        value: function doesSegSegIntersect(a, b) {\n            var ccw = Vector2d.ccw;\n            if (ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) > 0) {\n                return false;\n            } else if (ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) > 0) {\n                return false;\n            }\n            return true;\n        }\n        /**\n        * Returns the squared distance between two 2d points.\n        * @param p1 - A point\n        * @param p2 - Another point\n        */\n\n    }, {\n        key: \"squaredDistanceBetween\",\n        value: function squaredDistanceBetween(p1, p2) {\n            var x = p2[0] - p1[0];\n            var y = p2[1] - p1[1];\n            return x * x + y * y;\n        }\n        /**\n        * Returns a scaled version of the given 2-vector.\n        * @param p - A vector\n        * @param factor - A scale factor\n        */\n\n    }, {\n        key: \"scale\",\n        value: function scale(p, factor) {\n            return [p[0] * factor, p[1] * factor];\n        }\n        /**\n        * Returns the given 2-vector reversed.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"reverse\",\n        value: function reverse(p) {\n            return [-p[0], -p[1]];\n        }\n        /**\n        * Returns the given 2-vector scaled to a length of one.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"toUnitVector\",\n        value: function toUnitVector(p) {\n            var scaleFactor = 1 / Vector2d.len(p);\n            return [p[0] * scaleFactor, p[1] * scaleFactor];\n        }\n        /**\n        * Returns the given 2-vector scaled to the given length.\n        * @param p - A vector\n        * @param length - The length to scale to\n        */\n\n    }, {\n        key: \"toLength\",\n        value: function toLength(p, len) {\n            var scaleFactor = len / Vector2d.len(p);\n            return [p[0] * scaleFactor, p[1] * scaleFactor];\n        }\n        /**\n        * Returns the second 2-vector minus the first.\n        * @param p1 - The first vector\n        * @param p2 - The second vector\n        */\n\n    }, {\n        key: \"fromTo\",\n        value: function fromTo(p1, p2) {\n            return [p2[0] - p1[0], p2[1] - p1[1]];\n        }\n        /**\n        * Performs linear interpolation between two 2d points and returns the resultant point.\n        * @param p1 - The first point.\n        * @param p2 - The second point.\n        * @param t - The interpolation fraction (often in [0,1]).\n        */\n\n    }, {\n        key: \"interpolate\",\n        value: function interpolate(p1, p2, t) {\n            return [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];\n        }\n        /**\n        * Returns the mean of two 2d points.\n        * @param ps - The two points\n        */\n\n    }, {\n        key: \"mean\",\n        value: function mean(ps) {\n            var p1 = ps[0];\n            var p2 = ps[1];\n            return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n        }\n        /**\n        * Returns the distance between two 2d points.\n        * @param p1 - A point.\n        * @param p2 - Another point.\n        */\n\n    }, {\n        key: \"distanceBetween\",\n        value: function distanceBetween(p1, p2) {\n            return Math.sqrt(Vector2d.squaredDistanceBetween(p1, p2));\n        }\n        /**\n        * Returns the length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"len\",\n        value: function len(p) {\n            return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        }\n        /**\n        * Returns the squared length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"lengthSquared\",\n        value: function lengthSquared(v) {\n            return v[0] * v[0] + v[1] * v[1];\n        }\n        /**\n        * Returns the Manhattan distance between two 2d points.\n        * @param p1 - A point.\n        * @param p2 - Another point.\n        */\n\n    }, {\n        key: \"manhattanDistanceBetween\",\n        value: function manhattanDistanceBetween(p1, p2) {\n            return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n        }\n        /**\n        * Returns the Manhattan length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"manhattanLength\",\n        value: function manhattanLength(p) {\n            return Math.abs(p[0]) + Math.abs(p[1]);\n        }\n        /**\n        * <p>\n        * Returns the distance between the given point and line.\n        * </p>\n        * <p>\n        * See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\n        * this Wikipedia article</a>\n        * </p>\n        * @param p - A point\n        * @param l - A line\n        */\n\n    }, {\n        key: \"distanceBetweenPointAndLine\",\n        value: function distanceBetweenPointAndLine(p, l) {\n            var _p = _slicedToArray(p, 2),\n                x0 = _p[0],\n                y0 = _p[1];\n\n            var _l = _slicedToArray(l, 2),\n                _l$ = _slicedToArray(_l[0], 2),\n                x1 = _l$[0],\n                y1 = _l$[1],\n                _l$2 = _slicedToArray(_l[1], 2),\n                x2 = _l$2[0],\n                y2 = _l$2[1];\n\n            var y = y2 - y1;\n            var x = x2 - x1;\n            var a = y * x0 - x * y0 + x2 * y1 - y2 * x1;\n            var b = Math.sqrt(x * x + y * y);\n            return Math.abs(a / b);\n        }\n        /**\n        * Returns the squared distance between the given point and line segment.\n        * @param p - A point\n        * @param l - A line\n        */\n\n    }, {\n        key: \"squaredDistanceBetweenPointAndLineSegment\",\n        value: function squaredDistanceBetweenPointAndLineSegment(p, l) {\n            var sqDst = Vector2d.squaredDistanceBetween;\n            var v = l[0];\n            var w = l[1];\n            var l2 = sqDst(v, w);\n            if (l2 == 0) {\n                return sqDst(p, v);\n            }\n            var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n            t = Math.max(0, Math.min(1, t));\n            var d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n            return d2;\n        }\n        /**\n        * Returns the circumcenter of the given 2d triangle.\n        * @param triangle\n        */\n\n    }, {\n        key: \"circumCenter\",\n        value: function circumCenter(triangle) {\n            // See wikipedia\n            var p1 = triangle[0];\n            var p2 = triangle[1];\n            var p3 = triangle[2];\n            var sqLen = Vector2d.lengthSquared;\n            var Sx = 0.5 * Vector2d.det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\n            var Sy = 0.5 * Vector2d.det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\n            var a = Vector2d.det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n            var b = Vector2d.det3([p1[0], p1[1], sqLen(p1)], [p2[0], p2[1], sqLen(p2)], [p3[0], p3[1], sqLen(p3)]);\n            return [Sx / a, Sy / a];\n        }\n        /**\n        * <p>\n        * Returns the incenter of the given triangle.\n        * </p>\n        * <p>\n        * See Wikipedia - https://en.wikipedia.org/wiki/Incenter\n        * </p>\n        * @param triangle\n        */\n\n    }, {\n        key: \"inCenter\",\n        value: function inCenter(triangle) {\n            var dst = Vector2d.distanceBetween;\n            var p1 = triangle[0];\n            var p2 = triangle[1];\n            var p3 = triangle[2];\n            var l1 = dst(p2, p3);\n            var l2 = dst(p1, p3);\n            var l3 = dst(p1, p2);\n            var lengthSum = l1 + l2 + l3;\n            return [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n        }\n        /**\n        * Returns the centroid of the given polygon, e.g. triangle. The polygon\n        * must be simple, i.e. not self-intersecting.\n        * @param polygon\n        */\n\n    }, {\n        key: \"centroid\",\n        value: function centroid(polygon) {\n            if (polygon.length === 3) {\n                var p1 = polygon[0];\n                var p2 = polygon[1];\n                var p3 = polygon[2];\n                var x = p1[0] + p2[0] + p3[0];\n                var y = p1[1] + p2[1] + p3[1];\n                return [x / 3, y / 3];\n            }\n            // polygon.length assumed > 3 and assumed to be non-self-intersecting\n            // See wikipedia\n            // First calculate the area, A, of the polygon\n            var A = 0;\n            for (var i = 0; i < polygon.length; i++) {\n                var p0 = polygon[i];\n                var _p2 = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n                A = A + (p0[0] * _p2[1] - _p2[0] * p0[1]);\n            }\n            A = A / 2;\n            var C = [0, 0];\n            for (var _i = 0; _i < polygon.length; _i++) {\n                var _p3 = polygon[_i];\n                var _p4 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n                C[0] = C[0] + (_p3[0] + _p4[0]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n                C[1] = C[1] + (_p3[1] + _p4[1]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n            }\n            return [C[0] / (6 * A), C[1] / (6 * A)];\n        }\n        /**\n        * Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\n        * @ignore\n        * @param x - A 2d vector\n        * @param y - Another 2d vector\n        * @param z - Another 2d vector\n        */\n\n    }, {\n        key: \"det3\",\n        value: function det3(x, y, z) {\n            return x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(a, b) {\n            function f(b) {\n                return [a[0] + b[0], a[1] + b[1]];\n            }\n            // Curry the function\n            return b === undefined ? f : f(b);\n        }\n    }, {\n        key: \"rotate\",\n        value: function rotate(sinθ, cosθ, p) {\n            var a = Vector2d.translatePs([1, 2]);\n            function rotateByθ(p) {\n                return [p[0] * cosθ - p[1] * sinθ, p[0] * sinθ + p[1] * cosθ];\n            }\n            // Curry the function\n            return p === undefined ? rotateByθ : rotateByθ(p);\n        }\n        /**\n        * Returns true if two 2-vectors are identical (by value), false otherwise.\n        * @param a - A 2d vector\n        * @param b - Another 2d vector\n        */\n\n    }, {\n        key: \"equal\",\n        value: function equal(a, b) {\n            return a[0] === b[0] && a[1] === b[1];\n        }\n        /**\n        * Returns a anti-clockwise rotated version of the given 2-vector given the\n        * sine and cosine of the angle.\n        * @param p - A 2d vector\n        * @param sinθ\n        * @param cosθ\n        */\n\n    }, {\n        key: \"reverseRotate\",\n        value: function reverseRotate(sinθ, cosθ, p) {\n            return [+p[0] * cosθ + p[1] * sinθ, -p[0] * sinθ + p[1] * cosθ];\n        }\n        /**\n        * Returns a 90 degrees rotated version of the given 2-vector.\n        * @param p - A 2d vector\n        */\n\n    }, {\n        key: \"rotate90Degrees\",\n        value: function rotate90Degrees(p) {\n            return [-p[1], p[0]];\n        }\n        /**\n        * Returns a negative 90 degrees rotated version of the given 2-vector.\n        * @param p - A 2d vector\n        */\n\n    }, {\n        key: \"rotateNeg90Degrees\",\n        value: function rotateNeg90Degrees(p) {\n            return [p[1], -p[0]];\n        }\n        /**\n        * Transforms the given 2-vector by applying the given function to each\n        * coordinate.\n        * @param p - A 2d vector\n        * @param f - A transformation function\n        */\n\n    }, {\n        key: \"transform\",\n        value: function transform(p, f) {\n            return [f(p[0]), f(p[1])];\n        }\n        /**\n        * Returns the closest point to the array of 2d points, optionally providing\n        * a distance function.\n        * @param p\n        * @param ps\n        * @param f - Optional distance function - defaults to\n        * Vector2d.squaredDistanceBetween\n        */\n\n    }, {\n        key: \"getClosestTo\",\n        value: function getClosestTo(p, ps) {\n            var cp = undefined; // Closest Point\n            var bestd = Number.POSITIVE_INFINITY;\n            for (var i = 0; i < ps.length; i++) {\n                var p_ = ps[i];\n                var d = Vector2d.squaredDistanceBetween(p, p_);\n                if (d < bestd) {\n                    cp = p_;\n                    bestd = d;\n                }\n            }\n            return cp;\n        }\n        /**\n        * Returns an array of points by applying a translation and then rotation to\n        * the given points.\n        * @param v - The translation vector\n        * @param sinθ\n        * @param cosθ\n        * @param ps - The input points\n        **/\n\n    }, {\n        key: \"translateThenRotatePs\",\n        value: function translateThenRotatePs(v, sinθ, cosθ, ps) {\n            var translate = Vector2d.translate(v);\n            return ps.map(function (p) {\n                return Vector2d.rotate(sinθ, cosθ, translate(p));\n            });\n        }\n        /**\n        * Returns an array of points by applying a rotation and then translation to\n        * the given points.\n        * @param sinθ\n        * @param cosθ\n        * @param v - The translation vector\n        * @param ps - The input points\n        **/\n\n    }, {\n        key: \"rotateThenTranslatePs\",\n        value: function rotateThenTranslatePs(sinθ, cosθ, v, ps) {\n            return ps.map(function (p) {\n                return Vector2d.translate(v, Vector2d.rotate(sinθ, cosθ, p));\n            });\n        }\n    }]);\n\n    return Vector2d;\n}();\n/**\n* Return the given 2d points translated by the given 2d vector. This\n* function is curried.\n* @param v\n* @param ps\n*/\n\n\nVector2d.translatePs = mapCurry2(Vector2d.translate);\n/**\n* Return the given 2d points translated by the given 2d vector. This function\n* is curried.\n* @param sinθ\n* @param cosθ\n* @param ps\n*/\nVector2d.rotatePs = specialMapCurry(Vector2d.rotate);\nexports.default = Vector2d;\n\n},{}]},{},[1])(1)\n});"]}
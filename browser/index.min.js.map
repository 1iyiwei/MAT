{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloMat","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","default","./index","2","Object","defineProperty","value","smoothen_1","find_mat_1","to_scale_axis_1","mat_tree_1","get_nodes_as_array_1","point_on_shape_1","linked_loop_1","shape_1","circle_1","svg_1","findMat","toScaleAxis","smoothen","MatTree","PointOnShape","LinkedLoop","Shape","Circle","Svg","fs","getNodesAsArray","./lib/geometry/classes/circle","./lib/geometry/classes/point-on-shape","./lib/geometry/classes/shape","./lib/linked-list/linked-loop","./lib/mat/classes/mat-tree","./lib/mat/functions/find-mat","./lib/mat/functions/get-nodes-as-array","./lib/mat/functions/smoothen","./lib/mat/functions/to-scale-axis","./lib/svg/svg","3","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","mat_constants_1","flo_vector2d_1","flo_memoize_1","flo_bezier3_1","memoize","m1","bezierNode","type","order","order2","p","evaluate","item","bezier3","pathCurve","ps","κ","radius","maxOsculatingCircleRadius","Math","min","normal","circleCenter","shape","dullCornerHash","makeSimpleKey","pos","pointType","getOsculatingCircle","sharp","extreme","calcOsculatingCircle","compare","b","undefined","res","indx","isPointingStraightUp","circle","circleDirection","toUnitVector","fromTo","center","abs","setPointOrder","dullCorner","dullCornerAt","beziers","tan1pre","tangent","tan1","tan2","dot","toHumanString","typeToStr","../../mat-constants","./circle","flo-bezier3","flo-memoize","flo-vector2d","4","geometry_1","Arc","sinAngle1","cosAngle1","sinAngle2","cosAngle2","startpoint","endpoint","arc","x","y","translate","arco","pp","len","sin_pp","cos_pp","isAngleBetween","r_o_l","position","_asp","_aep","distanceBetween","asp","aep","d1","d2","ds","sqrt","squaredDistanceBetweenPointAndLineSegment","v","l1p2","lineLineIntersection","../geometry","5","BezierPiece","tRange","6","c1","c2","d","squaredDistanceBetween","dr","7","Corner","tans","8","PathCurve","reverse","curve","newIndx","slice","9","10","_toConsumableArray","arr","Array","isArray","arr2","from","createSharpCornerCpLoops","sharpCornersArray","contactPointsPerLoop","comparator","contact_point_1","k","sharpCorners","cpLoop","prevNode","cp","insert","mat_circle_1","create","prevOnCircle","nextOnCircle","push","orient","bezierLoops","map","isPathPositivelyOrientated","loop","reverseBeziersOrientation","bezierLoop","bezierArray","getAsArray","idx","path_curve_1","acos","PI","createCoupledLoops","pointOnShapeArr","posLoop","getCurvatureAtInterface","pss","next","cosθ","sinθ","cross","θ","getTotalBy","node","head","total","list_node_1","bezier_piece_1","get_contact_circles_at_bezier_bezier_interface_1","get_bezier_osculating_circles_1","bezierArrays","_this","skip2ProngHash","straightUpHash","holeClosers","_debug_","generated","timing","start","performance","now","array","extremes","getExtremes","sort","a_","b_","shapeBoundingBox","getLoopBounds","pointOnShapeArrPerLoop","getInterestingPointsOnShape","pointsOnShapePerLoop","_Shape$getPotential2P","getPotential2Prongs","for2ProngsArray","forEachPointOnShape","dull","dullCorners","after1Prongs","pointsOnShape","posNode","for2Prongs","allPointsArray","getInterestingPointsOnLoop","allPoints","pointsOnShape1","prev","apply","pointsOnShape2","standard","firstPoint","lastPoint","splice","atLeast1","_i","_node","_pos","cptree","cps","findBounds","data","max","root","getBoundaryBeziers","bezierPieces","forEach","bezierPiece","getTotalCurvature","totalCurvature","getTotalAbsoluteCurvature","totalAbsoluteCurvature","forAllBeziers","getBoundaryPieceBeziers","δ","keepStraight","arguments","cp0","cp1","goStraight","posThis","pointOnShape","posNext","_pos2","_bezierPiece","bezierNode0","bezierNode1","t1","ii","bNode","_bezierPiece2","_bezierPiece3","console","log","INF","Number","POSITIVE_INFINITY","extremeBeziers","boundingBox","getBoundingBox","j","m","_getLoopBounds","maxXBezierNode","ts","getBounds","tAtMaxX","tan","psNext","tanNext","_getLoopBounds2","../../geometry/classes/bezier-piece","../../geometry/classes/path-curve","../../geometry/classes/point-on-shape","../../linked-list/linked-loop","../../linked-list/list-node","../../mat/classes/contact-point","../../mat/classes/mat-circle","../functions/get-bezier-osculating-circles","../functions/get-contact-circles-at-bezier-bezier-interface","11","calcBezierCurvatureExtremaBrackets","_ps","_slicedToArray","_ps$","x0","y0","_ps$2","x1","y1","_ps$3","x2","y2","_ps$4","x3","y3","brackets","P_1x","P_1y","P_2x","P_2y","P_3x","P_3y","W_0x","W_1x","W_2x","W_0y","W_1y","W_2y","DELTA","atan_numer","atan_denom","atan_numer_squared","atan_denom_squared","radpre","rad","cos_theta","sin_theta","R_1x","R_1y","R_2x","R_2y","R_3x","R_3y","dif","mu","lambda","gamma1","gamma2","sigd_","deReParamBoundary","deReParameterizeBoundary","ssigd_","sda","sdb","NEGATIVE_INFINITY","clipBoundary","ksi_pre1","ksi_pre2","ksi1","ksi2","bound","b0","b1","deReParameterize","sigma","boundary","sliceIterator","_arr","_n","_d","_e","_s","Symbol","iterator","done","err","12","getBezierOsculatingCircles","calc_bezier_curvature_extrema_1","κPs","lenb","bracket","_root","lookForRoot","κAtMinsd","κAtMaxsd","_ref","_ref2","minsd","maxsd","dκMod","flo_poly_1","brent","./calc-bezier-curvature-extrema","flo-poly","13","getClosestBoundaryPointToPoint","bezierPieces_","point","touchedBezierNode","cullBezierPieces","bestDistance","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","closestPointOnBezier","Point_on_shape_1","return","bestSquaredDistance","getClosePoint","cullByLooseBoundingBox","cullByTightBoundingBox","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","evPs","p1","p2","candidateBezierPieces","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","getClosestSquareDistanceToRect","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tightBoundingBox","getBoundingBoxTight","closestSquaredDistanceToRotatedRect","_p","xp","yp","xx0","xx1","xx2","xx3","yy0","yy1","yy2","yy3","x00","x01","x02","x03","x11","x12","x13","x22","x23","x33","y00","y01","y02","y03","y11","y12","y13","y22","y23","y33","t5","t4","t3","t2","t0","poly","deflate","roots","allRoots","push0","push1","getClosest","bestd","p_","../classes/Point-on-shape","14","getContactCirclesAtBezierBezierInterface","bezierNodes","crossTangents","negDot","CROSS_TANGENT_LIMIT","corner_1","orders","DEGREES","0","0.25","15","16","../classes/corner","l1","l2","_l","_l$","p1x","p1y","_l$2","p2x","p2y","_l2","_l2$","p3x","p3y","_l2$2","p4x","p4y","v1x","v1y","v2x","v2y","getLineBoundaryIntersectionPoints","line","points","iPoints","getLineBezierIntersectionPoints","box","_box","_box$","_box$2","_d2","_d3","degAngleFromSinCos","toDeg","atan","arcFrom3Points","midPoint1","mean","midPoint2","chord1","chord2","perpendicular1","perpendicular2","sideVector1","midVector","sideVector2","sinθ1","cosθ1","sinθ2","cosθ2","arc_1","quadrant","isAngle1LargerOrEqual","q1","q2","θ1_larger_θ2","θ_larger_θ2","θ_larger_θ1","lineThroughPointAtRightAngleTo","lineLength","newPs","translateThenRotatePs","getY","Geometry","./classes/arc","./classes/circle","./classes/shape","flo_ll_rb_tree_1","items","addAllFromScratch","prev_","coupledNode","remove","nodes","advanceNSteps","./list-node","flo-ll-rb-tree","17","ListNode","18","MAT_CONSTANTS","19","ContactPoint","matCircle","equal","20","ThreeProngForDebugging","threeProng","deltas","bestIndx","candidateThreeProngs","deltasSimple","delta","../../../geometry/classes/point-on-shape","21","TwoProngForDebugging","z","xs","failed","holeClosing","22","HoleClosing2Prong","k1","k2","cpNodeA2","cpNodeA1","cpNodeB1","cpNodeB2","23","MatCircle","cpNodes","visited","24","MatNode","branches","matNode","priorNode","newPriorNode","newNode","25","traverse_1","startNode","traverse","../../mat/functions/traverse","26","add2Prong","pos1","pos2","cp2","delta2","getNeighbouringPoints","cmp3","cmp4","newCp2Node","delta1","cmp1","cmp2","newCp1Node","posA1","posB2","copy","cpB2","newCpB2Node","posA2","posB1","cpB1","newCpB1Node","hole_closing_2_prong_1","prepForDebug","contactPoint","cpKey","cpHash","cpArr","arrIndx","cpHashDebugObj","visitedPointsArr","../../geometry/classes/shape","../classes/hole-closing-2-prong","27","add3Prong","delta3s","idxsPrev","idxsNext","28","buildMat","cpNodeStart","fromNode","fromCpNode","isRetry","visitedPoints","traverseShape","findAndAdd3Prong","createMatNode","_matNode2","cpBranches","cpNext","bm","mat_node_1","prepDebugHashes","cpNode","visitedPoint","idxi","endP","startP","find_3_prong_1","_i2","add_3_prong_1","nodeHash","../../mat/classes/mat-node","./add-3-prong","./find-3-prong","29","copyMat","matTree","../classes/mat-tree","30","find2Prong","oCircle","shortestSquaredDistance","_bezierPieces","pieces","squaredError","get_closest_boundary_point_to_point_1","SQUARED_1PRONG_TOLERANCE","add1Prong","SQUARED_SEPERATION_TOLERANCE","nextX","findEquidistantPointOnLine","squaredDistance","SQUARED_ERROR_TOLERANCE","MAX_ITERATIONS","recordForDebugging","newCpNode","oneProngs","isNaN","oneProngsAtDullCorner","twoProngForDebugging","two_prong_for_debugging_1","twoProngs","rSquared","newPieces","rect","swapAxes","z1","z2","c","SEPERATION_TOLERANCE","_1PRONG_TOLERANCE","ERROR_TOLERANCE","../../geometry/classes/Point-on-shape","../../geometry/classes/circle","../../geometry/functions/get-closest-boundary-point-to-point","../../geometry/geometry","../classes/debug/two-prong-for-debugging","31","find3Prong","δs","bezierPiecess","smallestError","_find3ProngForDelta3s","find3ProngForDelta3s","error","_debug_2","threeProngForDebugging","three_prong_for_debugging_1","threeProngs","bezierPiece3s","circumCenter","calcInitial3ProngPoint","tolerance","getClosestPoints","vectorToZeroV","calcVectorToZeroV_StraightToIt","upds","calcBetterX","newX","V","newV","totalAngleError","vv","v1","rotate90Degrees","perps","angleError1Pre","angleError2Pre","angleError1","asin","angleError2","angleError","v2","closestDs","closestD","nu","better","shift","scale","newCircleCenter","newVectorToZeroV","twoProngCircleCenter","point1","meanPoints","isFinite","sames","whichNotSame","../classes/debug/three-prong-for-debugging","32","findAndAddHoleClosing2Prongs","findAndAdd2ProngsOnAllPaths","after2Prongs","contactPoints","cptest","branchForth","build_mat_1","branchBack","mat","after3Prongs","fixMat","twoProngInfo","find_2_prong_1","add_2_prong_1","findAndAdd2Prongs","index","indexLinear","firstRight","secondRight","./add-2-prong","./build-mat","./find-2-prong","33","./traverse","34","getNodesAsHash","35","getLinkedCps","prevCpNodes","currCpNodes","prevCpNode","currCpNode","lines","quads","cubes","currNode","getDirectionToNextMatCircle","isPrev","vDir","spanner","bezierNode2","rotate","toLength","prevMatCircle","prevCc","currMatCircle","currCc","_getLinkedCps","_getLinkedCps2","prevL","currL","mid","twisted","dot1","dot2","lp1","vv1","vvv1","lpp1","mid1","mid2","36","mat_","copy_mat_1","get_nodes_as_hash_1","biggest","biggestNode","tree","createSpacialTree","sat","cullHash","traverseSpacialTree","cullem","cullNodes","cullIt","cullTheNodes","afterSat","addToTree","coordinate","limits","depth","_calcGroups","calcGroups","groups","newLimits","group","Map","set","width","height","extraParams","getCullNodes","_key","helper","size","testNode","cullBranch5","branch","engulfsCircle","delete","_calcGroups2","_branch4","newCoordinate","_branch2","_branch3","satNode","anyNotCull","cullTheNode","cullNode","indexOf","limit","q","w","newLimit","qStart","floor","qEnd","qDiff","lowerLimit","_lowerLimit","otherCoordinate","./copy-mat","./get-nodes-as-hash","37","38","getBeziersFromSvgElem","elem","isCloseToOrigin","manhattanLength","isAlmostZeroLength","manhattanDistanceBetween","pushBezier","ps_","interpolate","MUST_START_WITH_M","paths","getElementsByTagName","path","pathSegs","pathSegList","numberOfItems","pathStarted","prev2ndCubicControlPoint","prev2ndQuadraticControlPoint","initialPoint","pathSeg","getItem","_type","pathSegTypeAsLetter","addX","addY","toLowerCase","prevType","toUpperCase","_path","vals","_xInterval","_yInterval","_path2","_vals","_path3","_vals2","_path4","_vals3","_xInterval2","_yInterval2","_path5","_vals4","_xInterval3","_path6","_vals5","_yInterval3","_path7","_vals6","QP0","QP1","QP2","_path8","_vals7","_x3","_y","_QP","_QP2","_QP3","xInterval","yInterval","getPathStrFromBezierLoop","getPathStrFromBeziers","decimalPlaces","D","str","toFixed","../geometry/classes/path-curve","39","fromLine","evX","evY","_ps3","_ps3$","_ps3$2","evaluateX","evaluateY","dx","evDx","dy","evDy","ddx","evDdx","evDdy","pow","evaluateDx","evaluateDy","evaluateDdx","evaluateDdy","κds","omt","h","_ps5","_ps5$","_ps5$2","_ps5$3","_ps5$4","tanPs","interval","flo_gauss_quadrature_1","_ps6","_ps6$","_ps6$2","_ps6$3","_ps6$4","evDs","getTAtLength","lenAtT","xPs","getX","yPs","dPs","getDx","getDy","ddPs","getDdx","getDdy","evaluateDddx","dddPs","getDddx","evaluateDddy","getDddy","getNormalizedBoundingBox","vectorToOrigin","transform","boundingPs","from0ToT","fromTTo1","_ps8","_ps8$","_ps8$2","_ps8$3","_ps8$4","s2","s3","_ps9","_ps9$","_ps9$2","_ps9$3","_ps9$4","splitAt","_ps10","_ps10$","_ps10$2","_ps10$3","_ps10$4","ps1","factor","lineIntersection","tsAtY","tsAtX","toQuadratic","_ps12","_ps12$","_ps12$2","_ps12$3","_ps12$4","toHybridQuadratic","_ps13","_ps13$","_ps13$2","_ps13$3","_ps13$4","evaluateHybridQuadratic","hq","th","P0","P2","evaluateQuadratic","evaluateLinear","_ps14","_ps14$","_ps14$2","clone","_ps15","_ps15$","_ps15$2","_ps15$3","_ps15$4","_ps16","_ps16$","_ps16$2","_ps16$3","toCubic","_ps17","_ps17$","_ps17$2","_ps17$3","coincident","P","Q","calcPointAndNeighbor","pp1","normalVector","pp2","bestT","bestP","bestD","_t2","_P","_Q","_calcPointAndNeighbor","tPQ0","dPQ0","_calcPointAndNeighbor2","tPQ1","dPQ1","_calcPointAndNeighbor3","tQP0","dQP0","_calcPointAndNeighbor4","tQP1","dQP1","tStartQ","tEndQ","tStartP","tEndP","count","tSpanP","_calcPointAndNeighbor5","bezier3Intersection","ps2","Δ","intersection","Q_","P_","qRange","pRange","cidx","_center","_center2","_Q_","_Q_2","Q0","Q3","_P_","_P_2","dQ","getDistanceToLineFunction","dQi","dQs","_dQs","dQ1","dQ2","C","dMin","dMax","_geoClip","geoClip","tMin","tMax","pSpan","qSpan","_ref3","_ref4","_span","tMinA","tMaxA","tMinB","tMaxB","A","B","span","tMin_","tMax_","pq","calcOtherT","tss","dPi","_dPs","dH0","dH2","dH10","dH11","dHmin","dHmax","DyMin","DyMax","errorBound","hornerErrorBound","DyMinMin","DyMinMax","DyMaxMin","DyMaxMax","rootsMinMin","rootsMinMax","rootsMaxMin","rootsMaxMax","concat","_P2","_P3","P1","P3","_Q2","_Q3","Q1","Q2","lengthP","sdst","lengthQ","moveX","moveY","_pp","tqsh","tqsv","tqs","tq","δMin","EPSILON","getLineEquation","_l3","_l3$","_l3$2","_getLineEquation","_getLineEquation2","flo_graham_scan_1","_flo_vector2d_1$defau","rotatePs","translatePs","_ps2","_ps2$","_ps2$2","_ps2$3","differentiate","getBoundingHull","curvature","_ps7","_ps7$","_ps7$2","_ps7$3","_ps7$4","baseLength","p0x","p0y","axisAlignedBox","rotateThenTranslatePs","minX","maxX","minY","maxY","tMinX","tMinY","tMaxX","tMaxY","_t","Bezier3","flo-gauss-quadrature","flo-graham-scan","40","gaussQuadrature","_GAUSS_CONSTANTS$orde","GAUSS_CONSTANTS","weights","abscissas","_interval","result","m2","41","stableSort","indxArray","sorted","swap","temp","getSmallestIndxYThenX","smallest","smallestI","grahamScan","includeAllBoundaryPoints","_ps$splice","_ps$splice2","Vector","unshift","p3","ccw","42","isRed","color","tree_node_color_1","RED","removeFromArray","dir","otherDir","tree_node_direction_1","LEFT","RIGHT","parent","removeMin","moveRedLeft","fixUp","flipColor","BLACK","flipColors","moveRedRight","tree_node_1","LlRbTree","datas","replaceDups","getMinNode","getMinOrMaxNode","getMaxNode","setComparator","all","bounds","./src/tree-node","./src/tree-node-color","./src/tree-node-direction","43","TreeNodeColor","44","TreeNodeDirection","45","TreeNode","asArray","./tree-node-color","46","SUPPORTED","results","WeakMap","get","Memoize","47","core_operators_1","root_operators_1","root_bounds_1","all_roots_recursive_1","random_1","error_analysis_1","from_roots_1","FloPoly","multiply","assign","random","fromRoots","./src/all-roots-recursive","./src/core-operators","./src/error-analysis","./src/from-roots","./src/random","./src/root-bounds","./src/root-operators","48","clip0","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","rootsWithin","intervals","peval","prevRoot","evA","evB","_core_operators_1$def","_root_operators_1$def","toCasStr","_root_bounds_1$defaul","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","./core-operators","./root-bounds","./root-operators","49","add","Δd","Δd1","Δd2","subtract","negate","multiplyByConst","fill","degree","evaluateAt0","signChanges","prevSign","sign","bs","invert","changeVariables","_j","acc","reflectAboutYAxis","sturmChain","pnext","clip","maxCoefficient","cStr","toString","coreOperators","50","conditionNumber","errorAnalysis","51","52","createArrFunction","seed","SEED","odds","predictiveRandom","RANGE","randomArray","vs","values","flatRoots","randArr","flatCoefficients","flatRootsArr","flatCoefficientsArr","./from-roots","53","maxAbs","ns","rootMagnitudeUpperBound_rouche","an","deg","timesUsed","ub","tempub","any","powres","POWERS","rootBounds","54","root1","root2","numRootsWithin","as","bisection","fa","fb","fc","mflag","fac","fab","fbc","b_c","s_b","c_d","_temp","rootOperators","55","Vector2d","ab","cd","_ab","_cd","denom","rNumer","sNumer","scaleFactor","sqDst","triangle","sqLen","lengthSquared","Sx","det3","Sy","dst","l3","lengthSum","polygon","p0","_p2","_p3","_p4","rotateByθ","us","hUs"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloMat = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = _dereq_(\"./index\").default;\n\n},{\"./index\":2}],2:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//---- Functions \nvar smoothen_1 = _dereq_(\"./lib/mat/functions/smoothen\");\nvar find_mat_1 = _dereq_(\"./lib/mat/functions/find-mat\");\nvar to_scale_axis_1 = _dereq_(\"./lib/mat/functions/to-scale-axis\");\n//---- Classes - can be instantiated\nvar mat_tree_1 = _dereq_(\"./lib/mat/classes/mat-tree\");\nvar get_nodes_as_array_1 = _dereq_(\"./lib/mat/functions/get-nodes-as-array\");\nvar point_on_shape_1 = _dereq_(\"./lib/geometry/classes/point-on-shape\");\nvar linked_loop_1 = _dereq_(\"./lib/linked-list/linked-loop\");\nvar shape_1 = _dereq_(\"./lib/geometry/classes/shape\");\nvar circle_1 = _dereq_(\"./lib/geometry/classes/circle\");\nvar svg_1 = _dereq_(\"./lib/svg/svg\");\nvar FloMat = {\n    findMat: find_mat_1.default,\n    toScaleAxis: to_scale_axis_1.default,\n    smoothen: smoothen_1.default,\n    MatTree: mat_tree_1.default,\n    PointOnShape: point_on_shape_1.default,\n    LinkedLoop: linked_loop_1.default,\n    Shape: shape_1.default,\n    Circle: circle_1.default,\n    Svg: svg_1.default,\n    fs: {\n        getNodesAsArray: get_nodes_as_array_1.default\n    }\n};\nexports.default = FloMat;\n\n},{\"./lib/geometry/classes/circle\":6,\"./lib/geometry/classes/point-on-shape\":9,\"./lib/geometry/classes/shape\":10,\"./lib/linked-list/linked-loop\":16,\"./lib/mat/classes/mat-tree\":25,\"./lib/mat/functions/find-mat\":32,\"./lib/mat/functions/get-nodes-as-array\":33,\"./lib/mat/functions/smoothen\":35,\"./lib/mat/functions/to-scale-axis\":36,\"./lib/svg/svg\":38}],3:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"./circle\");\nvar memoize = flo_memoize_1.default.m1;\n/**\r\n * @constructor\r\n *\r\n * @param bezierNode\r\n * @param t - The bezier parameter value\r\n * @param type {MAT_CONSTANTS.pointType}\r\n *  'standard' : 0, // Not special,\r\n *  'sharp'    : 1, // Sharp corner,\r\n *  'dull'     : 2, // dull corner,\r\n * @param order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.\r\n * @param order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately.\r\n * @param circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\n\nvar PointOnShape = function () {\n    function PointOnShape(bezierNode, t, type, order, order2) {\n        _classCallCheck(this, PointOnShape);\n\n        this.bezierNode = bezierNode;\n        this.t = t;\n        this.type = type;\n        this.order = order;\n        this.order2 = order2;\n        //---- Cache\n        var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3, t);\n        this.p = p;\n        // Removing this cache will help in that if {PointOnShape} is \n        // called as a parameter (where a point is required) it will more \n        // likely result in monomorphic behaviour as opposed to polymorphic \n        // or megamorphic.\n        this[0] = p[0];\n        this[1] = p[1];\n    }\n    /**\r\n     * Calculates the osculating circle of the bezier at a\r\n     * specific t. If it is found to have negative or nearly zero radius\r\n     * it is clipped to have positive radius so it can point into the shape.\r\n     * @param pathCurve\r\n     * @param t\r\n     */\n\n\n    _createClass(PointOnShape, null, [{\n        key: \"calcOsculatingCircle\",\n        value: function calcOsculatingCircle(pathCurve, t) {\n            var ps = pathCurve.bezier3;\n            var κ = -flo_bezier3_1.default.κ(ps, t);\n            // If (κ > 0) { Bending inwards. }\n            var radius = void 0;\n            if (κ <= 1 / mat_constants_1.default.maxOsculatingCircleRadius) {\n                // Curving wrong way (or flat, or too big), but probably a \n                // significant point to put a 2-prong.\n                radius = mat_constants_1.default.maxOsculatingCircleRadius;\n            } else {\n                radius = Math.min(1 / κ, mat_constants_1.default.maxOsculatingCircleRadius);\n            }\n            var normal = flo_bezier3_1.default.normal(ps, t);\n            var p = flo_bezier3_1.default.evaluate(ps, t);\n            var circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n            return new circle_1.default(circleCenter, radius);\n        }\n    }, {\n        key: \"dullCornerAt\",\n        value: function dullCornerAt(shape, p) {\n            var dullCornerHash = shape.dullCornerHash;\n            var key = PointOnShape.makeSimpleKey(p);\n            return dullCornerHash[key] || null;\n        }\n        /**\r\n         * Clones the PointOnShape.\r\n         */\n        // TODO - rename to clone\n        // TODO - deep clone?\n\n    }, {\n        key: \"copy\",\n        value: function copy(pos) {\n            return new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n        }\n        /**\r\n         * Returns the PointOnShape type as a human-readable\r\n         * string.\r\n         * @param {number} type\r\n         * @returns {string}\r\n         */\n        // TODO - remove - use enum\n\n    }, {\n        key: \"typeToStr\",\n        value: function typeToStr(type) {\n            for (var key in mat_constants_1.default.pointType) {\n                if (mat_constants_1.default.pointType[key] === type) {\n                    return key;\n                }\n            }\n        }\n    }]);\n\n    return PointOnShape;\n}();\n\nPointOnShape.getOsculatingCircle = memoize(function (pos) {\n    if (pos.type === mat_constants_1.default.pointType.sharp) {\n        return new circle_1.default(pos.p, 0);\n    } else if (pos.type === mat_constants_1.default.pointType.extreme) {\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [pos.p[0], pos.p[1] - r];\n        return new circle_1.default(p, r);\n    }\n    return PointOnShape.calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n/**\r\n* Compares two PointOnShapes according to their position on the bezier loop.\r\n*/\nPointOnShape.compare = function (a, b) {\n    if (a === undefined || b === undefined) {\n        return undefined;\n    }\n    var res = void 0;\n    res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order - b.order;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order2 - b.order2;\n    return res;\n};\n/**\r\n* Returns true if its osculation circle is pointing straight upwards.\r\n*/\nPointOnShape.isPointingStraightUp = function (pos) {\n    var circle = PointOnShape.getOsculatingCircle(pos);\n    if (!circle) {\n        return false;\n    }\n    var circleDirection = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    // If not almost pointing straight up\n    if (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Sets the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n    var dullCorner = PointOnShape.dullCornerAt(shape, pos.p);\n    if (!dullCorner) {\n        return;\n    }\n    var ps = dullCorner.beziers[0];\n    var tan1pre = flo_bezier3_1.default.tangent(ps, 1);\n    var tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n    var tan2 = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    pos.order = -flo_vector2d_1.default.dot(tan1, tan2);\n    return pos.order;\n};\n/**\r\n * Creates a string key that only depends on the PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n    return '' + p[0] + ', ' + p[1];\n};\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n    return '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + PointOnShape.typeToStr(pos.type); // TODO - use enum\n};\nexports.default = PointOnShape;\n\n},{\"../../mat-constants\":18,\"./circle\":6,\"flo-bezier3\":39,\"flo-memoize\":46,\"flo-vector2d\":55}],4:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar circle_1 = _dereq_(\"./circle\");\nvar geometry_1 = _dereq_(\"../geometry\");\n\nvar Arc = function () {\n    /**\r\n     * Arc class.\r\n     * If circle === null then the arc degenerates into a line segment\r\n     * given by sinAngle1 and cosAngle2 which now represent points.\r\n     * The arc curve is always defined as the piece from angle1 -> angle2.\r\n     * Note: startpoint and endpoint is redundant\r\n     */\n    function Arc(circle, sinAngle1, cosAngle1, sinAngle2, cosAngle2, startpoint, endpoint) {\n        _classCallCheck(this, Arc);\n\n        // Intrinsic\n        this.circle = circle;\n        this.sinAngle1 = sinAngle1;\n        this.sinAngle2 = sinAngle2;\n        this.cosAngle1 = cosAngle1;\n        this.cosAngle2 = cosAngle2;\n        // Cache\n        this.startpoint = startpoint; // Redundant but useful\n        this.endpoint = endpoint; // Redundant but useful\n    }\n    /**\r\n     * Returns the closest point on the arc.\r\n     * NOTE: Not currently used.\r\n     * @private\r\n     */\n\n\n    _createClass(Arc, null, [{\n        key: \"closestPointOnArc\",\n        value: function closestPointOnArc(p, arc) {\n            if (arc.circle !== null) {\n                // First move arc circle onto origin\n                var x = arc.circle.center[0];\n                var y = arc.circle.center[1];\n                var translate = flo_vector2d_1.default.translate([-x, -y]);\n                var arco = new Arc(new circle_1.default([0, 0], arc.circle.radius), arc.sinAngle1, arc.cosAngle1, arc.sinAngle2, arc.cosAngle2, translate(arc.startpoint), translate(arc.endpoint));\n                var pp = translate(p);\n                var l = flo_vector2d_1.default.len(pp);\n                var sin_pp = -pp[1] / l;\n                var cos_pp = pp[0] / l;\n                if (geometry_1.default.isAngleBetween(sin_pp, cos_pp, arco.sinAngle1, arco.cosAngle1, arco.sinAngle2, arco.cosAngle2)) {\n                    var r_o_l = arco.circle.radius;\n                    var _res = { p: flo_vector2d_1.default.translate([x, y], [r_o_l * cos_pp, r_o_l * -sin_pp]), position: 0 };\n                    return _res;\n                } else {\n                    var _asp = arc.startpoint;\n                    var _aep = arc.endpoint;\n                    var _d = flo_vector2d_1.default.distanceBetween(_asp, p);\n                    var _d2 = flo_vector2d_1.default.distanceBetween(_aep, p);\n                    if (_d < _d2) {\n                        return { p: _asp, position: 1 };\n                    }\n                    return { p: _aep, position: 2 };\n                }\n            }\n            // Line degenerate case - this is exactly a routine for \n            // distance (and closest point) between point and line segment.\n            var asp = arc.startpoint;\n            var aep = arc.endpoint;\n            var d1 = flo_vector2d_1.default.distanceBetween(asp, p);\n            var d2 = flo_vector2d_1.default.distanceBetween(aep, p);\n            var ds = Math.sqrt(flo_vector2d_1.default.squaredDistanceBetweenPointAndLineSegment(p, [asp, aep]));\n            if (d1 <= d2 && d1 <= ds) {\n                return { p: asp, position: 1 };\n            } else if (d2 <= d1 && d2 <= ds) {\n                return { p: aep, position: 2 };\n            }\n            // else ds is shortest\n            var v = flo_vector2d_1.default.fromTo(asp, aep);\n            var l1p2 = [p[0] + v[1], p[1] + -v[0]];\n            var res = {\n                p: geometry_1.default.lineLineIntersection([p, l1p2], [asp, aep]),\n                position: 0\n            };\n            return res;\n        }\n    }]);\n\n    return Arc;\n}();\n\nexports.default = Arc;\n\n},{\"../geometry\":15,\"./circle\":6,\"flo-vector2d\":55}],5:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar BezierPiece =\n/**\r\n * @param bezierNode\r\n * @param tRange\r\n */\nfunction BezierPiece(bezierNode, tRange) {\n    _classCallCheck(this, BezierPiece);\n\n    this.bezierNode = bezierNode;\n    this.tRange = tRange;\n};\n\nexports.default = BezierPiece;\n\n},{}],6:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\n\nvar Circle = function () {\n    /**\r\n    * @param center\r\n    * @param radius\r\n    */\n    function Circle(center, radius) {\n        _classCallCheck(this, Circle);\n\n        this.center = center;\n        this.radius = radius;\n    }\n    /**\r\n     * Returns a scaled version of the given circle without\r\n     * changing its center position.\r\n     * @param circle\r\n     * @param s multiplier\r\n     */\n\n\n    _createClass(Circle, null, [{\n        key: \"scale\",\n        value: function scale(circle, s) {\n            return new Circle(circle.center, circle.radius * s);\n        }\n        /**\r\n         * Returns true if the first circle engulfs the second.\r\n         */\n\n    }, {\n        key: \"engulfsCircle\",\n        value: function engulfsCircle(c1, c2) {\n            if (c1.radius <= c2.radius) {\n                return false;\n            }\n            var d = flo_vector2d_1.default.squaredDistanceBetween(c1.center, c2.center);\n            var dr = c1.radius - c2.radius;\n            var δ = dr * dr;\n            return δ > d;\n        }\n        /**\r\n         * Returns a human-readable string description.\r\n         */\n\n    }, {\n        key: \"toString\",\n        value: function toString(circle) {\n            return 'c: ' + circle.center + ' radius: ' + circle.radius;\n        }\n    }]);\n\n    return Circle;\n}();\n\nexports.default = Circle;\n\n},{\"flo-vector2d\":55}],7:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar Corner = function Corner(beziers, tans) {\n    _classCallCheck(this, Corner);\n\n    this.beziers = beziers;\n    this.tans = tans;\n};\n\nexports.default = Corner;\n\n},{}],8:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar PathCurve =\n/**\r\n * An indexed cubic bezier curve.\r\n * @param indx\r\n * @param bezier3\r\n */\nfunction PathCurve(indx, bezier3) {\n    _classCallCheck(this, PathCurve);\n\n    this.indx = indx;\n    this.bezier3 = bezier3;\n};\n/**\r\n * Returns the reverse of the given bezier and assign the new given idx.\r\n * @param {PathCurve} curve - a path curve\r\n * @param {number} idx\r\n * @returns {Bezier3}\r\n */\n\n\nPathCurve.reverse = function (curve, newIndx) {\n    var ps = curve.bezier3.slice().reverse();\n    return new PathCurve(newIndx, ps);\n};\nexports.default = PathCurve;\n\n},{}],9:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"./circle\");\nvar memoize = flo_memoize_1.default.m1;\n/**\r\n * @constructor\r\n *\r\n * @param bezierNode\r\n * @param t - The bezier parameter value\r\n * @param type {MAT_CONSTANTS.pointType}\r\n *  'standard' : 0, // Not special,\r\n *  'sharp'    : 1, // Sharp corner,\r\n *  'dull'     : 2, // dull corner,\r\n * @param order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.\r\n * @param order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately.\r\n * @param circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\n\nvar PointOnShape = function () {\n    function PointOnShape(bezierNode, t, type, order, order2) {\n        _classCallCheck(this, PointOnShape);\n\n        this.bezierNode = bezierNode;\n        this.t = t;\n        this.type = type;\n        this.order = order;\n        this.order2 = order2;\n        //---- Cache\n        var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3, t);\n        this.p = p;\n        // Removing this cache will help in that if {PointOnShape} is \n        // called as a parameter (where a point is required) it will more \n        // likely result in monomorphic behaviour as opposed to polymorphic \n        // or megamorphic.\n        this[0] = p[0];\n        this[1] = p[1];\n    }\n    /**\r\n     * Calculates the osculating circle of the bezier at a\r\n     * specific t. If it is found to have negative or nearly zero radius\r\n     * it is clipped to have positive radius so it can point into the shape.\r\n     * @param pathCurve\r\n     * @param t\r\n     */\n\n\n    _createClass(PointOnShape, null, [{\n        key: \"calcOsculatingCircle\",\n        value: function calcOsculatingCircle(pathCurve, t) {\n            var ps = pathCurve.bezier3;\n            var κ = -flo_bezier3_1.default.κ(ps, t);\n            // If (κ > 0) { Bending inwards. }\n            var radius = void 0;\n            if (κ <= 1 / mat_constants_1.default.maxOsculatingCircleRadius) {\n                // Curving wrong way (or flat, or too big), but probably a \n                // significant point to put a 2-prong.\n                radius = mat_constants_1.default.maxOsculatingCircleRadius;\n            } else {\n                radius = Math.min(1 / κ, mat_constants_1.default.maxOsculatingCircleRadius);\n            }\n            var normal = flo_bezier3_1.default.normal(ps, t);\n            var p = flo_bezier3_1.default.evaluate(ps, t);\n            var circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n            return new circle_1.default(circleCenter, radius);\n        }\n    }, {\n        key: \"dullCornerAt\",\n        value: function dullCornerAt(shape, p) {\n            var dullCornerHash = shape.dullCornerHash;\n            var key = PointOnShape.makeSimpleKey(p);\n            return dullCornerHash[key] || null;\n        }\n        /**\r\n         * Clones the PointOnShape.\r\n         */\n        // TODO - rename to clone\n        // TODO - deep clone?\n\n    }, {\n        key: \"copy\",\n        value: function copy(pos) {\n            return new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n        }\n        /**\r\n         * Returns the PointOnShape type as a human-readable\r\n         * string.\r\n         * @param {number} type\r\n         * @returns {string}\r\n         */\n        // TODO - remove - use enum\n\n    }, {\n        key: \"typeToStr\",\n        value: function typeToStr(type) {\n            for (var key in mat_constants_1.default.pointType) {\n                if (mat_constants_1.default.pointType[key] === type) {\n                    return key;\n                }\n            }\n        }\n    }]);\n\n    return PointOnShape;\n}();\n\nPointOnShape.getOsculatingCircle = memoize(function (pos) {\n    if (pos.type === mat_constants_1.default.pointType.sharp) {\n        return new circle_1.default(pos.p, 0);\n    } else if (pos.type === mat_constants_1.default.pointType.extreme) {\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [pos.p[0], pos.p[1] - r];\n        return new circle_1.default(p, r);\n    }\n    return PointOnShape.calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n/**\r\n* Compares two PointOnShapes according to their position on the bezier loop.\r\n*/\nPointOnShape.compare = function (a, b) {\n    if (a === undefined || b === undefined) {\n        return undefined;\n    }\n    var res = void 0;\n    res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.t - b.t;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order - b.order;\n    if (res !== 0) {\n        return res;\n    }\n    res = a.order2 - b.order2;\n    return res;\n};\n/**\r\n* Returns true if its osculation circle is pointing straight upwards.\r\n*/\nPointOnShape.isPointingStraightUp = function (pos) {\n    var circle = PointOnShape.getOsculatingCircle(pos);\n    if (!circle) {\n        return false;\n    }\n    var circleDirection = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    // If not almost pointing straight up\n    if (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Sets the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n    var dullCorner = PointOnShape.dullCornerAt(shape, pos.p);\n    if (!dullCorner) {\n        return;\n    }\n    var ps = dullCorner.beziers[0];\n    var tan1pre = flo_bezier3_1.default.tangent(ps, 1);\n    var tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n    var tan2 = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(pos.p, circle.center));\n    pos.order = -flo_vector2d_1.default.dot(tan1, tan2);\n    return pos.order;\n};\n/**\r\n * Creates a string key that only depends on the PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n    return '' + p[0] + ', ' + p[1];\n};\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n    return '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + PointOnShape.typeToStr(pos.type); // TODO - use enum\n};\nexports.default = PointOnShape;\n\n},{\"../../mat-constants\":18,\"./circle\":6,\"flo-bezier3\":39,\"flo-memoize\":46,\"flo-vector2d\":55}],10:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar path_curve_1 = _dereq_(\"../../geometry/classes/path-curve\");\nvar linked_loop_1 = _dereq_(\"../../linked-list/linked-loop\");\nvar list_node_1 = _dereq_(\"../../linked-list/list-node\");\nvar bezier_piece_1 = _dereq_(\"../../geometry/classes/bezier-piece\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar memoize = flo_memoize_1.default.m1;\n\nvar get_contact_circles_at_bezier_bezier_interface_1 = _dereq_(\"../functions/get-contact-circles-at-bezier-bezier-interface\");\nvar get_bezier_osculating_circles_1 = _dereq_(\"../functions/get-bezier-osculating-circles\");\n\nvar Shape = function () {\n    /**\r\n     * A Shape represents the loop of individual cubic bezier curves composing\r\n     * an SVG element. When constructed, some initial analysis is done.\r\n     * @param bezierArrays - An array (loop) of cubic bezier arrays. Each loop\r\n     * represents a closed path of the shape.\r\n     */\n    function Shape(bezierArrays) {\n        var _this = this;\n\n        _classCallCheck(this, Shape);\n\n        /** Hash of 2-prongs that need to be skipped in 2-prong procedure\r\n        since we already have a hole-closing 2-prong there. */\n        this.skip2ProngHash = {};\n        /** Hash of PointOnShapes that has a normal pointing straight up. */\n        this.straightUpHash = {};\n        /** A hash of all the dull corners (i.e. those with angle > 180 deg) */\n        this.dullCornerHash = {};\n        /** Hole closing 2-prongs that will be populated during find-mat */\n        this.holeClosers = [];\n        // TODO - check if this will run in node (due to window object)\n        if (typeof window !== 'undefined' && window._debug_) {\n            window._debug_.generated.timing.start = performance.now();\n        }\n        // The shape paths and sub-paths, a.k.a bezier loops.\n        var bezierLoops = bezierArrays.map(function (array, k) {\n            return new linked_loop_1.default(array, undefined, k);\n        });\n        // Orient the loops so that the outer loop is oriented positively - \n        // defined as anti-clockwise.  \n        this.bezierLoops = orient(bezierLoops);\n        this.extremes = this.bezierLoops.map(getExtremes);\n        // This is to find the topmost points on each loop.\n        this.extremes.sort(function (a, b) {\n            return a.p[1] - b.p[1];\n        });\n        this.bezierLoops.sort(function (a_, b_) {\n            var a = getExtremes(a_);\n            var b = getExtremes(b_);\n            return a.p[1] - b.p[1];\n        });\n        // Re-index after ordering.\n        for (var i = 0; i < this.bezierLoops.length; i++) {\n            this.bezierLoops[i].indx = i;\n        }\n        // Get metrics of the outer loop. ??\n        this.shapeBoundingBox = getLoopBounds(bezierLoops[0]).shapeBoundingBox;\n        // Gets interesting points on the shape, i.e. those that makes \n        // sense to use for the 2-prong procedure.\n        var pointOnShapeArrPerLoop = Shape.getInterestingPointsOnShape(this);\n        this.pointsOnShapePerLoop = pointOnShapeArrPerLoop.map(function (array, i) {\n            return createCoupledLoops(array, i);\n        });\n        // TODO Finish implementation. This is to space the points more\n        // evenly. \n        //respacePoints(this.contactPointsPerLoop, 30);\n\n        var _Shape$getPotential2P = Shape.getPotential2Prongs(this),\n            sharpCornersArray = _Shape$getPotential2P.sharpCornersArray,\n            for2ProngsArray = _Shape$getPotential2P.for2ProngsArray;\n\n        this.for2ProngsArray = for2ProngsArray;\n        // Take account of sharp and dull corners for debugging and update \n        // straightUpHash.\n        Shape.forEachPointOnShape(this, function (pos) {\n            if (pos.type === mat_constants_1.default.pointType.sharp) {\n                if (typeof window !== 'undefined' && window._debug_) {\n                    var _debug_ = window._debug_;\n                    _debug_.generated.sharpCorners.push({ pos: pos });\n                }\n            } else {\n                if (point_on_shape_1.default.isPointingStraightUp(pos)) {\n                    var key = point_on_shape_1.default.makeSimpleKey(pos.p);\n                    _this.straightUpHash[key] = pos;\n                }\n                if (typeof window !== 'undefined' && window._debug_) {\n                    if (pos.type === mat_constants_1.default.pointType.dull) {\n                        var _debug_2 = window._debug_;\n                        _debug_2.generated.dullCorners.push({ pos: pos });\n                    }\n                }\n            }\n        });\n        this.contactPointsPerLoop = createSharpCornerCpLoops(this, sharpCornersArray);\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            _debug_.generated.timing.after1Prongs = performance.now();\n        }\n    }\n    /**\r\n     * Applies f to each PointOnShape within the shape\r\n     * @param shape - The shape\r\n     * @param f - The function to call.\r\n     */\n\n\n    _createClass(Shape, null, [{\n        key: \"forEachPointOnShape\",\n        value: function forEachPointOnShape(shape, f) {\n            var pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n            for (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n                var pointsOnShape = pointsOnShapePerLoop[k];\n                var posNode = pointsOnShape.head;\n                do {\n                    var pos = posNode.item;\n                    f(pos);\n                    posNode = posNode.next;\n                } while (posNode !== pointsOnShape.head);\n            }\n        }\n        /**\r\n         * Get potential 2-prong points on shape.\r\n         * @param shape\r\n         */\n\n    }, {\n        key: \"getPotential2Prongs\",\n        value: function getPotential2Prongs(shape) {\n            var pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n            var sharpCornersArray = [];\n            var for2ProngsArray = [];\n            for (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n                var pointsOnShape = pointsOnShapePerLoop[k];\n                var sharpCorners = [];\n                var for2Prongs = [];\n                var posNode = pointsOnShape.head;\n                do {\n                    var pos = posNode.item;\n                    if (pos.type === mat_constants_1.default.pointType.sharp) {\n                        sharpCorners.push(pos);\n                    } else {\n                        for2Prongs.push(posNode);\n                    }\n                    posNode = posNode.next;\n                } while (posNode !== pointsOnShape.head);\n                sharpCornersArray.push(sharpCorners);\n                for2ProngsArray.push(for2Prongs);\n            }\n            return { sharpCornersArray: sharpCornersArray, for2ProngsArray: for2ProngsArray };\n        }\n        /**\r\n         * Get useful points on the shape - these incude osculating points and points at\r\n         * the bezier-bezier interfaces.\r\n         * @param shape\r\n         */\n\n    }, {\n        key: \"getInterestingPointsOnShape\",\n        value: function getInterestingPointsOnShape(shape) {\n            var bezierLoops = shape.bezierLoops;\n            var allPointsArray = [];\n            for (var k = 0; k < bezierLoops.length; k++) {\n                var bezierLoop = bezierLoops[k];\n                allPointsArray.push(Shape.getInterestingPointsOnLoop(shape, bezierLoop));\n            }\n            return allPointsArray;\n        }\n        /**\r\n         * TODO - uncomment and finish\r\n         * Get all points where shape intersect itself.\r\n         */\n        /*\r\n        function getSelfIntersections(shape: Shape) {\r\n            //aaa\r\n        }\r\n        */\n        /**\r\n         * @param shape\r\n         * @param bezierLoop\r\n         */\n\n    }, {\n        key: \"getInterestingPointsOnLoop\",\n        value: function getInterestingPointsOnLoop(shape, bezierLoop) {\n            var dullCornerHash = shape.dullCornerHash;\n            var points = [];\n            var allPoints = [];\n            var node = bezierLoop.head;\n            do {\n                //let bezier = node.item;\n                var pointsOnShape1 = get_contact_circles_at_bezier_bezier_interface_1.default([node.prev, node], dullCornerHash);\n                allPoints.push.apply(allPoints, _toConsumableArray(pointsOnShape1));\n                var pointsOnShape2 = get_bezier_osculating_circles_1.default(node);\n                allPoints.push.apply(allPoints, _toConsumableArray(pointsOnShape2));\n                // TODO - remove; experimenting\n                for (var i = 1; i < 2; i++) {\n                    var pos = new point_on_shape_1.default(node, i / 2, mat_constants_1.default.pointType.standard, 0, 0);\n                    allPoints.push(pos);\n                }\n                node = node.next;\n            } while (node !== bezierLoop.head);\n            // Ensure order - first point may be ordered last at this stage\n            // (due to bezier-bezier interface checking)\n            var firstPoint = allPoints[0];\n            var lastPoint = allPoints[allPoints.length - 1];\n            if (point_on_shape_1.default.compare(firstPoint, lastPoint) > 0) {\n                allPoints.push(firstPoint); // Add the first point to the end\n                allPoints.splice(0, 1); // ... and remove the front point.\n            }\n            allPoints.sort(point_on_shape_1.default.compare);\n            // Check if at least one 2-prong has been added. If not, add one.\n            var atLeast1 = false;\n            for (var _i = 0; _i < allPoints.length; _i++) {\n                if (allPoints[_i].type !== mat_constants_1.default.pointType.sharp) {\n                    atLeast1 = true;\n                    break;\n                }\n            }\n            //if (bezierLoop.indx === 0 && !atLeast1) {\n            if (!atLeast1) {\n                // Not a single potential 2-prong found on envelope. Add one \n                // to make the algorithm simpler from here on.\n                var _node = bezierLoop.head;\n                var _pos = new point_on_shape_1.default(_node, 0.4999995, // Can really be anything in the range (0,1)\n                mat_constants_1.default.pointType.standard, 0, 0);\n                allPoints.push(_pos);\n            }\n            return allPoints;\n        }\n        /**\r\n         * Returns the boundary piece that starts at the immediate previous point on\r\n         * the shape and ends at the immediate next point.\r\n         * Note: Uses a red-black tree to quickly find the required bounds\r\n         */\n\n    }, {\n        key: \"getNeighbouringPoints\",\n        value: function getNeighbouringPoints(shape, pos) {\n            var k = pos.bezierNode.loop.indx;\n            var cptree = shape.contactPointsPerLoop[k].cptree;\n            //let cps = cptree.findBounds({ item: new ContactPoint(pos) });\n            // TODO - ugly - improve code\n            var cps = cptree.findBounds(new list_node_1.default(undefined, new contact_point_1.default(pos, undefined), undefined, undefined));\n            if (!cps[0] && !cps[1]) {\n                // The tree is still empty\n                return [undefined, undefined];\n            }\n            if (!cps[0] || !cps[1]) {\n                // Smaller than all -> cptree.min() === cps[1].data OR\n                // Larger than all -> cptree.max() === cps[0].data\n                return [\n                //LlRbTree.max(cptree.root), \n                //LlRbTree.min(cptree.root)\n                cptree.max(cptree.root), cptree.min(cptree.root)];\n            }\n            return [cps[0].data, cps[1].data];\n        }\n    }]);\n\n    return Shape;\n}();\n/**\r\n * TODO - uncomment and finish implementation\r\n * Respace points so that the total absolute curvature between\r\n * consecutive points are very roughly equal.\r\n *\r\n * @param contactPointsPerLoop\r\n * @param maxAbsCurvatureInDegrees\r\n *\r\n * NOTES: Mutates contactPoints.\r\n */\n/*\r\nprivate static respacePoints(\r\n        contactPointsPerLoop: LinkedLoop<ContactPoint>[],\r\n        maxAbsCurvatureInDegrees: number) {\r\n    \r\n    for (let k=0; k<contactPointsPerLoop.length; k++) {\r\n        let contactPoints = contactPointsPerLoop[k];\r\n        \r\n        let cpNode = contactPoints.head;\r\n        let recheck;\r\n        do {\r\n            recheck = false;\r\n            \r\n            let totalCurvatures = [];\r\n            let denseCpNode = cpNode.coupledNode;\r\n            \r\n            do {\r\n                let c = getTotalAbsCurvatureBetweenCps(\r\n                        [denseCpNode.item, denseCpNode.next.item]\r\n                );\r\n                \r\n                totalCurvatures.push({cpNode: denseCpNode, c});\r\n                \r\n                denseCpNode = denseCpNode.next;\r\n            } while (denseCpNode.coupledNode !== cpNode.next);\r\n\r\n            let totalCurvature = sumCurvatures(totalCurvatures);\r\n            \r\n            cpNode.totalCurvatures = totalCurvatures;\r\n            cpNode.totalCurvature  = totalCurvature;\r\n            \r\n            \r\n            let totalInDegrees = totalCurvature * 180 / Math.PI;\r\n            // if (totalInDegrees > 180 || totalInDegrees < 5) { console.log(totalInDegrees); }\r\n            if (totalInDegrees > maxAbsCurvatureInDegrees) {\r\n                // Add a point\r\n                //console.log(totalCurvatures);\r\n                \r\n                let accumTot = 0;\r\n                let tc = cpNode.totalCurvature; // cache\r\n                let bestIndx = undefined;\r\n                let leftDenseIndx = 0;\r\n                let rightDenseIndx;\r\n                let accumTotAtLeft  = 0;\r\n                let accumTotAtRight = undefined;\r\n                let bestDiff = Number.POSITIVE_INFINITY;\r\n                for (let i=0; i<totalCurvatures.length; i++) {\r\n                    \r\n                    let c = totalCurvatures[i].c;\r\n                    let cTot = c.totalCurvature + c.totalTurn;\r\n                    accumTot += cTot;\r\n                    \r\n                    let cpn = totalCurvatures[i].cpNode;\r\n                    if (accumTot <= tc/2) {\r\n                        leftDenseIndx = i;\r\n                        accumTotAtLeft = accumTot;\r\n                    }\r\n\r\n                    if (!rightDenseIndx && accumTot > tc/2) {\r\n                        // This may be out of bounds but really means cpNode.next\r\n                        rightDenseIndx = i;\r\n                        accumTotAtRight = accumTot;\r\n                    }\r\n                \r\n                    let absDiff = Math.abs(tc/2 - accumTot);\r\n                    // TODO - We can also add a weight for point values here\r\n                    // such that for instance inverse curvature points\r\n                    // carry more weight than dull corners, etc.\r\n                    // TODO Make the 1/4 or 1/3 below a constant that can\r\n                    // be set.\r\n                    //if (accumTot > tc/3 && accumTot < 2*tc/3 &&\r\n                    if (accumTot > tc/4 && accumTot < 3*tc/4 &&\r\n                        bestDiff > absDiff) {\r\n                        // If within middle 1/3 and better\r\n                        \r\n                        bestIndx = i;\r\n                        bestDiff = absDiff;\r\n                    }\r\n                }\r\n\r\n                \r\n                // aaa console.log(leftDenseIndx, bestIndx, rightDenseIndx);\r\n                \r\n                if (bestIndx !== undefined) {\r\n                    // Reify the point\r\n                    let tcInfo = totalCurvatures[bestIndx];\r\n                    \r\n                    // Note that after the below insert cpNode.next will\r\n                    // equal the newly inserted cpNode.\r\n                    let newCpNode = LinkedLoop.insert(\r\n                            contactPoints,\r\n                            tcInfo.cpNode.next.item,\r\n                            cpNode,\r\n                            tcInfo.cpNode.next\r\n                    );\r\n                    tcInfo.cpNode.next.coupledNode = newCpNode;\r\n                    \r\n                    cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n                            0, bestIndx+1\r\n                    );\r\n                    cpNode.totalCurvature = sumCurvatures(\r\n                            cpNode.totalCurvatures\r\n                    );\r\n                    \r\n                    recheck = true; // Start again from same contact point.\r\n                } else {\r\n                    // We could not find an 'interesting' point to use, so\r\n                    // find some center point between the two contact\r\n                    // points.\r\n                    \r\n\r\n                    let leftTcInfo  = totalCurvatures[leftDenseIndx];\r\n                    let rightTcInfo = totalCurvatures[rightDenseIndx];\r\n                    \r\n                    let leftCpNode  = leftTcInfo. cpNode;\r\n                    let rightCpNode = rightTcInfo.cpNode;\r\n                    \r\n                    let leftC = leftTcInfo.c;\r\n                    \r\n                    let leftCp = leftTcInfo.cpNode.next;\r\n                    let rightCp = rightTcInfo.cpNode.next;\r\n                    \r\n                    //aaa console.log(accumTotAtLeft,\taccumTotAtRight, tc/2);\r\n                    \r\n                    \r\n                    let pos = getCPointBetweenCps(\r\n                            leftCpNode.item, rightCpNode.item,\r\n                            accumTotAtLeft,\taccumTotAtRight,\r\n                            tc/2\r\n                    );\r\n\r\n                    \r\n                    /*\r\n                    let newCp = new ContactPoint(pos, undefined);\r\n                    let newCpNode = LinkedLoop.insert(\r\n                            contactPoints,\r\n                            newCp,\r\n                            leftCpNode,\r\n                            undefined\r\n                    );\r\n                    \r\n                    let newDenseCpNode = LinkedLoop.insert(\r\n                            denseContactPoints,\r\n                            newCp,\r\n                            cpNode,\r\n                            undefined\r\n                    );\r\n                    \r\n                    newCpNode.coupledNode = newDenseCpNode;\r\n                    newDenseCpNode.coupledNode = newCpNode;\r\n                    \r\n                    \r\n                    aaa\r\n                    cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n                            0, bestIndx\r\n                    );\r\n                    cpNode.totalCurvature = sumCurvatures(\r\n                            cpNode.totalCurvatures\r\n                    );\r\n                    \r\n                    recheck = true; // Start again from same contact point.\r\n                    */ /*\r\n                       }\r\n                       } else if (totalInDegrees < 15) {\r\n                       // Remove a point\r\n                       //console.log(totalCurvatures);\r\n                       }\r\n                       if (!recheck) {\r\n                       cpNode = cpNode.next;\r\n                       }\r\n                       } while (cpNode !== contactPoints.head);\r\n                       }\r\n                       }*/\n/**\r\n *\r\n */\n\n\nShape.getBoundaryBeziers = function (shape, k) {\n    var bezierLoop = shape.bezierLoops[k];\n    var bezierPieces = [];\n    bezierLoop.forEach(function (bezierNode) {\n        var bezierPiece = new bezier_piece_1.default(bezierNode, [0, 1]);\n        bezierPieces.push(bezierPiece);\n    });\n    return bezierPieces;\n};\n/**\r\n *\r\n */\nShape.getTotalCurvature = getTotalBy(function (bezierNode) {\n    var bezierCurvature = flo_bezier3_1.default.totalCurvature(bezierNode.item.bezier3, [0, 1]);\n    var interfaceCurvature = getCurvatureAtInterface(bezierNode);\n    return bezierCurvature + interfaceCurvature;\n});\n/**\r\n *\r\n */\nShape.getTotalAbsoluteCurvature = getTotalBy(function (bezierNode) {\n    return flo_bezier3_1.default.totalAbsoluteCurvature(bezierNode.item.bezier3, [0, 1]) + Math.abs(getCurvatureAtInterface(bezierNode));\n});\n/**\r\n *\r\n */\nShape.forAllBeziers = function (f, shape) {\n    var bezierLoops = shape.bezierLoops;\n    for (var i = 0; i < bezierLoops.length; i++) {\n        var bezierLoop = bezierLoops[i];\n        var node = bezierLoop.head;\n        do {\n            var ps = node.item.bezier3;\n            f(ps);\n            node = node.next;\n        } while (node !== bezierLoop.head);\n    }\n};\n/**\r\n * Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n * from the given boundary piece.\r\n * @param δ - An ordered pair that represents the start and ending points of\r\n * the boundary piece\r\n * @param keepStraight - If true then don't go around any mat circles\r\n */\nShape.getBoundaryPieceBeziers = function (δ) {\n    var keepStraight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var cp0 = δ[0];\n    var cp1 = δ[1];\n    var bezierPieces = [];\n    // As opposed to going around the circle and taking the last exit\n    var goStraight = true;\n    do {\n        if (!goStraight && !keepStraight) {\n            goStraight = true;\n            // Actually, next, next, ..., i.e. take last exit\n            cp0 = cp0.prevOnCircle;\n            continue;\n        }\n        goStraight = false;\n        var posThis = cp0.item.pointOnShape;\n        var posNext = cp0.next.item.pointOnShape;\n        if (posNext.bezierNode === posThis.bezierNode && (posNext.t > posThis.t || posNext.t === posThis.t && posNext.order > posThis.order)) {\n            var pos = cp0.item.pointOnShape;\n            var bezierPiece = new bezier_piece_1.default(pos.bezierNode, [pos.t, posNext.t]);\n            bezierPieces.push(bezierPiece);\n        } else {\n            var _pos2 = cp0.item.pointOnShape;\n            var _bezierPiece = new bezier_piece_1.default(_pos2.bezierNode, [_pos2.t, 1]);\n            bezierPieces.push(_bezierPiece);\n            addSkippedBeziers(bezierPieces, posThis.bezierNode, posNext.bezierNode, posNext.t);\n        }\n        cp0 = cp0.next;\n    } while (cp0 !== cp1);\n    return bezierPieces;\n    /**\r\n     * Adds pieces of skipped beziers\r\n     */\n    function addSkippedBeziers(bezierPieces, bezierNode0, bezierNode1, t1) {\n        var ii = 0;\n        var bNode = bezierNode0;\n        do {\n            ii++;\n            bNode = bNode.next;\n            if (bNode === bezierNode1) {\n                var _bezierPiece2 = new bezier_piece_1.default(bNode, [0, t1]);\n                bezierPieces.push(_bezierPiece2);\n            } else {\n                var _bezierPiece3 = new bezier_piece_1.default(bNode, [0, 1]);\n                bezierPieces.push(_bezierPiece3);\n            }\n        } while (bNode !== bezierNode1 && ii < 100);\n        if (ii === 100) {\n            console.log('maxed');\n        }\n    }\n};\n/**\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornersArray\r\n */\nfunction createSharpCornerCpLoops(shape, sharpCornersArray) {\n    var contactPointsPerLoop = [];\n    var comparator = function comparator(a, b) {\n        return contact_point_1.default.compare(a.item, b.item);\n    };\n    for (var k = 0; k < sharpCornersArray.length; k++) {\n        var sharpCorners = sharpCornersArray[k];\n        var cpLoop = new linked_loop_1.default([], comparator, k);\n        var prevNode = undefined;\n        for (var i = 0; i < sharpCorners.length; i++) {\n            var pos = sharpCorners[i];\n            var cp = new contact_point_1.default(pos, undefined);\n            prevNode = cpLoop.insert(cp, prevNode, undefined);\n            var mCircle = mat_circle_1.default.create(point_on_shape_1.default.getOsculatingCircle(pos), [prevNode]);\n            prevNode.prevOnCircle = prevNode; // Trivial loop\n            prevNode.nextOnCircle = prevNode; // ...\n        }\n        contactPointsPerLoop.push(cpLoop);\n    }\n    return contactPointsPerLoop;\n}\n/**\r\n * Destructively orient the bezier loops so that the outermost loop is\r\n * positively oriented (i.e. counter-clockwise).\r\n */\nfunction orient(bezierLoops) {\n    var orientations = bezierLoops.map(isPathPositivelyOrientated);\n    //console.log(orientations)\n    if (!orientations[0]) {\n        return bezierLoops;\n    } else {\n        var loops = bezierLoops.map(function (loop, k) {\n            return reverseBeziersOrientation(loop, k);\n        });\n        return loops;\n    }\n}\n/**\r\n * Completely reverse the loop direction of the given bezier loop. Returns the\r\n * reversed loop.\r\n * @param bezierLoop\r\n * @param k\r\n */\nfunction reverseBeziersOrientation(bezierLoop, k) {\n    var beziers = [];\n    var bezierArray = bezierLoop.getAsArray();\n    var idx = 0;\n    for (var i = bezierArray.length - 1; i >= 0; i--) {\n        var curve = path_curve_1.default.reverse(bezierArray[i], idx);\n        idx++;\n        beziers.push(curve);\n    }\n    return new linked_loop_1.default(beziers, undefined, k);\n}\n/**\r\n * Returns the the top, left, bottom and right extreme points of the given\r\n * bezier loop, including the bezier nodes they belong to. If an extreme is at a\r\n * bezier-bezier interface the first bezier will always be used (at t=1).\r\n */\nvar getLoopBounds = memoize(function (bezierLoop) {\n    var INF = Number.POSITIVE_INFINITY;\n    var shapeBoundingBox = [[INF, INF], [-INF, -INF]];\n    var extremeBeziers = [[undefined, undefined], [undefined, undefined]];\n    bezierLoop.forEach(function (bezierNode) {\n        var ps = bezierNode.item.bezier3;\n        var boundingBox = flo_bezier3_1.default.getBoundingBox(ps);\n        //console.log(boundingBox)\n        for (var i = 0; i < 2; i++) {\n            for (var j = 0; j < 2; j++) {\n                var v = boundingBox[i][j];\n                var m = i === 0 ? 1 : -1;\n                if (m * v < m * shapeBoundingBox[i][j]) {\n                    shapeBoundingBox[i][j] = v;\n                    extremeBeziers[i][j] = bezierNode;\n                }\n            }\n        }\n    });\n    return { shapeBoundingBox: shapeBoundingBox, extremeBeziers: extremeBeziers };\n});\n/**\r\n * Returns true if the given beizer loop is positively orientated, false\r\n * otherwise.\r\n */\nvar isPathPositivelyOrientated = function isPathPositivelyOrientated(bezierLoop) {\n    var _getLoopBounds = getLoopBounds(bezierLoop),\n        extremeBeziers = _getLoopBounds.extremeBeziers;\n\n    var maxXBezierNode = extremeBeziers[1][0];\n    var ps = maxXBezierNode.item.bezier3;\n    var ts = flo_bezier3_1.default.getBounds(ps).ts;\n    var tAtMaxX = ts[1][0];\n    var tan = flo_bezier3_1.default.tangent(ps)(tAtMaxX);\n    if (tAtMaxX !== 1) {\n        // Not a sharp corner\n        return tan[1] > 0;\n    }\n    var psNext = maxXBezierNode.next.item.bezier3;\n    var tanNext = flo_bezier3_1.default.tangent(psNext)(0);\n    if (tan[1] * tanNext[1] > 0) {\n        // Both tangents points up or both points down.\n        return tan[1] > 0;\n    }\n    // One tangent points up and the other down.\n    return flo_vector2d_1.default.cross(tan, tanNext) > 0;\n    // We don't check for the very special case where the cross === 0. \n};\n/*\r\nclass LoopExtreme {\r\n    p: number[];\r\n    bezierNode: ListNode<number[][]>;\r\n    t: number;\r\n\r\n    constructor(p: number[], bezierNode: ListNode<number[][]>, t: number) {\r\n        this.p = p;\r\n        this.bezierNode = bezierNode;\r\n        this.t = t;\r\n    }\r\n}\r\n*/\n/**\r\n * Get topmost point, bezierNode and t-value of the given loop.\r\n */\nvar getExtremes = memoize(function (bezierLoop) {\n    var _getLoopBounds2 = getLoopBounds(bezierLoop),\n        extremeBeziers = _getLoopBounds2.extremeBeziers;\n\n    var bezierNode = extremeBeziers[0][1]; // Bezier at minimum y\n    var ts = flo_bezier3_1.default.getBounds(bezierNode.item.bezier3).ts;\n    var t = ts[0][1];\n    var p = flo_bezier3_1.default.evaluate(bezierNode.item.bezier3)(t);\n    //return new LoopExtreme(p, bezierNode, t);\n    return { p: p, bezierNode: bezierNode, t: t };\n});\n/**\r\n * Returns true if bezier box is entirely outside circle box, false otherwise.\r\n *\r\n * Given a circle, bound it tightly by an axes-aligned box (i.e. circle\r\n * box). And given a bezier, bound tightly by a rectangle (not\r\n * necessarily axes aligned) (i.e. bezier box).\r\n */\nfunction isBezierBoxWhollyOutsideCircleBox(ps, circle) {\n    //---- Cache\n    var r = circle.radius;\n    var ox = circle.center[0];\n    var oy = circle.center[1];\n    var radius_2 = r * r;\n    //---- Translate bezier tight bounding box (4 point rectangle) so that circle center is at origin. \n    var boxTight = flo_vector2d_1.default.translatePs([-ox, -oy], flo_bezier3_1.default.getBoundingBoxTight(ps));\n    //---- Rotate circle and rectangle together so that box rectangle is aligned with axes.\n    var boxDiagonal = flo_vector2d_1.default.fromTo(boxTight[0], boxTight[1]);\n    var l = flo_vector2d_1.default.len(boxDiagonal);\n    var sinθ = boxDiagonal[1] / l;\n    var cosθ = boxDiagonal[0] / l;\n    var rotateByθ = flo_vector2d_1.default.rotate(sinθ, -cosθ);\n    var b0 = rotateByθ(boxTight[0]);\n    var b1 = rotateByθ(boxTight[2]);\n    var anyBoxVerticalInside = b0[0] > -r && b0[0] < r || b1[0] > -r && b1[0] < r;\n    var boxVerticalsCapture = b0[0] < -r && b1[0] > r || b1[0] < -r && b0[0] > r;\n    var anyBoxHorizontalInside = b0[1] > -r && b0[1] < r || b1[1] > -r && b1[1] < r;\n    var boxHorizontalsCapture = b0[1] < -r && b1[1] > r || b1[1] < -r && b0[1] > r;\n    if (anyBoxVerticalInside && (anyBoxHorizontalInside || boxHorizontalsCapture) || anyBoxHorizontalInside && (anyBoxVerticalInside || boxVerticalsCapture) || boxVerticalsCapture && boxHorizontalsCapture) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * Floating-point 'safer' version of acos. If x is larger than 1 (or smaller\r\n * than -1), still returns 0 (or Math.PI) instead of NAN.\r\n * @param x\r\n * @example\r\n * \t\tacos(1);  //=> 0\r\n *      acos(2);  //=> 0\r\n */\nfunction acos(x) {\n    if (x > 1) {\n        return 0;\n    } else if (x < -1) {\n        return Math.PI;\n    }\n    return Math.acos(x);\n}\n/**\r\n * TODO - finish implementation - the function below with the same name\r\n * is temporary.\r\n * @param contactPointArr\r\n */ /*\r\n    function createCoupledLoops(contactPointArr, k) {\r\n     let comparator = (a,b) => ContactPoint.compare(a.item, b.item);\r\n    let cpLoop = new LinkedLoop([], comparator, k);\r\n    \n    let denseContactPoints = new LinkedLoop([], undefined, k);\r\n    \n    let prevCpNode = undefined;\r\n    let prevCoupledCpNode = undefined;\r\n    for (let i=0; i<contactPointArr.length; i++) {\r\n       let cp = contactPointArr[i];\r\n       let pos = cp.pointOnShape;\r\n       \r\n       prevCoupledCpNode = LinkedLoop.insert(\r\n               denseContactPoints, cp, prevCoupledCpNode\r\n       );\r\n       // TODO !!!!\r\n       /*\r\n       if (pos.type === MAT_CONSTANTS.pointType.dull) {\r\n           if (acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n               prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n           }\r\n       } else if (pos.type === MAT_CONSTANTS.pointType.sharp) {\r\n           if (acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n               prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n           }\r\n       } else {*/ /*\r\n                  prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n                  //}\r\n                  prevCoupledCpNode.coupledNode = prevCpNode;\r\n                  }\r\n                  return cpLoop;\r\n                  }*/\nfunction createCoupledLoops(pointOnShapeArr, k) {\n    var posLoop = new linked_loop_1.default([], undefined, k);\n    var prevNode = undefined;\n    for (var i = 0; i < pointOnShapeArr.length; i++) {\n        var pos = pointOnShapeArr[i];\n        prevNode = posLoop.insert(pos, prevNode, undefined);\n    }\n    return posLoop;\n}\n/**\r\n * TODO - uncomment and finish\r\n * Finds a point on the shape between the given contact points which\r\n * is as close as possible to a point with accumalated abs curvature\r\n * (from accumAtLeft) equal to totAtMid.\r\n *\r\n * @param leftCp\r\n * @param rightCp\r\n * @param accumTotAtLeft\r\n * @param accumTotAtRight\r\n * @param totAtMid\r\n * @returns {PointOnShape}\r\n */\n/*\r\nfunction getCPointBetweenCps(\r\n        leftCp: ContactPoint,\r\n        rightCp: ContactPoint,\r\n        accumTotAtLeft: number,\r\n        accumTotAtRight: number,\r\n        totAtMid: number) {\r\n    \r\n    let accumTo = totAtMid - accumTotAtLeft;\r\n    \r\n    let posStart = leftCp .pointOnShape;\r\n    let posEnd   = rightCp.pointOnShape;\r\n    \r\n    let bezierNodeStart = posStart.bezierNode;\r\n    let bezierNodeEnd   = posEnd.  bezierNode;\r\n    \r\n    let bezierNode = bezierNodeStart;\r\n    \r\n    let totalTurn = 0;\r\n    let totalCurvature = 0;\r\n    do {\r\n        let turn;\r\n        if (bezierNode !== bezierNodeEnd) {\r\n            turn = Math.abs(getCurvatureAtInterface(bezierNode));\r\n        } else {\r\n            turn = 0;\r\n        }\r\n        \r\n        \r\n        let curvature;\r\n        let interval = [0,1];\r\n        if (bezierNode === bezierNodeStart) { interval[0] = posStart.t; }\r\n        if (bezierNode === bezierNodeEnd)   { interval[1] = posEnd.t; }\r\n        curvature = Bezier3.getTotalAbsoluteCurvature(bezierNode.item.bezier3)(interval);\r\n\r\n        \r\n        totalTurn += turn;\r\n        totalCurvature += curvature;\r\n        \r\n        let totalBoth = totalTurn + totalCurvature;\r\n        if (totalBoth >= accumTo) {\r\n            // aaa console.log('accumTo: ' + accumTo, 'totalBoth: ' + totalBoth);\r\n            break;\r\n        }\r\n        \r\n        bezierNode = bezierNode.next;\r\n    } while (bezierNode.prev !== bezierNodeEnd);\r\n\r\n    \r\n    //return { totalTurn, totalCurvature };\r\n}\r\n*/\n/**\r\n * TODO - uncomment and finish\r\n */\n/*\r\nfunction sumCurvatures(curvatures: number[]): number {\r\n    let total = 0;\r\n    \r\n    for (let i=0; i<curvatures.length; i++) {\r\n        let c = curvatures[i].c;\r\n        \r\n        total += c.totalTurn + c.totalCurvature;\r\n    }\r\n    \r\n    return total;\r\n}\r\n*/\n/**\r\n * TODO - uncomment and finish\r\n * Calculates and returns total absolute curvature between\r\n * the given contact points.\r\n * @param {ContactPoint[]}\r\n * @returns {Object}\r\n */\n/*\r\nfunction getTotalAbsCurvatureBetweenCps([cpStart, cpEnd]) {\r\n    let posStart = cpStart.pointOnShape;\r\n    let posEnd   = cpEnd.  pointOnShape;\r\n    \r\n    let bezierNodeStart = posStart.bezierNode;\r\n    let bezierNodeEnd   = posEnd.  bezierNode;\r\n    \r\n    let bezierNode = bezierNodeStart;\r\n    \r\n    let totalTurn = 0;\r\n    let totalCurvature = 0;\r\n    do {\r\n        let turn;\r\n        if (bezierNode !== bezierNodeEnd) {\r\n            turn = Math.abs(getCurvatureAtInterface(bezierNode));\r\n        } else {\r\n            turn = 0;\r\n        }\r\n        \r\n        \r\n        let curvature;\r\n        let interval = [0,1];\r\n        if (bezierNode === bezierNodeStart) { interval[0] = posStart.t; }\r\n        if (bezierNode === bezierNodeEnd)   { interval[1] = posEnd.t; }\r\n        curvature = Bezier3.getTotalAbsoluteCurvature(bezierNode.item.bezier3)(interval);\r\n\r\n        \r\n        totalTurn += turn;\r\n        totalCurvature += curvature;\r\n        \r\n        bezierNode = bezierNode.next;\r\n    } while (bezierNode.prev !== bezierNodeEnd);\r\n\r\n    \r\n    return { totalTurn, totalCurvature };\r\n}\r\n*/\n/**\r\n * Get the angle between the given bezier endpoint and the\r\n * startpoint of the next bezier.\r\n * @param bezierNode\r\n */\nfunction getCurvatureAtInterface(bezierNode) {\n    var ts = [1, 0];\n    var pss = [bezierNode.item.bezier3, bezierNode.next.item.bezier3];\n    var tans = [flo_bezier3_1.default.tangent(pss[0])(1), flo_bezier3_1.default.tangent(pss[0])(0)];\n    // The integral of a kind of Dirac Delta function.\n    var cosθ = flo_vector2d_1.default.dot(tans[0], tans[1]);\n    var sinθ = flo_vector2d_1.default.cross(tans[0], tans[1]);\n    var θ = acos(cosθ);\n    var result = sinθ >= 0 ? θ : -θ;\n    return result;\n}\n/**\r\n * @description Helper function.\r\n * @param f\r\n * @returns {Funtion}\r\n */\nfunction getTotalBy(f) {\n    return function (bezierLoop) {\n        var node = bezierLoop.head;\n        var total = 0;\n        do {\n            total += f(node);\n            node = node.next;\n        } while (node !== bezierLoop.head);\n        return total;\n    };\n}\nexports.default = Shape;\n\n},{\"../../geometry/classes/bezier-piece\":5,\"../../geometry/classes/path-curve\":8,\"../../geometry/classes/point-on-shape\":9,\"../../linked-list/linked-loop\":16,\"../../linked-list/list-node\":17,\"../../mat-constants\":18,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../functions/get-bezier-osculating-circles\":12,\"../functions/get-contact-circles-at-bezier-bezier-interface\":14,\"flo-bezier3\":39,\"flo-memoize\":46,\"flo-vector2d\":55}],11:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DELTA = 1e-6;\n/**\r\n * Calculates the curvature extrema brackets of the given\r\n * bezier.\r\n *\r\n * See the paper at: http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Note that naming conventions is roughly as in the paper above.\r\n */\nfunction calcBezierCurvatureExtremaBrackets(ps) {\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 2),\n        x0 = _ps$[0],\n        y0 = _ps$[1],\n        _ps$2 = _slicedToArray(_ps[1], 2),\n        x1 = _ps$2[0],\n        y1 = _ps$2[1],\n        _ps$3 = _slicedToArray(_ps[2], 2),\n        x2 = _ps$3[0],\n        y2 = _ps$3[1],\n        _ps$4 = _slicedToArray(_ps[3], 2),\n        x3 = _ps$4[0],\n        y3 = _ps$4[1];\n\n    var brackets = [];\n    // Bezier points translated to origin;\n    var P_1x = x1 - x0;\n    var P_1y = y1 - y0;\n    var P_2x = x2 - x0;\n    var P_2y = y2 - y0;\n    var P_3x = x3 - x0;\n    var P_3y = y3 - y0;\n    // Distance to consecutive points\n    var W_0x = P_1x;\n    var W_1x = P_2x - P_1x;\n    var W_2x = P_3x - P_2x;\n    var W_0y = P_1y;\n    var W_1y = P_2y - P_1y;\n    var W_2y = P_3y - P_2y;\n    // Check for degenerate case in which cubic curve becomes quadratic. \n    if (Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA && Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA) {}\n    // TODO - This case is simpler due to being quadratic but we're \n    // lazy now and will skip it for the moment. \n\n    // See : http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n    // Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\n    var atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\n    var atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\n    var atan_numer_squared = atan_numer * atan_numer;\n    var atan_denom_squared = atan_denom * atan_denom;\n    var radpre = atan_numer_squared / atan_denom_squared + 1;\n    var rad = Math.sqrt(radpre);\n    var cos_theta = 1 / rad;\n    var sin_theta = void 0;\n    if (cos_theta === 0) {\n        sin_theta = 1;\n    } else {\n        sin_theta = atan_numer / (atan_denom * rad);\n    }\n    // For next rotated points see Maxima file bez5 - here we skip \n    // expensive trig evaluations\n    var R_0x = 0;\n    var R_0y = 0;\n    var R_1x = P_1x * cos_theta - P_1y * sin_theta;\n    var R_1y = P_1x * sin_theta + P_1y * cos_theta;\n    var R_2x = P_2x * cos_theta - P_2y * sin_theta;\n    var R_2y = P_2x * sin_theta + P_2y * cos_theta;\n    var R_3x = P_3x * cos_theta - P_3y * sin_theta;\n    var R_3y = P_3x * sin_theta + P_3y * cos_theta;\n    // Modify W_0x, etc. to be correct for new rotated curve \n    W_0x = R_1x;\n    W_1x = R_2x - R_1x;\n    W_2x = R_3x - R_2x;\n    W_0y = R_1y;\n    W_1y = R_2y - R_1y;\n    W_2y = R_3y - R_2y;\n    var a_ = 3 * (W_0y - 2 * W_1y + W_2y);\n    var dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\n    if (dif === 0) {\n        // Case 1 (special) - W_1x - W_0x === 0\n        // Degenerate to cubic function\t\n        if (W_0x !== 0) {\n            // TODO - FINISH!!!\n            // TODO - we also still need to check for degenerate cubic \n            // (see start of paper)\n        } else {\n            // We have a straight line x=0!\n            return [];\n        }\n    } else {\n        // Case 2 (usual) - W_1x - W_0x !== 0\n        if (dif < 0) {\n            // Reflect curve accross y-axis to make dif > 0\n            R_1x = -R_1x;\n            R_2x = -R_2x;\n            R_3x = -R_3x;\n            // Modify W_0x, etc. to be correct for new reflected \n            W_0x = -W_0x;\n            W_1x = -W_1x;\n            W_2x = -W_2x;\n            dif = -dif;\n        }\n        // From the paper:\n        // ---------------\n        // All curves has exactly one of 4 cases:\n        //\n        // 1. It has a single inflection point and exactly 2 curvature \n        //    maxima (symmetrically positioned about inflection point).\n        //    This is the case if dif === 0 in above code.\n        // 2. It has a single cusp - we ignore this case for now - but \n        //    we must still do it!\n        // 3. It has a point of self-intersection - occurs if d < 0 in \n        //    paper (in code d is called sigd_). \n        // 4. It has 2 inflection points, no cusps, no self-\n        //    intersections.\n        //    It can have either 3 or 5 curvature extrema\n        //    a. The case of 5 curvature extrema is ignored for now - \n        //       in the paper it is mentioned to even find such a curve \n        //       is difficult and it seems such curves have very sharp \n        //       curvature at one point which should not usually occur \n        //       in an SVG shape. \n        //       But this case should later be included or we'll miss \n        //       some points.\n        //    b. There are 3 curvature extrema:\n        //       Extrema occur in the range (-inf, -sqrt(d)), \n        //       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \n        //       Since we dont know how to select -inf and inf we will \n        //       just choose them to be -10 and 11 (remember bezier runs \n        //       from t=0 to t=1). If Brent's method runs out of the \n        //       (0,1) interval we stop and use 0 or 1 as the extremum? \n        //       Remember extrema can also occur at t=0 and t=1!\n        //\n        // At the moment we only test for case 1 and 4b, but in future \n        // we can test and eliminate the other cases.\n        var mu = 6 * dif;\n        var lambda = 3 * a_ * W_0x / (mu * mu);\n        var gamma1 = 3 * a_ * W_0y / (mu * mu);\n        var gamma2 = 3 * (W_1y - W_0y) / mu;\n        // This d in the paper\n        var sigd_ = lambda * lambda - 2 * gamma2 * lambda + gamma1;\n        var b_ = 2 * (gamma2 - lambda);\n        var deReParamBoundary = deReParameterizeBoundary(lambda, mu, a_);\n        if (sigd_ > 0) {\n            var ssigd_ = Math.sqrt(sigd_);\n            //console.log(ssigd_);\n            // de-reparametize\n            // Note: the sda and sdb here are the inflection points for \n            // a case iv!! there are easier ways to calculate these\n            var sda = -ssigd_;\n            var sdb = ssigd_;\n            brackets = [[Number.NEGATIVE_INFINITY, sda], [sda, sdb], [sdb, Number.POSITIVE_INFINITY]].map(deReParamBoundary).map(clipBoundary);\n        } else if (sigd_ < 0) {\n            // Loop \n            // Note: The loop intersection may be outside t=[0,1]. \n            // In fact, for a well behaved shape this is always the \n            // case.\n            // But, curvature maxima may still occur inside t=[0,1] \n            // of course.\n            // There can be 1 or 3 maxima of curvature\n            var ksi_pre1 = 2 * b_ * b_ - 8 * sigd_ - 3;\n            if (ksi_pre1 < 0) {\n                brackets = [[0, Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n            } else {\n                var ksi_pre2 = Math.sqrt(5 * ksi_pre1);\n                var ksi1 = (-5 * b_ - ksi_pre2) / 10;\n                var ksi2 = (-5 * b_ + ksi_pre2) / 10;\n                brackets = [[Number.NEGATIVE_INFINITY, ksi1], [ksi1, Math.min(0, ksi2)], [Math.max(0, ksi2), Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n            }\n        } else if (sigd_ === 0) {\n            // TODO Cusp - ignore for now - lazy\n        }\n    }\n    return brackets;\n}\n/**\r\n * Clips to [0,1] or returns false if not within [0,1].\r\n * @private\r\n */\nfunction clipBoundary(bound) {\n    var b0 = bound[0];\n    var b1 = bound[1];\n    if (b0 < 0 && b1 < 0 || b0 > 1 && b1 > 1) {\n        return undefined;\n    }\n    if (b0 < 0) {\n        b0 = 0;\n    }\n    if (b0 > 1) {\n        b0 = 1;\n    }\n    if (b1 < 0) {\n        b1 = 0;\n    }\n    if (b1 > 1) {\n        b1 = 1;\n    }\n    return [b0, b1];\n}\n/**\r\n * @private\r\n */\nfunction deReParameterize(lambda, mu, a_) {\n    return function (sigma) {\n        return (sigma - lambda) * (mu / a_);\n    };\n}\n/**\r\n * @private\r\n */\nfunction deReParameterizeBoundary(lambda, mu, a_) {\n    return function (boundary) {\n        return boundary.map(deReParameterize(lambda, mu, a_));\n    };\n}\n;\nexports.default = calcBezierCurvatureExtremaBrackets;\n\n},{}],12:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar calc_bezier_curvature_extrema_1 = _dereq_(\"./calc-bezier-curvature-extrema\");\n/**\r\n * Finds the osculating circles for the given bezier.\r\n */\nfunction getBezierOsculatingCircles(bezierNode) {\n    var pointsOnShape = [];\n    var root = void 0;\n    var ps = bezierNode.item.bezier3;\n    var brackets = calc_bezier_curvature_extrema_1.default(ps);\n    var κPs = flo_bezier3_1.default.κ(ps);\n    var lenb = brackets.length;\n    for (var k = 0; k < lenb; k++) {\n        var bracket = brackets[k];\n        if (!bracket) {\n            continue;\n        }\n        var _root = lookForRoot(ps, bracket);\n        if (!_root) {\n            continue;\n        }\n        var κ = -κPs(_root);\n        // Check if local extrema is a maximum or minimum.\n        var κAtMinsd = -κPs(bracket[0]);\n        var κAtMaxsd = -κPs(bracket[1]);\n        if (κ > κAtMinsd && κ > κAtMaxsd) {\n            // maximum\n        } else if (κ <= κAtMinsd && κ <= κAtMaxsd) {\n            // minimum\n            continue;\n        }\n        var pos = new point_on_shape_1.default(bezierNode, _root, mat_constants_1.default.pointType.standard, 0, 0);\n        pointsOnShape.push(pos);\n    }\n    pointsOnShape.sort(point_on_shape_1.default.compare);\n    return pointsOnShape;\n}\nfunction lookForRoot(ps, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        minsd = _ref2[0],\n        maxsd = _ref2[1];\n\n    // At this point there can be exactly 0 or 1 roots within \n    // [minsd, maxsd]\n    var c0 = flo_bezier3_1.default.dκMod(ps)(minsd);\n    var c1 = flo_bezier3_1.default.dκMod(ps)(maxsd);\n    if (c0 * c1 >= 0) {\n        return;\n    }\n    // There is exactly one root in the interval.\n    var root = flo_poly_1.default.brent(flo_bezier3_1.default.dκMod(ps), minsd, maxsd);\n    return root;\n}\nexports.default = getBezierOsculatingCircles;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat-constants\":18,\"./calc-bezier-curvature-extrema\":11,\"flo-bezier3\":39,\"flo-poly\":47}],13:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar geometry_1 = _dereq_(\"../geometry\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar Point_on_shape_1 = _dereq_(\"../classes/Point-on-shape\");\n/**\r\n * Gets the closest boundary point to the given point, limited to the\r\n * given bezier pieces.\r\n *\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedBezierNode\r\n * @returns {PointOnShape} The closest point.\r\n */\nfunction getClosestBoundaryPointToPoint(bezierPieces_, point, touchedBezierNode, t) {\n    var bezierPieces = cullBezierPieces(bezierPieces_, point);\n    var bestDistance = Number.POSITIVE_INFINITY;\n    var pos = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var bezierPiece = _step.value;\n\n            //let bezier = bezierPiece.bezierNode.item;\n            var p = closestPointOnBezier(bezierPiece.bezierNode, point, bezierPiece.tRange, touchedBezierNode, t);\n            var d = p === undefined ? Number.POSITIVE_INFINITY : flo_vector2d_1.default.distanceBetween(p.p, point);\n            if (d < bestDistance) {\n                pos = new Point_on_shape_1.default(bezierPiece.bezierNode, p.t, mat_constants_1.default.pointType.standard, 0, 0);\n                bestDistance = d;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return pos;\n}\nfunction cullBezierPieces(bezierPieces, p) {\n    var CULL_THRESHOLD = 5; // TODO Put somewhere better.\n    var shortCircuit = bezierPieces.length > CULL_THRESHOLD;\n    if (shortCircuit) {\n        // First get an initial point such that the closest point can not be \n        // further than this point.\n        var bestSquaredDistance = getClosePoint(bezierPieces, p);\n        bezierPieces = cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\n        bezierPieces = cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\n    }\n    return bezierPieces;\n}\n/**\r\n * Finds an initial point such that the closest point can not be further than\r\n * this point.\r\n */\nfunction getClosePoint(bezierPieces, p) {\n    var bestSquaredDistance = Number.POSITIVE_INFINITY;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = bezierPieces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var bezierPiece = _step2.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var evPs = flo_bezier3_1.default.evaluate(ps);\n            var p1 = evPs(bezierPiece.tRange[0]);\n            var p2 = evPs(bezierPiece.tRange[1]);\n            var d1 = flo_vector2d_1.default.squaredDistanceBetween(p, p1);\n            var d2 = flo_vector2d_1.default.squaredDistanceBetween(p, p2);\n            var d = Math.min(d1, d2);\n            if (d < bestSquaredDistance) {\n                bestSquaredDistance = d;\n            }\n        }\n        // The extra bit is to account for floating point precision \n        // TODO change 0.01 below to more meaningfull value dependent on \n        // shape dimensions.\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    return bestSquaredDistance + 0.01;\n}\n/**\r\n * When checking distances, ignore all those with closest\r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    var candidateBezierPieces = [];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = bezierPieces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var bezierPiece = _step3.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var boundingBox = flo_bezier3_1.default.getBoundingBox(ps);\n            var d = geometry_1.default.getClosestSquareDistanceToRect(boundingBox, p);\n            if (d <= bestSquaredDistance) {\n                candidateBezierPieces.push(bezierPiece);\n            }\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    return candidateBezierPieces;\n}\n/**\r\n * When checking distances, ignore all those with closest\r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n    var candidateBezierPieces = [];\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n        for (var _iterator4 = bezierPieces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var bezierPiece = _step4.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var tightBoundingBox = flo_bezier3_1.default.getBoundingBoxTight(ps);\n            var d = geometry_1.default.closestSquaredDistanceToRotatedRect(tightBoundingBox, p);\n            if (d <= bestSquaredDistance) {\n                candidateBezierPieces.push(bezierPiece);\n            }\n        }\n    } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n            }\n        } finally {\n            if (_didIteratorError4) {\n                throw _iteratorError4;\n            }\n        }\n    }\n\n    return candidateBezierPieces;\n}\n/**\r\n * @private\r\n * @param bezierNode - The bezier\r\n * @param p - The point from which to check\r\n * @param tRange - The allowed t range\r\n * @param touchedBezierNode - The bezier on which p is located\r\n * @param t - The t value of the bezier that locates p\r\n */\nfunction closestPointOnBezier(bezierNode, p, tRange, touchedBezierNode, t) {\n    var ps = bezierNode.item.bezier3;\n    // TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\n    // may hint at requiring much fewer assignments?\n\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 2),\n        x0 = _ps$[0],\n        y0 = _ps$[1],\n        _ps$2 = _slicedToArray(_ps[1], 2),\n        x1 = _ps$2[0],\n        y1 = _ps$2[1],\n        _ps$3 = _slicedToArray(_ps[2], 2),\n        x2 = _ps$3[0],\n        y2 = _ps$3[1],\n        _ps$4 = _slicedToArray(_ps[3], 2),\n        x3 = _ps$4[0],\n        y3 = _ps$4[1];\n\n    var _p = _slicedToArray(p, 2),\n        xp = _p[0],\n        yp = _p[1];\n\n    var xx0 = x0 - xp;\n    var xx1 = x1 - xp;\n    var xx2 = x2 - xp;\n    var xx3 = x3 - xp;\n    var yy0 = y0 - yp;\n    var yy1 = y1 - yp;\n    var yy2 = y2 - yp;\n    var yy3 = y3 - yp;\n    var x00 = xx0 * xx0;\n    var x01 = 6 * xx0 * xx1;\n    var x02 = 6 * xx0 * xx2;\n    var x03 = 2 * xx0 * xx3;\n    var x11 = 9 * xx1 * xx1;\n    var x12 = 18 * xx1 * xx2;\n    var x13 = 6 * xx1 * xx3;\n    var x22 = 9 * xx2 * xx2;\n    var x23 = 6 * xx2 * xx3;\n    var x33 = xx3 * xx3;\n    var y00 = yy0 * yy0;\n    var y01 = 6 * yy0 * yy1;\n    var y02 = 6 * yy0 * yy2;\n    var y03 = 2 * yy0 * yy3;\n    var y11 = 9 * yy1 * yy1;\n    var y12 = 18 * yy1 * yy2;\n    var y13 = 6 * yy1 * yy3;\n    var y22 = 9 * yy2 * yy2;\n    var y23 = 6 * yy2 * yy3;\n    var y33 = yy3 * yy3;\n    var t5 = 6 * (x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00 + (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\n    var t4 = 5 * (x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00 + (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\n    var t3 = 4 * (x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00 + (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\n    var t2 = 3 * (x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00 + (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\n    var t1 = 2 * (x02 + x11 - 5 * x01 + 15 * x00 + (y02 + y11 - 5 * y01 + 15 * y00));\n    var t0 = x01 - 6 * x00 + (y01 - 6 * y00);\n    var poly = [t5, t4, t3, t2, t1, t0];\n    if (bezierNode === touchedBezierNode) {\n        var deflatedPoly = flo_poly_1.default.deflate(poly, t);\n        poly = deflatedPoly;\n    }\n    var roots = flo_poly_1.default.allRoots(poly, tRange[0], tRange[1]);\n    var push0 = true;\n    var push1 = true;\n    if (t === 1 && bezierNode === touchedBezierNode.next || bezierNode === touchedBezierNode && t === 0) {\n        push0 = false;\n    }\n    if (t === 0 && bezierNode === touchedBezierNode.prev || bezierNode === touchedBezierNode && t === 1) {\n        push1 = false;\n    }\n    if (tRange[0] === 0) {\n        if (push0) {\n            roots.push(tRange[0]);\n        }\n    } else if (tRange[0] === 1) {\n        if (push1) {\n            roots.push(tRange[0]);\n        }\n    } else {\n        roots.push(tRange[0]);\n    }\n    if (tRange[1] === 0) {\n        if (push0) {\n            roots.push(tRange[1]);\n        }\n    } else if (tRange[1] === 1) {\n        if (push1) {\n            roots.push(tRange[1]);\n        }\n    } else {\n        roots.push(tRange[1]);\n    }\n    /*\r\n    let closestPs = roots.map(function(root) {\r\n        return Bezier3.evaluate(ps)(root);\r\n    });\r\n    let closestPoint = Vector.getClosestTo(p, closestPs);\r\n    */\n    var closestPs = roots.map(function (root) {\n        return { p: flo_bezier3_1.default.evaluate(ps)(root), t: root };\n    });\n    var closestPoint = getClosest(p, closestPs, function (p1, p2) {\n        return flo_vector2d_1.default.squaredDistanceBetween(p1, p2.p);\n    });\n    return closestPoint;\n}\nfunction getClosest(p, ps, f) {\n    var cp = undefined; // Closest Point\n    var bestd = Number.POSITIVE_INFINITY;\n    for (var i = 0; i < ps.length; i++) {\n        var p_ = ps[i];\n        var d = f(p, p_);\n        if (d < bestd) {\n            cp = p_;\n            bestd = d;\n        }\n    }\n    return cp;\n}\nexports.default = getClosestBoundaryPointToPoint;\n\n},{\"../../mat-constants\":18,\"../classes/Point-on-shape\":3,\"../geometry\":15,\"flo-bezier3\":39,\"flo-poly\":47,\"flo-vector2d\":55}],14:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar corner_1 = _dereq_(\"../classes/corner\");\n// Angle in degrees\nvar DEGREES = {\n    '0': 0.0000,\n    '0.25': 0.0050,\n    '1': 0.0167,\n    '4': 0.0698,\n    '15': 0.2588,\n    '16': 0.2756\n};\nvar CROSS_TANGENT_LIMIT = DEGREES[0.25];\n/**\r\n * Get the circles at the bezier-bezier interface points with circle\r\n * curvature coinciding with the bezier curvature at those points.\r\n *\r\n * @param bezierNodes - The two bezier nodes.\r\n **/\n// TODO dullCornerHash should not be modified inside the function\nfunction getContactCirclesAtBezierBezierInterface(bezierNodes, dullCornerHash) {\n    var ts = [1, 0];\n    var beziers = [0, 1].map(function (i) {\n        return bezierNodes[i].item.bezier3;\n    });\n    var tans = [0, 1].map(function (i) {\n        return flo_bezier3_1.default.tangent(beziers[i], ts[i]);\n    });\n    var crossTangents = +flo_vector2d_1.default.cross(tans[0], tans[1]);\n    var negDot = -flo_vector2d_1.default.dot(tans[0], tans[1]);\n    // The if below is important. Due to floating point approximation\n    // it sometimes happen that crossTangents !== 0 but\n    // negDot === -1. Remove the if and see what happens. :)\n    if (crossTangents === 0 || negDot === -1) {\n        // Too close to call \n        return [];\n    }\n    var p = beziers[0][3];\n    if (crossTangents < -CROSS_TANGENT_LIMIT) {\n        // Sharp corner\n        var pos = new point_on_shape_1.default(bezierNodes[0], 1, mat_constants_1.default.pointType.sharp, 0, 0);\n        return [pos];\n    }\n    if (crossTangents > 0) {\n        var key = point_on_shape_1.default.makeSimpleKey(p);\n        dullCornerHash[key] = new corner_1.default(beziers, tans);\n    }\n    if (crossTangents <= CROSS_TANGENT_LIMIT) {\n        // The interface is too straight, but put a point close-by.\n        // TODO - this point may be order wrong in the end causing \n        // disaster. Fix.\n        var _pos = new point_on_shape_1.default(bezierNodes[0], 0.9, mat_constants_1.default.pointType.standard, 0, 0);\n        return [_pos];\n    }\n    //---- Dull corner\n    var pointsOnShape = [];\n    var orders = [-1, negDot];\n    for (var i = 0; i < 2; i++) {\n        var _pos2 = new point_on_shape_1.default(bezierNodes[i], ts[i], mat_constants_1.default.pointType.dull, orders[i], 0);\n        pointsOnShape.push(_pos2);\n    }\n    return pointsOnShape;\n}\nexports.default = getContactCirclesAtBezierBezierInterface;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat-constants\":18,\"../classes/corner\":7,\"flo-bezier3\":39,\"flo-vector2d\":55}],15:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar circle_1 = _dereq_(\"./classes/circle\");\nvar shape_1 = _dereq_(\"./classes/shape\");\nvar arc_1 = _dereq_(\"./classes/arc\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or null if they don't intersect or are the same line.\r\n * @param l1 - The first line\r\n * @param l2 - The second line\r\n */\nfunction lineLineIntersection(l1, l2) {\n    var _l = _slicedToArray(l1, 2),\n        _l$ = _slicedToArray(_l[0], 2),\n        p1x = _l$[0],\n        p1y = _l$[1],\n        _l$2 = _slicedToArray(_l[1], 2),\n        p2x = _l$2[0],\n        p2y = _l$2[1];\n\n    var _l2 = _slicedToArray(l2, 2),\n        _l2$ = _slicedToArray(_l2[0], 2),\n        p3x = _l2$[0],\n        p3y = _l2$[1],\n        _l2$2 = _slicedToArray(_l2[1], 2),\n        p4x = _l2$2[0],\n        p4y = _l2$2[1];\n\n    var v1x = p2x - p1x;\n    var v1y = p2y - p1y;\n    var v2x = p4x - p3x;\n    var v2y = p4y - p3y;\n    var cross = v2x * v1y - v2y * v1x;\n    if (cross === 0) {\n        // parallel\n        return undefined;\n    }\n    var b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\n    return [p3x + b * v2x, p3y + b * v2y];\n}\n/**\r\n * Get line shape intersection points.\r\n *\r\n * @param line A line described by two points\r\n * @param δ A boundary piece described by start and end contact points\r\n *\r\n * Currently not used\r\n */\nfunction getLineBoundaryIntersectionPoints(line, δ) {\n    var points = [];\n    var bezierPieces = shape_1.default.getBoundaryPieceBeziers(δ);\n    for (var i = 0; i < bezierPieces.length; i++) {\n        var bezierPiece = bezierPieces[i];\n        var ps = bezierPiece.bezierNode.item.bezier3;\n        var iPoints = getLineBezierIntersectionPoints(line, ps, bezierPiece.tRange);\n        for (var j = 0; j < iPoints.length; j++) {\n            points.push(iPoints[j].p);\n        }\n    }\n    return points;\n}\n/**\r\n * @description .\r\n */\nfunction closestSquaredDistanceToRotatedRect(ps, p) {\n    var tightBoundingBox = ps;\n    var ds = [0, 1, 2, 3].map(function (i) {\n        return flo_vector2d_1.default.squaredDistanceBetweenPointAndLineSegment(p, [tightBoundingBox[i], tightBoundingBox[(i + 1) % 4]]);\n    });\n    return Math.min.apply(Math, _toConsumableArray(ds));\n}\n/**\r\n * .\r\n */\nfunction getClosestSquareDistanceToRect(box, p) {\n    var _box = _slicedToArray(box, 2),\n        _box$ = _slicedToArray(_box[0], 2),\n        x0 = _box$[0],\n        y0 = _box$[1],\n        _box$2 = _slicedToArray(_box[1], 2),\n        x1 = _box$2[0],\n        y1 = _box$2[1];\n\n    var _p = _slicedToArray(p, 2),\n        xp = _p[0],\n        yp = _p[1];\n\n    if (xp < x0) {\n        if (yp < y0) {\n            return flo_vector2d_1.default.squaredDistanceBetween(box[0], p);\n        } else if (yp > y1) {\n            return flo_vector2d_1.default.squaredDistanceBetween([x0, y1], p);\n        } else {\n            var d = x0 - xp;\n            return d * d;\n        }\n    } else if (xp > x1) {\n        if (yp < y0) {\n            return flo_vector2d_1.default.squaredDistanceBetween([x1, y0], p);\n        } else if (yp > y1) {\n            return flo_vector2d_1.default.squaredDistanceBetween(box[1], p);\n        } else {\n            var _d = xp - x1;\n            return _d * _d;\n        }\n    } else {\n        if (yp < y0) {\n            var _d2 = y0 - yp;\n            return _d2 * _d2;\n        } else if (yp > y1) {\n            var _d3 = yp - y1;\n            return _d3 * _d3;\n        } else {\n            return 0;\n        }\n    }\n}\n/**\r\n * Returns the angle (in degrees) given the sine and the cosine of an angle.\r\n * @private\r\n */\nfunction degAngleFromSinCos(sinθ, cosθ) {\n    var toDeg = function toDeg(θ) {\n        return θ * (180 / Math.PI);\n    };\n    if (cosθ === 0) {\n        if (sinθ > 0) {\n            return 90;\n        }\n        return 270;\n    }\n    if (cosθ > 0) {\n        return toDeg(Math.atan(sinθ / cosθ));\n    }\n    return 180 + toDeg(Math.atan(sinθ / cosθ));\n}\n/**\r\n * Returns a directional arc from 3 ordered points.\r\n */\nfunction arcFrom3Points(ps) {\n    var midPoint1 = flo_vector2d_1.default.mean([ps[0], ps[1]]);\n    var midPoint2 = flo_vector2d_1.default.mean([ps[1], ps[2]]);\n    var chord1 = flo_vector2d_1.default.fromTo(ps[0], ps[1]);\n    var chord2 = flo_vector2d_1.default.fromTo(ps[1], ps[2]);\n    var perpendicular1 = [chord1[1], -chord1[0]];\n    var perpendicular2 = [chord2[1], -chord2[0]];\n    var l1 = [midPoint1, flo_vector2d_1.default.translate(perpendicular1, midPoint1)];\n    var l2 = [midPoint2, flo_vector2d_1.default.translate(perpendicular2, midPoint2)];\n    var circleCenter = lineLineIntersection(l1, l2);\n    var arc = void 0;\n    if (!circleCenter) {\n        // TODO - not right - fix\n        /*\r\n        // The circle is in effect a line segment.\r\n        if (Vector.equal(ps[0], ps[2])) {\r\n            return null;\r\n        }\r\n        arc = new Arc(null, ps[0], ps[2]);\r\n        return arc;\r\n        */\n        return undefined;\n    }\n    var sideVector1 = flo_vector2d_1.default.fromTo(circleCenter, ps[0]);\n    var midVector = flo_vector2d_1.default.fromTo(circleCenter, ps[1]);\n    var sideVector2 = flo_vector2d_1.default.fromTo(circleCenter, ps[2]);\n    var radius = flo_vector2d_1.default.len(sideVector1);\n    var sinθ1 = -sideVector1[1] / radius;\n    var cosθ1 = sideVector1[0] / radius;\n    var sinθ2 = -sideVector2[1] / radius;\n    var cosθ2 = sideVector2[0] / radius;\n    var sin_midangle = -midVector[1] / radius;\n    var cos_midangle = midVector[0] / radius;\n    if (isAngleBetween(sin_midangle, cos_midangle, sinθ1, cosθ1, sinθ2, cosθ2)) {\n        arc = new arc_1.default(new circle_1.default(circleCenter, radius), sinθ1, cosθ1, sinθ2, cosθ2, ps[0], ps[2]);\n    } else {\n        arc = new arc_1.default(new circle_1.default(circleCenter, radius), sinθ2, cosθ2, sinθ1, cosθ1, ps[2], ps[0]);\n    }\n    return arc;\n}\n/**\r\n * @description .\r\n */\nfunction quadrant(sinθ, cosθ) {\n    if (sinθ >= 0) {\n        if (cosθ >= 0) {\n            return 1;\n        }\n        return 2;\n    }\n    if (cosθ >= 0) {\n        return 4;\n    }\n    return 3;\n}\n/**\r\n * @description .\r\n */\nfunction isAngle1LargerOrEqual(sinθ1, cosθ1, sinθ2, cosθ2) {\n    var q1 = quadrant(sinθ1, cosθ1);\n    var q2 = quadrant(sinθ2, cosθ2);\n    if (q1 > q2) {\n        return true;\n    }\n    if (q1 < q2) {\n        return false;\n    }\n    // Same quadrant\n    if (q1 === 1 || q1 === 4) {\n        return sinθ1 >= sinθ2;\n    }\n    return sinθ1 <= sinθ2;\n}\n/**\r\n * Returns true if angle1 < angle < angle2 in the non-trivial sense.\r\n */\nfunction isAngleBetween(sinθ, cosθ, sinθ1, cosθ1, sinθ2, cosθ2) {\n    var θ1_larger_θ2 = isAngle1LargerOrEqual(sinθ1, cosθ1, sinθ2, cosθ2);\n    var θ_larger_θ2 = isAngle1LargerOrEqual(sinθ, cosθ, sinθ2, cosθ2);\n    var θ_larger_θ1 = isAngle1LargerOrEqual(sinθ, cosθ, sinθ1, cosθ1);\n    return θ1_larger_θ2 ? θ_larger_θ1 || !θ_larger_θ2 : θ_larger_θ1 && !θ_larger_θ2;\n}\n/**\r\n *\r\n */\nfunction lineThroughPointAtRightAngleTo(p, v) {\n    var u = [-v[1], v[0]];\n    var p20 = p[0] + u[0];\n    var p21 = p[1] + u[1];\n    return [p, [p20, p21]];\n}\n/**\r\n * Get all intersection points between a line and a bezier within a certain t\r\n * range.\r\n */\nfunction getLineBezierIntersectionPoints(line, ps, tRange) {\n    var t = [-line[0][0], -line[0][1]];\n    var p = [line[1][0] + t[0], line[1][1] + t[1]];\n    // Cache\n    var lineLength = flo_vector2d_1.default.len(p);\n    var sinθ = -p[1] / lineLength;\n    var cosθ = p[0] / lineLength;\n    var newPs = flo_vector2d_1.default.translateThenRotatePs(t, sinθ, cosθ, ps);\n    var roots = flo_poly_1.default.allRoots(flo_bezier3_1.default.getY(newPs), 0, 1);\n    return roots.map(function (t) {\n        return { p: flo_bezier3_1.default.evaluate(ps)(t), t: t };\n    });\n}\nvar Geometry = {\n    lineLineIntersection: lineLineIntersection,\n    getLineBoundaryIntersectionPoints: getLineBoundaryIntersectionPoints,\n    closestSquaredDistanceToRotatedRect: closestSquaredDistanceToRotatedRect,\n    getClosestSquareDistanceToRect: getClosestSquareDistanceToRect,\n    degAngleFromSinCos: degAngleFromSinCos,\n    arcFrom3Points: arcFrom3Points,\n    quadrant: quadrant,\n    isAngle1LargerOrEqual: isAngle1LargerOrEqual,\n    isAngleBetween: isAngleBetween,\n    lineThroughPointAtRightAngleTo: lineThroughPointAtRightAngleTo,\n    getLineBezierIntersectionPoints: getLineBezierIntersectionPoints\n};\nexports.default = Geometry;\n\n},{\"./classes/arc\":4,\"./classes/circle\":6,\"./classes/shape\":10,\"flo-bezier3\":39,\"flo-poly\":47,\"flo-vector2d\":55}],16:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_ll_rb_tree_1 = _dereq_(\"flo-ll-rb-tree\");\nvar list_node_1 = _dereq_(\"./list-node\");\n/**\r\n * Represents a destructive (i.e. not functional) two-way linked loop.\r\n * @param items - A pre-ordered array of items to add initially; it is\r\n * faster to add items initially than to add them in a loop with insert.\r\n * @param comparator - Tree item comparator\r\n * @param indx - Loop identifier.\r\n */\n\nvar LinkedLoop = function () {\n    function LinkedLoop(items, comparator, indx) {\n        _classCallCheck(this, LinkedLoop);\n\n        if (comparator) {\n            this.cptree = new flo_ll_rb_tree_1.default(comparator, [], true);\n        }\n        this.indx = indx;\n        this.addAllFromScratch(items || []);\n    }\n    /**\r\n     * Adds all given items from scratch onto the empty LinkedLoop.\r\n     */\n\n\n    _createClass(LinkedLoop, [{\n        key: \"addAllFromScratch\",\n        value: function addAllFromScratch(arr) {\n            if (arr.length === 0) {\n                return;\n            }\n            var head = void 0;\n            var prevNode = null;\n            var node = void 0;\n            for (var i = 0; i < arr.length; i++) {\n                node = new list_node_1.default(this, arr[i], prevNode, null);\n                if (prevNode) {\n                    prevNode.next = node;\n                }\n                prevNode = node;\n                if (i === 0) {\n                    head = node;\n                }\n                if (this.cptree) {\n                    this.cptree.insert(node);\n                }\n                ;\n            }\n            // Close loop\n            head.prev = node;\n            node.next = head;\n            this.head = head;\n        }\n        /**\r\n         * Insert an item into the linked loop after the specified point.\r\n         * @param item - Item to insert\r\n         * @param prev - Inserts the new item right after this item\r\n         * @param coupledNode - A node coupled to this one\r\n         */\n\n    }, {\n        key: \"insert\",\n        value: function insert(item, prev_) {\n            var coupledNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n            var loop = this;\n            var node = new list_node_1.default(loop, item, undefined, undefined);\n            var prev = void 0;\n            var next = void 0;\n            if (!loop.head) {\n                prev = node;\n                next = node;\n                loop.head = node;\n            } else {\n                prev = prev_;\n                next = prev.next;\n            }\n            next.prev = node;\n            prev.next = node;\n            node.prev = prev;\n            node.next = next;\n            node.coupledNode = coupledNode;\n            if (loop.cptree) {\n                loop.cptree.insert(node);\n            }\n            ;\n            return node;\n        }\n        /**\r\n         * Removes a node from the linked loop.\r\n         */\n\n    }, {\n        key: \"remove\",\n        value: function remove(node) {\n            var loop = this;\n            var prev = node.prev;\n            var next = node.next;\n            if (node === loop.head) {\n                loop.head = next;\n            }\n            prev.next = next;\n            next.prev = prev;\n            if (loop.cptree) {\n                loop.cptree.remove(node, false); // TODO, make the second parameter default\n            }\n            ;\n        }\n        /**\r\n         *\r\n         */\n\n    }, {\n        key: \"getAsArray\",\n        value: function getAsArray() {\n            var loop = this;\n            var nodes = [];\n            var node = loop.head;\n            do {\n                nodes.push(node.item);\n                node = node.next;\n            } while (node !== loop.head);\n            return nodes;\n        }\n        /**\r\n         *\r\n         */\n\n    }, {\n        key: \"forEach\",\n        value: function forEach(f) {\n            var loop = this;\n            var node = loop.head;\n            do {\n                f(node);\n                node = node.next;\n            } while (node !== loop.head);\n        }\n        /**\r\n         * Returns the item at the specified index position.\r\n         * @note This is slow ( O(n) ); use in debugging code only.\r\n         */\n\n    }, {\n        key: \"getByIndx\",\n        value: function getByIndx(n) {\n            var loop = this;\n            return list_node_1.default.advanceNSteps(loop.head, n);\n        }\n    }]);\n\n    return LinkedLoop;\n}();\n\nexports.default = LinkedLoop;\n\n},{\"./list-node\":17,\"flo-ll-rb-tree\":42}],17:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Representation of a linked loop vertex (i.e. node) having various edges, two\r\n * of which enforce an ordering on the nodes, i.e. 'prev' and 'next'.\r\n * @param loop - The linked loop this node belongs to.\r\n * @param item - The actual item stored at a node.\r\n * @param prev - The previous item.\r\n * @param next - The next item.\r\n */\n\nvar ListNode = function () {\n    function ListNode(loop, item, prev, next) {\n        _classCallCheck(this, ListNode);\n\n        // TODO - we should really subclass linked-loop and/or list-node as the \n        // below only applies to the segregated shape pieces\n        this.prevOnCircle = undefined;\n        this.nextOnCircle = undefined;\n        this.loop = loop;\n        this.item = item;\n        this.prev = prev;\n        this.next = next;\n    }\n    /**\r\n     * Advances the node by the given number of steps. This is slow ( O(n) );\r\n     * use mostly for debugging.\r\n     * @param node - Node to start counting from\r\n     * @param n - Number of steps to advance\r\n     */\n\n\n    _createClass(ListNode, null, [{\n        key: \"advanceNSteps\",\n        value: function advanceNSteps(node, n) {\n            for (var i = 0; i < n; i++) {\n                node = node.next;\n            }\n            return node;\n        }\n    }]);\n\n    return ListNode;\n}();\n\nexports.default = ListNode;\n\n},{}],18:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAT_CONSTANTS = {\n    // TODO - should be dynamic and of order of shape dimensions.\n    maxOsculatingCircleRadius: 800,\n    pointType: {\n        'standard': 0,\n        'sharp': 1,\n        'dull': 2,\n        'extreme': 3\n    }\n};\nexports.default = MAT_CONSTANTS;\n\n},{}],19:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\n/**\r\n * Class representing a single contact point of a MatCircle.\r\n *\r\n * @param pointOnShape\r\n * @param {MatCircle} matCircle\r\n */\n\nvar ContactPoint = function () {\n    function ContactPoint(pointOnShape, matCircle) {\n        _classCallCheck(this, ContactPoint);\n\n        this.pointOnShape = pointOnShape;\n        this.matCircle = matCircle;\n        this.key = point_on_shape_1.default.toHumanString(pointOnShape); // TODO - remove\n        // TODO - remove from cache?\n        this[0] = pointOnShape[0]; // Shortcut\n        this[1] = pointOnShape[1]; // ...\n    }\n\n    _createClass(ContactPoint, null, [{\n        key: \"compare\",\n        value: function compare(a, b) {\n            return point_on_shape_1.default.compare(a.pointOnShape, b.pointOnShape);\n        }\n    }, {\n        key: \"equal\",\n        value: function equal(a, b) {\n            return flo_vector2d_1.default.equal(a.pointOnShape.p, b.pointOnShape.p);\n        }\n    }]);\n\n    return ContactPoint;\n}();\n\nexports.default = ContactPoint;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"flo-vector2d\":55}],20:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_on_shape_1 = _dereq_(\"../../../geometry/classes/point-on-shape\");\n\nvar ThreeProngForDebugging = function ThreeProngForDebugging(threeProng, deltas, bestIndx, candidateThreeProngs) {\n    _classCallCheck(this, ThreeProngForDebugging);\n\n    this.threeProng = threeProng;\n    this.deltas = deltas;\n    this.bestIndx = bestIndx;\n    this.candidateThreeProngs = candidateThreeProngs;\n    this.deltasSimple = deltas.map(function (delta) {\n        return [point_on_shape_1.default.toHumanString(delta[0].item.pointOnShape), point_on_shape_1.default.toHumanString(delta[1].item.pointOnShape)];\n    });\n};\n\nexports.default = ThreeProngForDebugging;\n\n},{\"../../../geometry/classes/point-on-shape\":9}],21:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar TwoProngForDebugging = function TwoProngForDebugging(pos, δ, y, z, x, circle, xs, failed, holeClosing) {\n    _classCallCheck(this, TwoProngForDebugging);\n\n    this.pos = pos;\n    this.δ = δ;\n    this.y = y;\n    this.z = z;\n    this.x = x;\n    this.circle = circle;\n    this.xs = xs;\n    this.failed = failed;\n    this.holeClosing = holeClosing;\n};\n\nexports.default = TwoProngForDebugging;\n\n},{}],22:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar HoleClosing2Prong = function HoleClosing2Prong(k1, k2, cpNodeA2, cpNodeA1, cpNodeB1, cpNodeB2) {\n    _classCallCheck(this, HoleClosing2Prong);\n\n    this.k1 = k1;\n    this.k2 = k2;\n    this.cpNodeA2 = cpNodeA2;\n    this.cpNodeA1 = cpNodeA1;\n    this.cpNodeB1 = cpNodeB1;\n    this.cpNodeB2 = cpNodeB2;\n};\n\nexports.default = HoleClosing2Prong;\n\n},{}],23:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Medial (or Scale) Axis Transform (MAT) maximal contact circle class,\r\n * i.e. a representative data point of the MAT.\r\n *\r\n * @constructor\r\n * @param {Circle} circle\r\n * @param {ListNode[]} cpNodes - The contact points of this circle on the shape.\r\n * @note Do not do 'new MatCircle', rather use 'MatCircle.create'.\r\n */\n\nvar MatCircle = function () {\n    function MatCircle(circle, cpNodes) {\n        _classCallCheck(this, MatCircle);\n\n        this.circle = circle;\n        this.cpNodes = cpNodes;\n        this.visited = 0; // TODO - does not belong inside the class\n    }\n    /**\r\n     * MatCircle creator.\r\n     * @param {Circle} circle\r\n     * @param {ListNode[]} cpNodes An array of 'orphaned'\r\n     *        (i.e. without belonging to a MatCircle) contact points.\r\n     * Notes: Due to the mutual dependency between the matCircle and\r\n     * contactPoints fields, a normal constructor can not instantiate a\r\n     * MatCircle in one step - hence this creator.\r\n     */\n\n\n    _createClass(MatCircle, null, [{\n        key: \"create\",\n        value: function create(circle, cpNodes) {\n            var matCircle = new MatCircle(circle, undefined);\n            for (var i = 0; i < cpNodes.length; i++) {\n                cpNodes[i].item.matCircle = matCircle;\n            }\n            matCircle.cpNodes = cpNodes;\n            return matCircle;\n        }\n    }]);\n\n    return MatCircle;\n}();\n\nexports.default = MatCircle;\n\n},{}],24:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Representation of a node in the MAT structure.\r\n * @param matCircle\r\n * @param branches\r\n */\n\nvar MatNode = function () {\n    function MatNode(matCircle, branches) {\n        _classCallCheck(this, MatNode);\n\n        this.matCircle = matCircle;\n        this.branches = branches;\n    }\n\n    _createClass(MatNode, null, [{\n        key: \"copy\",\n        value: function copy(node) {\n            return f(node);\n            function f(matNode, priorNode, newPriorNode) {\n                var branches = [];\n                var newNode = new MatNode(matNode.matCircle, branches);\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var _node = _step.value;\n\n                        if (_node === priorNode) {\n                            // Don't go back in tracks.\n                            branches.push(newPriorNode);\n                            continue;\n                        }\n                        branches.push(f(_node, matNode, newNode));\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                return newNode;\n            }\n        }\n    }]);\n\n    return MatNode;\n}();\n\nexports.default = MatNode;\n\n},{}],25:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_1 = _dereq_(\"../../mat/functions/traverse\");\n/**\r\n * The Medial Axis Transform. It is defined recursively as a rooted tree with\r\n * each node containing a point, a radius and 1, 2 or 3 branches.\r\n * @param node - A handle on the MAT tree structure.\r\n */\n\nvar MatTree = function MatTree(node) {\n    _classCallCheck(this, MatTree);\n\n    this.startNode = node;\n};\n\nMatTree.traverse = traverse_1.default;\nexports.default = MatTree;\n\n},{\"../../mat/functions/traverse\":37}],26:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar hole_closing_2_prong_1 = _dereq_(\"../classes/hole-closing-2-prong\");\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n *\r\n * @param shape Shape to add the 2-prong to\r\n * @param circle Circle containing the 2 contact points\r\n * @param pos1 - First point on shape\r\n * @param pos2 - Second point on shape\r\n * @param delta The boundary piece within which the new contact point should be\r\n * placed\r\n */\nfunction add2Prong(shape, circle, pos1, pos2, holeClosing) {\n    if (holeClosing) {\n        pos1.order2 = 1;\n        pos2.order2 = -1;\n    }\n    var cp2 = new contact_point_1.default(pos2, undefined);\n    var delta2 = shape_1.default.getNeighbouringPoints(shape, pos2);\n    var cmp3 = delta2[0] === undefined ? undefined : contact_point_1.default.compare(delta2[0].item, cp2);\n    var cmp4 = delta2[1] === undefined ? undefined : contact_point_1.default.compare(cp2, delta2[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp3 > 0 || cmp4 > 0) {\n            //console.log(`2-PRONG 2 Order is wrong 2: ${cmp3}, ${cmp4}`);\n        }\n    }\n    if (cmp3 === 0 || cmp4 === 0) {\n        // Should not really be possible with hole-closing 2-prongs.\n        return undefined;\n    }\n    var k2 = pos2.bezierNode.loop.indx;\n    var newCp2Node = shape.contactPointsPerLoop[k2].insert(cp2, delta2[0]);\n    var cp1 = new contact_point_1.default(pos1, undefined);\n    var delta1 = shape_1.default.getNeighbouringPoints(shape, pos1);\n    var cmp1 = delta1[0] === undefined ? undefined : contact_point_1.default.compare(delta1[0].item, cp1);\n    var cmp2 = delta1[1] === undefined ? undefined : contact_point_1.default.compare(cp1, delta1[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp1 > 0 || cmp2 > 0) {\n            //console.log(`2-PRONG 1 Order is wrong 2: ${cmp1}, ${cmp2}`);\n        }\n    }\n    // If they are so close together, don't add it - there's already 1\n    if (cmp1 === 0 || cmp2 === 0) {\n        // Should not be possible with hole-closing 2-prongs.\n        shape.contactPointsPerLoop[k2].remove(newCp2Node);\n        return undefined;\n    }\n    var k1 = pos1.bezierNode.loop.indx;\n    var newCp1Node = shape.contactPointsPerLoop[k1].insert(cp1, delta1[0]);\n    var matCircle = mat_circle_1.default.create(circle, [newCp1Node, newCp2Node]);\n    newCp1Node.prevOnCircle = newCp2Node;\n    newCp1Node.nextOnCircle = newCp2Node;\n    newCp2Node.prevOnCircle = newCp1Node;\n    newCp2Node.nextOnCircle = newCp1Node;\n    if (holeClosing) {\n        // If hole-closing then we duplicate the 2 contact points\n        // so that we can 'split the loop'.\n        var posA1 = pos2;\n        var posB2 = point_on_shape_1.default.copy(posA1);\n        posB2.order2 = 1;\n        var cpB2 = new contact_point_1.default(posB2, undefined);\n        var newCpB2Node = shape.contactPointsPerLoop[k2].insert(cpB2, newCp2Node);\n        var posA2 = pos1;\n        var posB1 = point_on_shape_1.default.copy(posA2);\n        posB1.order2 = -1;\n        var cpB1 = new contact_point_1.default(posB1, undefined);\n        var newCpB1Node = shape.contactPointsPerLoop[k1].insert(cpB1, newCp1Node.prev);\n        mat_circle_1.default.create(circle, [newCpB1Node, newCpB2Node]);\n        newCpB1Node.prevOnCircle = newCpB2Node;\n        newCpB1Node.nextOnCircle = newCpB2Node;\n        newCpB2Node.prevOnCircle = newCpB1Node;\n        newCpB2Node.nextOnCircle = newCpB1Node;\n        newCp2Node.next = newCp1Node;\n        newCp1Node.prev = newCp2Node;\n        newCpB1Node.next = newCpB2Node;\n        newCpB2Node.prev = newCpB1Node;\n        shape.holeClosers.push(new hole_closing_2_prong_1.default(k1, k2, newCp1Node, newCp2Node, newCpB1Node, newCpB2Node));\n    }\n    if (typeof window !== 'undefined' && window._debug_) {\n        // Add points so when we alt-click shape point is logged.\n        var _debug_ = window._debug_;\n        prepForDebug(newCp1Node, _debug_);\n        prepForDebug(newCp2Node, _debug_);\n    }\n    return;\n}\nfunction prepForDebug(contactPoint, _debug_) {\n    //---- Prepare debug info for the ContactPoint\n    var cpKey = point_on_shape_1.default.makeSimpleKey(contactPoint.item.pointOnShape.p);\n    var cpHash = _debug_.generated.cpHash;\n    var cpArr = _debug_.generated.cpArr;\n    if (!cpHash[cpKey]) {\n        cpHash[cpKey] = {\n            cp: contactPoint,\n            arrIndx: cpArr.length\n        };\n        cpArr.push(contactPoint);\n    }\n    var cpHashDebugObj = cpHash[cpKey];\n    cpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\nexports.default = add2Prong;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../geometry/classes/shape\":10,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../classes/hole-closing-2-prong\":22}],27:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given\r\n * (previously calculated) points on the shape.\r\n *\r\n * @param shape\r\n * @param circle\r\n * @param [p1,p2,p3]\r\n * @param deltas\r\n * @returns {MatCircle} matCircle\r\n */\nfunction add3Prong(shape, threeProng) {\n    var circle = threeProng.circle,\n        ps = threeProng.ps,\n        delta3s = threeProng.delta3s;\n\n    var cps = [0, 1, 2].map(function (i) {\n        return new contact_point_1.default(ps[i], undefined);\n    });\n    if (typeof window !== 'undefined' && window._debug_) {\n        // Keep for possible future debugging.\n        /*\r\n        for (let i=0; i<3; i++) {\r\n            let cmpBef = ContactPoint.compare(delta3s[i][0].item, cps[i]);\r\n            let cmpAft = ContactPoint.compare(delta3s[i][1].item, cps[i]);\r\n              let len = FloMat._debug_.generated.threeProngs.length-1; // Used by debug functions to reference a particular three-prong\r\n            if (cmpBef > 0) {\r\n                console.log(`3-PRONG Order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log(`3-PRONG Order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n            }\r\n        }\r\n        */\n    }\n    var cpNodes = [];\n    for (var i = 0; i < 3; i++) {\n        var pos = ps[i];\n        var k = pos.bezierNode.loop.indx;\n        cpNodes.push(shape.contactPointsPerLoop[k].insert(cps[i], delta3s[i][0]));\n    }\n    var matCircle = mat_circle_1.default.create(circle, cpNodes);\n    var idxsPrev = [2, 0, 1];\n    var idxsNext = [1, 2, 0];\n    for (var _i = 0; _i < 3; _i++) {\n        cpNodes[_i].prevOnCircle = cpNodes[idxsPrev[_i]];\n        cpNodes[_i].nextOnCircle = cpNodes[idxsNext[_i]];\n    }\n    return matCircle;\n}\nexports.default = add3Prong;\n\n},{\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23}],28:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar find_3_prong_1 = _dereq_(\"./find-3-prong\");\nvar add_3_prong_1 = _dereq_(\"./add-3-prong\");\nvar mat_node_1 = _dereq_(\"../../mat/classes/mat-node\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\n/**\r\n * Recursively builds the MAT tree.\r\n *\r\n * @param {ListNode} cpNodeStart\r\n * @returns {MatNode}\r\n */\nfunction buildMat(shape, cpNodeStart, fromNode, fromCpNode, isRetry) {\n    var visitedPoints = void 0;\n    do {\n        visitedPoints = traverseShape(cpNodeStart);\n        if (typeof window !== 'undefined' && window._debug_) {\n            // Oops - fix\n            // cpHashDebugObj.visitedPointsArr.push(visitedPoints);\n        }\n        if (visitedPoints.length > 2) {\n            findAndAdd3Prong(shape, visitedPoints);\n        }\n    } while (visitedPoints.length > 2);\n    if (cpNodeStart.item.matCircle.cpNodes.length === 1) /*&&\r\n                                                         (fromCpNode.nextOnCircle === cpNodeStart.next)*/{\n            //console.log('terminal 1-prong');\n            var matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n            return matNode;\n        }\n    if (visitedPoints.length === 1) {\n        // Terminating 2-prong - should mostly have been eliminated\n        // by osculating circles and points, but can still occur\n        // due to floating point incaccuracies.\n        // console.log('terminal 2-prong');\n        var _matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n        return _matNode;\n    } else if (visitedPoints.length === 2) {\n        var branches = fromNode ? [fromNode] : [];\n        var _matNode2 = createMatNode(cpNodeStart, branches);\n        var cpBranches = cpNodeStart;\n        var i = 0;\n        while (cpBranches.nextOnCircle !== cpNodeStart && cpBranches.next !== cpBranches.nextOnCircle) {\n            i++;\n            var cpNext = void 0;\n            if (i === 1) {\n                cpNext = cpBranches.next;\n                cpNodeStart.item.matCircle.visited++;\n            } else if (i === 2) {\n                // TODO - instead of the commented line below working\n                // perfectly, we must call the few lines below it and\n                // then later call fixMat. WHY!!!??? does the line\n                // below not simply work?\n                // cpNext = cpBranches.next;\n                cpNext = cpBranches;\n                if (cpBranches.item.matCircle.visited !== 1) {\n                    break;\n                }\n            }\n            var bm = buildMat(shape, cpNext, _matNode2, cpBranches, false);\n            branches.push(bm);\n            cpBranches = cpBranches.nextOnCircle;\n        }\n        return _matNode2;\n    }\n}\nfunction createMatNode(cp, branches) {\n    var matNode = new mat_node_1.default(cp.item.matCircle, branches);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        prepDebugHashes(cp, matNode, _debug_);\n    }\n    return matNode;\n}\nfunction traverseShape(cpNodeStart) {\n    var visitedPoints = void 0;\n    var cpNode = cpNodeStart;\n    visitedPoints = [];\n    do {\n        //if ()\n        visitedPoints.push(cpNode);\n        var next = cpNode.next;\n        cpNode = next.prevOnCircle; // Take last exit\n    } while (cpNode !== cpNodeStart);\n    return visitedPoints;\n}\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape. Modifies shape.\r\n *\r\n * @param shape\r\n * @param visitedPoints\r\n */\nfunction findAndAdd3Prong(shape, visitedPoints) {\n    /*\r\n     * visitedPoints.sort(function(a,b) { return\r\n     * PointOnShape.compare(a.item.pointOnShape,b.item.pointOnShape); });\r\n     */\n    var deltas = [];\n    for (var i = 0; i < visitedPoints.length; i++) {\n        var visitedPoint = visitedPoints[i];\n        deltas.push([visitedPoint, visitedPoint.next]);\n    }\n    // Check if any deltas are continuous (they should rather be\n    // disjoint). It should be quite safe to consider points 'equal'\n    // if they are within a certain threshold of each other, but is it\n    // necessary? Maybe not.\n    var continuous = false;\n    for (var _i = 0; _i < deltas.length; _i++) {\n        var idxi = _i + 1;\n        if (idxi === deltas.length) {\n            idxi = 0;\n        }\n        var endP = deltas[_i][1].item;\n        var startP = deltas[idxi][0].item;\n        if (contact_point_1.default.equal(endP, startP)) {\n            continuous = true;\n            break;\n        }\n    }\n    if (continuous) {\n        // aaa\n    }\n    var threeProng = find_3_prong_1.default(shape, deltas);\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n        point_on_shape_1.default.setPointOrder(shape, threeProng.circle, threeProng.ps[_i2]);\n    }\n    add_3_prong_1.default(shape, threeProng);\n}\nfunction prepDebugHashes(cpNodeStart, matNode, _debug_) {\n    // ---- Prepare debug info for the MatCircle\n    var circle = cpNodeStart.item.matCircle.circle;\n    var key = point_on_shape_1.default.makeSimpleKey(circle.center);\n    var nodeHash = _debug_.generated.nodeHash;\n    nodeHash[key] = nodeHash[key] || {};\n    nodeHash[key].matNode = matNode;\n    // ---- Prepare debug info for the ContactPoint\n    var cpKey = point_on_shape_1.default.makeSimpleKey(cpNodeStart.item.pointOnShape.p);\n    var cpHash = _debug_.generated.cpHash;\n    var cpArr = _debug_.generated.cpArr;\n    if (!cpHash[cpKey]) {\n        cpHash[cpKey] = {\n            cp: cpNodeStart,\n            arrIndx: cpArr.length\n        };\n        cpArr.push(cpNodeStart);\n    }\n    var cpHashDebugObj = cpHash[cpKey];\n    cpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\nexports.default = buildMat;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-node\":24,\"./add-3-prong\":27,\"./find-3-prong\":31}],29:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_node_1 = _dereq_(\"../../mat/classes/mat-node\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\nfunction copyMat(matTree) {\n    return new mat_tree_1.default(mat_node_1.default.copy(matTree.startNode));\n}\nexports.default = copyMat;\n\n},{\"../../mat/classes/mat-node\":24,\"../classes/mat-tree\":25}],30:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAX_ITERATIONS = 50;\n//TODO Change tolerances to take shape dimension into \n// account, e.g. shapeDim / 10000 for SEPERATION_TOLERANCE;\n//CONST SEPERATION_TOLERANCE = 1e-3;\nvar SEPERATION_TOLERANCE = 1e-3;\nvar SQUARED_SEPERATION_TOLERANCE = SEPERATION_TOLERANCE * SEPERATION_TOLERANCE;\nvar _1PRONG_TOLERANCE = 1e-4;\nvar SQUARED_1PRONG_TOLERANCE = _1PRONG_TOLERANCE * _1PRONG_TOLERANCE;\n//const ERROR_TOLERANCE = 1e-3;\nvar ERROR_TOLERANCE = SEPERATION_TOLERANCE / 10;\nvar SQUARED_ERROR_TOLERANCE = ERROR_TOLERANCE * ERROR_TOLERANCE;\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar geometry_1 = _dereq_(\"../../geometry/geometry\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar Point_on_shape_1 = _dereq_(\"../../geometry/classes/Point-on-shape\");\nvar contact_point_1 = _dereq_(\"../../mat/classes/contact-point\");\nvar mat_circle_1 = _dereq_(\"../../mat/classes/mat-circle\");\nvar get_closest_boundary_point_to_point_1 = _dereq_(\"../../geometry/functions/get-closest-boundary-point-to-point\");\nvar two_prong_for_debugging_1 = _dereq_(\"../classes/debug/two-prong-for-debugging\");\n/**\r\n * Adds a 2-prong to the MAT. The first point is given and the second one is\r\n * found by the algorithm.\r\n *\r\n * A 2-prong is a MAT circle that touches the shape at exactly 2 points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle\r\n *    Br(x) centered at an interior point x which contains two boundary\r\n *    portions c and d of d-Omega as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n *\r\n * @param shape\r\n * @param y - The first point of the 2-prong.\r\n */\nfunction find2Prong(shape, y, holeClosing) {\n    /* The failed flag is set if a 2-prong cannot be found. This occurs\r\n     * when the 2 points are too close together and the 2-prong\r\n     * becomes, in the limit, a 1-prong. We do not want these 2-prongs\r\n     * as they push the floating point precision limits when finding\r\n     * their circle center causing too much inaccuracy. Of course, our\r\n     * entire algorithm's precision is limited by floating point\r\n     * doubles.\r\n     */\n    var failed = false;\n    // The first point on the shape of the 2-prong.\n    //let y = pos;\n    var bezierNode = y.bezierNode;\n    var t = y.t;\n    var oCircle = Point_on_shape_1.default.getOsculatingCircle(y);\n    var x = oCircle.center;\n    /*\r\n     * The shortest distance so far between the first contact point and\r\n     * the circle center - we require this to get shorter on each\r\n     * iteration as convergence occurs. If it does not, oscillation\r\n     * of the algorithm has occured due to floating point inaccuracy\r\n     * and the algorithm must terminate.\r\n     */\n    var radius = oCircle.radius;\n    var shortestSquaredDistance = radius * radius;\n    /* The boundary piece that should contain the other point of\r\n     * the 2-prong circle. (Defined by start and end points).\r\n     */\n    var δ = void 0;\n    var bezierPieces = void 0;\n    var k = y.bezierNode.loop.indx;\n    if (holeClosing) {\n        bezierPieces = [];\n        for (var k2 = 0; k2 < k; k2++) {\n            var _bezierPieces;\n\n            var pieces = shape_1.default.getBoundaryBeziers(shape, k2);\n            (_bezierPieces = bezierPieces).push.apply(_bezierPieces, _toConsumableArray(pieces));\n        }\n    } else {\n        // TODO - getNeighbouringPoints *can* be eliminated (as with 3-prongs)\n        // by keeping track of boundary piece in which it is being searched \n        // - not sure if same can be done with hole-closing 2-prongs.\n        var ps = shape_1.default.getNeighbouringPoints(shape, y);\n        δ = [ps[0], ps[0]];\n        if (!ps[0]) {\n            bezierPieces = shape_1.default.getBoundaryBeziers(shape, k);\n        } else {\n            bezierPieces = shape_1.default.getBoundaryPieceBeziers(δ);\n        }\n    }\n    var xs = []; // Trace the convergence.\n    var z = void 0;\n    var squaredError = void 0;\n    var i = 0;\n    do {\n        i++;\n        var r = flo_vector2d_1.default.squaredDistanceBetween(x, y.p);\n        bezierPieces = cullBezierPieces(bezierPieces, x, r);\n        z = get_closest_boundary_point_to_point_1.default(bezierPieces, x, bezierNode, t);\n        if (typeof window !== 'undefined' && window._debug_) {\n            xs.push({ x: x, y: y, z: z, t: t });\n        }\n        var d = flo_vector2d_1.default.squaredDistanceBetween(x, z.p);\n        if (i === 1 && d + SQUARED_1PRONG_TOLERANCE >= r) {\n            // It is a 1-prong.\n            add1Prong(shape, y);\n            return undefined;\n        }\n        var squaredChordDistance = flo_vector2d_1.default.squaredDistanceBetween(y.p, z.p);\n        if (squaredChordDistance <= SQUARED_SEPERATION_TOLERANCE) {\n            failed = true;\n            break;\n        }\n        /*\r\n         * Find the point on the line connecting y with x that is\r\n         * equidistant from y and z. This will be our next x.\r\n         */\n        var nextX = findEquidistantPointOnLine(x, y.p, z.p);\n        squaredError = flo_vector2d_1.default.squaredDistanceBetween(x, nextX);\n        /*\r\n         * Prevent oscillation of calculated x (due to floating point\r\n         * inaccuracies). See comment above decleration of\r\n         * shortestSquaredDistance.\r\n         */\n        var squaredDistance = flo_vector2d_1.default.squaredDistanceBetween(y.p, nextX);\n        if (squaredDistance < shortestSquaredDistance) {\n            shortestSquaredDistance = squaredDistance;\n        } else {\n            //failed = true;\n            //break;\n        }\n        x = nextX;\n    } while (squaredError > SQUARED_ERROR_TOLERANCE && i < MAX_ITERATIONS);\n    if (typeof window !== 'undefined' && window._debug_) {\n        xs.push({ x: x, y: y, z: z, t: t });\n    }\n    if (i === MAX_ITERATIONS) {\n        // This is simply a case of convergence being too slow. The\n        // gecko, for example, takes a max of 21 iterations.\n        //console.log('max')\n        failed = true;\n    }\n    var circle = new circle_1.default(x, flo_vector2d_1.default.distanceBetween(x, z.p));\n    Point_on_shape_1.default.setPointOrder(shape, circle, y);\n    Point_on_shape_1.default.setPointOrder(shape, circle, z);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        recordForDebugging(failed, y, circle, y.p, z.p, δ, xs, holeClosing, _debug_);\n    }\n    if (failed) {\n        //console.log('failed');\n        return undefined;\n    }\n    return { circle: circle, z: z };\n}\nfunction add1Prong(shape, pos) {\n    if (pos.type === mat_constants_1.default.pointType.dull) {\n        // This is a 1-prong at a dull corner.\n        /* TODO IMPORTANT remove this line, uncomment piece below\r\n         * it and implement the following strategy to find the\r\n         * 3-prongs: if deltas are conjoined due to dull corner,\r\n         * split the conjoinment by inserting successively closer\r\n         * (binary division) 2-prongs. If a 2-prong actually fails,\r\n         * simply remove the 1-prong at the dull corner.\r\n         *\r\n         * In this way **all** terminal points are found, e.g.\r\n         * zoom in on top left leg of ant.\r\n         */\n        //console.log(posNode);\n        //toRemove.push(posNode); /* this */\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            // TODO - why would it be NaN in some cases?\n            var oCircle = Point_on_shape_1.default.getOsculatingCircle(pos);\n            if (!Number.isNaN(oCircle.center[0])) {\n                _debug_.generated.oneProngsAtDullCorner.push({ pos: pos });\n            }\n        }\n        return;\n    }\n    var cp = new contact_point_1.default(pos, undefined);\n    var delta = shape_1.default.getNeighbouringPoints(shape, pos);\n    //let cmp1 = ContactPoint.compare(delta[0].item, cp);\n    //let cmp2 = ContactPoint.compare(cp, delta[1].item);\n    var cmp1 = delta[0] === undefined ? undefined : contact_point_1.default.compare(delta[0].item, cp);\n    var cmp2 = delta[1] === undefined ? undefined : contact_point_1.default.compare(cp, delta[1].item);\n    if (typeof window !== 'undefined' && window._debug_) {\n        if (cmp1 > 0 || cmp2 > 0) {\n            //console.log(`1-PRONG Order is wrong: ${cmp1}, ${cmp2}`);\n        }\n    }\n    // If they are so close together, don't add it - there's already 1\n    if (cmp1 === 0 || cmp2 === 0) {\n        return;\n    }\n    var k = pos.bezierNode.loop.indx;\n    var newCpNode = shape.contactPointsPerLoop[k].insert(cp, delta[0]);\n    var matCircle = mat_circle_1.default.create(\n    //pos.osculatingCircle,\n    Point_on_shape_1.default.getOsculatingCircle(pos), [newCpNode]);\n    newCpNode.prevOnCircle = newCpNode; // Trivial loop\n    newCpNode.nextOnCircle = newCpNode; // ...\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.oneProngs.push({ pos: pos });\n    }\n    return;\n}\nfunction recordForDebugging(failed, pos, circle, y, z, δ, xs, holeClosing, _debug_) {\n    var twoProngForDebugging = new two_prong_for_debugging_1.default(pos, δ, y, z, circle.center, circle, xs, failed, holeClosing);\n    _debug_.generated.twoProngs.push(twoProngForDebugging);\n}\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n *\r\n * @param {BezierPieces[]} bezierPieces\r\n * @param {number[]} p\r\n * @param {number} r\r\n * @returns {BezierPieces[]}\r\n */\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\n    var CULL_THRESHOLD = 5;\n    if (bezierPieces.length <= CULL_THRESHOLD) {\n        return bezierPieces;\n    }\n    var newPieces = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var bezierPiece = _step.value;\n\n            var ps = bezierPiece.bezierNode.item.bezier3;\n            var rect = flo_bezier3_1.default.getBoundingBox(ps);\n            var bd = geometry_1.default.getClosestSquareDistanceToRect(rect, p);\n            if (bd <= rSquared + 0.1 /* Make this in relation to shape extents! <- No! Do proper error analysis */) {\n                    newPieces.push(bezierPiece);\n                }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return newPieces;\n}\n/**\r\n *\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from\r\n *          y and z.\r\n *\r\n * Notes: It is important that this function is numerically stable,\r\n * but this has not been investigated properly yet.\r\n */\nfunction findEquidistantPointOnLine(x, y, z) {\n    // Some basic algebra (not shown) finds the required point.\n    // Swap axis if x and y are more aligned to y-axis than to x-axis.\n    var swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\n    // Cache\n    var x1 = void 0,\n        x2 = void 0,\n        y1 = void 0,\n        y2 = void 0,\n        z1 = void 0,\n        z2 = void 0;\n    if (swapAxes) {\n        x1 = x[1];\n        x2 = x[0];\n        y1 = y[1];\n        y2 = y[0];\n        z1 = z[1];\n        z2 = z[0];\n    } else {\n        x1 = x[0];\n        x2 = x[1];\n        y1 = y[0];\n        y2 = y[1];\n        z1 = z[0];\n        z2 = z[1];\n    }\n    // a <= 1 (due to swapped axes)\n    var a = (x2 - y2) / (x1 - y1);\n    var b = y2 - a * y1;\n    var c = y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2 + 2 * b * (z2 - y2);\n    var d = y1 - z1 + a * (y2 - z2);\n    var t1 = c / (2 * d);\n    var t2 = a * t1 + b;\n    return swapAxes ? [t2, t1] : [t1, t2];\n}\nexports.default = find2Prong;\n\n},{\"../../geometry/classes/Point-on-shape\":3,\"../../geometry/classes/circle\":6,\"../../geometry/classes/shape\":10,\"../../geometry/functions/get-closest-boundary-point-to-point\":13,\"../../geometry/geometry\":15,\"../../mat-constants\":18,\"../../mat/classes/contact-point\":19,\"../../mat/classes/mat-circle\":23,\"../classes/debug/two-prong-for-debugging\":21,\"flo-bezier3\":39,\"flo-vector2d\":55}],31:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar shape_1 = _dereq_(\"../../geometry/classes/shape\");\nvar get_closest_boundary_point_to_point_1 = _dereq_(\"../../geometry/functions/get-closest-boundary-point-to-point\");\nvar three_prong_for_debugging_1 = _dereq_(\"../classes/debug/three-prong-for-debugging\");\n/**\r\n * Look for a 3-prong from the given walked boundary piece.\r\n *\r\n * @param shape\r\n * @param δs\r\n *\r\n */\nfunction find3Prong(shape, δs) {\n    var bezierPiecess = δs.map(function (δ) {\n        return shape_1.default.getBoundaryPieceBeziers(δ);\n    });\n    var candidateThreeProngs = [];\n    // The best candidate amongst the different 'permutations' of the given δs.\n    var threeProng = void 0;\n    var bestIndx = undefined;\n    var smallestError = Number.POSITIVE_INFINITY;\n    for (var i = 1; i < δs.length - 1; i++) {\n        var _find3ProngForDelta3s = find3ProngForDelta3s(shape, δs, i, bezierPiecess),\n            circle = _find3ProngForDelta3s.circle,\n            ps = _find3ProngForDelta3s.ps,\n            error = _find3ProngForDelta3s.error;\n\n        if (typeof window !== 'undefined' && window._debug_) {\n            var _debug_ = window._debug_;\n            candidateThreeProngs.push({ circle: circle, ps: ps });\n        }\n        if (error < smallestError) {\n            smallestError = error;\n            bestIndx = i - 1;\n            threeProng = { circle: circle, ps: ps, delta3s: undefined };\n        }\n    }\n    //-------------------------------------\n    //---- Add some additional properties\n    //-------------------------------------\n    var delta3s = [δs[0], δs[bestIndx + 1], δs[δs.length - 1]];\n    threeProng.delta3s = delta3s;\n    //-------------------------------------\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        var threeProngForDebugging = new three_prong_for_debugging_1.default(threeProng, δs, bestIndx, candidateThreeProngs);\n        _debug_2.generated.threeProngs.push(threeProngForDebugging);\n    }\n    return threeProng;\n}\n/**\r\n * Finds a 3-prong using only the 3 given delta's.\r\n *\r\n * @param i - Specific delta indx.\r\n * @returns {Object}\r\n */\nfunction find3ProngForDelta3s(shape, deltas, idx, bezierPiecess) {\n    // TODO - Choose a tolerance relative to shape size.\n    var TOLERANCE = 1e-7;\n    var delta3s = [deltas[0], deltas[idx], deltas[deltas.length - 1]];\n    var bezierPiece3s = [bezierPiecess[0], bezierPiecess[idx], bezierPiecess[deltas.length - 1]];\n    var ps = void 0;\n    var circumCenter = void 0;\n    var ii = 0; // Safeguard\n    var x = calcInitial3ProngPoint(shape, delta3s, bezierPiece3s);\n    var tolerance = Number.POSITIVE_INFINITY;\n    // TODO 10 below is magic, fix or add somewhere as a constant\n    while (tolerance > TOLERANCE && ii < 10) {\n        ii++;\n        ps = getClosestPoints(x, bezierPiece3s);\n        circumCenter = flo_vector2d_1.default.circumCenter(ps.map(function (x) {\n            return x.p;\n        }));\n        var vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter);\n        var upds = calcBetterX(bezierPiece3s, x, vectorToZeroV);\n        x = upds.newX;\n        var V = flo_vector2d_1.default.len(vectorToZeroV);\n        ps = upds.newPs;\n        tolerance = Math.abs(V - upds.newV);\n    }\n    var radius = (flo_vector2d_1.default.distanceBetween(x, ps[0].p) + flo_vector2d_1.default.distanceBetween(x, ps[1].p) + flo_vector2d_1.default.distanceBetween(x, ps[2].p)) / 3;\n    var circle = new circle_1.default(x, radius);\n    //-----------------------------------------------------------------\n    // Calculate the unit tangent vector at 3-prong circle points -\n    // they should be very close to tangent to the boundary piece \n    // tangents at those points (up to sign). Sharp corners are a\n    // common special case.\n    //-----------------------------------------------------------------\n    var totalAngleError = 0;\n    for (var i = 0; i < 3; i++) {\n        var p = ps[i];\n        //----------------------------\n        // Tangent of circle at point\n        //----------------------------\n        var vv = flo_vector2d_1.default.toUnitVector(flo_vector2d_1.default.fromTo(p.p, x));\n        var v1 = flo_vector2d_1.default.rotate90Degrees(vv);\n        //-----------------------------------\n        // Check if point is on dull crorner\n        //-----------------------------------\n        var key = point_on_shape_1.default.makeSimpleKey(p.p);\n        var dullCorner = shape.dullCornerHash[key];\n        if (dullCorner) {\n            //if (FloMat._debug_ && FloMat._debug_.log) { console.log(dullCorner); }\n            var tans = dullCorner.tans;\n            var perps = tans.map(flo_vector2d_1.default.rotate90Degrees);\n            if (typeof window !== 'undefined' && window._debug_) {\n                var _debug_ = window._debug_;\n                if (_debug_.log) {\n                    /*\r\n                    FloMat._debug_.fs.draw.line(\r\n                            [p, Vector.translate(p, perps[0])],\r\n                            'thin10 red'\r\n                    );\r\n                    FloMat._debug_.fs.draw.line(\r\n                            [p, Vector.translate(p, perps[1])],\r\n                            'thin10 red'\r\n                    );\r\n                    */\n                    // The below must be elem [0,1].\n                    //console.log(Vector.cross( perps[0], perps[1] )); \n                }\n            }\n            var angleError1Pre = flo_vector2d_1.default.cross(perps[0], vv);\n            var angleError2Pre = flo_vector2d_1.default.cross(vv, perps[1]);\n            var angleError1 = Math.asin(angleError1Pre);\n            var angleError2 = Math.asin(angleError2Pre);\n            var angleError = 0;\n            if (angleError1 > 0) {\n                angleError += angleError1;\n            }\n            if (angleError2 > 0) {\n                angleError += angleError2;\n            }\n            totalAngleError += angleError;\n        } else {\n            //---------------------------\n            // Tangent of curve at point\n            //---------------------------\n            var _ps = p.bezierNode.item.bezier3;\n            var v2 = flo_vector2d_1.default.toUnitVector(flo_bezier3_1.default.tangent(_ps)(p.t));\n            // Cross is more numerically stable than Vector.dot at angles\n            // a multiple of Math.PI **and** is close to the actual angle\n            // value and can thus just be added to cone method of looking\n            // at tolerance.\n            // Should be close to zero and is close to the actual angle.\n            var cross = Math.abs(Math.asin(flo_vector2d_1.default.cross(v1, v2)));\n            totalAngleError += cross;\n        }\n    }\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log(totalAngleError); }\n    //-----------------------------------------------------------------\n    // Calculate radiusDelta, the difference between the radius and \n    // the closest point to the 3-prong. It should be around 0. If not,\n    // this is not a good candidate for the 3-prong.\n    //-----------------------------------------------------------------\n    var closestDs = [];\n    for (var _i = 0; _i < bezierPiecess.length; _i++) {\n        var _p = get_closest_boundary_point_to_point_1.default(bezierPiecess[_i], x, undefined, undefined // TODO - bug: we must provide a t value and the\n        // parameter order of the last 2 parameters of this function\n        // should be swapped. Consider the consequences of leaving this\n        // bug unchecked.\n        );\n        closestDs.push(flo_vector2d_1.default.distanceBetween(_p.p, x));\n    }\n    var closestD = Math.min.apply(Math, closestDs);\n    var radiusDelta = Math.abs(radius - closestD);\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log(radiusDelta); }\n    //if (FloMat._debug_ && FloMat._debug_.log) { console.log('---------------------'); }\n    //-----------------------------------------------------------------\n    // TODO Weights still need to be determined\n    var W1 = 1;\n    var W2 = 1;\n    var error = W1 * radiusDelta + W2 * totalAngleError;\n    return { ps: ps, circle: circle, error: error };\n}\nvar calcVectorToZeroV_StraightToIt = flo_vector2d_1.default.fromTo;\n// This function is currently unused\n/*\r\nfunction calcVectorToZeroV_AlongMedial(\r\n        circleCenter: number[],\r\n        ps: number[][]) {\r\n\r\n    let v1 = Vector.fromTo(ps[0], ps[2]);\r\n    let v2 = [-v1[1], v1[0]]; // Rotate by 90 degrees\r\n    let l1 = Vector.len(Vector.fromTo(x, circleCenter));\r\n    let v3 = Vector.toUnitVector(v2);\r\n    let v4 = Vector.scale(v3, l1);\r\n    /*\r\n    if (typeof FloMat !== 'undefined' && FloMat._debug_ && !FloMat._debug_.config.isTiming) {\r\n        FloMat._debug_.fs.draw.line([x, Vector.translate(x,vectorToZeroV)], 'thin10 red');\r\n        FloMat._debug_.fs.draw.line([x, Vector.translate(x,v4)], 'thin10 blue');\r\n    }\r\n    */ /*\r\n       return v4;\r\n       }\r\n       */\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong\r\n * circle.\r\n *\r\n * The potential function, V, is defined as the distance to the\r\n * actual 3 prong circle center.\r\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\n    var V = flo_vector2d_1.default.len(vectorToZeroV);\n    var nu = 1;\n    var better = void 0;\n    var newX = void 0;\n    var newPs = void 0;\n    var newV = void 0;\n    var i = 0; // Safeguard\n    do {\n        var shift = flo_vector2d_1.default.scale(vectorToZeroV, nu);\n        newX = flo_vector2d_1.default.translate(shift, x);\n        newPs = getClosestPoints(newX, bezierPiece3s);\n        // Point of zero V\n        var newCircleCenter = flo_vector2d_1.default.circumCenter(newPs.map(function (x) {\n            return x.p;\n        }));\n        var newVectorToZeroV = flo_vector2d_1.default.fromTo(newX, newCircleCenter);\n        newV = flo_vector2d_1.default.len(newVectorToZeroV);\n        better = newV < V;\n        nu = nu / 2;\n        i++;\n    } while (!better && i < 3);\n    return { newX: newX, newV: newV, newPs: newPs };\n}\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate.\r\n * The point must be within the shape.\r\n *\r\n * @param delta3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n */\nfunction calcInitial3ProngPoint(shape, delta3s, bezierPiece3s) {\n    // TODO - No need to calculate, we already have this info somewhere.\n    var twoProngCircleCenter = flo_vector2d_1.default.mean([delta3s[0][0].item.pointOnShape.p, delta3s[2][1].item.pointOnShape.p]);\n    var point1 = get_closest_boundary_point_to_point_1.default(bezierPiece3s[1], twoProngCircleCenter, undefined, // bezierNode\n    undefined // t\n    );\n    var meanPoints = [delta3s[0][0].item.pointOnShape.p,\n    //Vector.mean([delta3s[1][0].item, delta3s[1][1].item]),\n    point1.p, delta3s[2][1].item.pointOnShape.p];\n    var p = void 0;\n    if (delta3s[0][0].item.pointOnShape.type === mat_constants_1.default.pointType.sharp) {\n        // delta3s start and end at sharp corner. If delta3s start at a sharp \n        // corner it will end there also so no need to check for end point as \n        // well.\n        p = flo_vector2d_1.default.mean([meanPoints[0], meanPoints[1]]);\n    } else {\n        p = flo_vector2d_1.default.circumCenter(meanPoints);\n    }\n    if (!Number.isFinite(p[0])) {\n        if (typeof window !== 'undefined' && window._debug_) {\n            // TODO - check why this actuall happens sometimes\n            //console.log(FloMat._debug_.pointsToNiceStr(meanPoints));\n            //console.log(FloMat._debug_.deltasToNiceStr(delta3s));\n            //console.log(p, meanPoints);\n        }\n    }\n    if (!Number.isFinite(p[0])) {\n        var sames = whichNotSame(meanPoints);\n        return flo_vector2d_1.default.mean([meanPoints[sames[0]], meanPoints[sames[1]]]);\n    }\n    return p;\n}\nfunction whichNotSame(ps) {\n    if (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\n        return [0, 2];\n    } else if (ps[1][0] === ps[2][0] && ps[1][1] === ps[2][1]) {\n        return [0, 2];\n    } else if (ps[2][0] === ps[0][0] && ps[2][1] === ps[0][1]) {\n        return [1, 2];\n    }\n    ;\n    return [];\n}\nfunction getClosestPoints(x, bezierPiece3s) {\n    return bezierPiece3s.map(function (bezierPieces) {\n        var p = get_closest_boundary_point_to_point_1.default(bezierPieces, x, undefined, // bezierNode\n        undefined // t\n        );\n        return p;\n    });\n}\nexports.default = find3Prong;\n\n},{\"../../geometry/classes/circle\":6,\"../../geometry/classes/point-on-shape\":9,\"../../geometry/classes/shape\":10,\"../../geometry/functions/get-closest-boundary-point-to-point\":13,\"../../mat-constants\":18,\"../classes/debug/three-prong-for-debugging\":20,\"flo-bezier3\":39,\"flo-vector2d\":55}],32:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar Point_on_shape_1 = _dereq_(\"../../geometry/classes/Point-on-shape\");\nvar add_2_prong_1 = _dereq_(\"./add-2-prong\");\nvar find_2_prong_1 = _dereq_(\"./find-2-prong\");\nvar build_mat_1 = _dereq_(\"./build-mat\");\n/**\r\n * Find the MAT from the given Shape.\r\n * @param shape\r\n */\nfunction findMat(shape) {\n    findAndAddHoleClosing2Prongs(shape);\n    findAndAdd2ProngsOnAllPaths(shape);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        _debug_.generated.timing.after2Prongs = performance.now();\n    }\n    //---- Connect the n-prong centers and add the 3-prongs.\n    var contactPoints = shape.contactPointsPerLoop[0];\n    var cpNode = contactPoints.head;\n    do {\n        if (cpNode.item.matCircle.cpNodes.length === 2 && !(cpNode.next.prevOnCircle === cpNode)) {\n            break;\n        }\n        cpNode = cpNode.next;\n    } while (cpNode !== contactPoints.head);\n    var cptest = cpNode.prevOnCircle;\n    var branchForth = build_mat_1.default(shape, cptest, undefined, undefined, false);\n    var branchBack = build_mat_1.default(shape, cptest.prevOnCircle, undefined, undefined, false);\n    branchForth.branches.push(branchBack.branches[0]);\n    branchBack.branches[0].branches[0] = branchForth;\n    var mat = new mat_tree_1.default(branchForth);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.timing.after3Prongs = performance.now();\n    }\n    return fixMat(mat);\n}\n/**\r\n * Finds and adds two-prongs that removes any holes in the shape.\r\n * @param {Shape} shape\r\n * @returns {undefined}\r\n */\nfunction findAndAddHoleClosing2Prongs(shape) {\n    var extremes = shape.extremes;\n    for (var k = 1; k < extremes.length; k++) {\n        var extreme = extremes[k];\n        var r = mat_constants_1.default.maxOsculatingCircleRadius;\n        var p = [extreme.p[0], extreme.p[1] - r];\n        var osculatingCircle = new circle_1.default(p, r);\n        var posA2 = new Point_on_shape_1.default(extreme.bezierNode, extreme.t, mat_constants_1.default.pointType.extreme, 0, //order \n        0);\n        // A normal traversal should give (cyclically) A1->A2->B1->B2\n        var twoProngInfo = find_2_prong_1.default(shape, posA2, true);\n        var circle = twoProngInfo.circle,\n            z = twoProngInfo.z;\n\n        var posA1 = z;\n        var key = Point_on_shape_1.default.makeSimpleKey(posA2.p);\n        if (shape.straightUpHash[key]) {\n            // Skip these when doing normal 2-prong procedure.\n            shape.skip2ProngHash[key] = posA2;\n        }\n        add_2_prong_1.default(shape, circle, posA2, posA1, true);\n    }\n}\n/**\r\n * Add 2 prongs.\r\n *\r\n * See comments on the add2Prong function.\r\n */\nfunction findAndAdd2ProngsOnAllPaths(shape) {\n    var for2ProngsArray = shape.for2ProngsArray;\n    for (var k = 0; k < for2ProngsArray.length; k++) {\n        var for2Prongs = for2ProngsArray[k];\n        findAndAdd2Prongs(shape, k, for2Prongs);\n    }\n}\nfunction findAndAdd2Prongs(shape, k, for2Prongs) {\n    var len = for2Prongs.length;\n    //let index = indexInterlaced(len); // Keep for debuggin.\n    var index = indexLinear(len);\n    for (var i = 0; i < len; i++) {\n        var posNode = for2Prongs[index[i]];\n        var pos = posNode.item;\n        var key = Point_on_shape_1.default.makeSimpleKey(pos.p);\n        if (shape.skip2ProngHash[key]) {\n            continue;\n        }\n        var twoProngInfo = find_2_prong_1.default(shape, pos, false);\n        if (twoProngInfo) {\n            var circle = twoProngInfo.circle,\n                z = twoProngInfo.z;\n\n            add_2_prong_1.default(shape, circle, pos, z, false);\n        } else {\n            // failed\n        }\n    }\n    /*\r\n     * Don't delete - keep for future debugging.\r\n     * Check if point orders follow each other - they absolutely must.\r\n     */\n    /*\r\n    if (typeof FloMat !== 'undefined' && FloMat._debug_) {\r\n        let contactPoints = shape.contactPointsPerLoop[k];\r\n        let cpNode = contactPoints.head;\r\n        let first = true;\r\n        let prev = undefined;\r\n        do {\r\n            if (first) {\r\n                first = false;\r\n                prev = cpNode.item;\r\n                cpNode = cpNode.next;\r\n                continue;\r\n            }\r\n        \r\n            let cmp = ContactPoint.compare(prev, cpNode.item);\r\n            if (cmp >= 0) {\r\n                console.log(cmp);\r\n            }\r\n            \r\n            prev = cpNode.item;\r\n            cpNode = cpNode.next;\r\n        } while (cpNode !== contactPoints.head);\r\n    }\r\n    */\n}\n/**\r\n * This is unfortunately currently required since I can't get the buildMat\r\n * recursive algorithm right on the first pass.\r\n * @param mat\r\n */\nfunction fixMat(mat) {\n    f(mat.startNode, undefined);\n    function f(matNode, priorNode) {\n        if (matNode.branches.length === 3 && matNode.branches[2].matCircle === matNode.matCircle) {\n            var firstRight = matNode.branches[2];\n            var secondRight = firstRight.branches[1];\n            matNode.branches[2] = secondRight;\n            secondRight.branches[0] = matNode;\n        }\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var node = _step.value;\n\n                if (node === priorNode) {\n                    // Don't go back in tracks.\n                    continue;\n                }\n                f(node, matNode);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return mat;\n}\n/**\r\n * Creates a kind of interlaced index vector, e.g. TODO\r\n *\r\n * @param n\r\n * @returns {number[]}\r\n */\n/*\r\nfunction indexInterlaced(n) {\r\n    \r\n    let arr = [];\r\n    helper(0, n, arr);\r\n    \r\n    return arr;\r\n    \r\n    function helper(start, end) {\r\n        \r\n        if (end === start) {\r\n            return;\r\n        }\r\n        \r\n        if ((end - start) === 1) {\r\n            arr.push(start);\r\n            return;\r\n        }\r\n        \r\n        \r\n        let halfway = start + Math.floor((end-start) / 2);\r\n        \r\n        arr.push(halfway);\r\n        helper(start, halfway);\r\n        helper(halfway+1, end);\r\n    }\r\n}\r\n*/\nfunction indexInterlaced(n) {\n    var source = {};\n    var arr = [];\n    // l <=> the lowest power of 2 so that 2^l > n\n    var l = Math.pow(2, Math.floor(Math.log2(n)));\n    while (l >= 1) {\n        var k = 0;\n        while (k < n) {\n            if (!source[k]) {\n                arr.push(k);\n                source[k] = true;\n            }\n            k = k + l;\n        }\n        l = l / 2;\n    }\n    return arr;\n}\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n * @returns {number[]}\r\n */\nfunction indexLinear(n) {\n    var arr = [];\n    for (var i = 0; i < n; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\nexports.default = findMat;\n\n},{\"../../geometry/classes/Point-on-shape\":3,\"../../geometry/classes/circle\":6,\"../../mat-constants\":18,\"../classes/mat-tree\":25,\"./add-2-prong\":26,\"./build-mat\":28,\"./find-2-prong\":30}],33:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar traverse_1 = _dereq_(\"./traverse\");\n/**\r\n * Returns all the calculated MAT nodes as an array.\r\n */\nfunction getNodesAsArray(mat) {\n    var nodes = [];\n    traverse_1.default(mat, function (node) {\n        nodes.push(node);\n    });\n    return nodes;\n}\nexports.default = getNodesAsArray;\n\n},{\"./traverse\":37}],34:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar traverse_1 = _dereq_(\"./traverse\");\nfunction getNodesAsHash(mat) {\n    var nodes = {};\n    traverse_1.default(mat, function (node) {\n        var key = point_on_shape_1.default.makeSimpleKey(node.matCircle.circle.center);\n        nodes[key] = node;\n    });\n    return nodes;\n}\nexports.default = getNodesAsHash;\n\n},{\"../../geometry/classes/point-on-shape\":9,\"./traverse\":37}],35:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mat_constants_1 = _dereq_(\"../../mat-constants\");\nvar geometry_1 = _dereq_(\"../../geometry/geometry\");\nvar flo_bezier3_1 = _dereq_(\"flo-bezier3\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\n/**\r\n * Smoothens the given MAT by fitting consecutive node links by\r\n * lines, quadratic or cubic beziers.\r\n */\nfunction smoothen(mat) {\n    /**\r\n     * Get the linked contact points. TODO This information to be\r\n     * stored in the MatCircle in the future then there is no need\r\n     * to actually search for it!\r\n     */\n    function getLinkedCps(prevCpNodes, currCpNodes) {\n        for (var i = 0; i < prevCpNodes.length; i++) {\n            var prevCpNode = prevCpNodes[i];\n            for (var j = 0; j < currCpNodes.length; j++) {\n                var currCpNode = currCpNodes[j];\n                if (prevCpNode.next === currCpNode) {\n                    return [prevCpNode, currCpNode];\n                }\n            }\n        }\n    }\n    var lines = [];\n    var quads = [];\n    var cubes = [];\n    mat_tree_1.default.traverse(mat, function (currNode, prevNode) {\n        if (!prevNode) {\n            return;\n        }\n        var prevMatCircle = prevNode.matCircle;\n        var prevCc = prevMatCircle.circle.center;\n        var prevCpNodes = prevMatCircle.cpNodes;\n        var currMatCircle = currNode.matCircle;\n        var currCc = currMatCircle.circle.center;\n        var currCpNodes = currMatCircle.cpNodes;\n\n        var _getLinkedCps = getLinkedCps(prevCpNodes, currCpNodes),\n            _getLinkedCps2 = _slicedToArray(_getLinkedCps, 2),\n            prevCpNode = _getLinkedCps2[0],\n            currCpNode = _getLinkedCps2[1];\n\n        var prevL = getDirectionToNextMatCircle(prevCpNode, prevCc, true);\n        var currL = getDirectionToNextMatCircle(currCpNode, currCc, false);\n        function getDirectionToNextMatCircle(cpNode, circleCenter, isPrev) {\n            var cp1 = cpNode.item;\n            var cp2 = isPrev ? cpNode.nextOnCircle.item : cpNode.prevOnCircle.item;\n            var vDir = void 0;\n            if (cp1 !== cp2) {\n                // Not a 1-prong.\n                var spanner = flo_vector2d_1.default.fromTo(cp1.pointOnShape.p, cp2.pointOnShape.p);\n                vDir = flo_vector2d_1.default.rotate90Degrees(spanner);\n            } else {\n                if (cp1.pointOnShape.type === mat_constants_1.default.pointType.sharp) {\n                    var bezierNode1 = void 0;\n                    var bezierNode2 = void 0;\n                    if (cp1.pointOnShape.t === 0) {\n                        bezierNode1 = cp1.pointOnShape.bezierNode;\n                        bezierNode2 = cp1.pointOnShape.bezierNode.prev;\n                    } else if (cp1.pointOnShape.t === 1) {\n                        bezierNode1 = cp1.pointOnShape.bezierNode.next;\n                        bezierNode2 = cp1.pointOnShape.bezierNode;\n                    }\n                    var tan1 = flo_bezier3_1.default.tangent(bezierNode1.item.bezier3)(0);\n                    var tan2 = flo_vector2d_1.default.reverse(flo_bezier3_1.default.tangent(bezierNode2.item.bezier3)(1));\n                    var x = flo_vector2d_1.default.dot(tan1, tan2);\n                    // Recall the identities sin(acos(x)) = sqrt(1-x^2),\n                    // etc. Also recall the half angle formulas. Then \n                    // the rotation matrix, R, can be calculated.\n                    var cosθ = Math.sqrt((1 + x) / 2);\n                    var sinθ = Math.sqrt((1 - x) / 2);\n                    vDir = flo_vector2d_1.default.rotate(sinθ, cosθ, tan2);\n                } else {\n                    vDir = flo_vector2d_1.default.fromTo(cp1.pointOnShape.p, circleCenter);\n                }\n            }\n            var v = flo_vector2d_1.default.translate(flo_vector2d_1.default.toLength(vDir, 1), circleCenter);\n            var l = [circleCenter, v];\n            return l;\n        }\n        var mid = geometry_1.default.lineLineIntersection(prevL, currL);\n        var twisted = void 0;\n        if (mid) {\n            var a = flo_vector2d_1.default.fromTo(prevCc, mid);\n            var b = flo_vector2d_1.default.fromTo(currCc, mid);\n            var c = flo_vector2d_1.default.fromTo(prevCc, currCc);\n            var dot1 = flo_vector2d_1.default.dot(a, c);\n            var dot2 = flo_vector2d_1.default.dot(b, c);\n            twisted = dot1 < 0 || dot2 > 0;\n        }\n        if (!mid) {\n            lines.push([prevCc, currCc]);\n        } else if (twisted) {\n            var lp1 = flo_vector2d_1.default.mean([prevCc, currCc]);\n            var vv1 = flo_vector2d_1.default.fromTo(prevCc, currCc);\n            var vvv1 = flo_vector2d_1.default.rotate90Degrees(vv1);\n            var lpp1 = flo_vector2d_1.default.translate(vvv1, lp1);\n            var l = [lp1, lpp1];\n            var mid1 = geometry_1.default.lineLineIntersection(prevL, l);\n            var mid2 = geometry_1.default.lineLineIntersection(currL, l);\n            cubes.push([prevCc, mid1, mid2, currCc]);\n        } else {\n            //console.log(prevCc, mid, currCc);\n            quads.push([prevCc, mid, currCc]);\n        }\n    });\n    return {\n        lines: lines,\n        quads: quads,\n        cubes: cubes\n    };\n}\nexports.default = smoothen;\n\n},{\"../../geometry/geometry\":15,\"../../mat-constants\":18,\"../classes/mat-tree\":25,\"flo-bezier3\":39,\"flo-vector2d\":55}],36:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = _dereq_(\"../../geometry/classes/circle\");\nvar copy_mat_1 = _dereq_(\"./copy-mat\");\nvar get_nodes_as_hash_1 = _dereq_(\"./get-nodes-as-hash\");\nvar point_on_shape_1 = _dereq_(\"../../geometry/classes/point-on-shape\");\nvar mat_tree_1 = _dereq_(\"../classes/mat-tree\");\n// TODO - fix highly convoluted typescript typings by modifiying code so that \n// a tree node (i.e. TTree type) does not use type union\nvar width = 1620; // TODO change to actual shape coordinates\nvar height = 1560; // ...\n/**\r\n * Apply the Scale Axis Transform (SAT) to the MAT.\r\n *\r\n * @param mat_ - The Medial Axis Transform (MAT) on which to apply the SAT.\r\n * @param s - The scale factor >= 1 (e.g. 1.3)\r\n * @returns {MatTree}\r\n */\nfunction toScaleAxis(mat_, s) {\n    // TODO\n    // This algorithm might be made somewhat faster by building tree to a depth \n    // where there is say less than 4 other circles and then only split the \n    // branch once this threshold has been exceeded.\n    // \n    // Also, when searching, search only in relevant branches even when circle \n    // overlaps more than one group.\n    var mat = copy_mat_1.default(mat_);\n    // Start with the biggest circle (since it is the most likely to eclipse \n    // other circles), multiply its radius by s and see which circles are fully \n    // contained in it and trim it away in the MAT tree.\n    var nodeHash = get_nodes_as_hash_1.default(mat);\n    var biggest = -Number.POSITIVE_INFINITY;\n    var biggestNode = void 0;\n    for (var key in nodeHash) {\n        var node = nodeHash[key];\n        var r = node.matCircle.circle.radius;\n        if (r > biggest) {\n            biggestNode = node;\n            biggest = r;\n        }\n    }\n    var tree = createSpacialTree(s, nodeHash);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_ = window._debug_;\n        /*\r\n        if (FloMat._debug_.shouldDrawSATTree) {\r\n            FloMat._debug_.drawSATTree(tree);\r\n        }\r\n        */\n        _debug_.generated.sat.tree = tree;\n    }\n    // Grab the MAT tree at its biggest node.\n    var sat = new mat_tree_1.default(biggestNode);\n    var cullHash = {};\n    // Look at circles in roughly order of size for each tree branch,\n    // e.g. circles in branch 5 are always larger than in branches 0\n    // to 4.\n    traverseSpacialTree(tree, cullem, { s: s, tree: tree, cullHash: cullHash });\n    // We now walk the MAT tree and keep all non-culled nodes and any\n    // nodes that have a non-culled node further down the line toward\n    // the tree leaves.\n    var cullNodes = [];\n    cullIt(cullHash, cullNodes, sat.startNode);\n    cullTheNodes(cullNodes);\n    if (typeof window !== 'undefined' && window._debug_) {\n        var _debug_2 = window._debug_;\n        _debug_2.generated.timing.afterSat = performance.now();\n    }\n    return sat;\n}\nfunction addToTree(s, tree, coordinate, limits, node, key, depth) {\n    // DEPTH_LIMIT can be anything from 1 to 16, but from 2 to 6 seem \n    // to be the fastest.\n    var DEPTH_LIMIT = 6;\n    var circle = node.matCircle.circle;\n\n    var _calcGroups = calcGroups(s, coordinate, limits, circle),\n        groups = _calcGroups.groups,\n        newLimits = _calcGroups.newLimits;\n    // Create new branch if it does not exist yet.\n\n\n    if (groups.length === 1 && depth !== DEPTH_LIMIT) {\n        var group = groups[0];\n        if (!tree[group]) {\n            tree[group] = {};\n        }\n        var _branch = tree[group];\n        // Flip coordinates\n        var newCoordinate = coordinate ? 0 : 1;\n        addToTree(s, _branch, newCoordinate, newLimits, node, key, depth + 1);\n        return;\n    }\n    if (!tree[5]) {\n        tree[5] = new Map();\n    }\n    var branch = tree[5];\n    branch.set(key, node);\n}\nfunction createSpacialTree(s, nodeHash) {\n    var coordinate = 0;\n    var limits = [[0, width], [0, height]];\n    var tree = {};\n    for (var key in nodeHash) {\n        var node = nodeHash[key];\n        addToTree(s, tree, coordinate, limits, node, key, 0);\n    }\n    return tree;\n}\nfunction cullem(node, key, extraParams) {\n    var s = extraParams.s,\n        tree = extraParams.tree,\n        cullHash = extraParams.cullHash;\n\n    if (node.matCircle.circle.radius === 0) {\n        return;\n    }\n    if (cullHash[key]) {\n        return;\n    }\n    var cullNodes = getCullNodes(s, tree, node);\n    for (var _key in cullNodes) {\n        if (!cullHash[_key]) {\n            cullHash[_key] = node;\n        }\n    }\n}\nfunction traverseSpacialTree(tree, f, extraParams) {\n    function helper(tree) {\n        if (!tree) {\n            return;\n        }\n        if (tree.size) {\n            tree.forEach(function (node, key) {\n                f(node, key, extraParams);\n            });\n            return; // Leaf reached \n        }\n        if (tree[5]) {\n            helper(tree[5]);\n        }\n        if (tree[0]) {\n            helper(tree[0]);\n        }\n        if (tree[2]) {\n            helper(tree[2]);\n        }\n        if (tree[4]) {\n            helper(tree[4]);\n        }\n        if (tree[1]) {\n            helper(tree[1]);\n        }\n        if (tree[3]) {\n            helper(tree[3]);\n        }\n    }\n    helper(tree);\n}\nfunction getCullNodes(s, tree, testNode) {\n    var c1 = circle_1.default.scale(testNode.matCircle.circle, s);\n    var cullNodes = {};\n    var limits = [[0, width], [0, height]];\n    var circle = testNode.matCircle.circle;\n    helper(tree, 0, limits, 0);\n    return cullNodes;\n    function cullBranch5(tree) {\n        var branch = tree[5];\n        if (!branch) {\n            return;\n        }\n        branch.forEach(function (node, key) {\n            var c2 = circle_1.default.scale(node.matCircle.circle, s);\n            if (circle_1.default.engulfsCircle(c1, c2)) {\n                cullNodes[key] = node;\n                branch.delete(key);\n            }\n        });\n    }\n    function helper(tree, coordinate, limits, depth) {\n        if (limits === null) {\n            // If we already reached a circle which spans multiple groups \n            // previously, then check all circles in the tree.\n            cullBranch5(tree);\n            for (var i = 0; i <= 4; i++) {\n                var branch = tree[i];\n                if (branch) {\n                    helper(branch, 0, null, depth + 1);\n                }\n            }\n            return;\n        }\n\n        var _calcGroups2 = calcGroups(s, coordinate, limits, circle),\n            groups = _calcGroups2.groups,\n            newLimits = _calcGroups2.newLimits;\n\n        if (groups.length === 1) {\n            cullBranch5(tree);\n            var group = groups[0];\n            var newCoordinate = coordinate ? 0 : 1;\n            if (group === 1 || group === 3) {\n                // One of the higher priority left/top or \n                // right/bottom half groups.\n                var _branch2 = tree[group];\n                if (_branch2) {\n                    helper(_branch2, newCoordinate, newLimits, depth + 1);\n                }\n            } else {\n                // One of the lower priority even \n                // groups (0,2 or 4).\n                var branches = [];\n                branches.push(tree[group]);\n                if (group > 0) {\n                    branches.push(tree[group - 1]);\n                }\n                if (group < 4) {\n                    branches.push(tree[group + 1]);\n                }\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var _branch3 = _step.value;\n\n                        if (_branch3) {\n                            helper(_branch3, newCoordinate, newLimits, depth + 1);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            }\n            return;\n        }\n        cullBranch5(tree);\n        // Circle spans multiple groups at this level of the \n        // tree. Check all circles in all branches.\n        for (var _i = 0; _i <= 4; _i++) {\n            var _branch4 = tree[_i];\n            if (_branch4) {\n                helper(_branch4, 0, null, depth + 1);\n            }\n        }\n    }\n}\n/**\r\n * Modifies cullNodes by adding nodes that potentially need to be called.\r\n * Returns true if a node should NOT be culled, false otherwise.\r\n */\nfunction cullIt(cullHash, cullNodes, satNode, priorNode) {\n    var key = point_on_shape_1.default.makeSimpleKey(satNode.matCircle.circle.center);\n    var anyNotCull = !cullHash[key];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = satNode.branches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var node = _step2.value;\n\n            if (node === priorNode) {\n                continue;\n            }\n            if (cullIt(cullHash, cullNodes, node, satNode)) {\n                anyNotCull = true;\n            }\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    if (anyNotCull) {\n        return true; // Don't cull me\n    }\n    cullNodes.push({ satNode: satNode, priorNode: priorNode });\n    return false;\n}\nfunction cullTheNode(cullNode) {\n    var satNode = cullNode.satNode,\n        priorNode = cullNode.priorNode;\n\n    var idx = priorNode.branches.indexOf(satNode);\n    if (idx >= 0) {\n        priorNode.branches.splice(idx, 1);\n    }\n}\nfunction cullTheNodes(cullNodes) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = cullNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var node = _step3.value;\n\n            cullTheNode(node);\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n}\n/**\r\n * Spacially divide into 5 special groups as follows:\r\n *\r\n *   *******||*******|*******|*******|*******||*******\r\n * 0 <--------------->\r\n * 1         <--------------->\r\n * 2                 <--------------->\r\n * 3                         <--------------->\r\n * 4                                 <--------------->\r\n * 5 - If the circle does not fall in any of above 5 groups.\r\n *\r\n * Note: In the above, the double pipes denote the limits for\r\n *       a coordinate, so as can be seen groups 0 and 4 go outside\r\n *       the limits. Also, groups 1 and 3 are preferred and checked\r\n *       first.\r\n *\r\n * @param s Scale parameter, e.g. 1.1\r\n * @param coordinate - 0 -> horizontal or 1 -> vertical.\r\n * @param limits - The limits within which the circle bounds can fall.\r\n * @param circle - The circle to categorize into a group.\r\n */\nfunction calcGroups(s, coordinate, limits, circle) {\n    var limit = limits[coordinate];\n    var l1 = limit[0];\n    var l2 = limit[1];\n    // Relevant cut-off lines.\n    var q = (l2 - l1) / 4;\n    var w = q + q;\n    // Shift origin\n    var r = circle.radius;\n    var x = circle.center[coordinate] - l1;\n    var x0 = x - r * s;\n    var x1 = x + r * s;\n    var newLimit = [,];\n    var groups = []; // Group to which circle belongs;\n    /* This was the old method to get groups and newLimit, but it\r\n     * seems to be only slightly slower so could also be used\r\n    let is = [1,3,0,2,4]; // Groups 1 and 3 takes priority.\r\n    for (let i=0; i<=4; i++) {\r\n        let q0 = q*(is[i]-1);\r\n        let q1 = q0 + w;\r\n        if (x0 > q0 && x1 <= q1) {\r\n            groups.push(is[i]);\r\n            newLimit = [l1 + q0, l1 + q1];\r\n            break;\r\n        }\r\n    }*/\n    var qStart = Math.floor(x0 / q);\n    var qEnd = Math.floor(x1 / q) + 1;\n    var qDiff = qEnd - qStart;\n    var group = void 0;\n    if (qDiff === 1) {\n        // If contained in sliver.\n        group = 2 * Math.floor(qStart / 2) + 1;\n        groups.push(group);\n        var lowerLimit = l1 + q * (group - 1);\n        newLimit = [lowerLimit, lowerLimit + w];\n    } else if (qDiff === 2) {\n        group = qStart + 1;\n        groups.push(group);\n        var _lowerLimit = l1 + q * (group - 1);\n        newLimit = [_lowerLimit, _lowerLimit + w];\n    }\n    var newLimits = [,];\n    if (groups.length === 1) {\n        var otherCoordinate = coordinate ? 0 : 1;\n        newLimits[otherCoordinate] = limits[otherCoordinate];\n        newLimits[coordinate] = newLimit;\n    }\n    return { groups: groups, newLimits: newLimits };\n}\nexports.default = toScaleAxis;\n\n},{\"../../geometry/classes/circle\":6,\"../../geometry/classes/point-on-shape\":9,\"../classes/mat-tree\":25,\"./copy-mat\":29,\"./get-nodes-as-hash\":34}],37:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\r\n * Traverses the MAT tree and calls a function on each node. This\r\n * function must have side effects to be useful.\r\n *\r\n * @param mat\r\n */\nfunction traverse(mat, f) {\n    g(mat.startNode);\n    function g(matNode, priorNode) {\n        f(matNode, priorNode);\n        //for (let node of matNode.branches) {\n        for (var i = 0; i < matNode.branches.length; i++) {\n            var node = matNode.branches[i];\n            if (node === priorNode) {\n                // Don't go back in tracks.\n                continue;\n            }\n            g(node, matNode);\n        }\n    }\n}\nexports.default = traverse;\n\n},{}],38:[function(_dereq_,module,exports){\n\"use strict\";\n// TODO - move later out of mat module\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar path_curve_1 = _dereq_(\"../geometry/classes/path-curve\");\n//import pathDataPolyFill from './path-data-polyfill/path-data-polyfill.js';\n//\t\t'./path-data-polyfill/path-data-polyfill.js';\nvar DELTA = 1e-6; // TODO - must be replaced with value relative to image size.\n/**\r\n * Get the cubic beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C\", i.e. if it is not an absolute cubic bezier\r\n * coordinate then it is converted into one.\r\n * @param elem - An SVG element\r\n * @returns aaa\r\n */\nfunction getBeziersFromSvgElem(elem) {\n    /**\r\n     * Returns true if the given point is close to the origin (by Manhattan\r\n     * distance), fale otherwise.\r\n     * @private\r\n     * @param p - a point\r\n     * @param delta - a tolerance - defaults to 1e-6;\r\n     */\n    function isCloseToOrigin(p) {\n        var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA;\n\n        return flo_vector2d_1.default.manhattanLength(p) < delta;\n    }\n    /**\r\n     * Returns true if distance between consecutive points are all less than\r\n     * some delta, false otherwise.\r\n     * @private\r\n     * @param ps - an array of points\r\n     * @param {number} [delta] - a tolerance - defaults to 1e-6;\r\n     * @returns {boolean}\r\n     */\n    function isAlmostZeroLength(ps) {\n        var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA;\n\n        for (var i = 1; i < ps.length; i++) {\n            var p1 = ps[i - 1];\n            var p2 = ps[i];\n            if (flo_vector2d_1.default.manhattanDistanceBetween(p1, p2) > DELTA) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function pushBezier(arr, ps_, j) {\n        // TODO \n        // We check if any of the ps are coincident and thus\n        // that the bezier is degenerate in some sense. If that is the\n        // case we apply a heuristic to get a new similar bezier by \n        // respacing the points. This entire function is very \n        // convoluted.\n        // We should investigate a better mathematical solution.\n        // Currently if the bezier degenerates more or less into a point\n        // we make the next bezier start at the previous bezier's end\n        // point else we adjust the bezier to be less pathological.\n        //console.log(Vector)\n        var ds = [[0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[1]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[2]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[0], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[0]), 0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[2]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[1], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[0]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[1]), 0, flo_vector2d_1.default.manhattanDistanceBetween(ps_[2], ps_[3])], [flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[0]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[1]), flo_vector2d_1.default.manhattanDistanceBetween(ps_[3], ps_[2]), 0]];\n        var ps = ps_;\n        var SHIFT = 0.1;\n        // Check if first or last 3 points are coincident\n        if (ds[0][1] < DELTA && ds[1][2] < DELTA || ds[1][2] < DELTA && ds[2][3] < DELTA) {\n            ps = [ps_[0], flo_vector2d_1.default.interpolate(ps_[0], ps_[3], 1 / 3), flo_vector2d_1.default.interpolate(ps_[0], ps_[3], 2 / 3), ps_[3]];\n        }\n        // Check if first 2 points are coincident\n        if (ds[0][1] < DELTA) {\n            ps[1] = flo_vector2d_1.default.interpolate(ps_[0], ps_[2], SHIFT);\n        }\n        // Check if last 2 points are coincident\n        if (ds[2][3] < DELTA) {\n            ps[2] = flo_vector2d_1.default.interpolate(ps_[1], ps_[3], 1 - SHIFT);\n        }\n        // Check if middle 2 points are coincident\n        if (ds[1][2] < DELTA) {\n            ps[1] = flo_vector2d_1.default.interpolate(ps_[0], ps_[1], 1 - SHIFT);\n            ps[2] = flo_vector2d_1.default.interpolate(ps_[2], ps_[3], SHIFT);\n        }\n        arr.push(new path_curve_1.default(j, ps));\n    }\n    var MUST_START_WITH_M = 'Invalid SVG - every new path must start with an M or m.';\n    var INVALID_COMMAND = 'Invalid SVG - command not recognized.';\n    //pathDataPolyFill(); // Ensure polyfill is applied.\n    //let paths = (elem as any).getPathData();  \n    // TODO - must still implement handling of multiple <path>s\n    var paths = elem.getElementsByTagName('path');\n    var path = paths[0];\n    var pathSegs = path.pathSegList;\n    if (pathSegs.numberOfItems < 2) {\n        // A shape is not described   \n        return [];\n    }\n    var pathStarted = false;\n    // Used in conjunction with \"S\" and \"s\"\n    var prev2ndCubicControlPoint = undefined;\n    var prev2ndQuadraticControlPoint = undefined;\n    var bezierArrays = [];\n    var bezierArray = [];\n    var j = void 0;\n    var type = undefined;\n    var initialPoint = undefined;\n    var x0 = void 0;\n    var y0 = void 0;\n    /*\r\n    let pathSeg: {\r\n        type: string/*,\r\n        values: number[]*/ /*\r\n                           };*/\n    for (var i = 0; i < pathSegs.numberOfItems; i++) {\n        var pathSeg = pathSegs.getItem(i);\n        //let vals = pathSeg.values;\n        //pathSeg.type = pathSeg_.pathSegTypeAsLetter;\n        var _type = pathSeg.pathSegTypeAsLetter;\n        var addX = 0;\n        var addY = 0;\n        if (_type == _type.toLowerCase()) {\n            addX = x0;\n            addY = y0;\n        }\n        var prevType = _type;\n        _type = _type.toUpperCase();\n        // TODO - massively simplify this code by using SVGPathSegCurvetoCubicAbs ??????\n        var ps = void 0;\n        switch (_type) {\n            /*\r\n             * M and m: (from www.w3.org)\r\n             * --------------------------\r\n             * Start a new sub-path at the given (x,y) coordinate.\r\n             * M (uppercase) indicates that absolute coordinates will\r\n             * follow; m (lowercase) indicates that relative coordinates\r\n             * will follow. If a moveto is followed by multiple pairs of\r\n             * coordinates, the subsequent pairs are treated as implicit\r\n             * lineto commands. Hence, implicit lineto commands will be\r\n             * relative if the moveto is relative, and absolute if the\r\n             * moveto is absolute. If a relative moveto (m) appears as the\r\n             * first element of the path, then it is treated as a pair of\r\n             * absolute coordinates. In this case, subsequent pairs of\r\n             * coordinates are treated as relative even though the initial\r\n             * moveto is interpreted as an absolute moveto.\r\n             */\n            case 'M':\n                {\n                    // Note: A valid SVG path must start with \"M\" or \"m\".\n                    var _path = pathSeg;\n                    var vals = [_path.x, _path.y];\n                    if (pathStarted) {\n                        // This is a subpath, close as if a Z or z was the\n                        // previous command.\n                        if (prevType !== 'Z') {\n                            var _xInterval = (vals[0] + addX - x0) / 3;\n                            var _yInterval = (vals[1] + addY - y0) / 3;\n                            ps = [[x0, y0], [x0 + _xInterval * 1, y0 + _yInterval * 1], [x0 + _xInterval * 2, y0 + _yInterval * 2], [x0 + _xInterval * 3, y0 + _yInterval * 3]];\n                            prev2ndCubicControlPoint = undefined;\n                            prev2ndQuadraticControlPoint = undefined;\n                            if (!isCloseToOrigin([_xInterval, _yInterval])) {\n                                pushBezier(bezierArray, ps, j++);\n                            }\n                        }\n                    }\n                    if (bezierArray.length) {\n                        bezierArrays.push(bezierArray);\n                        bezierArray = [];\n                    }\n                    pathStarted = true;\n                    // Update current point\n                    x0 = vals[0];\n                    y0 = vals[1];\n                    // Update initial point of current path/sub-path.\n                    initialPoint = [x0, y0];\n                    j = 0;\n                    break;\n                }\n            /*\r\n             * C and c: (from www.w3.org)\r\n             * params: x1 y1 x2 y2 x y\r\n             * --------------------------\r\n             * Draws a cubic Bézier curve from the current point to (x,y)\r\n             * using (x1,y1) as the control point at the beginning of the\r\n             * curve and (x2,y2) as the control point at the end of the\r\n             * curve. C (uppercase) indicates that absolute coordinates\r\n             * will follow; c (lowercase) indicates that relative\r\n             * coordinates will follow. Multiple sets of coordinates may\r\n             * be specified to draw a polybézier. At the end of the\r\n             * command, the new current point becomes the final (x,y)\r\n             * coordinate pair used in the polybézier.\r\n             */\n            case 'C':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path2 = pathSeg;\n                    var _vals = [_path2.x, _path2.y, _path2.x1, _path2.y1, _path2.x2, _path2.y2];\n                    ps = [[x0, y0], [addX + _vals[0], addY + _vals[1]], [addX + _vals[2], addY + _vals[3]], [addX + _vals[4], addY + _vals[5]]];\n                    prev2ndCubicControlPoint = ps[2];\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * S and s: (from www.w3.org)\r\n             * params: x2 y2 x y\r\n             * --------------------------\r\n             * Draws a cubic Bézier curve from the current point to\r\n             * (x,y). The first control point is assumed to be the\r\n             * reflection of the second control point on the previous\r\n             * command relative to the current point. (If there is no\r\n             * previous command or if the previous command was not an\r\n             * C, c, S or s, assume the first control point is\r\n             * coincident with the current point.) (x2,y2) is the\r\n             * second control point (i.e., the control point at the end\r\n             * of the curve). S (uppercase) indicates that absolute\r\n             * coordinates will follow; s (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple sets of\r\n             * coordinates may be specified to draw a polybézier.\r\n             * At the end of the command, the new current point becomes\r\n             * the final (x,y) coordinate pair used in the polybézier.\r\n             */\n            case 'S':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path3 = pathSeg;\n                    var _vals2 = [_path3.x, _path3.y, _path3.x2, _path3.y2];\n                    var x1 = void 0;\n                    var y1 = void 0;\n                    if (prev2ndCubicControlPoint) {\n                        x1 = x0 - prev2ndCubicControlPoint[0] + x0;\n                        y1 = y0 - prev2ndCubicControlPoint[1] + y0;\n                    } else {\n                        x1 = x0;\n                        y1 = y0;\n                    }\n                    ps = [[x0, y0], [x1, y1], [addX + _vals2[0], addY + _vals2[1]], [addX + _vals2[2], addY + _vals2[3]]];\n                    prev2ndCubicControlPoint = ps[2];\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * L and l: (from www.w3.org)\r\n             * params: x y\r\n             * --------------------------\r\n             * Draw a line from the current point to the given (x,y)\r\n             * coordinate which becomes the new current point. L\r\n             * (uppercase) indicates that absolute coordinates will\r\n             * follow; l (lowercase) indicates that relative\r\n             * coordinates will follow. A number of coordinates pairs\r\n             * may be specified to draw a polyline. At the end of the\r\n             * command, the new current point is set to the final set\r\n             * of coordinates provided.\r\n             */\n            case 'L':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path4 = pathSeg;\n                    var _vals3 = [_path4.x, _path4.y];\n                    var _xInterval2 = (_vals3[0] + addX - x0) / 3;\n                    var _yInterval2 = (_vals3[1] + addY - y0) / 3;\n                    ps = [[x0, y0], [x0 + _xInterval2 * 1, y0 + _yInterval2 * 1], [x0 + _xInterval2 * 2, y0 + _yInterval2 * 2], [x0 + _xInterval2 * 3, y0 + _yInterval2 * 3]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isCloseToOrigin([_xInterval2, _yInterval2])) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * H and h: (from www.w3.org)\r\n             * params: x\r\n             * --------------------------\r\n             * Draws a horizontal line from the current point (cpx, cpy)\r\n             * to (x, cpy). H (uppercase) indicates that absolute\r\n             * coordinates will follow; h (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple x values can\r\n             * be provided (although usually this doesn't make sense).\r\n             * At the end of the command, the new current point becomes\r\n             * (x, cpy) for the final value of x.\r\n             */\n            case 'H':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path5 = pathSeg;\n                    var _vals4 = [_path5.x];\n                    var _xInterval3 = (_vals4[0] + addX - x0) / 3;\n                    ps = [[x0, y0], [x0 + _xInterval3 * 1, y0], [x0 + _xInterval3 * 2, y0], [x0 + _xInterval3 * 3, y0]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (Math.abs(_xInterval3) > DELTA) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * V and v: (from www.w3.org)\r\n             * params: y\r\n             * --------------------------\r\n             * Draws a vertical line from the current point (cpx, cpy)\r\n             * to (cpx, y). V (uppercase) indicates that absolute\r\n             * coordinates will follow; v (lowercase) indicates that\r\n             * relative coordinates will follow. Multiple y values can\r\n             * be provided (although usually this doesn't make sense).\r\n             * At the end of the command, the new current point becomes\r\n             * (cpx, y) for the final value of y.\r\n             */\n            case 'V':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path6 = pathSeg;\n                    var _vals5 = [_path6.y];\n                    //let yInterval = (vals[1] + addY - y0)/3;\n                    var _yInterval3 = (_vals5[0] + addY - y0) / 3;\n                    ps = [[x0, y0], [x0, y0 + _yInterval3 * 1], [x0, y0 + _yInterval3 * 2], [x0, y0 + _yInterval3 * 3]];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (Math.abs(_yInterval3) > DELTA) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * Q and q: (from www.w3.org)\r\n             * params: x1 y1 x y\r\n             * --------------------------\r\n             * Draws a quadratic Bézier curve from the current point to\r\n             * (x,y) using (x1,y1) as the control point. Q (uppercase)\r\n             * indicates that absolute coordinates will follow; q\r\n             * (lowercase) indicates that relative coordinates will\r\n             * follow. Multiple sets of coordinates may be specified\r\n             * to draw a polybézier. At the end of the command, the new\r\n             * current point becomes the final (x,y) coordinate pair\r\n             * used in the polybézier.\r\n             */\n            case 'Q':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path7 = pathSeg;\n                    var _vals6 = [_path7.x, _path7.y, _path7.x1, _path7.y1];\n                    //---------------------------------------------------\n                    // Convert quadratic to cubic\n                    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n                    //---------------------------------------------------\n                    var QP0 = [x0, y0];\n                    var QP1 = [addX + _vals6[0], addY + _vals6[1]];\n                    var QP2 = [addX + _vals6[2], addY + _vals6[3]];\n                    // Endpoints stay the same\n                    var CP0 = QP0;\n                    var CP3 = QP2;\n                    // CP1 = QP0 + 2/3 *(QP1-QP0)\n                    var CP1 = [QP0[0] + 2 / 3 * (QP1[0] - QP0[0]), QP0[1] + 2 / 3 * (QP1[1] - QP0[1])];\n                    // CP2 = QP2 + 2/3 *(QP1-QP2)\n                    var CP2 = [QP2[0] + 2 / 3 * (QP1[0] - QP2[0]), QP2[1] + 2 / 3 * (QP1[1] - QP2[1])];\n                    ps = [CP0, CP1, CP2, CP3];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = QP1;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * T and t: (from www.w3.org)\r\n             * params: x y\r\n             * --------------------------\r\n             * Draws a quadratic Bézier curve from the current point to\r\n             * (x,y). The control point is assumed to be the reflection\r\n             * of the control point on the previous command relative to\r\n             * the current point. (If there is no previous command or if\r\n             * the previous command was not a Q, q, T or t, assume the\r\n             * control point is coincident with the current point.) T\r\n             * (uppercase) indicates that absolute coordinates will\r\n             * follow; t (lowercase) indicates that relative coordinates\r\n             * will follow. At the end of the command, the new current\r\n             * point becomes the final (x,y) coordinate pair used in the\r\n             * polybézier.\r\n             */\n            case 'T':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    var _path8 = pathSeg;\n                    var _vals7 = [_path8.x, _path8.y];\n                    var _x3 = void 0;\n                    var _y = void 0;\n                    if (prev2ndQuadraticControlPoint) {\n                        _x3 = x0 - prev2ndQuadraticControlPoint[0] + x0;\n                        _y = y0 - prev2ndQuadraticControlPoint[1] + y0;\n                    } else {\n                        _x3 = x0;\n                        _y = y0;\n                    }\n                    //---------------------------------------------------\n                    // Convert quadratic to cubic\n                    // see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n                    //---------------------------------------------------\n                    var _QP = [x0, y0];\n                    var _QP2 = [_x3, _y];\n                    var _QP3 = [addX + _vals7[0], addY + _vals7[1]];\n                    // Endpoints stay the same\n                    var _CP = _QP;\n                    var _CP2 = _QP3;\n                    // CP1 = QP0 + 2/3 *(QP1-QP0)\n                    var _CP3 = [_QP[0] + 2 / 3 * (_QP2[0] - _QP[0]), _QP[1] + 2 / 3 * (_QP2[1] - _QP[1])];\n                    // CP2 = QP2 + 2/3 *(QP1-QP2)\n                    var _CP4 = [_QP3[0] + 2 / 3 * (_QP2[0] - _QP3[0]), _QP3[1] + 2 / 3 * (_QP2[1] - _QP3[1])];\n                    ps = [_CP, _CP3, _CP4, _CP2];\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = _QP2;\n                    // Update current point\n                    x0 = ps[3][0];\n                    y0 = ps[3][1];\n                    if (!isAlmostZeroLength(ps)) {\n                        pushBezier(bezierArray, ps, j++);\n                    }\n                    break;\n                }\n            /*\r\n             * A and a: (from www.w3.org)\r\n             * params: rx ry x-axis-rotation large-arc-flag\r\n             *         sweep-flag x y\r\n             * --------------------------------------------\r\n             * Draws an elliptical arc from the current point to (x, y).\r\n             * The size and orientation of the ellipse are defined by\r\n             * two radii (rx, ry) and an x-axis-rotation, which\r\n             * indicates how the ellipse as a whole is rotated relative\r\n             * to the current coordinate system. The center (cx, cy) of\r\n             * the ellipse is calculated automatically to satisfy the\r\n             * constraints imposed by the other parameters.\r\n             * large-arc-flag and sweep-flag contribute to the automatic\r\n             * calculations and help determine how the arc is drawn.\r\n             */\n            case 'A':\n                {\n                    if (!pathStarted) {\n                        throw new Error(MUST_START_WITH_M);\n                    }\n                    prev2ndCubicControlPoint = undefined;\n                    prev2ndQuadraticControlPoint = undefined;\n                    // Update current point\n                    //x0 = ? ps[3][0]; \n                    //y0 = ? ps[3][1];\n                    pushBezier(bezierArray, ps, j++);\n                    break;\n                }\n            /*\r\n             * Z and z: (from www.w3.org)\r\n             * params: (none)\r\n             * --------------------------\r\n             * Close the current subpath by drawing a straight line\r\n             * from the current point to current subpath's initial\r\n             * point. Since the Z and z commands take no parameters,\r\n             * they have an identical effect.\r\n             */\n            case 'Z':\n                if (!pathStarted) {\n                    throw new Error(MUST_START_WITH_M);\n                }\n                var xInterval = (initialPoint[0] + addX - x0) / 3;\n                var yInterval = (initialPoint[1] + addY - y0) / 3;\n                ps = [[x0, y0], [x0 + xInterval * 1, y0 + yInterval * 1], [x0 + xInterval * 2, y0 + yInterval * 2], [x0 + xInterval * 3, y0 + yInterval * 3]];\n                prev2ndCubicControlPoint = undefined;\n                prev2ndQuadraticControlPoint = undefined;\n                // Update current point\n                x0 = ps[3][0];\n                y0 = ps[3][1];\n                if (!isCloseToOrigin([xInterval, yInterval])) {\n                    pushBezier(bezierArray, ps, j++);\n                }\n                break;\n            default:\n                throw new Error(INVALID_COMMAND);\n        }\n    }\n    if (bezierArray.length) {\n        bezierArrays.push(bezierArray);\n        bezierArray = [];\n    }\n    return bezierArrays;\n}\n/**\r\n * Returns a string representation of the given beziers linked loop.\r\n * @param beziers - A linked loop of cubic beziers.\r\n */\nfunction getPathStrFromBezierLoop(bezierLoop) {\n    var beziers = bezierLoop.getAsArray().map(function (x) {\n        return x.item;\n    });\n    return Svg.getPathStrFromBeziers(beziers);\n}\n/**\r\n * Returns a string representation of the given array of beziers.\r\n * @param {number[][][]} beziers - An array of cubic beziers.\r\n * @returns {string}\r\n */\nfunction getPathStrFromBeziers(beziers) {\n    var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    var D = decimalPlaces;\n    var str = '';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = beziers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var ps = _step.value;\n\n            if (ps === beziers[0]) {\n                str = 'M ' + ps[0][0].toFixed(D) + ' ' + ps[0][1].toFixed(D) + '\\n';\n            }\n            str += 'C ' + ps[1][0].toFixed(D) + ' ' + ps[1][1].toFixed(D) + ' ' + ps[2][0].toFixed(D) + ' ' + ps[2][1].toFixed(D) + ' ' + ps[3][0].toFixed(D) + ' ' + ps[3][1].toFixed(D) + ' ' + '\\n';\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return str;\n}\nvar Svg = {\n    getBeziersFromSvgElem: getBeziersFromSvgElem,\n    getPathStrFromBezierLoop: getPathStrFromBezierLoop,\n    getPathStrFromBeziers: getPathStrFromBeziers\n};\nexports.default = Svg;\n\n},{\"../geometry/classes/path-curve\":8,\"flo-vector2d\":55}],39:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flo_poly_1 = _dereq_(\"flo-poly\");\nvar flo_vector2d_1 = _dereq_(\"flo-vector2d\");\nvar flo_memoize_1 = _dereq_(\"flo-memoize\");\nvar flo_gauss_quadrature_1 = _dereq_(\"flo-gauss-quadrature\");\nvar flo_graham_scan_1 = _dereq_(\"flo-graham-scan\");\nvar DELTA = 1e-10;\nvar _flo_vector2d_1$defau = flo_vector2d_1.default,\n    rotate = _flo_vector2d_1$defau.rotatePs,\n    translate = _flo_vector2d_1$defau.translatePs;\n\nvar memoize = flo_memoize_1.default.m1;\n/**\n * Returns the power basis representation of the bezier's x-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The power basis polynomial from highest power to lowest,\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\n */\nvar getX = memoize(function (ps) {\n    var _ps = _slicedToArray(ps, 4),\n        _ps$ = _slicedToArray(_ps[0], 1),\n        x0 = _ps$[0],\n        _ps$2 = _slicedToArray(_ps[1], 1),\n        x1 = _ps$2[0],\n        _ps$3 = _slicedToArray(_ps[2], 1),\n        x2 = _ps$3[0],\n        _ps$4 = _slicedToArray(_ps[3], 1),\n        x3 = _ps$4[0];\n\n    return [x3 - 3 * x2 + 3 * x1 - x0, 3 * x2 - 6 * x1 + 3 * x0, 3 * x1 - 3 * x0, x0];\n});\n/**\n * Returns the power basis representation of the bezier's y-coordinates.\n * This function is memoized on its points parameter by object reference.\n * @param ps - A bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nvar getY = memoize(function (ps) {\n    var _ps2 = _slicedToArray(ps, 4),\n        _ps2$ = _slicedToArray(_ps2[0], 2),\n        y0 = _ps2$[1],\n        _ps2$2 = _slicedToArray(_ps2[1], 2),\n        y1 = _ps2$2[1],\n        _ps2$3 = _slicedToArray(_ps2[2], 2),\n        y2 = _ps2$3[1],\n        _ps2$4 = _slicedToArray(_ps2[3], 2),\n        y3 = _ps2$4[1];\n\n    return [y3 - 3 * y2 + 3 * y1 - y0, 3 * y2 - 6 * y1 + 3 * y0, 3 * y1 - 3 * y0, y0];\n});\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * x-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n */\nvar getDx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getX(ps));\n});\n/**\n * Returns the derivative of the power basis representation of the bezier's\n * y-coordinates. This function is memoized on its points parameter by object\n * reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The differentiated power basis polynomial from highest\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\n */\nvar getDy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getY(ps));\n});\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nvar getDdx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDx(ps));\n});\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nvar getDdy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDy(ps));\n});\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nvar getDddx = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDdx(ps));\n});\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nvar getDddy = memoize(function (ps) {\n    return flo_poly_1.default.differentiate(getDdy(ps));\n});\n/**\n * Returns the convex hull of a bezier's control points. This hull bounds the\n * bezier curve. This function is memoized.\n *\n * The tolerance at which the cross product of two nearly collinear lines of the\n * hull are considered collinear is 1e-12.\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns An ordered array of convex hull points.\n */\nvar getBoundingHull = memoize(flo_graham_scan_1.default);\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n * @param l - a 2d line represented by two points\n * @returns Control points of the cubic bezier.\n */\nfunction fromLine(l) {\n    var _l = _slicedToArray(l, 2),\n        _l$ = _slicedToArray(_l[0], 2),\n        x0 = _l$[0],\n        y0 = _l$[1],\n        _l$2 = _slicedToArray(_l[1], 2),\n        x1 = _l$2[0],\n        y1 = _l$2[1];\n\n    var xInterval = (x1 - x0) / 3;\n    var yInterval = (y1 - y0) / 3;\n    return [[x0, y0], [x0 + xInterval, y0 + yInterval], [x0 + xInterval * 2, y0 + yInterval * 2], [x1, y1]];\n}\nfunction evaluate(ps, t) {\n    var _ps3 = _slicedToArray(ps, 4),\n        _ps3$ = _slicedToArray(_ps3[0], 2),\n        x0 = _ps3$[0],\n        y0 = _ps3$[1],\n        _ps3$2 = _slicedToArray(_ps3[3], 2),\n        x3 = _ps3$2[0],\n        y3 = _ps3$2[1];\n\n    var evX = evaluateX(ps);\n    var evY = evaluateY(ps);\n    function f(t) {\n        if (t === 0) {\n            return [x0, y0];\n        } else if (t === 1) {\n            return [x3, y3];\n        }\n        return [evX(t), evY(t)];\n    }\n    return t === undefined ? f : f(t);\n}\n/**\n * Returns the given bezier's inflection points.\n **/\nfunction findBezierInflectionPoints(ps) {\n    var _ps4 = _slicedToArray(ps, 4),\n        _ps4$ = _slicedToArray(_ps4[0], 2),\n        x0 = _ps4$[0],\n        y0 = _ps4$[1],\n        _ps4$2 = _slicedToArray(_ps4[1], 2),\n        x1 = _ps4$2[0],\n        y1 = _ps4$2[1],\n        _ps4$3 = _slicedToArray(_ps4[2], 2),\n        x2 = _ps4$3[0],\n        y2 = _ps4$3[1],\n        _ps4$4 = _slicedToArray(_ps4[3], 2),\n        x3 = _ps4$4[0],\n        y3 = _ps4$4[1];\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n\n\n    var ax = x1 - x0;\n    var ay = y1 - y0;\n    var bx = x2 - x1 - ax;\n    var by = y2 - y1 - ay;\n    var cx = x3 - x2 - ax - 2 * bx;\n    var cy = y3 - y2 - ay - 2 * by;\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\n    var a = bx * cy - by * cx;\n    var b = ax * cy - ay * cx;\n    var c = ax * by - ay * bx;\n    var inflectionTimes = flo_poly_1.default.allRoots([a, b, c], 0, 1);\n    var evPs = evaluate(ps);\n    return inflectionTimes.map(evPs);\n}\nfunction κ(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    var evDdx = evaluateDdx(ps);\n    var evDdy = evaluateDdy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var ddx = evDdx(t);\n        var ddy = evDdy(t);\n        var a = dx * ddy - dy * ddx;\n        var b = Math.sqrt(Math.pow(dx * dx + dy * dy, 3));\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\n/**\n * Alias of κ.\n */\nvar curvature = κ;\nfunction κds(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    var evDdx = evaluateDdx(ps);\n    var evDdy = evaluateDdy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var ddx = evDdx(t);\n        var ddy = evDdy(t);\n        var a = dx * ddy - dy * ddx;\n        var b = dx * dx + dy * dy;\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction dκMod(ps, t) {\n    var _ps5 = _slicedToArray(ps, 4),\n        _ps5$ = _slicedToArray(_ps5[0], 2),\n        x0 = _ps5$[0],\n        y0 = _ps5$[1],\n        _ps5$2 = _slicedToArray(_ps5[1], 2),\n        x1 = _ps5$2[0],\n        y1 = _ps5$2[1],\n        _ps5$3 = _slicedToArray(_ps5[2], 2),\n        x2 = _ps5$3[0],\n        y2 = _ps5$3[1],\n        _ps5$4 = _slicedToArray(_ps5[3], 2),\n        x3 = _ps5$4[0],\n        y3 = _ps5$4[1];\n\n    function f(t) {\n        var ts = t * t;\n        var omt = 1 - t;\n        var a = ts * x3;\n        var b = ts * y3;\n        var c = 2 * t - 3 * ts;\n        var d = (3 * t - 1) * omt;\n        var e = omt * omt;\n        var f = 3 * (a + c * x2 - d * x1 - e * x0);\n        var g = 3 * (b + c * y2 - d * y1 - e * y0);\n        var h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n        var i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n        var j = Math.sqrt(f * f + g * g);\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) - g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) - (f * h - b * g) * (2 * h * g + 2 * b * f) * j;\n    }\n    return t === undefined ? f : f(t);\n}\nfunction tangent(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        var d = Math.sqrt(dx * dx + dy * dy);\n        return [dx / d, dy / d];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction normal(ps, t) {\n    var tanPs = tangent(ps);\n    function f(t) {\n        var v = tanPs(t);\n        return [v[1], -v[0]];\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\n/**\n * <p>\n * Categorizes the given cubic bezier curve according to whether it has a loop,\n * a cusp, or zero, one or two inflection points all of which are mutually\n * exclusive.\n * </p>\n * <p>\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\n * this</a> paper.\n * </p>\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns {string} A value of 'L', 'C', '0', '1', or '2' depending on whether\n * the curve has a loop, a cusp, or zero, one or two inflection points.\n */\nfunction categorize(ps) {\n    // TODO - finish\n}\nfunction totalCurvature(ps, interval) {\n    var tanPs = tangent(ps);\n    function f(interval) {\n        return flo_gauss_quadrature_1.default(κds(ps), interval);\n        // TODO\n        /*\n        let [a,b] = interval;\n        let tangentA = tanPs(a);\n        let tangentB = tanPs(b);\n        let sinθ = Vector.cross(tanA, tanB)\n        */\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nfunction totalAbsoluteCurvature(ps, interval) {\n    function f() {\n        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 1];\n\n        // Numerically integrate the absolute curvature\n        var result = flo_gauss_quadrature_1.default(function (t) {\n            return Math.abs(κds(ps)(t));\n        }, interval);\n        return result;\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nfunction len(interval, ps) {\n    function f(ps) {\n        if (interval[0] === interval[1]) {\n            return 0;\n        }\n\n        var _ps6 = _slicedToArray(ps, 4),\n            _ps6$ = _slicedToArray(_ps6[0], 2),\n            x0 = _ps6$[0],\n            y0 = _ps6$[1],\n            _ps6$2 = _slicedToArray(_ps6[1], 2),\n            x1 = _ps6$2[0],\n            y1 = _ps6$2[1],\n            _ps6$3 = _slicedToArray(_ps6[2], 2),\n            x2 = _ps6$3[0],\n            y2 = _ps6$3[1],\n            _ps6$4 = _slicedToArray(_ps6[3], 2),\n            x3 = _ps6$4[0],\n            y3 = _ps6$4[1];\n        // Keep line below to ensure zero length curve returns zero!\n\n\n        if (x0 === x1 && x1 === x2 && x2 === x3 && y0 === y1 && y1 === y2 && y2 === y3) {\n            return 0;\n        }\n        var evDs = ds(ps);\n        return flo_gauss_quadrature_1.default(evDs, interval);\n    }\n    // Curry\n    return ps === undefined ? f : f(ps);\n}\nfunction getTAtLength(ps, s) {\n    var lenAtT = function lenAtT(t) {\n        return len([0, t], ps);\n    };\n    function f(s) {\n        return flo_poly_1.default.brent(function (t) {\n            return lenAtT(t) - s;\n        }, 0, 1);\n    }\n    // Curry\n    return s === undefined ? f : f(s);\n}\nfunction ds(ps, t) {\n    var evDx = evaluateDx(ps);\n    var evDy = evaluateDy(ps);\n    function f(t) {\n        var dx = evDx(t);\n        var dy = evDy(t);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction evaluateX(ps, t) {\n    var xPs = getX(ps); // Speed optimizing cache\n    var evPs = flo_poly_1.default.evaluate(xPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][0];\n        }\n        if (t === 1) {\n            return ps[3][0];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateY(ps, t) {\n    var yPs = getY(ps); // Speed optimizing cache\n    var evPs = flo_poly_1.default.evaluate(yPs);\n    function f(t) {\n        if (t === 0) {\n            return ps[0][1];\n        }\n        if (t === 1) {\n            return ps[3][1];\n        }\n        return evPs(t);\n    }\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDx(ps, t) {\n    var dPs = getDx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDy(ps, t) {\n    var dPs = getDy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDdx(ps, t) {\n    var ddPs = getDdx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDdy(ps, t) {\n    var ddPs = getDdy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDddx(ps, t) {\n    var dddPs = getDddx(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nfunction evaluateDddy(ps, t) {\n    var dddPs = getDddy(ps); // Speed optimizing cache\n    var f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\n// TODO - refactor getBounds, getBoundingBox, etc.\n/**\n * Helper function. Returns the bounding box of the normalized (i.e. first point\n * moved to origin and rotated so that last point lies on x-axis) given cubic\n * bezier.\n * @ignore\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param sinθ - Sine of angle made by line from first bezier point to\n * last with x-axis.\n * @param cosθ - Cosine of angle made by line from first bezier point\n * to last with x-axis.\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n    var vectorToOrigin = flo_vector2d_1.default.transform(ps[0], function (x) {\n        return -x;\n    });\n    var boundingPs = flo_vector2d_1.default.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\n    return getBoundingBox(boundingPs);\n}\n/**\n * Returns the tight bounding box of the given cubic bezier.\n * @returns The tight bounding box of the bezier as four ordered\n * points of a rotated rectangle.\n * TODO - test case of baseLength === 0\n */\nvar getBoundingBoxTight = memoize(function (ps) {\n    var _ps7 = _slicedToArray(ps, 4),\n        _ps7$ = _slicedToArray(_ps7[0], 2),\n        x0 = _ps7$[0],\n        y0 = _ps7$[1],\n        _ps7$2 = _slicedToArray(_ps7[1], 2),\n        x1 = _ps7$2[0],\n        y1 = _ps7$2[1],\n        _ps7$3 = _slicedToArray(_ps7[2], 2),\n        x2 = _ps7$3[0],\n        y2 = _ps7$3[1],\n        _ps7$4 = _slicedToArray(_ps7[3], 2),\n        x3 = _ps7$4[0],\n        y3 = _ps7$4[1];\n\n    var baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n    var sinθ = (y3 - y0) / baseLength;\n    var cosθ = (x3 - x0) / baseLength;\n    var box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n\n    var _box = _slicedToArray(box, 2),\n        _box$ = _slicedToArray(_box[0], 2),\n        p0x = _box$[0],\n        p0y = _box$[1],\n        _box$2 = _slicedToArray(_box[1], 2),\n        p1x = _box$2[0],\n        p1y = _box$2[1];\n\n    var axisAlignedBox = [box[0], [p1x, p0y], box[1], [p0x, p1y]];\n    return flo_vector2d_1.default.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\n});\n/**\n * Returns the axis-aligned bounding box of a given bezier.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns the axis-aligned bounding box in the form\n * [[minx, miny], [maxx,maxy]\n */\nvar getBoundingBox = memoize(function (ps) {\n    return getBounds(ps).box;\n});\n/**\n * Calculates and returns general bezier bounds.\n * @returns {object} The axis-aligned bounding box together with the t values\n * where the bounds on the bezier are reached.\n */\nvar getBounds = memoize(function (ps) {\n    // Roots of derivative\n    var roots = [getDx(ps), getDy(ps)].map(function (poly) {\n        return flo_poly_1.default.allRoots(poly, 0, 1);\n    });\n    // Endpoints\n    roots[0].push(0, 1);\n    roots[1].push(0, 1);\n    var minX = Number.POSITIVE_INFINITY;\n    var maxX = Number.NEGATIVE_INFINITY;\n    var minY = Number.POSITIVE_INFINITY;\n    var maxY = Number.NEGATIVE_INFINITY;\n    var tMinX = undefined;\n    var tMinY = undefined;\n    var tMaxX = undefined;\n    var tMaxY = undefined;\n    // Test points\n    for (var i = 0; i < roots[0].length; i++) {\n        var t = roots[0][i];\n        var x = evaluateX(ps, t);\n        if (x < minX) {\n            minX = x;\n            tMinX = t;\n        }\n        if (x > maxX) {\n            maxX = x;\n            tMaxX = t;\n        }\n    }\n    for (var _i = 0; _i < roots[1].length; _i++) {\n        var _t = roots[1][_i];\n        var y = evaluateY(ps, _t);\n        if (y < minY) {\n            minY = y;\n            tMinY = _t;\n        }\n        if (y > maxY) {\n            maxY = y;\n            tMaxY = _t;\n        }\n    }\n    var ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n    var box = [[minX, minY], [maxX, maxY]];\n    return { ts: ts, box: box };\n});\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given curve and ends at the\n * given t parameter. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t1 - The t parameter where the resultant bezier should start\n * @param t2 - The t parameter where the resultant bezier should end\n * @returns {number[][]}\n */\nfunction fromTo(ps) {\n    return function (t1, t2) {\n        if (t1 === t2) {\n            // Degenerate case\n            var p = evaluate(ps, t1);\n            return [p, p, p, p];\n        }\n        var t = fromTTo1(ps, t1);\n        return from0ToT(t, (t2 - t1) / (1 - t1));\n    };\n}\n;\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given curve's t=0 and ends\n * at the given t parameter. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should end\n */\nfunction from0ToT(ps, t) {\n    var _ps8 = _slicedToArray(ps, 4),\n        _ps8$ = _slicedToArray(_ps8[0], 2),\n        x0 = _ps8$[0],\n        y0 = _ps8$[1],\n        _ps8$2 = _slicedToArray(_ps8[1], 2),\n        x1 = _ps8$2[0],\n        y1 = _ps8$2[1],\n        _ps8$3 = _slicedToArray(_ps8[2], 2),\n        x2 = _ps8$3[0],\n        y2 = _ps8$3[1],\n        _ps8$4 = _slicedToArray(_ps8[3], 2),\n        x3 = _ps8$4[0],\n        y3 = _ps8$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    return [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n}\n/**\n * <p>\n * Returns a cubic bezier curve that starts at the given t parameter and\n * ends at t=1. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the resultant bezier should start\n */\nfunction fromTTo1(ps, t) {\n    var _ps9 = _slicedToArray(ps, 4),\n        _ps9$ = _slicedToArray(_ps9[0], 2),\n        x0 = _ps9$[0],\n        y0 = _ps9$[1],\n        _ps9$2 = _slicedToArray(_ps9[1], 2),\n        x1 = _ps9$2[0],\n        y1 = _ps9$2[1],\n        _ps9$3 = _slicedToArray(_ps9[2], 2),\n        x2 = _ps9$3[0],\n        y2 = _ps9$3[1],\n        _ps9$4 = _slicedToArray(_ps9[3], 2),\n        x3 = _ps9$4[0],\n        y3 = _ps9$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    return [[t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n}\n/**\n * <p>\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\n * </p>\n * <p>\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * </p>\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the curve should be split\n * @returns {number[][]}\n */\nfunction splitAt(ps, t) {\n    var _ps10 = _slicedToArray(ps, 4),\n        _ps10$ = _slicedToArray(_ps10[0], 2),\n        x0 = _ps10$[0],\n        y0 = _ps10$[1],\n        _ps10$2 = _slicedToArray(_ps10[1], 2),\n        x1 = _ps10$2[0],\n        y1 = _ps10$2[1],\n        _ps10$3 = _slicedToArray(_ps10[2], 2),\n        x2 = _ps10$3[0],\n        y2 = _ps10$3[1],\n        _ps10$4 = _slicedToArray(_ps10[3], 2),\n        x3 = _ps10$4[0],\n        y3 = _ps10$4[1];\n\n    var s = 1 - t;\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var s2 = s * s;\n    var s3 = s2 * s;\n    var ps1 = [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n    var ps2 = [ps1[3], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n    return [ps1, ps2];\n}\n/**\n * Returns a human readable string representation of the given bezier.\n * @param ps - A bezier curve\n * @returns {string}\n */\nfunction toString(ps) {\n    var _ps11 = _slicedToArray(ps, 4),\n        _ps11$ = _slicedToArray(_ps11[0], 2),\n        x0 = _ps11$[0],\n        y0 = _ps11$[1],\n        _ps11$2 = _slicedToArray(_ps11[1], 2),\n        x1 = _ps11$2[0],\n        y1 = _ps11$2[1],\n        _ps11$3 = _slicedToArray(_ps11[2], 2),\n        x2 = _ps11$3[0],\n        y2 = _ps11$3[1],\n        _ps11$4 = _slicedToArray(_ps11[3], 2),\n        x3 = _ps11$4[0],\n        y3 = _ps11$4[1];\n\n    return \"[[\" + x0 + \",\" + y0 + \"],[\" + x1 + \",\" + y1 + \"],[\" + x2 + \",\" + y2 + \"],[\" + x3 + \",\" + y3 + \"]]\";\n}\n/**\n * Scales all control points of the given bezier by the given factor.\n * @param ps - A bezier curve\n * @param factor - The scale factor\n * @returns {number[][]}\n */\nfunction scale(ps, factor) {\n    return ps.map(function (x) {\n        return [x[0] * factor, x[1] * factor];\n    });\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given line.\n * @param ps - The bezier curve\n * @param l - The line given as a start and end point\n * @returns {number[]}\n */\nfunction lineIntersection(ps, l) {\n    var _l2 = _slicedToArray(l, 2),\n        _l2$ = _slicedToArray(_l2[0], 2),\n        x0 = _l2$[0],\n        y0 = _l2$[1],\n        _l2$2 = _slicedToArray(_l2[1], 2),\n        x1 = _l2$2[0],\n        y1 = _l2$2[1];\n\n    var x = x1 - x0,\n        y = y1 - y0;\n\n    if (x === 0 && y === 0) {\n        return [];\n    }\n    // Move the line and the bezier together so the line's first point is on the\n    // origin.\n    ps = translate([-x0, -y0], ps);\n    // Rotate the bezier and line together so the line is y=0.\n    var len = Math.sqrt(x * x + y * y);\n    var sinθ = y / len;\n    var cosθ = x / len;\n    ps = rotate(-sinθ, cosθ, ps);\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getY(ps), 0, 1);\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given horizontal line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtY(ps, y) {\n    // Translate ps so that y = 0.\n    ps = ps.map(function (p) {\n        return [p[0], p[1] - y];\n    });\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getY(ps), 0, 1);\n}\n/**\n * Returns the bezier t values of the intersection between the given cubic\n * bezier and the given vertical line.\n * @param ps - The bezier curve\n * @param y - The y value of the horizontal line\n */\nfunction tsAtX(ps, x) {\n    // Translate ps so that x = 0.\n    ps = ps.map(function (p) {\n        return [p[0] - x, p[1]];\n    });\n    // Find the intersection t values\n    return flo_poly_1.default.allRoots(getX(ps), 0, 1);\n}\n/**\n * Returns the best least squares quadratic bezier approximation to the given\n * cubic bezier. Note that the two bezier endpoints differ in general.\n * @param ps - A cubic bezier curve.\n * @returns {number[][]}\n */\nfunction toQuadratic(ps) {\n    var _ps12 = _slicedToArray(ps, 4),\n        _ps12$ = _slicedToArray(_ps12[0], 2),\n        x0 = _ps12$[0],\n        y0 = _ps12$[1],\n        _ps12$2 = _slicedToArray(_ps12[1], 2),\n        x1 = _ps12$2[0],\n        y1 = _ps12$2[1],\n        _ps12$3 = _slicedToArray(_ps12[2], 2),\n        x2 = _ps12$3[0],\n        y2 = _ps12$3[1],\n        _ps12$4 = _slicedToArray(_ps12[3], 2),\n        x3 = _ps12$4[0],\n        y3 = _ps12$4[1];\n\n    return [[19 / 20 * x0 + 3 / 20 * x1 + -3 / 20 * x2 + 1 / 20 * x3, 19 / 20 * y0 + 3 / 20 * y1 + -3 / 20 * y2 + 1 / 20 * y3], [-1 / 4 * x0 + 3 / 4 * x1 + 3 / 4 * x2 + -1 / 4 * x3, -1 / 4 * y0 + 3 / 4 * y1 + 3 / 4 * y2 + -1 / 4 * y3], [1 / 20 * x0 + -3 / 20 * x1 + 3 / 20 * x2 + 19 / 20 * x3, 1 / 20 * y0 + -3 / 20 * y1 + 3 / 20 * y2 + 19 / 20 * y3]];\n}\n/**\n * Returns the hybrid quadratic version of the given cubic bezier. For a\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\n * this paper</a>.\n * @param ps - A cubic bezier curve.\n * @returns {object[]} An array of three quadratic bezier points where the\n * middle point is a 'hybrid' point represented as a line (itself represented\n * by two points (a linear bezier curve)) which can be evaluated at a different\n * t value (call it th). If evaluated at the same t value the result is the same\n * as evaluating the original cubic bezier at t. The set generated by evaluating\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\n * bound around the orginal cubic bezier curve. The length of the linear bezier\n * curve mentioned above is a measure of how closely the cubic can be\n * represented as a quadratic bezier curve.\n */\nfunction toHybridQuadratic(ps) {\n    var _ps13 = _slicedToArray(ps, 4),\n        _ps13$ = _slicedToArray(_ps13[0], 2),\n        x0 = _ps13$[0],\n        y0 = _ps13$[1],\n        _ps13$2 = _slicedToArray(_ps13[1], 2),\n        x1 = _ps13$2[0],\n        y1 = _ps13$2[1],\n        _ps13$3 = _slicedToArray(_ps13[2], 2),\n        x2 = _ps13$3[0],\n        y2 = _ps13$3[1],\n        _ps13$4 = _slicedToArray(_ps13[3], 2),\n        x3 = _ps13$4[0],\n        y3 = _ps13$4[1];\n\n    return [[x0, y0], [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2], [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]], [x3, y3] // evaluated at t\n    ];\n}\n/**\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\n * toHybridQuadratic for details).\n * @param hq - A hybrid quadratic\n * @param t - The bezier parameter value\n * @param th - The parameter value for the hybrid quadratic point.\n */\nfunction evaluateHybridQuadratic(hq, t, th) {\n    var P0 = hq[0];\n    var P1_ = hq[1];\n    var P2 = hq[2];\n    var P1 = evaluateLinear(hq[1], th);\n    return evaluateQuadratic([P0, P1, P2], t);\n}\n/**\n * Evaluates the given linear bezier (line) at a specific t value.\n * @param ps - A linear bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateLinear(ps, t) {\n    var _ps14 = _slicedToArray(ps, 2),\n        _ps14$ = _slicedToArray(_ps14[0], 2),\n        x0 = _ps14$[0],\n        y0 = _ps14$[1],\n        _ps14$2 = _slicedToArray(_ps14[1], 2),\n        x1 = _ps14$2[0],\n        y1 = _ps14$2[1];\n\n    var x = x0 * (1 - t) + x1 * t;\n    var y = y0 * (1 - t) + y1 * t;\n    return [x, y];\n}\n/**\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\n * spirit of functional programming.\n * @param ps - A cubic bezier given by its array of control points\n */\nfunction clone(ps) {\n    var _ps15 = _slicedToArray(ps, 4),\n        _ps15$ = _slicedToArray(_ps15[0], 2),\n        x0 = _ps15$[0],\n        y0 = _ps15$[1],\n        _ps15$2 = _slicedToArray(_ps15[1], 2),\n        x1 = _ps15$2[0],\n        y1 = _ps15$2[1],\n        _ps15$3 = _slicedToArray(_ps15[2], 2),\n        x2 = _ps15$3[0],\n        y2 = _ps15$3[1],\n        _ps15$4 = _slicedToArray(_ps15[3], 2),\n        x3 = _ps15$4[0],\n        y3 = _ps15$4[1];\n\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\n/**\n * Evaluates the given quadratic bezier at a specific t value.\n * @param ps - A quadratic bezier curve.\n * @param t - The value where the bezier should be evaluated\n * @returns {number[]}\n */\nfunction evaluateQuadratic(ps, t) {\n    var _ps16 = _slicedToArray(ps, 3),\n        _ps16$ = _slicedToArray(_ps16[0], 2),\n        x0 = _ps16$[0],\n        y0 = _ps16$[1],\n        _ps16$2 = _slicedToArray(_ps16[1], 2),\n        x1 = _ps16$2[0],\n        y1 = _ps16$2[1],\n        _ps16$3 = _slicedToArray(_ps16[2], 2),\n        x2 = _ps16$3[0],\n        y2 = _ps16$3[1];\n\n    var x = x0 * Math.pow(1 - t, 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\n    var y = y0 * Math.pow(1 - t, 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\n    return [x, y];\n}\n/**\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\n * bezier curves can always be represented by cubics - the converse is false.\n * @param ps - A quadratic bezier curve.\n * @returns {number[][]}\n */\nfunction toCubic(ps) {\n    var _ps17 = _slicedToArray(ps, 3),\n        _ps17$ = _slicedToArray(_ps17[0], 2),\n        x0 = _ps17$[0],\n        y0 = _ps17$[1],\n        _ps17$2 = _slicedToArray(_ps17[1], 2),\n        x1 = _ps17$2[0],\n        y1 = _ps17$2[1],\n        _ps17$3 = _slicedToArray(_ps17[2], 2),\n        x2 = _ps17$3[0],\n        y2 = _ps17$3[1];\n\n    return [[x0, y0], [1 / 3 * x0 + 2 / 3 * x1, 1 / 3 * y0 + 2 / 3 * y1], [2 / 3 * x1 + 1 / 3 * x2, 2 / 3 * y1 + 1 / 3 * y2], [x2, y2]];\n}\n/**\n * Check if the two given cubic beziers are nearly coincident everywhere and\n * returns the coincident stretch (if any), otherwise returns undefined.\n * @param P - A cubic bezier curve.\n * @param Q - Another cubic bezier curve.\n * @param δ - An indication of how closely the curves should stay to\n * each other before considered coincident.\n * @returns\n */\nfunction coincident(P, Q) {\n    var δ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-6;\n\n    var _P = _slicedToArray(P, 4),\n        P0 = _P[0],\n        P1 = _P[1],\n        P2 = _P[2],\n        P3 = _P[3];\n\n    var _Q = _slicedToArray(Q, 4),\n        Q0 = _Q[0],\n        Q1 = _Q[1],\n        Q2 = _Q[2],\n        Q3 = _Q[3];\n\n    var _calcPointAndNeighbor = calcPointAndNeighbor(P, Q, 0),\n        pP0 = _calcPointAndNeighbor.pp,\n        tPQ0 = _calcPointAndNeighbor.t,\n        pPQ0 = _calcPointAndNeighbor.p,\n        dPQ0 = _calcPointAndNeighbor.d;\n\n    var _calcPointAndNeighbor2 = calcPointAndNeighbor(P, Q, 1),\n        pP1 = _calcPointAndNeighbor2.pp,\n        tPQ1 = _calcPointAndNeighbor2.t,\n        pPQ1 = _calcPointAndNeighbor2.p,\n        dPQ1 = _calcPointAndNeighbor2.d;\n\n    var _calcPointAndNeighbor3 = calcPointAndNeighbor(Q, P, 0),\n        pQ0 = _calcPointAndNeighbor3.pp,\n        tQP0 = _calcPointAndNeighbor3.t,\n        pQP0 = _calcPointAndNeighbor3.p,\n        dQP0 = _calcPointAndNeighbor3.d;\n\n    var _calcPointAndNeighbor4 = calcPointAndNeighbor(Q, P, 1),\n        pQ1 = _calcPointAndNeighbor4.pp,\n        tQP1 = _calcPointAndNeighbor4.t,\n        pQP1 = _calcPointAndNeighbor4.p,\n        dQP1 = _calcPointAndNeighbor4.d;\n    // Check for start and end points coincident.\n\n\n    var tStartQ = 0;\n    var tEndQ = 1;\n    var tStartP = 0;\n    var tEndP = 1;\n    var count = 0;\n    if (dPQ0 <= δ) {\n        tStartQ = tPQ0;\n        count++;\n    }\n    if (dPQ1 <= δ) {\n        tEndQ = tPQ1;\n        count++;\n    }\n    if (dQP0 <= δ) {\n        tStartP = tQP0;\n        count++;\n    }\n    if (dQP1 <= δ) {\n        tEndP = tQP1;\n        count++;\n    }\n    // At least 2 endpoints must be coincident.\n    if (count < 2) {\n        return undefined;\n    }\n    if (tStartP > tEndP) {\n        var _ref = [tEndP, tStartP];\n        tStartP = _ref[0];\n        tEndP = _ref[1];\n    }\n    if (tStartQ > tEndQ) {\n        var _ref2 = [tEndQ, tStartQ];\n        tStartQ = _ref2[0];\n        tEndQ = _ref2[1];\n    }\n    var tSpanP = tEndP - tStartP;\n    var tSpanQ = tEndQ - tStartQ;\n    // We must check at least 8 additional points to ensure entire curve\n    // is coincident, otherwise we may simply have found intersection \n    // points.\n    // TODO - Change so that we cut the curves to be about equal and check the\n    // other two control points for closeness.\n    var res = true;\n    for (var i = 1; i < 10; i++) {\n        var t = tStartP + tSpanP * (i / 10);\n\n        var _calcPointAndNeighbor5 = calcPointAndNeighbor(P, Q, t),\n            pp = _calcPointAndNeighbor5.pp,\n            tt = _calcPointAndNeighbor5.t,\n            pq = _calcPointAndNeighbor5.p,\n            d = _calcPointAndNeighbor5.d;\n\n        if (d > δ) {\n            return undefined;\n        }\n    }\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\n    function calcPointAndNeighbor(P, Q, t) {\n        // TODO - must also check crossing of normals - for if two curves open\n        // at endpoints and stop essentially at same point.\n        var pp1 = evaluate(P)(t);\n        var normalVector = normal(P)(0);\n        var pp2 = flo_vector2d_1.default.translate(pp1, normalVector);\n        var ts = lineIntersection(Q, [pp1, pp2]);\n        var bestT = undefined;\n        var bestP = undefined;\n        var bestD = Number.POSITIVE_INFINITY;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = ts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _t2 = _step.value;\n\n                var p = evaluate(Q)(_t2);\n                var _d = flo_vector2d_1.default.distanceBetween(p, pp1);\n                if (_d < bestD) {\n                    bestT = _t2;\n                    bestP = p;\n                    bestD = _d;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return { pp: pp1, t: bestT, p: bestP, d: bestD };\n    }\n}\n/**\n * Robust, extremely accurate and extremely fast (cubically convergent in\n * general with fast iteration steps) algorithm that returns the intersections\n * between two cubic beziers.\n *\n * At stretches where the two curves run extremely close to (or on top of) each\n * other and curve the same direction an interval is returned instead of a\n * point.\n *\n * The algorithm is based on a <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">paper</a>\n * that finds the intersection of a fat line and a so-called geometric interval\n * making it faster and more accurate than the standard fat-line intersection\n * algorithm. The algorithm has been modified to prevent run-away recursion\n * by checking for coincident pieces at subdivision steps.\n *\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * @param [δ] - An optional tolerance to within which the t parameter\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\n * approximately 5e-15. Note that it might not make sense to set this to as\n * large as say 1e-5 since only a single iteration later the maximum accuracy\n * will be attained and not much speed will be gained anyway. Similarly if δ is\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\n * being cubically convergent (usually converging in about 4 to 8 iterations for\n * typical intersections).\n * @param [Δ] - A tolerance that indicates how closely a stretch of the\n * beziers can run together before being considered coincident. Defaults to the\n * minimum possible value of 1e-6 if not specified.\n * @returns An array that contains the t-value pairs at intersection\n * of the first and second beziers respectively. The array can also contain t\n * range pairs for coincident pieces that can be either used or ignored\n * depending on the application, e.g. the return value might be [[0.1,0.2],\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\n * the second bezier.\n */\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\n    var dst = flo_vector2d_1.default.distanceBetween;\n    var sdst = flo_vector2d_1.default.squaredDistanceBetween;\n    // The minimum value Δ can be. If it is too small the algorithm may take too\n    // long in cases where the two curves run extremely close to each other for\n    // their entire length and curve the same direction.\n    var ΔMin = 1e-6;\n    // This is an estimate of the relative floating point error during clipping.\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\n    var δMin = 24 * Number.EPSILON;\n    // Maximum error - limited to take rounding error into account.\n    if (δ === undefined) {\n        δ = 0;\n    }\n    δ = Math.max(δ, δMin);\n    if (Δ === undefined) {\n        Δ = ΔMin;\n    }\n    Δ = Math.max(Δ, ΔMin);\n    // Intersection t values for both beziers\n    var tss = [];\n    //let iterations = 0;\n    intersection(ps1, ps2, [0, 1], [0, 1], 1);\n    //console.log(iterations);\n    return tss;\n    // Helper function\n    function intersection(Q_, P_, qRange, pRange, idx) {\n        //iterations++;\n        var cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\n        // Move intersection toward the origin to prevent serious floating point \n        // issues that are introduced specifically by the getLineEquation \n        // function. This allows us to get a relative error in the final \n        // result usually in the 10 ULPS or less range.\n\n        var _center = center(P_, Q_);\n\n        var _center2 = _slicedToArray(_center, 2);\n\n        P_ = _center2[0];\n        Q_ = _center2[1];\n\n        var _Q_ = Q_,\n            _Q_2 = _slicedToArray(_Q_, 4),\n            Q0 = _Q_2[0],\n            Q1 = _Q_2[1],\n            Q2 = _Q_2[2],\n            Q3 = _Q_2[3];\n\n        var _P_ = P_,\n            _P_2 = _slicedToArray(_P_, 4),\n            P0 = _P_2[0],\n            P1 = _P_2[1],\n            P2 = _P_2[2],\n            P3 = _P_2[3];\n        // Get the implict line equation for the line from the first to the last\n        // control point of Q. This equation gives the distance between any \n        // point and the line.\n\n\n        var dQ = getDistanceToLineFunction([Q0, Q3]);\n        // Calculate the distance from the control points of Q to the line \n        // [Q0,Q3].\n        var dQi = function dQi(i) {\n            return dQ(Q_[i]);\n        };\n        var dQs = [1, 2].map(dQi);\n\n        var _dQs = _slicedToArray(dQs, 2),\n            dQ1 = _dQs[0],\n            dQ2 = _dQs[1];\n        // Calculate the fat line of Q.\n\n\n        var C = dQ1 * dQ2 > 0 ? 3 / 4 : 4 / 9;\n        var dMin = C * Math.min(0, dQ1, dQ2);\n        var dMax = C * Math.max(0, dQ1, dQ2);\n\n        var _geoClip = geoClip(P_, dQ, dMin, dMax),\n            tMin = _geoClip.tMin,\n            tMax = _geoClip.tMax;\n\n        if (tMin === Number.POSITIVE_INFINITY) {\n            return; // No intersection\n        }\n        // The paper calls for a heuristic that if less than 30% will be\n        // clipped, rather split the longest curve and find intersections in the\n        // two halfs seperately.\n        if (tMax - tMin > 0.7) {\n            // Some length measure\n            var pSpan = pRange[1] - pRange[0];\n            var qSpan = qRange[1] - qRange[0];\n            if (coincident(P_, Q_) !== undefined) {\n                return;\n            }\n            // Split the curve in half\n            if (pSpan <= qSpan) {\n                cidx = idx;\n                var _ref3 = [Q_, P_];\n                P_ = _ref3[0];\n                Q_ = _ref3[1];\n                var _ref4 = [qRange, pRange];\n                pRange = _ref4[0];\n                qRange = _ref4[1];\n            }\n            // Update t range.\n            var _span = pRange[1] - pRange[0];\n            // 1st half\n            var tMinA = pRange[0];\n            var tMaxA = tMinA + _span / 2;\n            // 2nd half\n            var tMinB = tMaxA;\n            var tMaxB = pRange[1];\n            var A = fromTo(P_)(0, 0.5);\n            var B = fromTo(P_)(0.5, 1);\n            intersection(A, Q_, [tMinA, tMaxA], qRange, cidx);\n            intersection(B, Q_, [tMinB, tMaxB], qRange, cidx);\n            return;\n        }\n        // Update t range.\n        var span = pRange[1] - pRange[0];\n        var tMin_ = tMin * span + pRange[0];\n        var tMax_ = tMax * span + pRange[0];\n        // Clip\n        P_ = fromTo(P_)(tMin, tMax);\n        if (Math.abs(tMax_ - tMin_) < δ) {\n            var t1 = (tMax_ + tMin_) / 2;\n            var pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\n            var t2 = calcOtherT(t1, pq[0], pq[1]);\n            if (t2 === undefined) {\n                return undefined;\n            }\n            var ts = idx === 0 ? [t2, t1] : [t1, t2];\n            tss.push(ts);\n            return;\n        }\n        // Swap Q and P and iterate.\n        intersection(P_, Q_, [tMin_, tMax_], qRange, cidx);\n    }\n    function geoClip(P, dQ, dMin, dMax) {\n        var dPi = function dPi(i) {\n            return dQ(P[i]);\n        };\n        var dPs = [0, 1, 2, 3].map(dPi);\n\n        var _dPs = _slicedToArray(dPs, 4),\n            dP0 = _dPs[0],\n            dP1 = _dPs[1],\n            dP2 = _dPs[2],\n            dP3 = _dPs[3];\n\n        var hq = toHybridQuadratic(P);\n        var dH0 = dQ(hq[0]);\n        var dH2 = dQ(hq[2]);\n        var dH10 = dQ(hq[1][0]);\n        var dH11 = dQ(hq[1][1]);\n        var dHmin = Math.min(dH10, dH11);\n        var dHmax = Math.max(dH10, dH11);\n        var DyMin = [dH0 - 2 * dHmin + dH2, -2 * dH0 + 2 * dHmin, dH0];\n        var DyMax = [dH0 - 2 * dHmax + dH2, -2 * dH0 + 2 * dHmax, dH0];\n        var errorBound = 2 * Math.max(flo_poly_1.default.hornerErrorBound(DyMin, 1), flo_poly_1.default.hornerErrorBound(DyMax, 1));\n        dMin = dMin - errorBound;\n        dMax = dMax + errorBound;\n        var DyMinMin = DyMin.slice();\n        DyMinMin[2] = DyMinMin[2] - dMin;\n        var DyMinMax = DyMin.slice();\n        DyMinMax[2] = DyMinMax[2] - dMax;\n        var DyMaxMin = DyMax.slice();\n        DyMaxMin[2] = DyMaxMin[2] - dMin;\n        var DyMaxMax = DyMax.slice();\n        DyMaxMax[2] = DyMaxMax[2] - dMax;\n        var tMin = Number.POSITIVE_INFINITY;\n        var tMax = Number.NEGATIVE_INFINITY;\n        var rootsMinMin = flo_poly_1.default.allRoots(DyMinMin, 0, 1);\n        var rootsMinMax = flo_poly_1.default.allRoots(DyMinMax, 0, 1);\n        var rootsMaxMin = flo_poly_1.default.allRoots(DyMaxMin, 0, 1);\n        var rootsMaxMax = flo_poly_1.default.allRoots(DyMaxMax, 0, 1);\n        tMin = Math.min.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n        tMax = Math.max.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n        if (dH0 >= dMin && dH0 <= dMax) {\n            tMin = 0;\n        }\n        if (dH2 >= dMin && dH2 <= dMax) {\n            tMax = 1;\n        }\n        if (tMin < 0) {\n            tMin = 0;\n        }\n        if (tMax > 1) {\n            tMax = 1;\n        }\n        return { tMin: tMin, tMax: tMax };\n    }\n    /**\n     * Return the given two beziers but translated such that the shorter (by\n     * some length measure) is closer to the origin.\n     * @private\n     * @param P\n     * @param Q\n     */\n    function center(P, Q) {\n        var _P2 = P,\n            _P3 = _slicedToArray(_P2, 4),\n            P0 = _P3[0],\n            P1 = _P3[1],\n            P2 = _P3[2],\n            P3 = _P3[3];\n\n        var _Q2 = Q,\n            _Q3 = _slicedToArray(_Q2, 4),\n            Q0 = _Q3[0],\n            Q1 = _Q3[1],\n            Q2 = _Q3[2],\n            Q3 = _Q3[3];\n\n        var lengthP = sdst(P0, P1) + sdst(P1, P2) + sdst(P2, P3);\n        var lengthQ = sdst(Q0, Q1) + sdst(Q1, Q2) + sdst(Q2, Q3);\n        var moveX = void 0;\n        var moveY = void 0;\n        if (lengthQ < lengthP) {\n            moveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\n            moveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\n        } else {\n            moveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\n            moveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\n        }\n        P = P.map(function (x) {\n            return [x[0] - moveX, x[1] - moveY];\n        });\n        Q = Q.map(function (x) {\n            return [x[0] - moveX, x[1] - moveY];\n        });\n        return [P, Q];\n    }\n    /**\n     * Calculates the t-value of the closest point on Q to P(t).\n     * @ignore\n     * @param {number}\n     * @param Q\n     * @param P\n     */\n    function calcOtherT(t, P, Q) {\n        var pp = evaluate(P)(t);\n\n        var _pp = _slicedToArray(pp, 2),\n            x = _pp[0],\n            y = _pp[1];\n\n        var tqsh = tsAtY(Q, y);\n        var tqsv = tsAtX(Q, x);\n        if (!tqsh.length && !tqsv.length) {\n            return undefined;\n        }\n        var tqs = [].concat(_toConsumableArray(tqsh), _toConsumableArray(tqsv));\n        var bestT = undefined;\n        var bestD = Number.POSITIVE_INFINITY;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n            for (var _iterator2 = tqs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var tq = _step2.value;\n\n                var pq = evaluate(Q)(tq);\n                var d = sdst(pp, pq);\n                if (d < bestD) {\n                    bestD = d;\n                    bestT = tq;\n                }\n            }\n        } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                }\n            } finally {\n                if (_didIteratorError2) {\n                    throw _iteratorError2;\n                }\n            }\n        }\n\n        return bestT;\n    }\n}\n/**\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\n * returned as the array [a,b,c].\n * @ignore\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\n * @returns {number[]}\n */\nfunction getLineEquation(l) {\n    var _l3 = _slicedToArray(l, 2),\n        _l3$ = _slicedToArray(_l3[0], 2),\n        x1 = _l3$[0],\n        y1 = _l3$[1],\n        _l3$2 = _slicedToArray(_l3[1], 2),\n        x2 = _l3$2[0],\n        y2 = _l3$2[1];\n\n    var a = y1 - y2;\n    var b = x2 - x1;\n    var c = x1 * y2 - x2 * y1;\n    return [a, b, c];\n}\n/**\n * @private\n * @param l\n */\nfunction getDistanceToLineFunction(l) {\n    var _getLineEquation = getLineEquation(l),\n        _getLineEquation2 = _slicedToArray(_getLineEquation, 3),\n        a = _getLineEquation2[0],\n        b = _getLineEquation2[1],\n        c = _getLineEquation2[2];\n\n    return function (p) {\n        return a * p[0] + b * p[1] + c;\n    };\n}\n/**\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\n * where a^2 + b^2 = 1 returned as the array [a,b,c].\n * @param l - A line given by two points, e.g. [[2,0],[3,3]]\n * @example\n * getNormalizedLineEquation([[1,0],[5,3]]); //=> [-0.6, 0.8, 0.6]\n */\nfunction getNormalizedLineEquation(l) {\n    var _l4 = _slicedToArray(l, 2),\n        _l4$ = _slicedToArray(_l4[0], 2),\n        x1 = _l4$[0],\n        y1 = _l4$[1],\n        _l4$2 = _slicedToArray(_l4[1], 2),\n        x2 = _l4$2[0],\n        y2 = _l4$2[1];\n\n    var a = y1 - y2;\n    var b = x2 - x1;\n    var c = x1 * y2 - x2 * y1;\n    var norm = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    // Normalize it\n    a = a / norm;\n    b = b / norm;\n    c = c / norm;\n    return [a, b, c];\n}\n/**\n * Returns the given points (e.g. bezier) in reverse order.\n * @param ps\n * @returns {number[][]}\n */\nfunction reverse(ps) {\n    return ps.slice().reverse();\n}\n/**\n * <p>\n * Purely functional cubic bezier library, including robust\n * cubic-cubic bezier intersection.\n * </p>\n * <p>\n * A cubic bezier is represented as an array of points, i.e.\n * [p0, p1, p2, p3] where each point is an ordered pair, e.g.\n * [[0,0],[1,1],[2,1],[3,0]].\n * </p>\n */\nvar Bezier3 = {\n    rotate: rotate,\n    getX: getX,\n    getY: getY,\n    getDx: getDx,\n    getDy: getDy,\n    getDdx: getDdx,\n    getDdy: getDdy,\n    getDddx: getDddx,\n    getDddy: getDddy,\n    getBounds: getBounds,\n    bezier3Intersection: bezier3Intersection,\n    lineIntersection: lineIntersection,\n    tsAtX: tsAtX,\n    tsAtY: tsAtY,\n    getBoundingHull: getBoundingHull,\n    fromLine: fromLine,\n    translate: translate,\n    evaluate: evaluate,\n    κ: κ,\n    dκMod: dκMod,\n    curvature: curvature,\n    tangent: tangent,\n    normal: normal,\n    totalCurvature: totalCurvature,\n    totalAbsoluteCurvature: totalAbsoluteCurvature,\n    len: len,\n    getTAtLength: getTAtLength,\n    evaluateX: evaluateX,\n    evaluateY: evaluateY,\n    evaluateDx: evaluateDx,\n    evaluateDy: evaluateDy,\n    evaluateDdx: evaluateDdx,\n    evaluateDdy: evaluateDdy,\n    evaluateDddx: evaluateDddx,\n    evaluateDddy: evaluateDddy,\n    getBoundingBoxTight: getBoundingBoxTight,\n    getBoundingBox: getBoundingBox,\n    fromTo: fromTo,\n    splitAt: splitAt,\n    scale: scale,\n    toCubic: toCubic,\n    toQuadratic: toQuadratic,\n    toHybridQuadratic: toHybridQuadratic,\n    evaluateHybridQuadratic: evaluateHybridQuadratic,\n    evaluateQuadratic: evaluateQuadratic,\n    evaluateLinear: evaluateLinear,\n    coincident: coincident,\n    from0ToT: from0ToT,\n    fromTTo1: fromTTo1,\n    clone: clone,\n    reverse: reverse\n};\nexports.default = Bezier3;\n\n},{\"flo-gauss-quadrature\":40,\"flo-graham-scan\":41,\"flo-memoize\":46,\"flo-poly\":47,\"flo-vector2d\":55}],40:[function(_dereq_,module,exports){\n'use strict';\n\n// TODO A future improvement can be to use the Gauss–Kronrod rules\n// to estimate the error and thus choose a number of constants based\n// on the error.\n// TODO In future, the constants can be calculated and cached so we can\n// chooce any value for the order.\n\n\n/** \r\n * <p>\r\n * Integrates the given function using the Gaussian Quadrature method.\r\n * </p>\r\n * <p> \r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * </p>\r\n * <p>\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * </p>\r\n * \r\n * @param {function} f - The univariate function to be integrated\r\n * @param {number[]} interval - The integration interval\r\n * @param {number} order - Can be 2, 4, 8, or 16. Higher values give \r\n * more accurate results but is slower - defaults to 16.\r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction gaussQuadrature(f, interval, order) {\n\torder = order === undefined ? 16 : order;\n\n\tvar _GAUSS_CONSTANTS$orde = GAUSS_CONSTANTS[order],\n\t    weights = _GAUSS_CONSTANTS$orde.weights,\n\t    abscissas = _GAUSS_CONSTANTS$orde.abscissas;\n\n\tvar _interval = _slicedToArray(interval, 2),\n\t    a = _interval[0],\n\t    b = _interval[1];\n\n\tvar result = 0;\n\tvar m1 = (b - a) / 2;\n\tvar m2 = (b + a) / 2;\n\tfor (var i = 0; i <= order - 1; i++) {\n\t\tresult += weights[i] * f(m1 * abscissas[i] + m2);\n\t}\n\n\treturn m1 * result;\n}\n\n// The Gaussian Legendre Quadrature method constants. \nvar GAUSS_CONSTANTS = {\n\t2: {\n\t\tweights: [1, 1],\n\t\tabscissas: [-0.5773502691896257, 0.5773502691896257]\n\t},\n\t4: {\n\t\tweights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538],\n\t\tabscissas: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526]\n\t},\n\t8: {\n\t\tweights: [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763],\n\t\tabscissas: [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363]\n\t},\n\t// Taken from http://keisan.casio.com/exec/system/1330940731\n\t16: {\n\t\tabscissas: [-0.989400934991649932596, -0.944575023073232576078, -0.86563120238783174388, -0.7554044083550030338951, -0.6178762444026437484467, -0.4580167776572273863424, -0.28160355077925891323, -0.0950125098376374401853, 0.0950125098376374401853, 0.28160355077925891323, 0.4580167776572273863424, 0.617876244402643748447, 0.755404408355003033895, 0.8656312023878317438805, 0.944575023073232576078, 0.989400934991649932596],\n\t\tweights: [0.0271524594117540948518, 0.062253523938647892863, 0.0951585116824927848099, 0.1246289712555338720525, 0.1495959888165767320815, 0.169156519395002538189, 0.182603415044923588867, 0.189450610455068496285, 0.1894506104550684962854, 0.182603415044923588867, 0.1691565193950025381893, 0.149595988816576732081, 0.124628971255533872053, 0.095158511682492784809, 0.062253523938647892863, 0.027152459411754094852]\n\t}\n};\n\nmodule.exports = gaussQuadrature;\n\n},{}],41:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Vector = _dereq_('flo-vector2d');\n\nvar DELTA = 1e-10;\n\n/**\r\n * Performs a functional stable sort on the given array and \r\n * returns the newly sorted array.\r\n * @ignore\r\n */\nfunction stableSort(arr, f) {\n\tvar indxArray = [];\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tindxArray.push(i);\n\t}\n\n\tindxArray.sort(function (a, b) {\n\t\tvar res = f(arr[a], arr[b]);\n\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a - b;\n\t});\n\n\tvar sorted = [];\n\tfor (var _i = 0; _i < arr.length; _i++) {\n\t\tsorted.push(arr[indxArray[_i]]);\n\t}\n\n\treturn sorted;\n}\n\n/**\r\n * In-place swap two elements in the given array.\r\n * @ignore\r\n */\nfunction swap(arr, a, b) {\n\tif (a === b) {\n\t\treturn;\n\t}\n\n\tvar temp = arr[a];\n\tarr[a] = arr[b];\n\tarr[b] = temp;\n}\n\n/**\r\n * @ignore\r\n */\nfunction getSmallestIndxYThenX(ps) {\n\tvar smallest = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n\tvar smallestI = void 0;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar y = ps[i][1];\n\t\tif (y < smallest[1] || y === smallest[1] && ps[i][0] < smallest[0]) {\n\t\t\tsmallestI = i;\n\t\t\tsmallest = ps[i];\n\t\t}\n\t}\n\n\treturn smallestI;\n}\n\n/** \r\n * <p>\r\n * Finds the convex hull of the given set of 2d points using the   \r\n * Graham Scan algorithm and returns the hull as an array of points. \r\n * </p>\r\n * <p>\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n * </p>\r\n * @param {number[][]} ps_ - A set of points\r\n * @param {boolean} includeAllBoundaryPoints - Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to false\r\n * @param {number} delta - Tolerance at which three points are considered collinear -\r\n * defaults to 1e-10\r\n * @returns {number[][]}\r\n */\nfunction grahamScan(ps_, includeAllBoundaryPoints, delta) {\n\tincludeAllBoundaryPoints = !!includeAllBoundaryPoints;\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tfunction fail(p1, p2, p3) {\n\t\tvar res = Vector.ccw(p1, p2, p3, delta);\n\t\tif (includeAllBoundaryPoints) {\n\t\t\treturn res < 0;\n\t\t}\n\t\treturn res <= 0;\n\t}\n\n\tvar ps = ps_.slice();\n\tvar n = ps.length;\n\n\tvar idx = getSmallestIndxYThenX(ps);\n\n\tvar _ps$splice = ps.splice(idx, 1),\n\t    _ps$splice2 = _slicedToArray(_ps$splice, 1),\n\t    p = _ps$splice2[0];\n\n\tps = stableSort(ps, function (a, b) {\n\t\tvar res = Vector.cross(Vector.fromTo(p, b), Vector.fromTo(p, a));\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\tres = a[1] - b[1];\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a[0] - b[0];\n\t});\n\n\tps.unshift(p);\n\n\tvar m = 1;\n\tfor (var i = 2; i < n; i++) {\n\t\twhile (fail(ps[m - 1], ps[m], ps[i])) {\n\t\t\tif (m > 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tcontinue;\n\t\t\t} else if (i === n - 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\n\t\tm += 1;\n\t\tswap(ps, m, i);\n\t}\n\n\treturn ps.slice(0, m + 1);\n}\n\nmodule.exports = grahamScan;\n\n},{\"flo-vector2d\":55}],42:[function(_dereq_,module,exports){\n\"use strict\";\n/*\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tree_node_1 = _dereq_(\"./src/tree-node\");\nvar tree_node_color_1 = _dereq_(\"./src/tree-node-color\");\nvar tree_node_direction_1 = _dereq_(\"./src/tree-node-direction\");\nfunction isRed(node) {\n    return node && node.color === tree_node_color_1.default.RED;\n}\n/**\n * @param compare\n * @param datas\n * @param replaceDups - If true then if a duplicate is\n * inserted (as per the equivalence relation induced by the compare)\n * then replace it. If false then keep an array of values at the relevant\n * node.\n */\n\nvar LlRbTree = function () {\n    function LlRbTree(compare, datas, replaceDups) {\n        _classCallCheck(this, LlRbTree);\n\n        this.getMinNode = this.getMinOrMaxNode(tree_node_direction_1.default.LEFT);\n        this.getMaxNode = this.getMinOrMaxNode(tree_node_direction_1.default.RIGHT);\n        var tree = this;\n        tree.setComparator(compare, replaceDups);\n        tree.replaceDups = replaceDups;\n        tree.root = null;\n        if (!datas) {\n            return;\n        }\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = datas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var data = _step.value;\n\n                tree.insert(data);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    /**\n     * Destructively sets the tree compare. This function can be used for for e.g.\n     * the Bentley Ottmann algorithm.\n     */\n\n\n    _createClass(LlRbTree, [{\n        key: \"setComparator\",\n        value: function setComparator(compare, replaceDups) {\n            if (replaceDups) {\n                this.compare = compare;\n            } else {\n                this.compare = function (a, b) {\n                    return compare(a, b[0]);\n                };\n            }\n        }\n    }, {\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return !this.root;\n        }\n        /**\n         * Find the node in the tree with the given data using the tree compare\n         * function.\n         * @returns {Node} node or null if not found.\n         */\n\n    }, {\n        key: \"find\",\n        value: function find(data) {\n            var tree = this;\n            var node = this.root;\n            while (node) {\n                var c = tree.compare(data, node.data);\n                if (c === 0) {\n                    return node;\n                } else {\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return null;\n        }\n        /**\n         * .\n         */\n\n    }, {\n        key: \"toArrayInOrder\",\n        value: function toArrayInOrder() {\n            var nodes = [];\n            f(this.root);\n            function f(node) {\n                if (!node) {\n                    return;\n                }\n                f(node[tree_node_direction_1.default.LEFT]);\n                nodes.push(node);\n                f(node[tree_node_direction_1.default.RIGHT]);\n            }\n            return nodes;\n        }\n        /**\n         * Inserts a node with the given data into the tree.\n         */\n\n    }, {\n        key: \"insert\",\n        value: function insert(data) {\n            var tree = this;\n            tree.root = f(tree.root, data);\n            tree.root.color = tree_node_color_1.default.BLACK;\n            tree.root.parent = undefined;\n            function f(h, data) {\n                if (!h) {\n                    return new tree_node_1.default(data, !tree.replaceDups);\n                }\n                var c = tree.compare(data, h.data);\n                if (c === 0) {\n                    if (tree.replaceDups) {\n                        h.data = data;\n                    } else {\n                        h.data.push(data);\n                    }\n                } else {\n                    var dir = c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT;\n                    h[dir] = f(h[dir], data);\n                    h[dir].parent = h;\n                }\n                if (isRed(h[tree_node_direction_1.default.RIGHT]) && !isRed(h[tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.LEFT, h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.RIGHT, h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.RIGHT])) {\n                    flipColors(h);\n                }\n                return h;\n            }\n        }\n        /**\n         * Removes an item from the tree based on the given data.\n         * @param {LlRbTree} tree\n         * @param {*} data\n         * @param {boolean} all - If the data is an array, remove all.\n         */\n\n    }, {\n        key: \"remove\",\n        value: function remove(data, all) {\n            var tree = this;\n            tree.root = f(tree.root, data);\n            if (tree.root) {\n                tree.root.color = tree_node_color_1.default.BLACK;\n                tree.root.parent = undefined;\n            }\n            function f(h, data) {\n                //let h = h_;\n                var c = tree.compare(data, h.data);\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                    removeFromArray(data, h.data);\n                    return h;\n                }\n                if (c < 0 && !h[tree_node_direction_1.default.LEFT] || c > 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                    return h;\n                }\n                if (c < 0) {\n                    if (!isRed(h[tree_node_direction_1.default.LEFT]) && !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n                        h = moveRedLeft(h);\n                    }\n                    h[tree_node_direction_1.default.LEFT] = f(h[tree_node_direction_1.default.LEFT], data);\n                    if (h[tree_node_direction_1.default.LEFT]) {\n                        h[tree_node_direction_1.default.LEFT].parent = h;\n                    }\n                    return fixUp(h);\n                }\n                if (isRed(h[tree_node_direction_1.default.LEFT])) {\n                    h = rotate(tree_node_direction_1.default.RIGHT, h);\n                    c = tree.compare(data, h.data);\n                    if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                        removeFromArray(data, h.data);\n                        return h;\n                    }\n                }\n                if (c === 0 && !h[tree_node_direction_1.default.RIGHT]) {\n                    return null;\n                }\n                if (!isRed(h[tree_node_direction_1.default.RIGHT]) && !isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n                    h = moveRedRight(h);\n                    c = tree.compare(data, h.data);\n                    if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\n                        removeFromArray(data, h.data);\n                        return h;\n                    }\n                }\n                if (c === 0) {\n                    h.data = tree.min(h[tree_node_direction_1.default.RIGHT]);\n                    h[tree_node_direction_1.default.RIGHT] = removeMin(h[tree_node_direction_1.default.RIGHT]);\n                } else {\n                    h[tree_node_direction_1.default.RIGHT] = f(h[tree_node_direction_1.default.RIGHT], data);\n                }\n                if (h[tree_node_direction_1.default.RIGHT]) {\n                    h[tree_node_direction_1.default.RIGHT].parent = h;\n                }\n                return fixUp(h);\n            }\n        }\n        /**\n         * Returns the two ordered nodes bounding the data. If the\n         * data falls on a node, that node and the next (to the right) is\n         * returned.\n         * @returns {Node[]}\n         */\n\n    }, {\n        key: \"findBounds\",\n        value: function findBounds(data) {\n            var tree = this;\n            var node = tree.root;\n            var bounds = [undefined, undefined];\n            if (node === null) {\n                return bounds;\n            }\n            while (node) {\n                var c = tree.compare(data, node.data);\n                if (c >= 0) {\n                    bounds[0] = node;\n                } else {\n                    bounds[1] = node;\n                }\n                node = node[c >= 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n            }\n            return bounds;\n        }\n        /**\n         * @param {LlRbTree} tree\n         * @param {*} data\n         * @returns {Node[]} The two ordered nodes bounding the data. If the\n         * data falls on a node, returns the nodes before and after this one.\n         */\n\n    }, {\n        key: \"findBoundsExcl\",\n        value: function findBoundsExcl(data) {\n            var tree = this;\n            var node = tree.root;\n            var bounds = [undefined, undefined];\n            if (node === null) {\n                return bounds;\n            }\n            f(node);\n            function f(node) {\n                while (node) {\n                    var c = tree.compare(data, node.data);\n                    if (c === 0) {\n                        // Search on both sides\n                        f(node[tree_node_direction_1.default.LEFT]);\n                        f(node[tree_node_direction_1.default.RIGHT]);\n                        return;\n                    }\n                    if (c > 0) {\n                        bounds[0] = node;\n                    } else if (c < 0) {\n                        bounds[1] = node;\n                    }\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return bounds;\n        }\n        /**\n         *\n         */\n\n    }, {\n        key: \"findAllInOrder\",\n        value: function findAllInOrder(data) {\n            var tree = this;\n            var nodes = [];\n            f(tree.root);\n            function f(node) {\n                while (node) {\n                    var c = tree.compare(data, node.data);\n                    if (c === 0) {\n                        f(node[tree_node_direction_1.default.LEFT]);\n                        nodes.push(node);\n                        f(node[tree_node_direction_1.default.RIGHT]);\n                        return;\n                    }\n                    node = node[c > 0 ? tree_node_direction_1.default.RIGHT : tree_node_direction_1.default.LEFT];\n                }\n            }\n            return nodes;\n        }\n    }, {\n        key: \"getMinOrMaxNode\",\n        value: function getMinOrMaxNode(dir) {\n            return function (node) {\n                if (!node) {\n                    return undefined;\n                }\n                while (node[dir]) {\n                    node = node[dir];\n                }\n                return node;\n            };\n        }\n    }, {\n        key: \"min\",\n        value: function min(node) {\n            return this.getMinNode(node).data;\n        }\n    }, {\n        key: \"max\",\n        value: function max(node) {\n            return this.getMaxNode(node).data;\n        }\n    }]);\n\n    return LlRbTree;\n}();\n/**\n * Removes the data from the tuple using ===.\n * Note this function uses === and not the compare function!\n */\n\n\nfunction removeFromArray(elem, arr) {\n    var index = arr.indexOf(elem);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n/**\n * Destructively rotates the given node, say h, in the\n * given direction as far as tree rotations go.\n * @param {boolean} dir true -> right, false -> left\n * @param {Node} h\n * @returns The node that is at the top after the rotation.\n */\nfunction rotate(dir, h) {\n    var otherDir = dir ? tree_node_direction_1.default.LEFT : tree_node_direction_1.default.RIGHT;\n    var x = h[otherDir];\n    h[otherDir] = x[dir];\n    if (x[dir]) {\n        x[dir].parent = h;\n    }\n    x[dir] = h;\n    h.parent = x;\n    x.color = h.color;\n    h.color = tree_node_color_1.default.RED;\n    return x;\n}\nfunction removeMin(h) {\n    if (!h[tree_node_direction_1.default.LEFT]) {\n        return null;\n    }\n    if (!isRed(h[tree_node_direction_1.default.LEFT]) && !isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = moveRedLeft(h);\n    }\n    h[tree_node_direction_1.default.LEFT] = removeMin(h[tree_node_direction_1.default.LEFT]);\n    if (h[tree_node_direction_1.default.LEFT]) {\n        h[tree_node_direction_1.default.LEFT].parent = h;\n    }\n    return fixUp(h);\n}\nfunction flipColor(color) {\n    return color === tree_node_color_1.default.RED ? tree_node_color_1.default.BLACK : tree_node_color_1.default.RED;\n}\n/**\n * Destructively flips the color of the given node and both\n * it's childrens' colors.\n * @param {Node} h\n */\nfunction flipColors(h) {\n    h.color = flipColor(h.color);\n    h[tree_node_direction_1.default.LEFT].color = flipColor(h[tree_node_direction_1.default.LEFT].color);\n    h[tree_node_direction_1.default.RIGHT].color = flipColor(h[tree_node_direction_1.default.RIGHT].color);\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedLeft(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.RIGHT][tree_node_direction_1.default.LEFT])) {\n        var a = rotate(tree_node_direction_1.default.RIGHT, h[tree_node_direction_1.default.RIGHT]);\n        h[tree_node_direction_1.default.RIGHT] = a;\n        a.parent = h;\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description\n * @param h\n * @returns The node that is at the top after the move.\n */\nfunction moveRedRight(h) {\n    flipColors(h);\n    if (isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n        flipColors(h);\n    }\n    return h;\n}\n/**\n * @description Fix right-leaning red nodes.\n * @returns The node that is at the top after the fix.\n */\nfunction fixUp(h) {\n    if (isRed(h[tree_node_direction_1.default.RIGHT])) {\n        h = rotate(tree_node_direction_1.default.LEFT, h);\n    }\n    if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.LEFT][tree_node_direction_1.default.LEFT])) {\n        h = rotate(tree_node_direction_1.default.RIGHT, h);\n    }\n    // Split 4-nodes.\n    if (isRed(h[tree_node_direction_1.default.LEFT]) && isRed(h[tree_node_direction_1.default.RIGHT])) {\n        flipColors(h);\n    }\n    return h;\n}\nexports.default = LlRbTree;\n\n},{\"./src/tree-node\":45,\"./src/tree-node-color\":43,\"./src/tree-node-direction\":44}],43:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeColor;\n(function (TreeNodeColor) {\n    TreeNodeColor[TreeNodeColor[\"BLACK\"] = 0] = \"BLACK\";\n    TreeNodeColor[TreeNodeColor[\"RED\"] = 1] = \"RED\";\n})(TreeNodeColor || (TreeNodeColor = {}));\nexports.default = TreeNodeColor;\n\n},{}],44:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNodeDirection;\n(function (TreeNodeDirection) {\n    TreeNodeDirection[TreeNodeDirection[\"LEFT\"] = 0] = \"LEFT\";\n    TreeNodeDirection[TreeNodeDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(TreeNodeDirection || (TreeNodeDirection = {}));\nexports.default = TreeNodeDirection;\n\n},{}],45:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tree_node_color_1 = _dereq_(\"./tree-node-color\");\n/**\n * Red Black Tree node.\n * @constructor\n * @param {*} data\n */\n\nvar TreeNode = function TreeNode(data, asArray) {\n    _classCallCheck(this, TreeNode);\n\n    if (asArray) {\n        this.data = [data];\n    } else {\n        this.data = data;\n    }\n    this.color = tree_node_color_1.default.RED;\n};\n\nexports.default = TreeNode;\n\n},{\"./tree-node-color\":43}],46:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SUPPORTED = typeof WeakMap === 'function';\n/**\n * Memoize the given arity 1 function.\n */\nfunction m1(f) {\n    if (!SUPPORTED) {\n        return f;\n    }\n    var results = new WeakMap();\n    return function (a) {\n        var result = results.get(a);\n        if (result !== undefined) {\n            //console.log('cache hit');\n            return result;\n        }\n        //console.log('cache miss');\n        result = f(a);\n        results.set(a, result);\n        return result;\n    };\n}\nvar Memoize = { m1: m1 };\nexports.default = Memoize;\n\n},{}],47:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./src/core-operators\");\nvar root_operators_1 = _dereq_(\"./src/root-operators\");\nvar root_bounds_1 = _dereq_(\"./src/root-bounds\");\nvar all_roots_recursive_1 = _dereq_(\"./src/all-roots-recursive\");\nvar random_1 = _dereq_(\"./src/random\");\nvar error_analysis_1 = _dereq_(\"./src/error-analysis\");\nvar from_roots_1 = _dereq_(\"./src/from-roots\");\nvar multiply = core_operators_1.default.multiply;\n/**\n* <p>\n* Simple & fast practical library functions for functional univariate\n* polynomials over the reals (actually ECMAScript numbers, i.e. double\n* floats).\n* </p>\n* <p>\n* All polinomials are represented as a simple array starting with the\n* highest non-zero power, e.g.\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\n* </p>\n* @ignore\n*/\nvar FloPoly = Object.assign({}, core_operators_1.default, root_operators_1.default, root_bounds_1.default, error_analysis_1.default, { random: random_1.default,\n    fromRoots: from_roots_1.default,\n    allRoots: all_roots_recursive_1.default });\nexports.default = FloPoly;\n\n},{\"./src/all-roots-recursive\":48,\"./src/core-operators\":49,\"./src/error-analysis\":50,\"./src/from-roots\":51,\"./src/random\":52,\"./src/root-bounds\":53,\"./src/root-operators\":54}],48:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar root_operators_1 = _dereq_(\"./root-operators\");\nvar root_bounds_1 = _dereq_(\"./root-bounds\");\nvar _core_operators_1$def = core_operators_1.default,\n    clip0 = _core_operators_1$def.clip0,\n    evaluate = _core_operators_1$def.evaluate,\n    differentiate = _core_operators_1$def.differentiate,\n    toCasStr = _core_operators_1$def.toCasStr;\nvar _root_operators_1$def = root_operators_1.default,\n    brent = _root_operators_1$def.brent,\n    quadraticRoots = _root_operators_1$def.quadraticRoots;\nvar _root_bounds_1$defaul = root_bounds_1.default,\n    rootMagnitudeUpperBound_fujiwara = _root_bounds_1$defaul.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = _root_bounds_1$defaul.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = _root_bounds_1$defaul.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = _root_bounds_1$defaul.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = _root_bounds_1$defaul.negativeRootLowerBound_LMQ;\n\nvar INF = Number.POSITIVE_INFINITY;\n/**\n * <p>Finds a near optimal approximation to the real roots (or those\n * within a range) of the input polynomial.\n * </p>\n * <p>\n * Only multiple roots of even order that is very close together may be\n * missed. (This is rarely a problem in practice - in a geometrical\n * application, for instance, this may mean two objects are barely\n * touching and returning either, all, or none of the repeated even\n * roots should not break the algorithm).\n * </p>\n * @param p - The polynomial\n * @param a - Lower limit of root values that should be returned -\n * defaults to -∞\n * @param b - Upper limit of root values that should be returned -\n * defaults to +∞\n * @example\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4]\n */\nfunction allRoots(p) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -INF;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +INF;\n\n    p = clip0(p);\n    var d = p.length - 1;\n    var rangeFilter = inRange(a, b);\n    if (d === 2) {\n        return quadraticRoots(p).filter(rangeFilter);\n        // Investigate if any numerically stable algorithm could be as fast\n        // as this algorithm (i.e by finding cubic roots within quadratic\n        // root demarcated intervals via Brent's method. The cubicRoots \n        // algoritm below has been removed since it was numerically \n        // unstable.\n        /*} else if (d === 3) {\n            return cubicRoots(p)\n                .filter(rangeFilter)\n                .sort((a,b) => a-b)\n        } else if (d > 3) {*/\n    } else if (d > 2) {\n        // TODO The root bounding function below might have an impact on \n        // performance - it would probably be better to use \n        // positiveRootUpperBound_LMQ or (possibly) even better, the \n        // linear version of it (see paper of Viglas, Akritas and \n        // Strzebonski) and re-calculate bounds on every iteration.\n        var lowerBound = void 0;\n        var upperBound = void 0;\n        if (a === -INF || b === +INF) {\n            //let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n            //lowerBound = a === -INF ? -magnitudeBound : a;\n            //upperBound = b === +INF ? +magnitudeBound : b;\n            if (a === -INF) {\n                lowerBound = negativeRootLowerBound_LMQ(p);\n            } else {\n                lowerBound = a;\n            }\n            if (b === +INF) {\n                upperBound = positiveRootUpperBound_LMQ(p);\n            } else {\n                upperBound = b;\n            }\n        } else {\n            lowerBound = a;\n            upperBound = b;\n        }\n        // If the roots of the differentiated polynomial is out of range \n        // then the roots of the polynomial itself will also be out of \n        // range.\n        var dp = differentiate(p);\n        var roots = allRoots(dp, lowerBound, upperBound).filter(rangeFilter);\n        if (roots[0] !== lowerBound) {\n            // For code coverage to cover the 'else' case we would need\n            // to find a case where the lower bound actually matches the\n            // root which would be very rare - needs further \n            // investigation.\n            // Not an actual root.\n            roots.unshift(lowerBound);\n        }\n        if (roots[roots.length - 1] !== upperBound) {\n            // Not an actual root.\n            roots.push(upperBound);\n        }\n        return rootsWithin(p, roots);\n    } else if (d === 1) {\n        // Less likely so put near bottom (micro optimization)\n        return [-p[1] / p[0]].filter(rangeFilter);\n    } else if (d === 0) {\n        return []; // y = c -> no roots\t\n    }\n    // Least likely so put at bottom (micro optimization)\n    // d === -1\n    // y = 0 -> infinite number of roots\n    return [];\n}\n/**\n * Returns a function that returns true if x is in the range [a,b].\n * @param a\n * @param b\n * @private\n */\nfunction inRange(a, b) {\n    return function (x) {\n        return x >= a && x <= b;\n    };\n}\n/**\n * Finds all roots of the given polynomial within the given intervals.\n * @private\n * @param p\n * @param intervals\n */\nfunction rootsWithin(p, intervals) {\n    var roots = [];\n    var peval = evaluate(p);\n    var prevRoot = void 0;\n    var a = intervals[0];\n    for (var i = 1; i < intervals.length; i++) {\n        var root = void 0;\n        var b = intervals[i];\n        var evA = peval(a);\n        var evB = peval(b);\n        var k = evA * evB;\n        if (k === 0) {\n            if (evA === 0) {\n                root = a;\n            } else if (evB === 0 && i === intervals.length - 1) {\n                root = b;\n            }\n        } else if (evA * evB < 0) {\n            root = brent(peval, a, b);\n        }\n        // Add root if it exists and suppress exact duplicates\n        if (root !== undefined && root !== prevRoot) {\n            roots.push(root);\n            prevRoot = root;\n        }\n        a = b;\n    }\n    return roots;\n}\nexports.default = allRoots;\n\n},{\"./core-operators\":49,\"./root-bounds\":53,\"./root-operators\":54}],49:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true if two polynomials are exactly equal by comparing\n * coefficients.\n * @param p1 - A polynomial\n * @param p2 - Another polynomial\n * @example\n * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\n * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\n */\nfunction equal(p1, p2) {\n    if (p1.length !== p2.length) {\n        return false;\n    }\n    for (var i = 0; i < p1.length; i++) {\n        if (p1[i] !== p2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Adds two polynomials.\n * @param p1 - The first polynomial\n * @param p2 - The second polynomial\n * @example\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\n */\nfunction add(p1, p2) {\n    // Initialize result array  \n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var Δd = d1 - d2;\n    var Δd1 = 0;\n    var Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    } else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    var d = Math.max(d1, d2);\n    // Add coefficients\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        var c1 = p1[i + Δd1];\n        var c2 = p2[i + Δd2];\n        result.push((c1 || 0) + (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Subtracts the second polynomial from first (p1 - p2).\n * @param p1 - The polynomial from which will be subtracted\n * @param p2 - The polynomial that will be subtracted\n * @example\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\n */\nfunction subtract(p1, p2) {\n    // Initialize result array  \n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var Δd = d1 - d2;\n    var Δd1 = 0;\n    var Δd2 = 0;\n    if (Δd > 0) {\n        Δd2 = -Δd;\n    } else if (Δd < 0) {\n        Δd1 = +Δd;\n    }\n    var d = Math.max(d1, d2);\n    // Add coefficients\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        var c1 = p1[i + Δd1];\n        var c2 = p2[i + Δd2];\n        result.push((c1 || 0) - (c2 || 0));\n    }\n    // Ensure the result is a valid polynomial representation\n    return clip0(result);\n}\n/**\n * Negate the given polynomial (p -> -p).\n * @param p - The polynomial\n * @example\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\n */\nfunction negate(p) {\n    return multiplyByConst(-1, p);\n}\n/**\n * Differentiates the given polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\n */\nfunction differentiate(p) {\n    var result = [];\n    var d = p.length - 1;\n    for (var i = 0; i < d; i++) {\n        result.push((d - i) * p[i]);\n    }\n    return result;\n}\n/**\n * <p>\n * Multiplies the two given polynomials and returns the result.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\n * </p>\n * <p>\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\n * </p>\n * @param p1 - The one polynomial.\n * @param p2 - The other polynomial.\n * @example\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\n */\nfunction multiply(p1, p2) {\n    var d1 = p1.length - 1;\n    var d2 = p2.length - 1;\n    var d = d1 + d2;\n    var result = new Array(d + 1).fill(0);\n    for (var i = 0; i < d1 + 1; i++) {\n        for (var j = 0; j < d2 + 1; j++) {\n            result[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n        }\n    }\n    return clip0(result);\n}\n/**\n * Multiplies 2 polynomials by a constant.\n * @param c - The constant\n * @param p - The polynomial\n * @example\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\n */\nfunction multiplyByConst(c, p) {\n    if (c === 0) {\n        return [];\n    }\n    var d = p.length - 1;\n    var result = [];\n    for (var i = 0; i < d + 1; i++) {\n        result.push(c * p[i]);\n    }\n    // We have to clip due to possible floating point underflow\n    return clip0(result);\n}\n/**\n * Returns the degree of the polynomial.\n * @param p - The polynomial\n * @example\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\n */\nfunction degree(p) {\n    return p.length - 1;\n}\nfunction evaluate(p, a) {\n    function f(a) {\n        //if p.length === 0 { return 0; }\n        var result = p[0];\n        for (var i = 1; i < p.length; i++) {\n            result = p[i] + result * a;\n        }\n        return result;\n    }\n    // Curry the function\n    return a === undefined ? f : f(a);\n}\n/**\n * Evaluates the given polynomial at 0 - it is much faster than at an\n * arbitrary point.\n * @param p - The polynomial\n * @example\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\n */\nfunction evaluateAt0(p) {\n    return p[p.length - 1];\n}\n;\n/**\n * <p>\n * Returns the number of sign changes in the polynomial coefficents\n * when ordered in descending order; zeros are ignored.\n * </p>\n * <p>\n * Descartes' rule of signs states (quoted from Wikipedia):\n * \"if the terms of a polynomial are ordered by descending variable\n * exponent, then the number of positive roots of the polynomial is\n * either equal to the number of sign differences between consecutive\n * nonzero coefficients, or is less than it by an even number. Multiple\n * roots of the same value are counted separately.\"\n * </p>\n * See https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\n * @param p - The polynomial\n * @example\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\n */\nfunction signChanges(p) {\n    var d = p.length - 1;\n    var result = 0;\n    var prevSign = Math.sign(p[0]);\n    for (var i = 1; i < d + 1; i++) {\n        var sign = Math.sign(p[i]);\n        if (sign !== prevSign && sign !== 0) {\n            result++;\n            prevSign = sign;\n        }\n    }\n    return result;\n}\n/**\n * Deflates the given polynomial by removing a factor (x - r), where\n * r is a root of the polynomial.\n * @param p - The polynomial\n * @param root - A pre-calculated root of the polynomial.\n * @example\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2]\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1]\n * FloPoly.deflate([1, -1], 1);        //=> [1]\n */\nfunction deflate(p, root) {\n    var d = p.length - 1;\n    var bs = [p[0]];\n    for (var i = 1; i < d; i++) {\n        bs.push(p[i] + root * bs[i - 1]);\n    }\n    return bs;\n}\n/**\n * Inverts the given polynomial by reversing the order of the\n * coefficients, i.e. p(x) -> x^deg(p) * p(1/x)\n * @param p - The polynomial\n * @example\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\n */\nfunction invert(p) {\n    return p.slice().reverse();\n}\n/**\n * <p>\n * Performs a change of variables of the form: p(x) <- p(ax + b).\n * </p>\n * <p>\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\n * </p>\n * @param p - The polynomial\n * @param a\n * @param b\n * @example\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\n */\nfunction changeVariables(p, a, b) {\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \n    // code below. \n    // d_i is calculated as d = T*c, where c are the original \n    // coefficients.\n    var d = p.length - 1;\n    // Initialize a zero matrix\n    var t = [];\n    for (var i = 0; i < d + 1; i++) {\n        t.push(new Array(d + 1).fill(0));\n    }\n    // Calculate the triangular matrix T\n    t[0][0] = 1;\n    for (var j = 1; j <= d; j++) {\n        t[0][j] = b * t[0][j - 1];\n        for (var _i = 1; _i <= j; _i++) {\n            t[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n        }\n    }\n    // Multiply\n    var res = new Array(d + 1).fill(0);\n    for (var _i2 = 0; _i2 <= d; _i2++) {\n        res[d - _i2] = 0;\n        for (var _j = _i2; _j <= d; _j++) {\n            var acc = t[_i2][_j] * p[d - _j];\n            res[d - _i2] += acc;\n        }\n    }\n    return res;\n}\n/**\n * Reflects the given polynomial about the Y-axis, i.e. perform the\n * change of variables: p(x) <- p(-x).\n * @param p - The polynomial to reflect\n * @example\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\n */\nfunction reflectAboutYAxis(p) {\n    var d = p.length - 1;\n    var result = p.slice();\n    for (var i = 0; i < d + 1; i++) {\n        if (i % 2) {\n            result[i] = -result[i];\n        }\n    }\n    return result;\n}\n/**\n * Generates a sturm chain for the given polynomial.\n * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n * @param p - The polynomial\n * @example\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\n */\nfunction sturmChain(p) {\n    /**\n     * Returns the negative of the remainder when dividing the first\n     * polynomial (the dividend) by the second (the divisor) provided\n     * that deg(p1) - deg(p2) === 1.\n     * @private\n     * @param p1 - The first polynomial (dividend)\n     * @param p2 - The second polynomial (divisor)\n     * See https://en.wikipedia.org/wiki/Sturm%27s_theorem\n     */\n    function negRemainder(p1, p2) {\n        var d1 = p1.length - 1;\n        var d2 = p2.length - 1;\n        var d = d1 - d2;\n        var a = p1[1] / p1[0] - p2[1] / p2[0];\n        var b = p1[0] / p2[0];\n        var p3 = multiply(multiplyByConst(b, p2), [1, a]);\n        return subtract(p3, p1);\n    }\n    var m = []; // Sturm chain\n    m.push(p);\n    m.push(differentiate(p));\n    //const δ = 10 * Number.EPSILON;\n    var i = 1;\n    while (m[i].length - 1 > 0) {\n        var pnext = negRemainder(m[i - 1], m[i]);\n        //pnext = clip(pnext, δ);\n        // If the polynomial degree was not reduced due to roundoff\n        // such that the first 1 or more terms are very small.\n        while (m[i].length - pnext.length < 1) {\n            pnext.shift();\n        }\n        /*\n        if (pnext.length === 0) {\n            break;\n        }\n        */\n        m.push(pnext);\n        i++;\n    }\n    return m;\n}\n/**\n * If the highest power coefficient is small in the sense that the\n * highest power term has a negligible contribution (compared to the\n * other terms) at x = 1 then clip() can be called to remove all such\n * highest terms. A contribution of less than Number.EPSILON of the\n * highest coefficient will be considered negligible by default.\n * @param p - The polynomial to be clipped.\n * @param δ - The optional contribution tolerence else\n *        Number.EPSILON will be used by default.\n * @example\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5]\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip(p, δ) {\n    δ = δ === undefined ? Number.EPSILON : δ;\n    var c = maxCoefficient(p);\n    if (c === 0) {\n        return [];\n    }\n    if (Math.abs(p[0]) > δ * c) {\n        return p;\n    }\n    var p_ = p.slice(1);\n    while (Math.abs(p_[0]) < δ * c) {\n        p_ = p_.slice(1);\n    }\n    return clip(p_, δ);\n}\n/**\n * If the highest power coefficient is 0 then clip() can be called to\n * remove all such highest terms so that the array is a valid\n * presentation of a polynomial.\n * @param p - The polynomial to be clipped.\n * @example\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\n */\nfunction clip0(p) {\n    return p[0] !== 0 ? p : clip0(p.slice(1));\n}\n/**\n * Returns the absolute value of the highest coefficient of the polynomial.\n * @param p - The polynomial.\n * @example\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\n */\nfunction maxCoefficient(p) {\n    var max = 0;\n    for (var i = 0; i < p.length; i++) {\n        var c = Math.abs(p[i]);\n        if (c > max) {\n            max = c;\n        }\n    }\n    return max;\n}\n/**\n * Returns a string representing the given polynomial that is readable\n * by a human or a CAS (Computer Algebra System).\n * @param p - The polynomial\n * @example\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\n */\nfunction toCasStr(p) {\n    var d = p.length - 1;\n    var str = '';\n    for (var i = 0; i < d + 1; i++) {\n        var cStr = p[i].toString();\n        if (i === d) {\n            str += cStr;\n        } else if (i === d - 1) {\n            str += 'x*' + cStr + ' + ';\n        } else {\n            str += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n        }\n    }\n    return str;\n}\nvar coreOperators = {\n    equal: equal,\n    add: add,\n    subtract: subtract,\n    multiplyByConst: multiplyByConst,\n    negate: negate,\n    differentiate: differentiate,\n    multiply: multiply,\n    degree: degree,\n    evaluate: evaluate,\n    evaluateAt0: evaluateAt0,\n    signChanges: signChanges,\n    invert: invert,\n    changeVariables: changeVariables,\n    reflectAboutYAxis: reflectAboutYAxis,\n    sturmChain: sturmChain,\n    clip: clip,\n    clip0: clip0,\n    deflate: deflate,\n    maxCoefficient: maxCoefficient,\n    toCasStr: toCasStr\n};\nexports.default = coreOperators;\n\n},{}],50:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar evaluate = core_operators_1.default.evaluate;\n/**\n * <p>\n * Approximate condition number for polynomial evaluation multiplied by the\n * exact value of the polynomial evaluation.\n * </p>\n * <p>\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\n * </p>\n * @ignore\n * @param p - The polynomial\n * @param x - The evaluation point\n */\n\nfunction conditionNumber(p, x) {\n    var d = p.length - 1;\n    var res = 0;\n    for (var i = 0; i < d; i++) {\n        res += Math.abs(p[i] * Math.pow(x, d - i));\n    }\n    return res;\n}\n/**\n * <p>\n * Classic rule of thumb approximate error bound when using Horner's\n * method to evaluate polynomials.\n * </p>\n * <p>\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\n * </p>\n * @param p - The polynomial\n * @param x - Value at which polynomial is evaluated.\n  * @example\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15\n */\nfunction hornerErrorBound(p, x) {\n    var δ = Number.EPSILON;\n    var d = p.length - 1;\n    return 2 * d * δ * conditionNumber(p, x);\n}\nvar errorAnalysis = {\n    hornerErrorBound: hornerErrorBound\n};\nexports.default = errorAnalysis;\n\n},{\"./core-operators\":49}],51:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar multiply = core_operators_1.default.multiply;\n/**\n * <p>\n * Constructs a polynomial from the given roots by multiplying out the\n * factors (x - root1)(x - root2)... Note that the resulting polynomial\n * will not have any complex roots.\n * </p>\n * <p>\n * Mostly provided for testing purposes. Note that the real roots of the\n * constructed polynomial may not be exactly the same as the roots that\n * the polynomial has been constructed from due to floating-point\n * round-off.\n * </p>\n *\n * @param roots - The roots\n * @example\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\n */\n\nfunction fromRoots(roots) {\n    var p = [1];\n    for (var i = 0; i < roots.length; i++) {\n        p = multiply(p, [1, -roots[i]]);\n    }\n    return p;\n}\nexports.default = fromRoots;\n\n},{\"./core-operators\":49}],52:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar from_roots_1 = _dereq_(\"./from-roots\");\n/**\n * Some seed value for the simple random number generator.\n * @ignore\n */\nvar SEED = 123456789;\n/**\n * The range for the simple random number generator, i.e. the generated\n * numbers will be in [0,RANGE].\n * @ignore\n */\nvar RANGE = 4294967296;\n/**\n * Creates a function from the given function with parameters similar\n * to flatRoots but with an extra parameter in the beginning indicating\n * the length of the array generated by the original function.\n * @private\n * @param {function} f\n * @returns {function}\n */\nfunction createArrFunction(f) {\n    return function (n, d, a, b) {\n        var seed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : SEED;\n        var odds = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n        var res = [];\n        for (var i = 0; i < n; i++) {\n            var v = f(d, a, b, seed, odds);\n            var p = v.p;\n            seed = v.seed;\n            res.push(p);\n        }\n        return res;\n    };\n}\n/**\n * Generates an array of random polynomials with parameters as specified\n * by flatRoots. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n * FloPoly.Random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n/**\n * Generates an array of random polynomials as specified by\n * flatCoefficients. The exact same polynomials will be created on each\n * call to this function if the same seed is used - this is by design to\n * improve testability.\n *\n * @memberof Random\n * @param n - The number of polynomials to generate.\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @returns {number[][]} The array of random polynomials.\n * @example\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n * FloPoly.Random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n/**\n * Returns a quasi-random number to be used as the next input to this function.\n * See https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\n * @private\n * @param seed\n */\nfunction predictiveRandom(seed) {\n    var a = 134775813;\n    return (a * seed + 1) % RANGE;\n}\n/**\n * Generates a random array of numbers picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values.\n *\n * @ignore\n * @param n - The number of values to generate.\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n */\nfunction randomArray(n, a, b) {\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n    var odds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    var vs = [];\n    for (var i = 0; i < n; i++) {\n        seed = predictiveRandom(seed);\n        var v = seed / RANGE * (b - a) + a;\n        seed = push(seed, vs, v, odds);\n    }\n    vs = vs.slice(0, n);\n    return { vs: vs, seed: seed };\n}\n/**\n * Helper function that will add more numbers to the passed array - modifies the\n * values parameter.\n * @private\n * @param seed\n * @param values - An existing array of values - will be modified!\n * @param x - The number that will be added (possibly multiple times)\n * @param odds - The odds that the number will be added again (recursively).\n */\nfunction push(seed, values, x, odds) {\n    seed = predictiveRandom(seed);\n    values.push(x);\n    if (seed / RANGE < odds) {\n        seed = push(seed, values, x, odds);\n    }\n    return seed;\n}\n/**\n * Generates a random polynomial with roots picked from a bounded flat\n * distribution (i.e. a rectangular distribution) with specified odds of\n * duplication of consecutive values. Note that the resulting polynomial\n * won't have any complex roots.\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults\n * to 0\n * @param b - The upper bound of the distribution - defaults\n * to 1\n * @param seed - A seed value for generating random values (so\n * that the results are reproducable)\n * @param odds - The odds that a root will be doubled (applied\n * recursively so that some roots will be tripled, etc. - defaults to 0\n * @example\n * FloPoly.Random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\n */\nfunction flatRoots(d) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n    var odds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    var randArr = randomArray(d, a, b, seed, odds);\n    seed = randArr.seed;\n    var p = from_roots_1.default(randArr.vs);\n    return { p: p, seed: seed };\n}\n/**\n * Generates a random polynomial with coefficients picked from a bounded\n * flat distribution (i.e. a rectangular distribution).\n * @memberof Random\n * @param d - The degree of the polynomials\n * @param a - The lower bound of the distribution - defaults to -1\n * @param b - The upper bound of the distribution - defaults to 1\n * @param seed - A seed value for generating random values (so that the results\n * are reproducable)\n * @example\n * FloPoly.Random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\n */\nfunction flatCoefficients(d) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +1;\n    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SEED;\n\n    a = a === undefined ? -1 : a;\n    b = b === undefined ? +1 : b;\n    seed = seed === undefined ? SEED : seed;\n    var randArr = randomArray(d, a, b, seed);\n    seed = randArr.seed;\n    var p = randArr.vs;\n    return { p: p, seed: seed };\n}\nvar random = {\n    flatRoots: flatRoots,\n    flatRootsArr: flatRootsArr,\n    flatCoefficients: flatCoefficients,\n    flatCoefficientsArr: flatCoefficientsArr\n};\nexports.default = random;\n\n},{\"./from-roots\":51}],53:[function(_dereq_,module,exports){\n\"use strict\";\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar _core_operators_1$def = core_operators_1.default,\n    invert = _core_operators_1$def.invert,\n    negate = _core_operators_1$def.negate,\n    reflectAboutYAxis = _core_operators_1$def.reflectAboutYAxis;\n/**\n * Returns the maximum magnitude value within the supplied array of numbers.\n * @private\n */\n\nfunction maxAbs(ns) {\n    return Math.max.apply(Math, _toConsumableArray(ns.map(function (n) {\n        return Math.abs(n);\n    })));\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * (including complex roots) of the given polynomial using Rouche's\n * Theorem with k = n. This function is fast but the bound is not tight.\n * @param p - The polynomial.\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n    var d = p.length - 1;\n    var R = 1 + 1 / p[0] * maxAbs(p.slice(1));\n    return R;\n}\n/**\n * Finds an upper bound on the magnitude (absolute value) of the roots\n * of the given polynomial using the near-optimal Fujiwara bound. Note\n * that the bound includes complex roots. The bound is tight but slow\n * due to usage of Math.pow().\n * See https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\n * @param p - The polynomial.\n * @example\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n    var d = p.length - 1;\n    var an = p[0];\n    var bs = [];\n    for (var i = 1; i < d; i++) {\n        var b = Math.pow(Math.abs(p[i] / an), 1 / i);\n        bs.push(b);\n    }\n    bs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n    return 2 * Math.max.apply(undefined, bs);\n}\nvar POWERS = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152];\n/**\n * <p>\n * Returns an upper bound for the positive real roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootUpperBound_LMQ(p) {\n    var deg = p.length - 1;\n    if (deg < 1) {\n        return 0;\n    }\n    if (p[0] < 0) {\n        p = negate(p);\n    }\n    var timesUsed = [];\n    for (var i = 0; i < deg; i++) {\n        timesUsed.push(1);\n    }\n    var ub = 0;\n    for (var m = 0; m <= deg; m++) {\n        if (p[m] >= 0) continue;\n        var tempub = Number.POSITIVE_INFINITY;\n        var any = false;\n        for (var k = 0; k < m; k++) {\n            if (p[k] <= 0) {\n                continue;\n            }\n            // Table lookup is about 70% faster but both are\n            // extemely fast anyway. \n            // Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n            var pow = timesUsed[k];\n            var powres = void 0;\n            if (pow > 20) {\n                powres = Math.pow(2, pow);\n            } else {\n                powres = POWERS[pow];\n            }\n            var temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n            timesUsed[k]++;\n            if (tempub > temp) {\n                tempub = temp;\n            }\n            any = true;\n        }\n        if (any && ub < tempub) ub = tempub;\n    }\n    return ub;\n}\n/**\n * <p>\n * Calculates a lower bound for the positive roots of the given\n * polynomial.\n * </p>\n * <p>\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\n * </p>\n * @param p - The polynomial\n * @example\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\n */\nfunction positiveRootLowerBound_LMQ(p) {\n    var ub = positiveRootUpperBound_LMQ(invert(p));\n    if (ub === 0) {\n        return 0;\n    }\n    return 1 / ub;\n}\n/**\n * See positiveRootUpperBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} An upper bound.\n */\nfunction negativeRootUpperBound_LMQ(p) {\n    return -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n/**\n * See positiveRootLowerBound_LMQ\n *\n * @param p - The polynomial\n * @returns {number} A lower bound.\n */\nfunction negativeRootLowerBound_LMQ(p) {\n    return -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\nvar rootBounds = {\n    rootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,\n    rootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche\n};\nexports.default = rootBounds;\n\n},{\"./core-operators\":49}],54:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_operators_1 = _dereq_(\"./core-operators\");\nvar _core_operators_1$def = core_operators_1.default,\n    sturmChain = _core_operators_1$def.sturmChain,\n    evaluate = _core_operators_1$def.evaluate,\n    signChanges = _core_operators_1$def.signChanges;\n/**\n * <p>\n * Floating-point-stably calculates and returns the ordered quadratic\n * roots of the given quadratic polynomial.\n * </p>\n * <p>\n * This function is included only because it might be slightly faster\n * than calling allRoots due to allRoots first checking if the\n * polynomial is quadratic and checking if the roots are within the\n * given range.\n * </p>\n * @param p - The 2nd order polynomial\n * @example\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\n */\n\nfunction quadraticRoots(p) {\n    var _p = _slicedToArray(p, 3),\n        a = _p[0],\n        b = _p[1],\n        c = _p[2];\n\n    var delta = b * b - 4 * a * c;\n    if (delta < 0) {\n        // No real roots;\n        return [];\n    }\n    if (delta === 0) {\n        return [-b / (2 * a)];\n    }\n    delta = Math.sqrt(delta);\n    var root1 = void 0;\n    var root2 = void 0;\n    if (b >= 0) {\n        root1 = (-b - delta) / (2 * a);\n        root2 = 2 * c / (-b - delta);\n    } else {\n        root1 = 2 * c / (-b + delta);\n        root2 = (-b + delta) / (2 * a);\n    }\n    if (root1 < root2) {\n        return [root1, root2];\n    }\n    return [root2, root1];\n}\n/**\n * Calculates the roots of the given cubic polynomial.\n *\n * This code is mostly from the Pomax guide found at\n * https://pomax.github.io/bezierinfo/#extremities\n *\n * @param p - A cubic polynomial.\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\nfunction cubicRoots(p) {\n\r\n    function cuberoot(v) {\n        return v < 0\n            ? -Math.pow(-v, 1/3)\n            : +Math.pow(v, 1/3);\n    }\n    \r\n    let cbrt = Math.cbrt || cuberoot;\n    \r\n    let d = p[0];\n    let a = p[1] / d;\n    let b = p[2] / d;\n    let c = p[3] / d;\n    \r\n    let s  = (3*b - a*a) / 9;\n    let q  = (2*a*a*a - 9*a*b + 27*c) / 54;\n    \r\n    let s3 = s*s*s;\n    let q2 = q*q;\n    \r\n    let discriminant = q2 + s3;\n\r\n    if (!Number.isFinite(discriminant)) {\n        \r\n        // Overflow occured - in which case one root will be very large.\n        // We might want to report such large roots as positive or\n        // negative infinity but since they are rarely of interest we\n        // report only the smaller roots.\n        \r\n        // Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\n        // and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\n        \r\n        return quadraticRoots(p.slice(1));\n    }\n    \r\n    if (discriminant < 0) {\n        // three real roots\n        \r\n        let r = Math.sqrt(-s3);\n        let t = -q / r;\n        \r\n        let cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\n        let phi    = Math.acos(cosphi);\n        let\tt1     = 2*cbrt(r);\n        \r\n        let ao3 = a/3;\n        \r\n        return [\n            t1*Math.cos((phi            )/3) - ao3,\n            t1*Math.cos((phi + 2*Math.PI)/3) - ao3,\n            t1*Math.cos((phi + 4*Math.PI)/3) - ao3\n        ]\n    } else if (discriminant === 0) {\n        // three real roots, but two of them are equal\n        \r\n        let u1 = q < 0 ? cbrt(-q) : -cbrt(q);\n        let ao3 = a/3;\n        \r\n        return [\n            2*u1 - ao3,\n            -u1 - ao3\n        ];\n    } else {\n        // one real root, two complex roots\n        \r\n        let sd = Math.sqrt(discriminant);\n        let u1 = cbrt(sd - q);\n        let v1 = cbrt(sd + q);\n        \r\n        return [u1 - v1 - a/3];\n    }\n}\n*/\n/**\n * Returns the number of real roots in the interval (a,b) of the given\n * polynomial.\n * @param p - The polynomial\n * @param a - The lower bound\n * @param b - The upper bound\n * @example\n * let p = [1, 1, -64, 236, -240];\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\n */\nfunction numRootsWithin(p, a, b) {\n    var ps = sturmChain(p);\n    var ev = evaluate(p);\n    var as = ps.map(function (p) {\n        return evaluate(p)(a);\n    });\n    var bs = ps.map(function (p) {\n        return evaluate(p)(b);\n    });\n    return signChanges(as) - signChanges(bs);\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Bisection\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Note: This function has no advantages above the Brent method except\n * for its simpler implementation and can be much slower. Use brent\n * instead.\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.bisection(f,2.2,3.8); //=> 3\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\n */\nfunction bisection(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    } else if (b < a) {\n        // Swap a and b \n        var _ref = [b, a];\n        a = _ref[0];\n        b = _ref[1];\n    }\n    var fa = f(a);\n    var fb = f(b);\n    if (fa === 0) {\n        return a;\n    }\n    if (fb === 0) {\n        return b;\n    }\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    while (true) {\n        var c = a + (b - a) / 2; // Take midpoint\n        var fc = f(c);\n        if (fc === 0) {\n            return c;\n        }\n        if (fa * fc < 0) {\n            b = c;\n        } else {\n            a = c;\n        }\n        // We don't add Number.EPSILON in the line below because we want\n        // accuracy to improve even below 1.\n        var δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n    }\n}\n/**\n * <p>\n * Searches an interval (a,b) for a root (i.e. zero) of the\n * given function with respect to its first argument using the Brent's\n * Method root-finding algorithm. Any function can be supplied (it does\n * not even have to be continuous) as long as the root is bracketed.\n * </p>\n * <p>\n * Brent's Method is an excellent root-finding choice since it is\n * (1) guaranteed to converge (unlike the Newton and other so-called\n * single-point methods), (2) converges in a reasonable number of\n * iterations even for highly contrived functions (unlike Dekker's\n * Method) and (3) nearly always converges extremely fast, i.e. super-\n * linearly (unlike the Secant and Regula-Falsi methods).\n * </p>\n * <p>\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\n * after each iteration where b is the max of the current 2 best\n * guesses.\n * </p>\n * <p>\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\n * </p>\n * <p>\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\n * </p>\n * @param f - The function for which the root is sought.\n * @param a - The lower limit of the search interval.\n * @param b - The upper limit of the search interval.\n * about 1e-15 multiplied by the root magnitued).\n * @example\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\n * let f = FloPoly.evaluate(p);\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\n */\nfunction brent(f, a, b) {\n    if (a === b) {\n        // Presumably the root is already found.\n        return a;\n    }\n    // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n    var fa = f(a);\n    var fb = f(b);\n    if (fa * fb > 0) {\n        // Root is not bracketed - this is a precondition.\n        throw new Error('Root not bracketed');\n    }\n    var c = void 0; // Value of previous guess - set to a initially \n    if (Math.abs(fa) < Math.abs(fb)) {\n        // Swap a,b\n        c = a;\n        a = b;\n        b = c;\n        // Swap fa,fb\n        var temp = fa;\n        fa = fb;\n        fb = temp;\n    }\n    c = a;\n    var mflag = true;\n    var d = void 0; // Value of guess before previous guess\n    while (true) {\n        var δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n        var fc = f(c);\n        // Calculate provisional interpolation value\n        var s = void 0;\n        if (fa !== fc && fb !== fc) {\n            // 3 points available - inverse quadratic interpolation\n            var fac = fa - fc;\n            var fab = fa - fb;\n            var fbc = fb - fc;\n            // The below has been multiplied out to speed up the algorithm.\n            /*s = ((a * fb * fc) / ( fab * fac)) +\n                  ((b * fa * fc) / (-fab * fbc)) +\n                  ((c * fa * fb) / ( fac * fbc));*/\n            s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n        } else {\n            // only 2 points available - secant method\n            s = b - fb * ((b - a) / (fb - fa));\n        }\n        var t1 = (3 * a + b) / 4;\n        var b_c = Math.abs(b - c);\n        var s_b = Math.abs(s - b);\n        var c_d = Math.abs(c - d);\n        if (!(s > t1 && s < b || s < t1 && s > b) || mflag && (\n        // condition 2\n        s_b >= b_c / 2 ||\n        // condition 4\n        b_c < δ) || !mflag && (\n        // condition 3\n        s_b >= c_d / 2 ||\n        // condition 5\n        c_d < δ)) {\n            // Bisection\n            s = (a + b) / 2;\n            mflag = true;\n        } else {\n            mflag = false;\n        }\n        var fs = f(s);\n        d = c;\n        c = b;\n        if (fa * fs < 0) {\n            b = s;\n        } else {\n            a = s;\n        }\n        if (Math.abs(fa) < Math.abs(fb)) {\n            // Swap a,b\n            var _temp = a;\n            a = b;\n            b = _temp;\n        }\n        if (fb === 0) {\n            return b;\n        }\n        if (fs === 0) {\n            return s;\n        }\n        if (Math.abs(a - b) <= δ) {\n            return b;\n        }\n        fa = f(a);\n        fb = f(b);\n    }\n}\nvar rootOperators = {\n    quadraticRoots: quadraticRoots,\n    numRootsWithin: numRootsWithin,\n    brent: brent,\n    bisection: bisection\n};\nexports.default = rootOperators;\n\n},{\"./core-operators\":49}],55:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DELTA = 1e-10;\n/**\n * Curry the given arity two function.\n * @param f - A function\n */\nfunction curry2(f) {\n    function g(t, u) {\n        return u === undefined ? function (u) {\n            return f(t, u);\n        } : f(t, u);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity two function.\n* @private\n*/\nfunction mapCurry2(f) {\n    function g(t, us) {\n        var h = f(t);\n        var hUs = function hUs(us) {\n            return us.map(h);\n        };\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n/**\n* Creates a transformation function that operates on multiple points from the\n* given arity 3 curried function (keeping the first two parameters uncurried).\n* @private\n*/\nfunction specialMapCurry(f) {\n    function g(s, t, us) {\n        var h = f(s, t);\n        var hUs = function hUs(us) {\n            return us.map(h);\n        };\n        // Curry the function\n        return us === undefined ? hUs : hUs(us);\n    }\n    return g;\n}\n\nvar Vector2d = function () {\n    function Vector2d() {\n        _classCallCheck(this, Vector2d);\n    }\n\n    _createClass(Vector2d, null, [{\n        key: \"dot\",\n\n        /**\n         * Returns the dot (inner) product between two 2-vectors.\n         * @param a - The first vector\n         * @param b - The second vector\n         */\n        value: function dot(a, b) {\n            return a[0] * b[0] + a[1] * b[1];\n        }\n        /**\n         * Returns the cross product signed magnitude between two 2-vectors.\n         * @param a - The first vector\n         * @param b - The second vector\n         */\n\n    }, {\n        key: \"cross\",\n        value: function cross(a, b) {\n            return a[0] * b[1] - a[1] * b[0];\n        }\n        /**\n         * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\n         * ccw < 0, and colinear if ccw = 0 because ccw is a determinant that gives\n         * twice the signed area of the triangle formed by p1, p2 and p3.\n         * @param p1 - The first point\n         * @param p2 - The second point\n         * @param p3 - The third point\n         * @param delta - The tolerance at which the three points are considered\n         * collinear - defaults to 1e-10.\n         */\n\n    }, {\n        key: \"ccw\",\n        value: function ccw(p1, p2, p3) {\n            var delta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DELTA;\n\n            var res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n            return Math.abs(res) <= delta ? 0 : res;\n        }\n        /**\n        * <p>\n        * Returns the point where two line segments intersect or undefined if they\n        * don't intersect or a line if they intersect at infinitely many points.\n        * </p>\n        * <p>\n        * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\n        * </p>\n        * @param ab - The first line\n        * @param cd - The second line\n        * @param delta - The tolerance at which the lines are considered parallel -\n        * defaults to 1e-10.\n        */\n\n    }, {\n        key: \"segSegIntersection\",\n        value: function segSegIntersection(ab, cd) {\n            var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DELTA;\n\n            var _ab = _slicedToArray(ab, 2),\n                a = _ab[0],\n                b = _ab[1];\n\n            var _cd = _slicedToArray(cd, 2),\n                c = _cd[0],\n                d = _cd[1];\n\n            var denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n            var rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n            var sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n            if (Math.abs(denom) <= delta) {\n                // parallel\n                if (Math.abs(rNumer) <= delta) {\n                    // colinear\n                    // TODO Check if x-projections and y-projections intersect\n                    // and return the line of intersection if they do.\n                    return undefined;\n                }\n                return undefined;\n            }\n            var r = rNumer / denom;\n            var s = sNumer / denom;\n            if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n                return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n            }\n            return undefined;\n        }\n        /**\n        * Returns true if the two given 2d line segments intersect, false otherwise.\n        * @param a - A line segment\n        * @param b - Another line segment\n        */\n\n    }, {\n        key: \"doesSegSegIntersect\",\n        value: function doesSegSegIntersect(a, b) {\n            var ccw = Vector2d.ccw;\n            if (ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) > 0) {\n                return false;\n            } else if (ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) > 0) {\n                return false;\n            }\n            return true;\n        }\n        /**\n        * Returns the squared distance between two 2d points.\n        * @param p1 - A point\n        * @param p2 - Another point\n        */\n\n    }, {\n        key: \"squaredDistanceBetween\",\n        value: function squaredDistanceBetween(p1, p2) {\n            var x = p2[0] - p1[0];\n            var y = p2[1] - p1[1];\n            return x * x + y * y;\n        }\n        /**\n        * Returns a scaled version of the given 2-vector.\n        * @param p - A vector\n        * @param factor - A scale factor\n        */\n\n    }, {\n        key: \"scale\",\n        value: function scale(p, factor) {\n            return [p[0] * factor, p[1] * factor];\n        }\n        /**\n        * Returns the given 2-vector reversed.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"reverse\",\n        value: function reverse(p) {\n            return [-p[0], -p[1]];\n        }\n        /**\n        * Returns the given 2-vector scaled to a length of one.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"toUnitVector\",\n        value: function toUnitVector(p) {\n            var scaleFactor = 1 / Vector2d.len(p);\n            return [p[0] * scaleFactor, p[1] * scaleFactor];\n        }\n        /**\n        * Returns the given 2-vector scaled to the given length.\n        * @param p - A vector\n        * @param length - The length to scale to\n        */\n\n    }, {\n        key: \"toLength\",\n        value: function toLength(p, len) {\n            var scaleFactor = len / Vector2d.len(p);\n            return [p[0] * scaleFactor, p[1] * scaleFactor];\n        }\n        /**\n        * Returns the second 2-vector minus the first.\n        * @param p1 - The first vector\n        * @param p2 - The second vector\n        */\n\n    }, {\n        key: \"fromTo\",\n        value: function fromTo(p1, p2) {\n            return [p2[0] - p1[0], p2[1] - p1[1]];\n        }\n        /**\n        * Performs linear interpolation between two 2d points and returns the resultant point.\n        * @param p1 - The first point.\n        * @param p2 - The second point.\n        * @param t - The interpolation fraction (often in [0,1]).\n        */\n\n    }, {\n        key: \"interpolate\",\n        value: function interpolate(p1, p2, t) {\n            return [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];\n        }\n        /**\n        * Returns the mean of two 2d points.\n        * @param ps - The two points\n        */\n\n    }, {\n        key: \"mean\",\n        value: function mean(ps) {\n            var p1 = ps[0];\n            var p2 = ps[1];\n            return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n        }\n        /**\n        * Returns the distance between two 2d points.\n        * @param p1 - A point.\n        * @param p2 - Another point.\n        */\n\n    }, {\n        key: \"distanceBetween\",\n        value: function distanceBetween(p1, p2) {\n            return Math.sqrt(Vector2d.squaredDistanceBetween(p1, p2));\n        }\n        /**\n        * Returns the length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"len\",\n        value: function len(p) {\n            return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        }\n        /**\n        * Returns the squared length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"lengthSquared\",\n        value: function lengthSquared(v) {\n            return v[0] * v[0] + v[1] * v[1];\n        }\n        /**\n        * Returns the Manhattan distance between two 2d points.\n        * @param p1 - A point.\n        * @param p2 - Another point.\n        */\n\n    }, {\n        key: \"manhattanDistanceBetween\",\n        value: function manhattanDistanceBetween(p1, p2) {\n            return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n        }\n        /**\n        * Returns the Manhattan length of the given 2-vector.\n        * @param p - A vector\n        */\n\n    }, {\n        key: \"manhattanLength\",\n        value: function manhattanLength(p) {\n            return Math.abs(p[0]) + Math.abs(p[1]);\n        }\n        /**\n        * <p>\n        * Returns the distance between the given point and line.\n        * </p>\n        * <p>\n        * See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\n        * this Wikipedia article</a>\n        * </p>\n        * @param p - A point\n        * @param l - A line\n        */\n\n    }, {\n        key: \"distanceBetweenPointAndLine\",\n        value: function distanceBetweenPointAndLine(p, l) {\n            var _p = _slicedToArray(p, 2),\n                x0 = _p[0],\n                y0 = _p[1];\n\n            var _l = _slicedToArray(l, 2),\n                _l$ = _slicedToArray(_l[0], 2),\n                x1 = _l$[0],\n                y1 = _l$[1],\n                _l$2 = _slicedToArray(_l[1], 2),\n                x2 = _l$2[0],\n                y2 = _l$2[1];\n\n            var y = y2 - y1;\n            var x = x2 - x1;\n            var a = y * x0 - x * y0 + x2 * y1 - y2 * x1;\n            var b = Math.sqrt(x * x + y * y);\n            return Math.abs(a / b);\n        }\n        /**\n        * Returns the squared distance between the given point and line segment.\n        * @param p - A point\n        * @param l - A line\n        */\n\n    }, {\n        key: \"squaredDistanceBetweenPointAndLineSegment\",\n        value: function squaredDistanceBetweenPointAndLineSegment(p, l) {\n            var sqDst = Vector2d.squaredDistanceBetween;\n            var v = l[0];\n            var w = l[1];\n            var l2 = sqDst(v, w);\n            if (l2 == 0) {\n                return sqDst(p, v);\n            }\n            var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n            t = Math.max(0, Math.min(1, t));\n            var d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n            return d2;\n        }\n        /**\n        * Returns the circumcenter of the given 2d triangle.\n        * @param triangle\n        */\n\n    }, {\n        key: \"circumCenter\",\n        value: function circumCenter(triangle) {\n            // See wikipedia\n            var p1 = triangle[0];\n            var p2 = triangle[1];\n            var p3 = triangle[2];\n            var sqLen = Vector2d.lengthSquared;\n            var Sx = 0.5 * Vector2d.det3([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\n            var Sy = 0.5 * Vector2d.det3([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\n            var a = Vector2d.det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n            var b = Vector2d.det3([p1[0], p1[1], sqLen(p1)], [p2[0], p2[1], sqLen(p2)], [p3[0], p3[1], sqLen(p3)]);\n            return [Sx / a, Sy / a];\n        }\n        /**\n        * <p>\n        * Returns the incenter of the given triangle.\n        * </p>\n        * <p>\n        * See Wikipedia - https://en.wikipedia.org/wiki/Incenter\n        * </p>\n        * @param triangle\n        */\n\n    }, {\n        key: \"inCenter\",\n        value: function inCenter(triangle) {\n            var dst = Vector2d.distanceBetween;\n            var p1 = triangle[0];\n            var p2 = triangle[1];\n            var p3 = triangle[2];\n            var l1 = dst(p2, p3);\n            var l2 = dst(p1, p3);\n            var l3 = dst(p1, p2);\n            var lengthSum = l1 + l2 + l3;\n            return [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n        }\n        /**\n        * Returns the centroid of the given polygon, e.g. triangle. The polygon\n        * must be simple, i.e. not self-intersecting.\n        * @param polygon\n        */\n\n    }, {\n        key: \"centroid\",\n        value: function centroid(polygon) {\n            if (polygon.length === 3) {\n                var p1 = polygon[0];\n                var p2 = polygon[1];\n                var p3 = polygon[2];\n                var x = p1[0] + p2[0] + p3[0];\n                var y = p1[1] + p2[1] + p3[1];\n                return [x / 3, y / 3];\n            }\n            // polygon.length assumed > 3 and assumed to be non-self-intersecting\n            // See wikipedia\n            // First calculate the area, A, of the polygon\n            var A = 0;\n            for (var i = 0; i < polygon.length; i++) {\n                var p0 = polygon[i];\n                var _p2 = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n                A = A + (p0[0] * _p2[1] - _p2[0] * p0[1]);\n            }\n            A = A / 2;\n            var C = [0, 0];\n            for (var _i = 0; _i < polygon.length; _i++) {\n                var _p3 = polygon[_i];\n                var _p4 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n                C[0] = C[0] + (_p3[0] + _p4[0]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n                C[1] = C[1] + (_p3[1] + _p4[1]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n            }\n            return [C[0] / (6 * A), C[1] / (6 * A)];\n        }\n        /**\n        * Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\n        * @ignore\n        * @param x - A 2d vector\n        * @param y - Another 2d vector\n        * @param z - Another 2d vector\n        */\n\n    }, {\n        key: \"det3\",\n        value: function det3(x, y, z) {\n            return x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(a, b) {\n            function f(b) {\n                return [a[0] + b[0], a[1] + b[1]];\n            }\n            // Curry the function\n            return b === undefined ? f : f(b);\n        }\n    }, {\n        key: \"rotate\",\n        value: function rotate(sinθ, cosθ, p) {\n            var a = Vector2d.translatePs([1, 2]);\n            function rotateByθ(p) {\n                return [p[0] * cosθ - p[1] * sinθ, p[0] * sinθ + p[1] * cosθ];\n            }\n            // Curry the function\n            return p === undefined ? rotateByθ : rotateByθ(p);\n        }\n        /**\n        * Returns true if two 2-vectors are identical (by value), false otherwise.\n        * @param a - A 2d vector\n        * @param b - Another 2d vector\n        */\n\n    }, {\n        key: \"equal\",\n        value: function equal(a, b) {\n            return a[0] === b[0] && a[1] === b[1];\n        }\n        /**\n        * Returns a anti-clockwise rotated version of the given 2-vector given the\n        * sine and cosine of the angle.\n        * @param p - A 2d vector\n        * @param sinθ\n        * @param cosθ\n        */\n\n    }, {\n        key: \"reverseRotate\",\n        value: function reverseRotate(sinθ, cosθ, p) {\n            return [+p[0] * cosθ + p[1] * sinθ, -p[0] * sinθ + p[1] * cosθ];\n        }\n        /**\n        * Returns a 90 degrees rotated version of the given 2-vector.\n        * @param p - A 2d vector\n        */\n\n    }, {\n        key: \"rotate90Degrees\",\n        value: function rotate90Degrees(p) {\n            return [-p[1], p[0]];\n        }\n        /**\n        * Returns a negative 90 degrees rotated version of the given 2-vector.\n        * @param p - A 2d vector\n        */\n\n    }, {\n        key: \"rotateNeg90Degrees\",\n        value: function rotateNeg90Degrees(p) {\n            return [p[1], -p[0]];\n        }\n        /**\n        * Transforms the given 2-vector by applying the given function to each\n        * coordinate.\n        * @param p - A 2d vector\n        * @param f - A transformation function\n        */\n\n    }, {\n        key: \"transform\",\n        value: function transform(p, f) {\n            return [f(p[0]), f(p[1])];\n        }\n        /**\n        * Returns the closest point to the array of 2d points, optionally providing\n        * a distance function.\n        * @param p\n        * @param ps\n        * @param f - Optional distance function - defaults to\n        * Vector2d.squaredDistanceBetween\n        */\n\n    }, {\n        key: \"getClosestTo\",\n        value: function getClosestTo(p, ps) {\n            var cp = undefined; // Closest Point\n            var bestd = Number.POSITIVE_INFINITY;\n            for (var i = 0; i < ps.length; i++) {\n                var p_ = ps[i];\n                var d = Vector2d.squaredDistanceBetween(p, p_);\n                if (d < bestd) {\n                    cp = p_;\n                    bestd = d;\n                }\n            }\n            return cp;\n        }\n        /**\n        * Returns an array of points by applying a translation and then rotation to\n        * the given points.\n        * @param v - The translation vector\n        * @param sinθ\n        * @param cosθ\n        * @param ps - The input points\n        **/\n\n    }, {\n        key: \"translateThenRotatePs\",\n        value: function translateThenRotatePs(v, sinθ, cosθ, ps) {\n            var translate = Vector2d.translate(v);\n            return ps.map(function (p) {\n                return Vector2d.rotate(sinθ, cosθ, translate(p));\n            });\n        }\n        /**\n        * Returns an array of points by applying a rotation and then translation to\n        * the given points.\n        * @param sinθ\n        * @param cosθ\n        * @param v - The translation vector\n        * @param ps - The input points\n        **/\n\n    }, {\n        key: \"rotateThenTranslatePs\",\n        value: function rotateThenTranslatePs(sinθ, cosθ, v, ps) {\n            return ps.map(function (p) {\n                return Vector2d.translate(v, Vector2d.rotate(sinθ, cosθ, p));\n            });\n        }\n    }]);\n\n    return Vector2d;\n}();\n/**\n* Return the given 2d points translated by the given 2d vector. This\n* function is curried.\n* @param v\n* @param ps\n*/\n\n\nVector2d.translatePs = mapCurry2(Vector2d.translate);\n/**\n* Return the given 2d points translated by the given 2d vector. This function\n* is curried.\n* @param sinθ\n* @param cosθ\n* @param ps\n*/\nVector2d.rotatePs = specialMapCurry(Vector2d.rotate);\nexports.default = Vector2d;\n\n},{}]},{},[1])(1)\n});"]}
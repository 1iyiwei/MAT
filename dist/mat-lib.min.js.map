{"version":3,"sources":["mat-lib.min.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","PointOnShape","bezierNode","type","order","order2","this","p","Bezier","evaluate","item","calcOsculatingCircle","bezier","κ","radius","MAT_CONSTANTS","maxOsculatingCircleRadius","Math","min","normal","circleCenter","Circle","dullCornerAt","shape","dullCornerHash","key","makeSimpleKey","typeToStr","pointType","Vector","Memoize","getOsculatingCircle","m1","pos","sharp","extreme","compare","b","undefined","res","indx","isPointingStraightUp","circle","circleDirection","toUnitVector","fromTo","center","abs","setPointOrder","dullCorner","beziers","tan1pre","tangent","tan1","tan2","dot","copy","toHumanString","../../mat-constants.js","../../memoize.js","../../vector/vector.js","./bezier.js","./circle.js","2","Arc","sinAngle1","cosAngle1","sinAngle2","cosAngle2","startpoint","endpoint","closestPointOnArc","arc","x","y","arco","translate","pp","sin_pp","cos_pp","Geometry","isAngleBetween","r_o_l","position","asp","aep","d1","distanceBetween","d2","ds","sqrt","distanceBetweenPointAndLineSegment","v","l1p2","lineLineIntersection","3","BezierPiece","tRange","4","bezierPoints","_bezierPoints","_slicedToArray","_bezierPoints$","x0","y0","_bezierPoints$2","x1","y1","_bezierPoints$3","x2","y2","_bezierPoints$4","x3","y3","dx","Poly","differentiate","dy","ddx","ddy","dddx","dddy","getNormalizedBoundingBox","sinAngle","cosAngle","vectorToOrigin","transform","normalizedBezier","translateThenRotatePoints","getBoundingBox","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","value","err","Array","isArray","Object","TypeError","gaussQuadrature","_bezier$bezierPoints","_bezier$bezierPoints$","_bezier$bezierPoints$2","_bezier$bezierPoints$3","_bezier$bezierPoints$4","evaluateX","evaluateY","evaluateDx","evaluateDy","evaluateDdx","evaluateDdy","numer","d","denom","κTimesSDiff","dκ","_bezier$bezierPoints2","_bezier$bezierPoints3","_bezier$bezierPoints4","_bezier$bezierPoints5","_bezier$bezierPoints6","ts","omt","c","g","h","pow","tan","getTotalCurvature","getTotalAbsoluteCurvature","totalAbsoluteCurvature","interval_","interval","result","getCurveLength","evaluateDddx","evaluateDddy","getBoundingBoxTight","_bezierPoints2","_bezierPoints2$","_bezierPoints2$2","_bezierPoints2$3","_bezierPoints2$4","straightLength","box","p0x","p0y","p1x","p1y","axisAlignedBox","rotateThenTranslatePoints","getBounds","roots","map","findQuadraticRoots01","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","tMinX","tMinY","tMaxX","tMaxY","_t","findIntersection","bezier1","bezier2","bezier1Points","_bezier1Points","_bezier1Points$","_bezier1Points$2","_bezier1Points$3","_bezier1Points$4","_bezier1Points2","_bezier1Points2$","_bezier1Points2$2","_bezier1Points2$3","_bezier1Points2$4","splitAt","_bezierPoints3","_bezierPoints3$","_bezierPoints3$2","_bezierPoints3$3","_bezierPoints3$4","t2","t3","s2","s3","part1","part2","../../numerical/functions/gaussian-quadrature.js","../../polynomial/polynomial.js","../../utils.js","5","scale","engulfsCircle","c1","c2","squaredDistanceBetween","dr","δ","prototype","toString","6","7","createSharpCornerCpLoops","sharpCornersArray","contactPointsPerLoop","comparator","ContactPoint","k","sharpCorners","cpLoop","LinkedLoop","prevNode","cp","insert","MatCircle","create","prevOnCircle","nextOnCircle","orient","bezierLoops","orientations","isPathPositivelyOrientated","loops","loop","reverseBeziersOrientation","bezierLoop","bezierArray","getAsArray","idx","reverseBezier","newBezier","createCoupledLoops","pointOnShapeArr","posLoop","getPotential2Prongs","pointsOnShapePerLoop","for2ProngsArray","pointsOnShape","for2Prongs","posNode","head","getInterestingPointsOnShape","allPointsArray","getInterestingPointsOnLoop","allPoints","node","pointsOnShape1","getContactCirclesAtBezierBezierInterface","prev","apply","pointsOnShape2","getBezierOsculatingCircles","firstPoint","lastPoint","splice","atLeast1","_node","standard","getCurvatureAtInterface","tans","cosθ","sinθ","cross","θ","Util","acos","getTotalBy","total","LlRbTree","Shape","bezierArrays","_this","straightUpHash","skip2ProngHash","array","extremes","getExtremes","sort","a_","b_","metrics","getPathMetrics","pointOnShapeArrPerLoop","_getPotential2Prongs","forEachPointOnShape","MatLib","_debug_","generated","dull","dullCorners","INF","extremeBeziers","forEach","boundingBox","j","m","_getPathMetrics","maxXBezierNode","tAtMaxX","_getPathMetrics2","getNeighbouringPoints","cptree","cps","findBounds","data","max","root","bezierCurvature","interfaceCurvature","forAllBeziers","getBoundaryBeziers","bezierPieces","bezierPiece","getBoundaryPieceBeziers","addSkippedBeziers","bezierNode0","bezierNode1","t1","ii","bNode","_bezierPiece2","_bezierPiece3","console","log","cp0","cp1","goStraight","posThis","pointOnShape","posNext","_pos","_bezierPiece","../../geometry/classes/bezier-piece.js","../../geometry/classes/bezier.js","../../geometry/classes/point-on-shape.js","../../linked-loop/linked-loop.js","../../ll-rb-tree//ll-rb-tree.js","../../mat/classes/contact-point.js","../../mat/classes/mat-circle.js","../../svg/svg.js","../functions/get-bezier-osculating-circles.js","../functions/get-contact-circles-at-bezier-bezier-interface.js","8","calcCurvatureExtremaBrackets","brackets","P_1x","P_1y","P_2x","P_2y","P_3x","P_3y","W_0x","W_1x","W_2x","W_0y","W_1y","W_2y","DELTA","atan_numer","atan_denom","atan_numer_squared","atan_denom_squared","radpre","rad","cos_theta","sin_theta","R_1x","R_1y","R_2x","R_2y","R_3x","R_3y","dif","mu","lambda","gamma1","gamma2","sigd_","deReParamBoundary","deReParameterizeBoundary","ssigd_","sda","sdb","clipBoundary","ksi_pre1","ksi_pre2","ksi1","ksi2","bound","b0","b1","deReParameterize","sigma","boundary","../classes/bezier.js","9","calcBezierCurvatureExtremaBrackets","lenb","bracket","_root","lookForRoot","κAtMinsd","κAtMaxsd","_ref","_ref2","minsd","maxsd","c0","brent","../../geometry/classes/circle.js","./calc-bezier-curvature-extrema.js","10","getClosestBoundaryPointToPoint","bezierPieces_","point","touchedBezierNode","cullBezierPieces","bestDistance","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","closestPointOnBezier","return","CULL_THRESHOLD","shortCircuit","bestSquaredDistance","getClosePoint","cullByLooseBoundingBox","cullByTightBoundingBox","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","p1","p2","candidateBezierPieces","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","looseBoundingBox","getClosestSquareDistanceToRect","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","closestSquaredDistanceToRotatedRect","touchedBezier","_p","xp","yp","xx0","xx1","xx2","xx3","yy0","yy1","yy2","yy3","x00","x01","x02","x03","x11","x12","x13","x22","x23","x33","y00","y01","y02","y03","y11","y12","y13","y22","y23","y33","t5","t4","t0","poly","deflatedPoly","deflate","allRoots","allRoots01","filter","push0","push1","ps","closestPoint","getClosestTo","../classes/Point-on-shape.js","../geometry.js","11","bezierNodes","crossTangents","negDot","CROSS_TANGENT_LIMIT","orders","_pos2","DEGREES","0","0.25","15","16","12","getLineShapeIntersectionPoints","line","points","iPoints","getLineBezierIntersectionPoints","tightBoundingBox","squaredDistanceBetweenPointAndLineSegment","_d2","_d3","degAngleFromSinCos","toDeg","PI","atan","arcFrom3Points","midPoint1","mean","midPoint2","chord1","chord2","perpendicular1","perpendicular2","l1","l2","equal","sideVector1","midVector","sideVector2","sinθ1","cosθ1","sinθ2","cosθ2","sin_midangle","cos_midangle","quadrant","isAngle1LargerOrEqual","q1","q2","θ1_larger_θ2","θ_larger_θ2","θ_larger_θ1","line1","line2","_line","_line$","_line$2","p2x","p2y","_line2","_line2$","p3x","p3y","_line2$2","p4x","p4y","v1x","v1y","v2x","v2y","lineThroughPointAtRightAngleTo","p20","p21","lineLength","findCubicRoots01","../memoize.js","../polynomial/polynomial.js","../utils.js","../vector/vector.js","./classes/arc.js","./classes/bezier.js","./classes/circle.js","./classes/point-on-shape.js","./classes/shape.js","13","addAllFromScratch","ListNode","prev_","coupledNode","remove","nodes","getByIndx","linkedLoop","advanceNSteps","../ll-rb-tree/ll-rb-tree.js","./list-node.js","14","Node","red","getMinOrMaxNode","dir","rotate","flipColors","LEFT","RIGHT","moveRedLeft","isRed","moveRedRight","fixUp","getMinNode","getMaxNode","tree","bounds","find","cmp","removeMin","17","smoothen","findMat","toScaleAxis","Mat","getNodesAsArray","Svg","window","assign","fs","./geometry/classes/bezier.js","./geometry/classes/circle.js","./geometry/classes/point-on-shape.js","./geometry/classes/shape.js","./geometry/geometry.js","./linked-loop/linked-loop.js","./ll-rb-tree//ll-rb-tree.js","./mat-constants.js","./mat/classes/contact-point.js","./mat/classes/mat-circle.js","./mat/classes/mat-node.js","./mat/classes/mat.js","./mat/functions/find-mat.js","./mat/functions/get-nodes-as-array.js","./mat/functions/smoothen.js","./mat/functions/to-scale-axis.js","./polynomial/polynomial.js","./svg/svg.js","./utils.js","./vector/vector.js","18","matCircle","19","ThreeProngForDebugging","threeProng","deltas","bestIndx","candidateThreeProngs","deltasSimple","delta","../../../geometry/classes/point-on-shape.js","20","TwoProngForDebugging","z","xs","failed","holeClosing","21","cpNodes","visited","22","MatNode","branches","helper","matNode","priorNode","newPriorNode","newNode","./mat-circle.js","23","startNode","traverse","../../mat/functions/traverse.js","24","add2Prong","pos1","pos2","cp2","delta2","cmp3","cmp4","k2","newCp2Node","delta1","cmp1","cmp2","k1","newCp1Node","posA1","posB2","cpB2","newCpB2Node","posA2","posB1","cpB1","newCpB1Node","prepForDebug","contactPoint","cpKey","cpHash","cpArr","arrIndx","cpHashDebugObj","visitedPointsArr","../../geometry/classes/shape.js","25","add3Prong","delta3s","idxsPrev","idxsNext","26","buildMat","cpNodeStart","fromNode","fromCpNode","isRetry","visitedPoints","traverseShape","findAndAdd3Prong","createMatNode","_matNode","_matNode2","cpBranches","cpNext","bm","prepDebugHashes","cpNode","visitedPoint","continuous","idxi","endP","startP","find3Prong","_i2","nodeHash","../../mat/classes/mat-node.js","./add-3-prong.js","./find-3-prong.js","27","copyMat","mat","../classes/mat.js","28","find2Prong","oCircle","shortestSquaredDistance","pieces","squaredError","iii","SQUARED_1PRONG_TOLERANCE","add1Prong","squaredChordDistance","SQUARED_SEPERATION_TOLERANCE","nextX","findEquidistantPointOnLine","squaredDistance","SQUARED_ERROR_TOLERANCE","MAX_ITERATIONS","recordForDebugging","newCpNode","oneProngs","isNaN","oneProngsAtDullCorner","twoProngForDebugging","twoProngs","rSquared","newPieces","rect","bd","swapAxes","z1","z2","SEPERATION_TOLERANCE","_1PRONG_TOLERANCE","ERROR_TOLERANCE","../../geometry/classes/Point-on-shape.js","../../geometry/functions/get-closest-boundary-point-to-point.js","../../geometry/geometry.js","../classes/debug/two-prong-for-debugging.js","29","δs","bezierPiecess","smallestError","_find3ProngForDelta3s","find3ProngForDelta3s","error","threeProngForDebugging","threeProngs","TOLERANCE","bezierPiece3s","circumCenter","calcInitial3ProngPoint","tolerance","getClosestPoints","vectorToZeroV","calcVectorToZeroV_StraightToIt","upds","calcBetterX","newX","V","newPs","newV","totalAngleError","vv","v1","rotateBy90Degrees","perps","angleError1Pre","angleError2Pre","angleError1","asin","angleError2","angleError","v2","closestDs","closestD","radiusDelta","W1","W2","nu","better","shift","newCircleCenter","newVectorToZeroV","twoProngCircleCenter","point1","meanPoints","isFinite","sames","whichNotSame","../classes/debug/three-prong-for-debugging.js","30","performance","now","findAndAddHoleClosing2Prongs","findAndAdd2ProngsOnAllPaths","add2ProngsDuration","toFixed","ta0","contactPoints","cptest","branchForth","branchBack","ta1","fixMat","twoProngInfo","findAndAdd2Prongs","len","index","indexLinear","firstRight","secondRight","../classes/contact-point.js","./add-2-prong.js","./build-mat.js","./find-2-prong.js","31","./traverse.js","32","getNodesAsHash","33","getLinkedCps","prevCpNodes","currCpNodes","prevCpNode","currCpNode","lines","quads","cubes","currNode","getDirectionToNextMatCircle","isPrev","vDir","spanner","bezierNode2","reverse","toLength","prevMatCircle","prevCc","currMatCircle","currCc","_getLinkedCps","_getLinkedCps2","prevL","currL","mid","twisted","dot1","dot2","lp1","vv1","vvv1","lpp1","mid1","mid2","34","mat_","biggest","biggestNode","createSpacialTree","sat","cullHash","traverseSpacialTree","cullem","cullNodes","cullIt","cullTheNodes","addToTree","coordinate","limits","depth","DEPTH_LIMIT","_calcGroups","calcGroups","groups","newLimits","group","_branch","newCoordinate","Map","branch","set","width","height","getCullNodes","_key","extraParams","size","testNode","cullBranch5","delete","_calcGroups2","_branch4","_branch2","_branch3","satNode","anyNotCull","cullTheNode","cullNode","indexOf","limit","q","w","newLimit","qStart","floor","qEnd","qDiff","lowerLimit","_lowerLimit","otherCoordinate","./copy-mat.js","./get-nodes-as-hash.js","35","36","SUPPORTED","WeakMap","resultsPerF","results","param1","get","37","order_","constants","GAUSS_CONSTANTS","weights","abscissas","_interval","m2","38","cuberoot","rootFilter01","u1","root1","root2","root3","p3","discriminant","mp3","mp33","cosphi","phi","crtr","cos","sd","39","coeff","multiplyByConst","negate","minus","poly1","poly2","multiply","degree","bn","evaluateAt0","signChanges","curSign","newSign","sign","remainder","unshift","pre1","pre2","pre3","pre4","pre5","slice","bs","sturmChain","numRootsWithin","as","newton","initialGuess","dp","val","positiveRootUpperBound","deg","timesUsed","ub","tempub","any","temp","invert","newP","changeVariables","fill","_i3","_i4","_j","acc","positiveRootLowerBound","zeroRoots","p_","numZeros","diff","rootsWithin","intervals","peval","evA","evB","sgn","_q","root1InRange","root2InRange","errorTol","fa","fb","mflag","prevError","fc","fac","fab","fbc","b_c","s_b","c_d","./functions/find-cubic-roots.js","40","svgGetAndSetPathDataPolyFill","SVGPathElement","getPathData","setPathData","applyPolyFill","commandsMap","Z","M","L","C","Q","A","H","S","T","Source","string","_string","_currentIndex","_endIndex","_prevCommand","_skipOptionalSpaces","isIE","navigator","userAgent","parseSegment","char","command","values","cmd","toUpperCase","_parseNumber","_parseArcFlag","hasMoreData","peekSegmentType","initialCommandIsMoveTo","_isCurrentSpace","_skipOptionalSpacesOrDelimiter","exponent","integer","frac","decimal","expsign","startIndex","startIntPartIndex","scanIntPartIndex","multiplier","number","flag","flagChar","symbols","parsePathDataString","source","pathData","pathSeg","setAttribute","removeAttribute","cachedPathData","cachedNormalizedPathData","arcToCubicCurves","r1","r2","angle","largeArcFlag","sweepFlag","_recursive","f1","f2","cx","cy","degToRad","degrees","angleRad","X","sin","Y","params","r1Pow","r2Pow","left","right","df","f2old","x2old","y2old","s1","hx","hy","m3","m4","concat","join","split","curves","curveParams","param","clonePathData","seg","absolutizePathData","absolutizedPathData","currentX","currentY","subpathX","subpathY","reducePathData","reducedPathData","lastType","lastControlX","lastControlY","cx1","cy1","cx2","cy2","curve","name","options","normalize","getAttribute","normalizedPathData","41","isAlmostZeroLength","isCloseToOrigin","manhattanLength","getBeziersFromSvgElem","elem","pushBezier","bezierPoints_","manhattanDistanceBetween","SHIFT","interpolate","MUST_START_WITH_M","INVALID_COMMAND","paths","pathStarted","prev2ndCubicControlPoint","prev2ndQuadraticControlPoint","initialPoint","path","vals","addX","addY","toLowerCase","prevType","_xInterval","_yInterval","_xInterval2","_yInterval2","_xInterval3","_yInterval3","QP0","QP1","QP2","CP0","CP3","CP1","CP2","_x","_y","_QP","_QP2","_QP3","_CP","_CP2","_CP3","_CP4","xInterval","yInterval","getPathStrFromBezierLoop","DEC","isFirst","prevPoint","str","../geometry/classes/bezier.js","../geometry/geometry.js","../linked-loop/linked-loop.js","./path-data-polyfill/path-data-polyfill.js","42","SLIGHTLY","43","det3","squaredNorm","factor","scaleFactor","lengthSquared","distanceBetweenPointAndLine","y2_y1","x2_x1","numerator","denominator","triangle","Sx","Sy","inCenter","l3","lengthSum","centroid","polygon","p0","_p2","_p3","reverseRotate","rotateByNeg90Degrees","distanceFunc","bestd","translatePoints","rotatePoints","trans"],"mappings":"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","file":"mat-lib.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Vector = require('../../vector/vector.js');\nvar Memoize = require('../../memoize.js');\n\nvar Bezier = require('./bezier.js');\nvar Circle = require('./circle.js');\n\n/** \r\n * @constructor \t\n * \t\n * @param p {number[]} - The point coordinates.\n * @param {ListNode<Bezier>} bezierNode\t\n * @param t\r\n * @param type {MAT_CONSTANTS.pointType} \t\n *  'standard' : 0, // Not special,   \t\n *  'sharp'    : 1, // Sharp corner, \t\n *  'dull'     : 2, // dull corner, \t\n * @param {Number} order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.   \r\n * @param {Number} order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately. \r\n * @param {Circle} circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\nfunction PointOnShape(bezierNode, t, type, order, order2) {\n\n\tthis.bezierNode = bezierNode;\n\tthis.t = t;\n\tthis.type = type;\n\tthis.order = order;\n\tthis.order2 = order2;\n\n\t//---- Cache\n\tvar p = Bezier.evaluate(bezierNode.item)(t);\n\tthis.p = p;\n\t// Removing this cache will help in that if {PointOnShape} is \n\t// called as a parameter (where a point is required) it will more \n\t// likely result in monomorphic behaviour as opposed to polymorphic \n\t// or megamorphic.\n\tthis[0] = p[0];\n\tthis[1] = p[1];\n}\n\nPointOnShape.getOsculatingCircle = Memoize.m1(function (pos) {\n\tif (pos.type === MAT_CONSTANTS.pointType.sharp) {\n\t\treturn new Circle(pos.p, 0);\n\t} else if (pos.type === MAT_CONSTANTS.pointType.extreme) {\n\t\tvar r = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t\tvar p = [pos.p[0], pos.p[1] - r];\n\t\treturn new Circle(p, r);\n\t}\n\treturn calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n\n/**\r\n * @description Calculates the osculating circle of the bezier at a \r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param bezier\r\n * @param t\r\n * @returns {Circle}\r\n */\nfunction calcOsculatingCircle(bezier, t) {\n\tvar κ = -Bezier.κ(bezier)(t);\n\n\t// If (κ > 0) { Bending inwards. }\n\n\tvar radius = void 0;\n\tif (κ <= 1 / MAT_CONSTANTS.maxOsculatingCircleRadius) {\n\t\t// Curving wrong way (or flat, or too big), but probably a \n\t\t// significant point to put a 2-prong.\n\t\tradius = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t} else {\n\t\tradius = Math.min(1 / κ, MAT_CONSTANTS.maxOsculatingCircleRadius);\n\t}\n\n\tvar normal = Bezier.normal(bezier)(t);\n\tvar p = Bezier.evaluate(bezier)(t);\n\tvar circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n\n\treturn new Circle(circleCenter, radius);\n}\n\n/**\r\n * @description Compares two PointOnShapes according to its position on\r\n * the bezier loop.\r\n */\nPointOnShape.compare = function (a, b) {\n\tif (a === undefined || b === undefined) {\n\t\treturn undefined;\n\t}\n\n\tvar res = void 0;\n\n\tres = a.bezierNode.item.indx - b.bezierNode.item.indx;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.t - b.t;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.order - b.order;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.order2 - b.order2;\n\n\treturn res;\n};\n\n/**\r\n * @description Returns true if its osculation circle is pointing \r\n * straight upwards. \r\n */\nPointOnShape.isPointingStraightUp = function (pos) {\n\tvar circle = PointOnShape.getOsculatingCircle(pos);\n\tif (!circle) {\n\t\treturn false;\n\t}\n\n\tvar circleDirection = Vector.toUnitVector(Vector.fromTo(pos, circle.center));\n\n\t// If not almost pointing straight up\n\tif (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nfunction dullCornerAt(shape, p) {\n\tvar dullCornerHash = shape.dullCornerHash;\n\tvar key = PointOnShape.makeSimpleKey(p);\n\n\treturn dullCornerHash[key] || null;\n}\n\n/**\r\n * @description Sets the order (to distinguish between points lying on top of each \r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n\n\tvar dullCorner = dullCornerAt(shape, pos);\n\n\tif (!dullCorner) {\n\t\treturn;\n\t}\n\n\tvar bezier = dullCorner.beziers[0];\n\tvar tan1pre = Bezier.tangent(bezier)(1);\n\n\tvar tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n\tvar tan2 = Vector.toUnitVector(Vector.fromTo(pos, circle.center));\n\n\tpos.order = -Vector.dot(tan1, tan2);\n\n\treturn pos.order;\n};\n\n/**\r\n * @description Clones the PointOnShape.\r\n */\nPointOnShape.copy = function (pos) {\n\treturn new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n};\n\n/**\r\n * @description Creates a string key that only depends on the \r\n * PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n\treturn '' + p[0] + ', ' + p[1];\n};\n\n/**\r\n * @description Returns the PointOnShape type as a human-readable \r\n * string.\r\n * @param type\r\n * @returns\r\n */\nfunction typeToStr(type) {\n\tfor (var key in MAT_CONSTANTS.pointType) {\n\t\tif (MAT_CONSTANTS.pointType[key] === type) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n\treturn '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + typeToStr(pos.type);\n};\n\nmodule.exports = PointOnShape;\n\n},{\"../../mat-constants.js\":16,\"../../memoize.js\":36,\"../../vector/vector.js\":43,\"./bezier.js\":4,\"./circle.js\":5}],2:[function(require,module,exports){\n'use strict';\n\n/* \r\n * Standard arc class.\r\n * \r\n * If circle === null then the arc degenerates into a line segment \r\n * given by sinAngle1 and cosAngle2 which now represent points.\r\n * \r\n * The arc curve is always defined as the piece from angle1 -> angle2.\r\n * \r\n * Note: startpoint and endpoint is redundant \r\n */\n\nvar Arc = function Arc(circle, sinAngle1, cosAngle1, sinAngle2, cosAngle2, startpoint, endpoint) {\n\n\t// Intrinsic\n\tthis.circle = circle;\n\tthis.sinAngle1 = sinAngle1;\n\tthis.sinAngle2 = sinAngle2;\n\tthis.cosAngle1 = cosAngle1;\n\tthis.cosAngle2 = cosAngle2;\n\n\t// Cache\n\tthis.startpoint = startpoint; // Redundant but useful\n\tthis.endpoint = endpoint; // Redundant but useful\n};\n\n/** \r\n * Returns the closest point on the arc.\r\n * \r\n * @returns { p: number[], position: number } where position is either \r\n * 0, 1 or 2 indicating if the closest point is at either endpoint \r\n * (1 or 2) or interior to the arc (0). \r\n * \r\n * NOTE: Not currently used. \r\n */\nArc.closestPointOnArc = function (p, arc) {\n\tif (arc.circle !== null) {\n\t\t// else the arc is degenerate into a line\n\t\t// First move arc circle onto origin\n\t\tvar x = arc.circle.center[0];\n\t\tvar y = arc.circle.center[1];\n\n\t\tvar arco = new Arc(new Circle([0, 0], arc.circle.radius), Vector.translate(arc.startpoint, [-x, -y]), Vector.translate(arc.endpoint, [-x, -y]), arc.sinAngle1, arc.cosAngle1, arc.sinAngle2, arc.cosAngle2);\n\n\t\tvar pp = Vector.translate(p, [-x, -y]);\n\t\tvar l = Vector.length(pp);\n\t\tvar sin_pp = -pp[1] / l;\n\t\tvar cos_pp = pp[0] / l;\n\n\t\tif (Geometry.isAngleBetween(sin_pp, cos_pp, arco.sinAngle1, arco.cosAngle1, arco.sinAngle2, arco.cosAngle2)) {\n\t\t\tvar r_o_l = arco.circle.radius;\n\t\t\tvar res = { p: Vector.translate([r_o_l * cos_pp, r_o_l * -sin_pp], [x, y]), position: 0 };\n\n\t\t\treturn res;\n\t\t} else {\n\t\t\tvar asp = arc.startpoint;\n\t\t\tvar aep = arc.endpoint;\n\n\t\t\tvar d1 = Vector.distanceBetween(asp, p);\n\t\t\tvar d2 = Vector.distanceBetween(aep, p);\n\n\t\t\tif (d1 < d2) {\n\t\t\t\treturn { p: asp, position: 1 };\n\t\t\t}\n\n\t\t\treturn { p: aep, position: 2 };\n\t\t}\n\t}\n\n\t// Line degenerate case - this is exactly a routine for \n\t// distance (and closest point) between point and line segment.\n\tvar asp = arc.startpoint;\n\tvar aep = arc.endpoint;\n\n\tvar d1 = Vector.distanceBetween(asp, p);\n\tvar d2 = Vector.distanceBetween(aep, p);\n\tvar ds = Math.sqrt(Vector.distanceBetweenPointAndLineSegment(p, [asp, aep]));\n\n\tif (d1 <= d2 && d1 <= ds) {\n\t\treturn { p: asp, position: 1 };\n\t} else if (d2 <= d1 && d2 <= ds) {\n\t\treturn { p: aep, position: 2 };\n\t}\n\n\t// else ds is shortest\n\tvar v = Vector.fromTo(asp, aep);\n\n\tvar l1p2 = [p[0] + v[1], p[1] + -v[0]];\n\tvar res = {\n\t\tp: Geometry.lineLineIntersection([p, l1p2], [asp, aep]),\n\t\tposition: 0\n\t};\n\n\treturn res;\n};\n\nmodule.exports = Arc;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/**\r\n * @constructor\r\n * @param bezierNode\r\n * @param tRange\r\n * @returns\r\n */\n\nfunction BezierPiece(bezierNode, tRange) {\n  this.bezierNode = bezierNode;\n  this.tRange = tRange;\n}\n\nmodule.exports = BezierPiece;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Util = require('../../utils.js');\nvar Poly = require('../../polynomial/polynomial.js');\nvar Vector = require('../../vector/vector.js');\nvar Memoize = require('../../memoize.js');\n\nvar gaussQuadrature = require('../../numerical/functions/gaussian-quadrature.js');\n\n/**\r\n * Representation of a 3rd degree (i.e. cubic) bezier, possibly in the \r\n * context of a shape.\r\n * \r\n * @param bezierPoints\r\n * @param indx\r\n * @returns\r\n */\nfunction Bezier(bezierPoints, indx) {\n\n\tthis.indx = indx;\n\tthis.bezierPoints = bezierPoints;\n\n\t//---- Bernstein basis representation\n\n\tvar _bezierPoints = _slicedToArray(bezierPoints, 4),\n\t    _bezierPoints$ = _slicedToArray(_bezierPoints[0], 2),\n\t    x0 = _bezierPoints$[0],\n\t    y0 = _bezierPoints$[1],\n\t    _bezierPoints$2 = _slicedToArray(_bezierPoints[1], 2),\n\t    x1 = _bezierPoints$2[0],\n\t    y1 = _bezierPoints$2[1],\n\t    _bezierPoints$3 = _slicedToArray(_bezierPoints[2], 2),\n\t    x2 = _bezierPoints$3[0],\n\t    y2 = _bezierPoints$3[1],\n\t    _bezierPoints$4 = _slicedToArray(_bezierPoints[3], 2),\n\t    x3 = _bezierPoints$4[0],\n\t    y3 = _bezierPoints$4[1];\n\n\t//---- Power basis representation\n\n\n\tthis.x = [x3 - 3 * x2 + 3 * x1 - x0, // t^3\n\t3 * x2 - 6 * x1 + 3 * x0, // t^2\n\t3 * x1 - 3 * x0, // t^1\n\tx0];\n\tthis.y = [y3 - 3 * y2 + 3 * y1 - y0, // t^3\n\t3 * y2 - 6 * y1 + 3 * y0, // t^2\n\t3 * y1 - 3 * y0, // t^1\n\ty0];\n\n\tthis.dx = Poly.differentiate(this.x); // Polynomial in t\n\tthis.dy = Poly.differentiate(this.y); // ...\n\tthis.ddx = Poly.differentiate(this.dx); // ...\n\tthis.ddy = Poly.differentiate(this.dy); // ...\n\tthis.dddx = Poly.differentiate(this.ddx); // ...\n\tthis.dddy = Poly.differentiate(this.ddy); // ...\n}\n\n/** \r\n * @description Evaluates the bezier parametric equation at t. \r\n * @param t {Number} - The point where the evaluation should take place. \r\n * \r\n * @returns {Number[]}\r\n **/\nBezier.evaluate = Memoize.m1(function (bezier) {\n\tvar _bezier$bezierPoints = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints$ = _slicedToArray(_bezier$bezierPoints[0], 2),\n\t    x0 = _bezier$bezierPoints$[0],\n\t    y0 = _bezier$bezierPoints$[1],\n\t    _bezier$bezierPoints$2 = _slicedToArray(_bezier$bezierPoints[1], 2),\n\t    x1 = _bezier$bezierPoints$2[0],\n\t    y1 = _bezier$bezierPoints$2[1],\n\t    _bezier$bezierPoints$3 = _slicedToArray(_bezier$bezierPoints[2], 2),\n\t    x2 = _bezier$bezierPoints$3[0],\n\t    y2 = _bezier$bezierPoints$3[1],\n\t    _bezier$bezierPoints$4 = _slicedToArray(_bezier$bezierPoints[3], 2),\n\t    x3 = _bezier$bezierPoints$4[0],\n\t    y3 = _bezier$bezierPoints$4[1];\n\n\treturn function (t) {\n\t\tif (t === 0) {\n\t\t\treturn [x0, y0];\n\t\t} else if (t === 1) {\n\t\t\treturn [x3, y3];\n\t\t}\n\n\t\treturn [Bezier.evaluateX(bezier)(t), Bezier.evaluateY(bezier)(t)];\n\t};\n});\n\n/**\r\n * @descrpiption Returns the curvature, κ, at a specific t. \r\n */\nBezier.κ = Memoize.m1(function (bezier) {\n\treturn function (t) {\n\t\tvar dx = Bezier.evaluateDx(bezier)(t);\n\t\tvar dy = Bezier.evaluateDy(bezier)(t);\n\t\tvar ddx = Bezier.evaluateDdx(bezier)(t);\n\t\tvar ddy = Bezier.evaluateDdy(bezier)(t);\n\n\t\tvar numer = dx * ddy - dy * ddx;\n\t\tvar d = dx * dx + dy * dy;\n\t\tvar denom = Math.sqrt(d * d * d);\n\t\treturn numer / denom;\n\t};\n});\n\n/**\r\n *\r\n */\nvar κTimesSDiff = Memoize.m1(function (bezier) {\n\treturn function (t) {\n\t\tvar dx = Bezier.evaluateDx(bezier)(t);\n\t\tvar dy = Bezier.evaluateDy(bezier)(t);\n\t\tvar ddx = Bezier.evaluateDdx(bezier)(t);\n\t\tvar ddy = Bezier.evaluateDdy(bezier)(t);\n\n\t\tvar numer = dx * ddy - dy * ddx;\n\t\tvar denom = dx * dx + dy * dy;\n\n\t\treturn numer / denom;\n\t};\n});\n\n/** \r\n * @description A modified version of differential of κ (use quotient \r\n * rule, ignore denominator and multiply by 2/3). We need to find the \r\n * zeros of this function to get the min/max curvature.\r\n * \r\n * NOTE: Math is from http://math.info/Calculus/Curvature_Parametric/\r\n**/\nBezier.dκ = Memoize.m1(function (bezier) {\n\tvar _bezier$bezierPoints2 = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints3 = _slicedToArray(_bezier$bezierPoints2[0], 2),\n\t    x0 = _bezier$bezierPoints3[0],\n\t    y0 = _bezier$bezierPoints3[1],\n\t    _bezier$bezierPoints4 = _slicedToArray(_bezier$bezierPoints2[1], 2),\n\t    x1 = _bezier$bezierPoints4[0],\n\t    y1 = _bezier$bezierPoints4[1],\n\t    _bezier$bezierPoints5 = _slicedToArray(_bezier$bezierPoints2[2], 2),\n\t    x2 = _bezier$bezierPoints5[0],\n\t    y2 = _bezier$bezierPoints5[1],\n\t    _bezier$bezierPoints6 = _slicedToArray(_bezier$bezierPoints2[3], 2),\n\t    x3 = _bezier$bezierPoints6[0],\n\t    y3 = _bezier$bezierPoints6[1];\n\n\treturn function (t) {\n\n\t\tvar ts = t * t;\n\t\tvar omt = 1 - t;\n\n\t\tvar a = ts * x3;\n\t\tvar i = ts * y3;\n\t\tvar b = 2 * t - 3 * ts;\n\t\tvar c = (3 * t - 1) * omt;\n\t\tvar d = omt * omt;\n\t\tvar e = 3 * (a + b * x2 - c * x1 - d * x0);\n\t\tvar f = 3 * (i + b * y2 - c * y1 - d * y0);\n\t\tvar g = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n\t\tvar h = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n\n\t\treturn 4 * (e * (y3 - 3 * y2 + 3 * y1 - y0) - f * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(f * f + e * e, 3 / 2) - (e * g - h * f) * (2 * g * f + 2 * h * e) * Math.sqrt(f * f + e * e);\n\t};\n});\n\n/**\r\n * @description Returns the tangent of the bezier at a specific t.\r\n */\nBezier.tangent = Memoize.m1(function (bezier) {\n\treturn function (t) {\n\t\tvar dx = Bezier.evaluateDx(bezier)(t);\n\t\tvar dy = Bezier.evaluateDy(bezier)(t);\n\t\tvar d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn [dx / d, dy / d];\n\t};\n});\n\n/**\r\n * @description Returns the normal of the bezier at a specific t.\r\n */\nBezier.normal = Memoize.m1(function (bezier) {\n\treturn function (t) {\n\t\tvar tan = Bezier.tangent(bezier)(t);\n\t\treturn [tan[1], -tan[0]];\n\t};\n});\n\n/**\r\n * @description Returns the total curvature of the bezier in [0,1].\r\n */\nBezier.getTotalCurvature = Memoize.m1(function (bezier) {\n\treturn gaussQuadrature(κTimesSDiff(bezier), [0, 1]);\n});\n\n/**\r\n * @description Returns the total absolute curvature of the bezier.\r\n * @param {Number[]} interval_\r\n * @returns The result in radians.\r\n */\nBezier.getTotalAbsoluteCurvature = Memoize.m1(function (bezier) {\n\tvar totalAbsoluteCurvature = {}; // Lookup cache\n\n\treturn function (interval_) {\n\t\tvar interval = interval_ || [0, 1];\n\n\t\tvar key = '' + interval[0] + ', ' + interval[1];\n\t\tif (totalAbsoluteCurvature[key]) {\n\t\t\treturn totalAbsoluteCurvature[key];\n\t\t}\n\n\t\t// Numerically integrate the absolute curvature\n\t\tvar result = gaussQuadrature(function (t) {\n\t\t\treturn Math.abs(κTimesSDiff(bezier)(t));\n\t\t}, interval);\n\t\ttotalAbsoluteCurvature[key] = result;\n\n\t\treturn result;\n\t};\n});\n\n/**\r\n * @descrpiption Returns the total curve length.\r\n */\nBezier.getCurveLength = Memoize.m1(function (bezier) {\n\treturn gaussQuadrature(Bezier.ds(bezier), [0, 1]);\n});\n\n/**\r\n * @descrpiption Returns the differential of length at t.\r\n */\nBezier.ds = Memoize.m1(function (bezier) {\n\treturn function (t) {\n\t\tvar dx = Bezier.evaluateDx(bezier)(t);\n\t\tvar dy = Bezier.evaluateDy(bezier)(t);\n\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t};\n});\n\nBezier.evaluateX = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.x);\n});\nBezier.evaluateY = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.y);\n});\nBezier.evaluateDx = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.dx);\n});\nBezier.evaluateDy = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.dy);\n});\nBezier.evaluateDdx = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.ddx);\n});\nBezier.evaluateDdy = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.ddy);\n});\nBezier.evaluateDddx = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.dddx);\n});\nBezier.evaluateDddy = Memoize.m1(function (bezier) {\n\treturn Poly.evaluate(bezier.dddy);\n});\n\n/**\r\n * @description Returns the bounding box of the normalized (i.e. first\r\n * point moved to origin and rotated so that last point lies on x-axis)\r\n * bezier.\r\n * @param {Number[][]} bezierPoints\r\n * @param {Number} sinAngle - Sine of angle made by line from first \r\n * bezier point to last with x-axis.\r\n * @param {Number} cosAngle - Cosine of angle made by line from first \r\n * bezier point to last with x-axis.\r\n * @returns {Number[][]} Bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\nfunction getNormalizedBoundingBox(bezierPoints, sinAngle, cosAngle) {\n\tvar vectorToOrigin = Vector.transform(bezierPoints[0], function (x) {\n\t\treturn -x;\n\t});\n\n\tvar normalizedBezier = new Bezier(Vector.translateThenRotatePoints(bezierPoints, vectorToOrigin, -sinAngle, cosAngle));\n\n\treturn Bezier.getBoundingBox(normalizedBezier);\n}\n\n/**\r\n * @description Returns tight bounding box of bezier.\r\n * @returns {Number[][]} The tight bounding box of the bezier as four\r\n * points of a rotated rectangle.\r\n */\nBezier.getBoundingBoxTight = Memoize.m1(function (bezier) {\n\tvar bezierPoints = bezier.bezierPoints;\n\n\tvar _bezierPoints2 = _slicedToArray(bezierPoints, 4),\n\t    _bezierPoints2$ = _slicedToArray(_bezierPoints2[0], 2),\n\t    x0 = _bezierPoints2$[0],\n\t    y0 = _bezierPoints2$[1],\n\t    _bezierPoints2$2 = _slicedToArray(_bezierPoints2[1], 2),\n\t    x1 = _bezierPoints2$2[0],\n\t    y1 = _bezierPoints2$2[1],\n\t    _bezierPoints2$3 = _slicedToArray(_bezierPoints2[2], 2),\n\t    x2 = _bezierPoints2$3[0],\n\t    y2 = _bezierPoints2$3[1],\n\t    _bezierPoints2$4 = _slicedToArray(_bezierPoints2[3], 2),\n\t    x3 = _bezierPoints2$4[0],\n\t    y3 = _bezierPoints2$4[1];\n\n\tvar straightLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n\tvar sinAngle = (y3 - y0) / straightLength;\n\tvar cosAngle = (x3 - x0) / straightLength;\n\n\tvar box = getNormalizedBoundingBox(bezierPoints, sinAngle, cosAngle);\n\n\tvar p0x = box[0][0];\n\tvar p0y = box[0][1];\n\tvar p1x = box[1][0];\n\tvar p1y = box[1][1];\n\n\tvar axisAlignedBox = [box[0], [p1x, p0y], box[1], [p0x, p1y]];\n\n\treturn Vector.rotateThenTranslatePoints(axisAlignedBox, bezierPoints[0], sinAngle, cosAngle);\n});\n\n/**\r\n * @description Returns general bezier bounds.\r\n * @returns The axis-aligned bounding box together with the t values\r\n * where the bounds on the bezier are reached.\r\n */\nBezier.getBounds = Memoize.m1(function (bezier) {\n\n\t// Roots of derivative\n\tvar roots = [bezier.dx, bezier.dy].map(Poly.findQuadraticRoots01);\n\n\t// Endpoints\n\troots[0].push(0, 1);\n\troots[1].push(0, 1);\n\n\tvar minX = Number.POSITIVE_INFINITY;\n\tvar maxX = Number.NEGATIVE_INFINITY;\n\tvar minY = Number.POSITIVE_INFINITY;\n\tvar maxY = Number.NEGATIVE_INFINITY;\n\n\tvar tMinX = undefined;\n\tvar tMinY = undefined;\n\tvar tMaxX = undefined;\n\tvar tMaxY = undefined;\n\n\t// Test points\n\tfor (var i = 0; i < roots[0].length; i++) {\n\t\tvar t = roots[0][i];\n\t\tvar x = Bezier.evaluateX(bezier)(t);\n\t\tif (x < minX) {\n\t\t\tminX = x;tMinX = t;\n\t\t}\n\t\tif (x > maxX) {\n\t\t\tmaxX = x;tMaxX = t;\n\t\t}\n\t}\n\tfor (var _i = 0; _i < roots[1].length; _i++) {\n\t\tvar _t = roots[1][_i];\n\t\tvar y = Bezier.evaluateY(bezier)(_t);\n\t\tif (y < minY) {\n\t\t\tminY = y;tMinY = _t;\n\t\t}\n\t\tif (y > maxY) {\n\t\t\tmaxY = y;tMaxY = _t;\n\t\t}\n\t}\n\n\tvar ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n\tvar box = [[minX, minY], [maxX, maxY]];\n\n\treturn { ts: ts, box: box };\n});\n\n/**\r\n * @description Returns the axis-aligned bounding box of a given bezier.\r\n * @returns {Number[][]} the axis-aligned bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\nBezier.getBoundingBox = Memoize.m1(function (bezier) {\n\treturn Bezier.getBounds(bezier).box;\n});\n\n/**\r\n * @description Find the intersection points of the two beziers.\r\n * @returns {Number[][]} A list of points.\r\n */\nBezier.findIntersection = function (bezier1, bezier2) {\n\tvar bezier1Points = bezier1.bezierPoints;\n\tvar bezier2Points = bezier2.bezierPoints;\n\n\tvar _bezier1Points = _slicedToArray(bezier1Points, 4),\n\t    _bezier1Points$ = _slicedToArray(_bezier1Points[0], 2),\n\t    x10 = _bezier1Points$[0],\n\t    y10 = _bezier1Points$[1],\n\t    _bezier1Points$2 = _slicedToArray(_bezier1Points[1], 2),\n\t    x11 = _bezier1Points$2[0],\n\t    y11 = _bezier1Points$2[1],\n\t    _bezier1Points$3 = _slicedToArray(_bezier1Points[2], 2),\n\t    x12 = _bezier1Points$3[0],\n\t    y12 = _bezier1Points$3[1],\n\t    _bezier1Points$4 = _slicedToArray(_bezier1Points[3], 2),\n\t    x13 = _bezier1Points$4[0],\n\t    y13 = _bezier1Points$4[1];\n\n\tvar _bezier1Points2 = _slicedToArray(bezier1Points, 4),\n\t    _bezier1Points2$ = _slicedToArray(_bezier1Points2[0], 2),\n\t    x20 = _bezier1Points2$[0],\n\t    y20 = _bezier1Points2$[1],\n\t    _bezier1Points2$2 = _slicedToArray(_bezier1Points2[1], 2),\n\t    x21 = _bezier1Points2$2[0],\n\t    y21 = _bezier1Points2$2[1],\n\t    _bezier1Points2$3 = _slicedToArray(_bezier1Points2[2], 2),\n\t    x22 = _bezier1Points2$3[0],\n\t    y22 = _bezier1Points2$3[1],\n\t    _bezier1Points2$4 = _slicedToArray(_bezier1Points2[3], 2),\n\t    x23 = _bezier1Points2$4[0],\n\t    y23 = _bezier1Points2$4[1];\n\n\t// TODO - finish\n\n};\n\n/**\r\n * Reterns 2 new beziers split at t, i.e. for the ranges \r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm. \r\n */\nBezier.splitAt = function (bezier, t) {\n\tvar bezierPoints = bezier.bezierPoints;\n\n\tvar _bezierPoints3 = _slicedToArray(bezierPoints, 4),\n\t    _bezierPoints3$ = _slicedToArray(_bezierPoints3[0], 2),\n\t    x0 = _bezierPoints3$[0],\n\t    y0 = _bezierPoints3$[1],\n\t    _bezierPoints3$2 = _slicedToArray(_bezierPoints3[1], 2),\n\t    x1 = _bezierPoints3$2[0],\n\t    y1 = _bezierPoints3$2[1],\n\t    _bezierPoints3$3 = _slicedToArray(_bezierPoints3[2], 2),\n\t    x2 = _bezierPoints3$3[0],\n\t    y2 = _bezierPoints3$3[1],\n\t    _bezierPoints3$4 = _slicedToArray(_bezierPoints3[3], 2),\n\t    x3 = _bezierPoints3$4[0],\n\t    y3 = _bezierPoints3$4[1];\n\n\tvar s = 1 - t;\n\tvar t2 = t * t;\n\tvar t3 = t2 * t;\n\tvar s2 = s * s;\n\tvar s3 = s2 * s;\n\n\tvar part1 = [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n\n\tvar part2 = [part1[3], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n\n\treturn [new Bezier(part1), new Bezier(part2)];\n};\n\nmodule.exports = Bezier;\n\n},{\"../../memoize.js\":36,\"../../numerical/functions/gaussian-quadrature.js\":37,\"../../polynomial/polynomial.js\":39,\"../../utils.js\":42,\"../../vector/vector.js\":43}],5:[function(require,module,exports){\n'use strict';\n\nvar Vector = require('../../vector/vector.js');\n\n/** \r\n * @constructor\r\n * Basic circle class. \r\n */\nfunction Circle(center, radius) {\n  this.center = center;\n  this.radius = radius;\n}\n\n/**\r\n * @description Returns a scaled version of the given circle without\r\n * changing its center position.\r\n * @returns {Circle} The scaled circle.\r\n */\nCircle.scale = function (circle, s) {\n  return new Circle(circle.center, circle.radius * s);\n};\n\n/** \r\n * @returns {boolean} true if the first circle engulfs the second.\r\n */\nCircle.engulfsCircle = function (c1, c2) {\n  if (c1.radius <= c2.radius) {\n    return false;\n  }\n\n  var d = Vector.squaredDistanceBetween(c1.center, c2.center);\n  var dr = c1.radius - c2.radius;\n  var δ = dr * dr;\n\n  return δ > d;\n};\n\n/**\r\n * @description Returns a human-readable string description.\r\n * @note For debugging only.\r\n */\nCircle.prototype.toString = function () {\n  return 'c: ' + this.center + ' radius: ' + this.radius;\n};\n\nmodule.exports = Circle;\n\n},{\"../../vector/vector.js\":43}],6:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Vector = require('../../vector/vector.js');\nvar Memoize = require('../../memoize.js');\n\nvar Bezier = require('./bezier.js');\nvar Circle = require('./circle.js');\n\n/** \r\n * @constructor \t\n * \t\n * @param p {number[]} - The point coordinates.\n * @param {ListNode<Bezier>} bezierNode\t\n * @param t\r\n * @param type {MAT_CONSTANTS.pointType} \t\n *  'standard' : 0, // Not special,   \t\n *  'sharp'    : 1, // Sharp corner, \t\n *  'dull'     : 2, // dull corner, \t\n * @param {Number} order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates and t values.   \r\n * @param {Number} order2 - For points of hole closing 2-prongs only;\r\n *\t\t  these points are duplicated to split the shape so they need\r\n *        to be ordered appropriately. \r\n * @param {Circle} circle - The osculating circle at this point pointing\r\n * towards the inside of the shape.\r\n */\nfunction PointOnShape(bezierNode, t, type, order, order2) {\n\n\tthis.bezierNode = bezierNode;\n\tthis.t = t;\n\tthis.type = type;\n\tthis.order = order;\n\tthis.order2 = order2;\n\n\t//---- Cache\n\tvar p = Bezier.evaluate(bezierNode.item)(t);\n\tthis.p = p;\n\t// Removing this cache will help in that if {PointOnShape} is \n\t// called as a parameter (where a point is required) it will more \n\t// likely result in monomorphic behaviour as opposed to polymorphic \n\t// or megamorphic.\n\tthis[0] = p[0];\n\tthis[1] = p[1];\n}\n\nPointOnShape.getOsculatingCircle = Memoize.m1(function (pos) {\n\tif (pos.type === MAT_CONSTANTS.pointType.sharp) {\n\t\treturn new Circle(pos.p, 0);\n\t} else if (pos.type === MAT_CONSTANTS.pointType.extreme) {\n\t\tvar r = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t\tvar p = [pos.p[0], pos.p[1] - r];\n\t\treturn new Circle(p, r);\n\t}\n\treturn calcOsculatingCircle(pos.bezierNode.item, pos.t);\n});\n\n/**\r\n * @description Calculates the osculating circle of the bezier at a \r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param bezier\r\n * @param t\r\n * @returns {Circle}\r\n */\nfunction calcOsculatingCircle(bezier, t) {\n\tvar κ = -Bezier.κ(bezier)(t);\n\n\t// If (κ > 0) { Bending inwards. }\n\n\tvar radius = void 0;\n\tif (κ <= 1 / MAT_CONSTANTS.maxOsculatingCircleRadius) {\n\t\t// Curving wrong way (or flat, or too big), but probably a \n\t\t// significant point to put a 2-prong.\n\t\tradius = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t} else {\n\t\tradius = Math.min(1 / κ, MAT_CONSTANTS.maxOsculatingCircleRadius);\n\t}\n\n\tvar normal = Bezier.normal(bezier)(t);\n\tvar p = Bezier.evaluate(bezier)(t);\n\tvar circleCenter = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n\n\treturn new Circle(circleCenter, radius);\n}\n\n/**\r\n * @description Compares two PointOnShapes according to its position on\r\n * the bezier loop.\r\n */\nPointOnShape.compare = function (a, b) {\n\tif (a === undefined || b === undefined) {\n\t\treturn undefined;\n\t}\n\n\tvar res = void 0;\n\n\tres = a.bezierNode.item.indx - b.bezierNode.item.indx;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.t - b.t;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.order - b.order;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.order2 - b.order2;\n\n\treturn res;\n};\n\n/**\r\n * @description Returns true if its osculation circle is pointing \r\n * straight upwards. \r\n */\nPointOnShape.isPointingStraightUp = function (pos) {\n\tvar circle = PointOnShape.getOsculatingCircle(pos);\n\tif (!circle) {\n\t\treturn false;\n\t}\n\n\tvar circleDirection = Vector.toUnitVector(Vector.fromTo(pos, circle.center));\n\n\t// If not almost pointing straight up\n\tif (Math.abs(circleDirection[0]) > 1e-6 || circleDirection[1] > 0) {\n\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nfunction dullCornerAt(shape, p) {\n\tvar dullCornerHash = shape.dullCornerHash;\n\tvar key = PointOnShape.makeSimpleKey(p);\n\n\treturn dullCornerHash[key] || null;\n}\n\n/**\r\n * @description Sets the order (to distinguish between points lying on top of each \r\n * other) of the contact point if it is a dull corner.\r\n * @param {PointOnShape} pos\r\n * @note Modifies pos\r\n */\nPointOnShape.setPointOrder = function (shape, circle, pos) {\n\n\tvar dullCorner = dullCornerAt(shape, pos);\n\n\tif (!dullCorner) {\n\t\treturn;\n\t}\n\n\tvar bezier = dullCorner.beziers[0];\n\tvar tan1pre = Bezier.tangent(bezier)(1);\n\n\tvar tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n\tvar tan2 = Vector.toUnitVector(Vector.fromTo(pos, circle.center));\n\n\tpos.order = -Vector.dot(tan1, tan2);\n\n\treturn pos.order;\n};\n\n/**\r\n * @description Clones the PointOnShape.\r\n */\nPointOnShape.copy = function (pos) {\n\treturn new PointOnShape(pos.bezierNode, pos.t, pos.type, pos.order, pos.order2);\n};\n\n/**\r\n * @description Creates a string key that only depends on the \r\n * PointOnShape's coordinates.\r\n */\nPointOnShape.makeSimpleKey = function (p) {\n\treturn '' + p[0] + ', ' + p[1];\n};\n\n/**\r\n * @description Returns the PointOnShape type as a human-readable \r\n * string.\r\n * @param type\r\n * @returns\r\n */\nfunction typeToStr(type) {\n\tfor (var key in MAT_CONSTANTS.pointType) {\n\t\tif (MAT_CONSTANTS.pointType[key] === type) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\n/**\r\n * @description Returns a human-readable string of the PointOnShape.\r\n * @note For debugging only.\r\n */\nPointOnShape.toHumanString = function (pos) {\n\treturn '' + pos[0] + ', ' + pos[1] + ' | bz: ' + pos.bezierNode.item.indx + ' | t: ' + pos.t + ' | ord: ' + pos.order + ' | ord2: ' + pos.order2 + ' | ' + typeToStr(pos.type);\n};\n\nmodule.exports = PointOnShape;\n\n},{\"../../mat-constants.js\":16,\"../../memoize.js\":36,\"../../vector/vector.js\":43,\"./bezier.js\":4,\"./circle.js\":5}],7:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Util = require('../../utils.js');\nvar Poly = require('../../polynomial/polynomial.js');\nvar Vector = require('../../vector/vector.js');\nvar Memoize = require('../../memoize.js');\n\nvar LlRbTree = require('../../ll-rb-tree//ll-rb-tree.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar Bezier = require('../../geometry/classes/bezier.js');\nvar BezierPiece = require('../../geometry/classes/bezier-piece.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Svg = require('../../svg/svg.js');\nvar MatCircle = require('../../mat/classes/mat-circle.js');\n\nvar getContactCirclesAtBezierBezierInterface = require('../functions/get-contact-circles-at-bezier-bezier-interface.js');\nvar getBezierOsculatingCircles = require('../functions/get-bezier-osculating-circles.js');\n\n/** \r\n * A Shape represents the loop of individual bezier curves composing \r\n * an SVG element. When constructed, some initial analysis is done. \r\n * \r\n * @constructor  \r\n */\nvar Shape = function Shape(bezierArrays) {\n\tvar _this = this;\n\n\t// Hash of PointOnShapes that has a normal pointing straight up. \n\tthis.straightUpHash = {};\n\t// Hash of 2-prongs that need to be skipped in 2-prong procedure\n\t// since we already have a hole-closing 2-prong there.\n\tthis.skip2ProngHash = {};\n\t// A hash of all the dull corners (i.e. those with angle > 180 deg)\n\tthis.dullCornerHash = {};\n\n\t// The shape paths and sub-paths, a.k.a bezier loops.\n\tvar bezierLoops = bezierArrays.map(function (array, k) {\n\t\treturn new LinkedLoop(array, undefined, k);\n\t});\n\n\t// Orient the loops so that the outer loop is oriented positively - \n\t// defined as anti-clockwise.  \n\tthis.bezierLoops = orient(bezierLoops);\n\n\tthis.extremes = this.bezierLoops.map(getExtremes);\n\n\t// This is to find the topmost points on each loop.\n\tthis.extremes.sort(function (a, b) {\n\t\treturn a.p[1] - b.p[1];\n\t});\n\tthis.bezierLoops.sort(function (a_, b_) {\n\t\tvar a = getExtremes(a_);\n\t\tvar b = getExtremes(b_);\n\n\t\treturn a.p[1] - b.p[1];\n\t});\n\t// Re-index after ordering.\n\tfor (var i = 0; i < this.bezierLoops.length; i++) {\n\t\tthis.bezierLoops[i].indx = i;\n\t}\n\n\t// Get metrics of the outer loop.\n\tthis.metrics = getPathMetrics(bezierLoops[0]);\n\n\t// Gets interesting points on the shape, i.e. those that makes \n\t// sense to use for the 2-prong procedure.\n\tvar pointOnShapeArrPerLoop = getInterestingPointsOnShape(this);\n\n\tthis.pointsOnShapePerLoop = pointOnShapeArrPerLoop.map(function (array, i) {\n\t\treturn createCoupledLoops(array, i);\n\t});\n\n\t// TODO Finish implementation. This is to space the points more\n\t// evenly. \n\t//respacePoints(this.contactPointsPerLoop, 30);\n\n\tvar _getPotential2Prongs = getPotential2Prongs(this),\n\t    sharpCornersArray = _getPotential2Prongs.sharpCornersArray,\n\t    for2ProngsArray = _getPotential2Prongs.for2ProngsArray;\n\n\tthis.for2ProngsArray = for2ProngsArray;\n\n\t// Take account of sharp and dull corners for debugging and update \n\t// straightUpHash.\n\tShape.forEachPointOnShape(this, function (pos) {\n\t\tif (pos.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\tif (MatLib._debug_) {\n\t\t\t\tMatLib._debug_.generated.sharpCorners.push({ pos: pos });\n\t\t\t}\n\t\t} else {\n\t\t\tif (PointOnShape.isPointingStraightUp(pos)) {\n\t\t\t\tvar key = PointOnShape.makeSimpleKey(pos);\n\t\t\t\t_this.straightUpHash[key] = pos;\n\t\t\t}\n\n\t\t\tif (MatLib._debug_) {\n\t\t\t\tif (pos.type === MAT_CONSTANTS.pointType.dull) {\n\t\t\t\t\tMatLib._debug_.generated.dullCorners.push({ pos: pos });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tthis.contactPointsPerLoop = createSharpCornerCpLoops(this, sharpCornersArray);\n};\n\n/**\r\n * @description Creates the initial ContactPoint loops from the given\r\n * sharp corners.\r\n * @param {Shape} shape\r\n * @param {PointOnShape[][]} sharpCornersArray\r\n * @returns\r\n */\nfunction createSharpCornerCpLoops(shape, sharpCornersArray) {\n\tvar contactPointsPerLoop = [];\n\tvar comparator = function comparator(a, b) {\n\t\treturn ContactPoint.compare(a.item, b.item);\n\t};\n\tfor (var k = 0; k < sharpCornersArray.length; k++) {\n\t\tvar sharpCorners = sharpCornersArray[k];\n\t\tvar cpLoop = new LinkedLoop([], comparator, k);\n\n\t\tvar prevNode = undefined;\n\t\tfor (var i = 0; i < sharpCorners.length; i++) {\n\t\t\tvar pos = sharpCorners[i];\n\n\t\t\tvar cp = new ContactPoint(pos, undefined);\n\t\t\tprevNode = LinkedLoop.insert(cpLoop, cp, prevNode);\n\n\t\t\tvar mCircle = MatCircle.create(PointOnShape.getOsculatingCircle(pos), [prevNode]);\n\t\t\tprevNode.prevOnCircle = prevNode; // Trivial loop\n\t\t\tprevNode.nextOnCircle = prevNode; // ...\n\t\t}\n\n\t\tcontactPointsPerLoop.push(cpLoop);\n\t}\n\n\treturn contactPointsPerLoop;\n}\n\n/**\r\n * @description Orient the bezier loops so that the outermost loop is\r\n * positively oriented (i.e. counter-clockwise).\r\n * @modifies bezierLoops\r\n */\nfunction orient(bezierLoops) {\n\tvar orientations = bezierLoops.map(isPathPositivelyOrientated);\n\n\tif (!orientations[0]) {\n\t\treturn bezierLoops;\n\t} else {\n\t\tvar loops = bezierLoops.map(function (loop, k) {\n\t\t\treturn reverseBeziersOrientation(loop, k);\n\t\t});\n\n\t\treturn loops;\n\t}\n}\n\n/**\r\n * Completely reverse the loop direction of the given bezier loop.\r\n * @param bezierLoop\r\n * @param k\r\n * @returns The reversed loop.\r\n */\nfunction reverseBeziersOrientation(bezierLoop, k) {\n\tvar beziers = [];\n\n\tvar bezierArray = LinkedLoop.getAsArray(bezierLoop);\n\n\tvar idx = 0;\n\tfor (var i = bezierArray.length - 1; i >= 0; i--) {\n\t\tvar bezier = reverseBezier(bezierArray[i], idx);\n\t\tidx++;\n\n\t\tbeziers.push(bezier);\n\t}\n\n\treturn new LinkedLoop(beziers, undefined, k);\n}\n\n/**\r\n * @description Reverse the given bezier and assign the new given idx.\r\n * @param bezier\r\n * @param idx\r\n * @returns The freshly reversed bezier.\r\n */\nfunction reverseBezier(bezier, idx) {\n\tvar bezierPoints = [];\n\tfor (var i = 3; i >= 0; i--) {\n\t\tbezierPoints.push(bezier.bezierPoints[i]);\n\t}\n\tvar newBezier = new Bezier(bezierPoints, idx);\n\n\treturn newBezier;\n}\n\n/**\r\n * @description Get the path metrics, i.e. the top, left, bottom and \r\n * right extremes of the bezer loop, together with the bezier nodes \r\n * they belong to. If an extreme is at a bezier-bezier interface the\r\n * first bezier will always be utilized (at t=1).\r\n */\nvar getPathMetrics = Memoize.m1(function (bezierLoop) {\n\n\tvar INF = Number.POSITIVE_INFINITY;\n\n\tvar metrics = [[INF, INF], [-INF, -INF]];\n\tvar extremeBeziers = [[undefined, undefined], [undefined, undefined]];\n\n\tLinkedLoop.forEach(bezierLoop, function (bezierNode) {\n\t\tvar bezier = bezierNode.item;\n\t\tvar boundingBox = Bezier.getBoundingBox(bezier);\n\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tfor (var j = 0; j < 2; j++) {\n\t\t\t\tvar v = boundingBox[i][j];\n\t\t\t\tvar m = i === 0 ? 1 : -1;\n\t\t\t\tif (m * v < m * metrics[i][j]) {\n\t\t\t\t\tmetrics[i][j] = v;\n\t\t\t\t\textremeBeziers[i][j] = bezierNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn { metrics: metrics, extremeBeziers: extremeBeziers };\n});\n\n/**\r\n * @description Checks if a shape is positively orientated or not. \r\n */\nvar isPathPositivelyOrientated = function isPathPositivelyOrientated(bezierLoop) {\n\tvar _getPathMetrics = getPathMetrics(bezierLoop),\n\t    extremeBeziers = _getPathMetrics.extremeBeziers;\n\n\tvar maxXBezierNode = extremeBeziers[1][0];\n\n\tvar ts = Bezier.getBounds(maxXBezierNode.item).ts;\n\tvar tAtMaxX = ts[1][0];\n\n\tvar tan1 = Bezier.tangent(maxXBezierNode.item)(tAtMaxX);\n\tif (tAtMaxX !== 1) {\n\t\treturn tan1[1] > 0;\n\t}\n\n\tvar tan2 = Bezier.tangent(maxXBezierNode.next.item)(0);\n\n\tif (tan1[1] * tan2[1] > 0) {\n\t\t// Both tangents points up or both points down.\n\t\treturn tan1[1] > 0;\n\t}\n\n\t// One tangent points up and the other down.\n\treturn Vector.cross(tan1, tan2) > 0;\n\n\t// We don't check for the very special case where the cross === 0. \n};\n\n/**\r\n * @description Get topmost point, bezierNode and t-value of the given\r\n * loop.\r\n */\nvar getExtremes = Memoize.m1(function (bezierLoop) {\n\tvar _getPathMetrics2 = getPathMetrics(bezierLoop),\n\t    extremeBeziers = _getPathMetrics2.extremeBeziers;\n\n\tvar bezierNode = extremeBeziers[0][1]; // Bezier at minimum y\n\tvar ts = Bezier.getBounds(bezierNode.item).ts;\n\tvar t = ts[0][1];\n\tvar p = Bezier.evaluate(bezierNode.item)(t);\n\n\treturn { p: p, bezierNode: bezierNode, t: t };\n});\n\n/**\r\n * Given a circle, bound it tightly by an axes-aligned box (i.e. circle \r\n * box). And given a bezier, bound tightly by a rectangle (not \r\n * necessarily axes aligned) (i.e. bezier box).\r\n *  \r\n * @returns {boolean} true if bezier box is entirely outside circle box.\r\n *  \r\n */\nfunction isBezierBoxWhollyOutsideCircleBox(bezier, circle) {\n\n\t//---- Cache\n\tvar r = circle.radius;\n\tvar ox = circle.center[0];\n\tvar oy = circle.center[1];\n\tvar radius_2 = r * r;\n\n\t//---- Translate bezier tight bounding box (4 point rectangle) so that circle center is at origin. \n\tvar boxTight = Vector.translatePoints(Bezier.getBoundingBoxTight(bezier), [-ox, -oy]);\n\n\t//---- Rotate circle and rectangle together so that box rectangle is aligned with axes.\n\tvar boxDiagonal = Vector.fromTo(boxTight[0], boxTight[1]);\n\tvar l = Vector.length(boxDiagonal);\n\tvar sinAngle = boxDiagonal[1] / l;\n\tvar cosAngle = boxDiagonal[0] / l;\n\tvar b0 = Vector.rotate(boxTight[0], sinAngle, -cosAngle);\n\tvar b1 = Vector.rotate(boxTight[2], sinAngle, -cosAngle);\n\n\tvar anyBoxVerticalInside = b0[0] > -r && b0[0] < r || b1[0] > -r && b1[0] < r;\n\tvar boxVerticalsCapture = b0[0] < -r && b1[0] > r || b1[0] < -r && b0[0] > r;\n\n\tvar anyBoxHorizontalInside = b0[1] > -r && b0[1] < r || b1[1] > -r && b1[1] < r;\n\tvar boxHorizontalsCapture = b0[1] < -r && b1[1] > r || b1[1] < -r && b0[1] > r;\n\tif (anyBoxVerticalInside && (anyBoxHorizontalInside || boxHorizontalsCapture) || anyBoxHorizontalInside && (anyBoxVerticalInside || boxVerticalsCapture) || boxVerticalsCapture && boxHorizontalsCapture) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\r\n * TODO - finish implementation - the function below with the same name\r\n * is temporary.\r\n * @description\r\n * @param contactPointArr\r\n * @returns\r\n */ /*\r\n    function createCoupledLoops(contactPointArr, k) {\r\n    \tlet comparator = (a,b) => ContactPoint.compare(a.item, b.item); \r\n    let cpLoop = new LinkedLoop([], comparator, k);\r\n    \tlet denseContactPoints = new LinkedLoop([], undefined, k);\r\n    \tlet prevCpNode = undefined;\r\n    let prevCoupledCpNode = undefined;\r\n    for (let i=0; i<contactPointArr.length; i++) {\r\n    let cp = contactPointArr[i];\r\n    let pos = cp.pointOnShape;\r\n    \n    prevCoupledCpNode = LinkedLoop.insert(\r\n    \tdenseContactPoints, cp, prevCoupledCpNode\r\n    );\r\n    // TODO !!!!\r\n    /*\r\n    if (pos.type === MAT_CONSTANTS.pointType.dull) {\r\n    if (Util.acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n    \tprevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n    }\r\n    } else if (pos.type === MAT_CONSTANTS.pointType.sharp) {\r\n    if (Util.acos(1-pos.sharpness) * 180 / Math.PI > 16) {\r\n    \tprevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\r\n    }\r\n    } else {*/ /*\r\n               prevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\t\r\n               //}\r\n               prevCoupledCpNode.coupledNode = prevCpNode; \r\n               }\r\n               return cpLoop;\r\n               }*/\nfunction createCoupledLoops(pointOnShapeArr, k) {\n\n\tvar posLoop = new LinkedLoop([], undefined, k);\n\n\tvar prevNode = undefined;\n\tfor (var i = 0; i < pointOnShapeArr.length; i++) {\n\t\tvar pos = pointOnShapeArr[i];\n\n\t\tprevNode = LinkedLoop.insert(posLoop, pos, prevNode, undefined);\n\t}\n\n\treturn posLoop;\n}\n\n/**\r\n * @description Applies f to each PointOnShape within the shape\r\n * @param {function(PointOnShape)} f - Function to call. \r\n */\nShape.forEachPointOnShape = function (shape, f) {\n\tvar pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n\n\tfor (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n\t\tvar pointsOnShape = pointsOnShapePerLoop[k];\n\n\t\tvar posNode = pointsOnShape.head;\n\t\tdo {\n\t\t\tvar pos = posNode.item;\n\t\t\tf(pos);\n\n\t\t\tposNode = posNode.next;\n\t\t} while (posNode !== pointsOnShape.head);\n\t}\n};\n\n/**\r\n * @description .\r\n * @param shape\r\n * @returns\r\n */\nfunction getPotential2Prongs(shape) {\n\n\tvar pointsOnShapePerLoop = shape.pointsOnShapePerLoop;\n\n\tvar sharpCornersArray = [];\n\tvar for2ProngsArray = [];\n\n\tfor (var k = 0; k < pointsOnShapePerLoop.length; k++) {\n\t\tvar pointsOnShape = pointsOnShapePerLoop[k];\n\n\t\tvar sharpCorners = [];\n\t\tvar for2Prongs = [];\n\n\t\tvar posNode = pointsOnShape.head;\n\t\tdo {\n\t\t\tvar pos = posNode.item;\n\n\t\t\tif (pos.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\t\tsharpCorners.push(pos);\n\t\t\t} else {\n\t\t\t\tfor2Prongs.push(posNode);\n\t\t\t}\n\n\t\t\tposNode = posNode.next;\n\t\t} while (posNode !== pointsOnShape.head);\n\n\t\tsharpCornersArray.push(sharpCorners);\n\t\tfor2ProngsArray.push(for2Prongs);\n\t}\n\n\treturn { sharpCornersArray: sharpCornersArray, for2ProngsArray: for2ProngsArray };\n}\n\n/**\r\n * TODO - finish implementation\r\n * Respace points so that the total absolute curvature between\r\n * consecutive points are very roughly equal. \r\n * \r\n * @param {LinkedLoop<ContactPoint>[]} contactPointsPerLoop\r\n * @returns undefined\r\n * \r\n * NOTES: Mutates contactPoints.\r\n */\nfunction respacePoints(contactPointsPerLoop, maxAbsCurvatureInDegrees) {\n\n\tfor (var k = 0; k < contactPointsPerLoop.length; k++) {\n\t\tvar contactPoints = contactPointsPerLoop[k];\n\n\t\tvar cpNode = contactPoints.head;\n\t\tvar recheck = void 0;\n\t\tdo {\n\t\t\trecheck = false;\n\n\t\t\tvar totalCurvatures = [];\n\t\t\tvar denseCpNode = cpNode.coupledNode;\n\n\t\t\tdo {\n\t\t\t\tvar c = getTotalAbsCurvatureBetweenCps([denseCpNode.item, denseCpNode.next.item]);\n\n\t\t\t\ttotalCurvatures.push({ cpNode: denseCpNode, c: c });\n\n\t\t\t\tdenseCpNode = denseCpNode.next;\n\t\t\t} while (denseCpNode.coupledNode !== cpNode.next);\n\n\t\t\tvar totalCurvature = sumCurvatures(totalCurvatures);\n\n\t\t\tcpNode.totalCurvatures = totalCurvatures;\n\t\t\tcpNode.totalCurvature = totalCurvature;\n\n\t\t\tvar totalInDegrees = totalCurvature * 180 / Math.PI;\n\t\t\t// if (totalInDegrees > 180 || totalInDegrees < 5) { console.log(totalInDegrees); }\n\t\t\tif (totalInDegrees > maxAbsCurvatureInDegrees) {\n\t\t\t\t// Add a point\n\t\t\t\t//console.log(totalCurvatures);\n\n\t\t\t\tvar accumTot = 0;\n\t\t\t\tvar tc = cpNode.totalCurvature; // cache\n\t\t\t\tvar bestIndx = undefined;\n\t\t\t\tvar leftDenseIndx = 0;\n\t\t\t\tvar rightDenseIndx = void 0;\n\t\t\t\tvar accumTotAtLeft = 0;\n\t\t\t\tvar accumTotAtRight = undefined;\n\t\t\t\tvar bestDiff = Number.POSITIVE_INFINITY;\n\t\t\t\tfor (var i = 0; i < totalCurvatures.length; i++) {\n\n\t\t\t\t\tvar _c = totalCurvatures[i].c;\n\t\t\t\t\tvar cTot = _c.totalCurvature + _c.totalTurn;\n\t\t\t\t\taccumTot += cTot;\n\n\t\t\t\t\tvar cpn = totalCurvatures[i].cpNode;\n\t\t\t\t\tif (accumTot <= tc / 2) {\n\t\t\t\t\t\tleftDenseIndx = i;\n\t\t\t\t\t\taccumTotAtLeft = accumTot;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!rightDenseIndx && accumTot > tc / 2) {\n\t\t\t\t\t\t// This may be out of bounds but really means cpNode.next\n\t\t\t\t\t\trightDenseIndx = i;\n\t\t\t\t\t\taccumTotAtRight = accumTot;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar absDiff = Math.abs(tc / 2 - accumTot);\n\t\t\t\t\t// TODO - We can also add a weight for point values here\n\t\t\t\t\t// such that for instance inverse curvature points \n\t\t\t\t\t// carry more weight than dull corners, etc.\n\t\t\t\t\t// TODO Make the 1/4 or 1/3 below a constant that can\n\t\t\t\t\t// be set.\n\t\t\t\t\t//if (accumTot > tc/3 && accumTot < 2*tc/3 &&\n\t\t\t\t\tif (accumTot > tc / 4 && accumTot < 3 * tc / 4 && bestDiff > absDiff) {\n\t\t\t\t\t\t// If within middle 1/3 and better\n\n\t\t\t\t\t\tbestIndx = i;\n\t\t\t\t\t\tbestDiff = absDiff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// aaa console.log(leftDenseIndx, bestIndx, rightDenseIndx);\n\n\t\t\t\tif (bestIndx !== undefined) {\n\t\t\t\t\t// Reify the point\n\t\t\t\t\tvar tcInfo = totalCurvatures[bestIndx];\n\n\t\t\t\t\t// Note that after the below insert cpNode.next will\n\t\t\t\t\t// equal the newly inserted cpNode.\n\t\t\t\t\tvar newCpNode = LinkedLoop.insert(contactPoints, tcInfo.cpNode.next.item, cpNode, tcInfo.cpNode.next);\n\t\t\t\t\ttcInfo.cpNode.next.coupledNode = newCpNode;\n\n\t\t\t\t\tcpNode.totalCurvatures = cpNode.totalCurvatures.slice(0, bestIndx + 1);\n\t\t\t\t\tcpNode.totalCurvature = sumCurvatures(cpNode.totalCurvatures);\n\n\t\t\t\t\trecheck = true; // Start again from same contact point.\n\t\t\t\t} else {\n\t\t\t\t\t// We could not find an 'interesting' point to use, so\n\t\t\t\t\t// find some center point between the two contact \n\t\t\t\t\t// points.\n\n\n\t\t\t\t\tvar leftTcInfo = totalCurvatures[leftDenseIndx];\n\t\t\t\t\tvar rightTcInfo = totalCurvatures[rightDenseIndx];\n\n\t\t\t\t\tvar leftCpNode = leftTcInfo.cpNode;\n\t\t\t\t\tvar rightCpNode = rightTcInfo.cpNode;\n\n\t\t\t\t\tvar leftC = leftTcInfo.c;\n\n\t\t\t\t\tvar leftCp = leftTcInfo.cpNode.next;\n\t\t\t\t\tvar rightCp = rightTcInfo.cpNode.next;\n\n\t\t\t\t\t//aaa console.log(accumTotAtLeft,\taccumTotAtRight, tc/2);\n\n\n\t\t\t\t\tvar pos = getCPointBetweenCps(leftCpNode.item, rightCpNode.item, accumTotAtLeft, accumTotAtRight, tc / 2);\n\n\t\t\t\t\t/*\r\n     let newCp = new ContactPoint(pos, undefined);\r\n     let newCpNode = LinkedLoop.insert(\r\n     \t\tcontactPoints, \r\n     \t\tnewCp, \r\n     \t\tleftCpNode,\r\n     \t\tundefined\r\n     );\r\n     \r\n     let newDenseCpNode = LinkedLoop.insert(\r\n     \t\tdenseContactPoints, \r\n     \t\tnewCp, \r\n     \t\tcpNode,\r\n     \t\tundefined\r\n     );\r\n     \r\n     newCpNode.coupledNode = newDenseCpNode;\r\n     newDenseCpNode.coupledNode = newCpNode;\r\n     \r\n     \r\n     aaa\r\n     cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n     \t\t0, bestIndx\r\n     );\r\n     cpNode.totalCurvature = sumCurvatures(\r\n     \t\tcpNode.totalCurvatures\r\n     );\r\n     \r\n     recheck = true; // Start again from same contact point.\r\n     */\n\t\t\t\t}\n\t\t\t} else if (totalInDegrees < 15) {\n\t\t\t\t// Remove a point\n\t\t\t\t//console.log(totalCurvatures);\n\n\t\t\t}\n\n\t\t\tif (!recheck) {\n\t\t\t\tcpNode = cpNode.next;\n\t\t\t}\n\t\t} while (cpNode !== contactPoints.head);\n\t}\n}\n\n/**\r\n * Finds a point on the shape between the given contact points which\r\n * is as close as possible to a point with accumalated abs curvature\r\n * (from accumAtLeft) equal to totAtMid.\r\n *  \r\n * @param leftCp\r\n * @param rightCp\r\n * @param accumTotAtLeft\r\n * @param accumTotAtRight\r\n * @param totAtMid\r\n * @returns {PointOnShape}\r\n */\nfunction getCPointBetweenCps(leftCp, rightCp, accumTotAtLeft, accumTotAtRight, totAtMid) {\n\n\tvar accumTo = totAtMid - accumTotAtLeft;\n\n\tvar posStart = leftCp.pointOnShape;\n\tvar posEnd = rightCp.pointOnShape;\n\n\tvar bezierNodeStart = posStart.bezierNode;\n\tvar bezierNodeEnd = posEnd.bezierNode;\n\n\tvar bezierNode = bezierNodeStart;\n\n\tvar totalTurn = 0;\n\tvar totalCurvature = 0;\n\tdo {\n\t\tvar turn = void 0;\n\t\tif (bezierNode !== bezierNodeEnd) {\n\t\t\tturn = Math.abs(getCurvatureAtInterface(bezierNode));\n\t\t} else {\n\t\t\tturn = 0;\n\t\t}\n\n\t\tvar curvature = void 0;\n\t\tvar interval = [0, 1];\n\t\tif (bezierNode === bezierNodeStart) {\n\t\t\tinterval[0] = posStart.t;\n\t\t}\n\t\tif (bezierNode === bezierNodeEnd) {\n\t\t\tinterval[1] = posEnd.t;\n\t\t}\n\t\tcurvature = Bezier.getTotalAbsoluteCurvature(bezierNode.item)(interval);\n\n\t\ttotalTurn += turn;\n\t\ttotalCurvature += curvature;\n\n\t\tvar totalBoth = totalTurn + totalCurvature;\n\t\tif (totalBoth >= accumTo) {\n\t\t\t// aaa console.log('accumTo: ' + accumTo, 'totalBoth: ' + totalBoth);\n\t\t\tbreak;\n\t\t}\n\n\t\tbezierNode = bezierNode.next;\n\t} while (bezierNode.prev !== bezierNodeEnd);\n\n\t//return { totalTurn, totalCurvature };\n}\n\nfunction sumCurvatures(curvatures) {\n\tvar total = 0;\n\n\tfor (var i = 0; i < curvatures.length; i++) {\n\t\tvar c = curvatures[i].c;\n\n\t\ttotal += c.totalTurn + c.totalCurvature;\n\t}\n\n\treturn total;\n}\n\n/**\r\n * \r\n * @param cps\r\n * @returns\r\n */\nfunction getTotalAbsCurvatureBetweenCps(_ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2),\n\t    cpStart = _ref2[0],\n\t    cpEnd = _ref2[1];\n\n\tvar posStart = cpStart.pointOnShape;\n\tvar posEnd = cpEnd.pointOnShape;\n\n\tvar bezierNodeStart = posStart.bezierNode;\n\tvar bezierNodeEnd = posEnd.bezierNode;\n\n\tvar bezierNode = bezierNodeStart;\n\n\tvar totalTurn = 0;\n\tvar totalCurvature = 0;\n\tdo {\n\t\tvar turn = void 0;\n\t\tif (bezierNode !== bezierNodeEnd) {\n\t\t\tturn = Math.abs(getCurvatureAtInterface(bezierNode));\n\t\t} else {\n\t\t\tturn = 0;\n\t\t}\n\n\t\tvar curvature = void 0;\n\t\tvar interval = [0, 1];\n\t\tif (bezierNode === bezierNodeStart) {\n\t\t\tinterval[0] = posStart.t;\n\t\t}\n\t\tif (bezierNode === bezierNodeEnd) {\n\t\t\tinterval[1] = posEnd.t;\n\t\t}\n\t\tcurvature = Bezier.getTotalAbsoluteCurvature(bezierNode.item)(interval);\n\n\t\ttotalTurn += turn;\n\t\ttotalCurvature += curvature;\n\n\t\tbezierNode = bezierNode.next;\n\t} while (bezierNode.prev !== bezierNodeEnd);\n\n\treturn { totalTurn: totalTurn, totalCurvature: totalCurvature };\n}\n\n/**\r\n * @description Get useful points on the shape - these incude osculating\r\n * points and points at the bezier-bezier interfaces.  \r\n * @param {Shape} shape\r\n * @returns {[{pointOnShape}]} - A list of interesting points on the \r\n * \t\t\tshape.\r\n */\nfunction getInterestingPointsOnShape(shape) {\n\tvar bezierLoops = shape.bezierLoops;\n\tvar allPointsArray = [];\n\n\tfor (var k = 0; k < bezierLoops.length; k++) {\n\t\tvar bezierLoop = bezierLoops[k];\n\n\t\tallPointsArray.push(getInterestingPointsOnLoop(shape, bezierLoop));\n\t}\n\n\treturn allPointsArray;\n}\n\nfunction getInterestingPointsOnLoop(shape, bezierLoop) {\n\tvar dullCornerHash = shape.dullCornerHash;\n\n\tvar points = [];\n\tvar allPoints = [];\n\n\tvar node = bezierLoop.head;\n\tdo {\n\t\tvar bezier = node.item;\n\n\t\tvar pointsOnShape1 = getContactCirclesAtBezierBezierInterface([node.prev, node], dullCornerHash);\n\t\tArray.prototype.push.apply(allPoints, pointsOnShape1);\n\n\t\tvar pointsOnShape2 = getBezierOsculatingCircles(node);\n\t\tArray.prototype.push.apply(allPoints, pointsOnShape2);\n\n\t\tnode = node.next;\n\t} while (node !== bezierLoop.head);\n\n\t// Ensure order - first point may be ordered last at this stage\n\t// (due to bezier-bezier interface checking)\n\tvar firstPoint = allPoints[0];\n\tvar lastPoint = allPoints[allPoints.length - 1];\n\tif (PointOnShape.compare(firstPoint, lastPoint) > 0) {\n\t\tallPoints.push(firstPoint); // Add the first point to the end\n\t\tallPoints.splice(0, 1); // ... and remove the front point.\n\t}\n\n\t// Check if at least one 2-prong has been added. If not, add one.\n\tvar atLeast1 = false;\n\tfor (var i = 0; i < allPoints.length; i++) {\n\t\tif (allPoints[i].type !== MAT_CONSTANTS.pointType.sharp) {\n\t\t\tatLeast1 = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bezierLoop.indx === 0 && !atLeast1) {\n\t\t// Not a single potential 2-prong found on envelope. Add one \n\t\t// to make the algorithm simpler from here on.\n\t\tvar _node = bezierLoop.head;\n\n\t\tvar pos = new PointOnShape(_node, 0.4999995, // Can really be anything in the range (0,1)\n\t\tMAT_CONSTANTS.pointType.standard, 0, 0);\n\n\t\tallPoints.push(pos);\n\t}\n\n\treturn allPoints;\n}\n\n/**\r\n * Returns the boundary piece that starts at the \r\n * immediate previous point on the shape and ends at \r\n * the immediate next point.  \r\n * \r\n * Notes:\r\n *   - Uses a red-black tree to quickly find the required bounds\r\n */\nShape.getNeighbouringPoints = function (shape, pos) {\n\tvar k = pos.bezierNode.loop.indx;\n\tvar cptree = shape.contactPointsPerLoop[k].cptree;\n\n\tvar cps = LlRbTree.findBounds(cptree, { item: new ContactPoint(pos) });\n\n\tif (cps === null) {\n\t\t// The tree is still empty\n\t\treturn [undefined, undefined];\n\t}\n\n\tif (!cps[0]) {\n\t\t// Smaller than all -> cptree.min() === cps[1].data\n\t\treturn [LlRbTree.max(cptree.root), LlRbTree.min(cptree.root)];\n\t}\n\tif (!cps[1]) {\n\t\t// Larger than all -> cptree.max() === cps[0].data\n\t\treturn [LlRbTree.max(cptree.root), LlRbTree.min(cptree.root)];\n\t}\n\n\treturn [cps[0].data, cps[1].data];\n};\n\n/**\r\n * @description\r\n * @param bezierNode\r\n * @returns\r\n */\nfunction getCurvatureAtInterface(bezierNode) {\n\tvar ts = [1, 0];\n\n\tvar beziers = [];\n\n\tbeziers.push(bezierNode.item);\n\tbeziers.push(bezierNode.next.item);\n\tvar tans = [Bezier.tangent(beziers[0])(1), Bezier.tangent(beziers[1])(0)];\n\n\t// The integral of a kind of Dirac Delta function.\n\tvar cosθ = Vector.dot(tans[0], tans[1]);\n\tvar sinθ = Vector.cross(tans[0], tans[1]);\n\tvar θ = Util.acos(cosθ);\n\n\tvar result = sinθ >= 0 ? θ : -θ;\n\n\treturn result;\n}\n\n/**\r\n * @description Helper function.\r\n * @param f\r\n * @returns\r\n */\nfunction getTotalBy(f) {\n\n\treturn function (bezierLoop) {\n\t\tvar node = bezierLoop.head;\n\t\tvar total = 0;\n\t\tdo {\n\t\t\ttotal += f(node);\n\n\t\t\tnode = node.next;\n\t\t} while (node !== bezierLoop.head);\n\n\t\treturn total;\n\t};\n}\n\n/**\r\n * \r\n */\nShape.getTotalCurvature = getTotalBy(function (bezierNode) {\n\tvar bezierCurvature = Bezier.getTotalCurvature(bezierNode.item);\n\tvar interfaceCurvature = getCurvatureAtInterface(bezierNode);\n\n\treturn bezierCurvature + interfaceCurvature;\n});\n\n/**\r\n * \r\n */\nShape.getTotalAbsoluteCurvature = getTotalBy(function (bezierNode) {\n\treturn Bezier.getTotalAbsoluteCurvature(bezierNode.item)() + Math.abs(getCurvatureAtInterface(bezierNode));\n});\n\n/**\r\n * \r\n */\nShape.forAllBeziers = function (f, shape) {\n\tvar bezierLoops = shape.bezierLoops;\n\n\tfor (var i = 0; i < bezierLoops.length; i++) {\n\t\tvar bezierLoop = bezierLoops[i];\n\n\t\tvar node = bezierLoop.head;\n\t\tdo {\n\t\t\tvar bezier = node.item;\n\n\t\t\tf(bezier);\n\n\t\t\tnode = node.next;\n\t\t} while (node !== bezierLoop.head);\n\t}\n};\n\n/**\r\n * @description\r\n */\nShape.getBoundaryBeziers = function (shape, k) {\n\tvar bezierLoop = shape.bezierLoops[k];\n\tvar bezierPieces = [];\n\n\tLinkedLoop.forEach(bezierLoop, function (bezierNode) {\n\t\tvar bezierPiece = new BezierPiece(bezierNode, [0, 1]);\n\n\t\tbezierPieces.push(bezierPiece);\n\t});\n\n\treturn bezierPieces;\n};\n\n/**\r\n * @description\r\n */\nShape.getBoundaryPieceBeziers = function (δ) {\n\n\tvar cp0 = δ[0];\n\tvar cp1 = δ[1];\n\n\tvar bezierPieces = [];\n\n\t// As opposed to going around the circle and taking the last exit\n\tvar goStraight = true;\n\tdo {\n\t\tif (goStraight) {\n\t\t\tgoStraight = false;\n\n\t\t\tvar posThis = cp0.item.pointOnShape;\n\t\t\tvar posNext = cp0.next.item.pointOnShape;\n\n\t\t\tif (posNext.bezierNode === posThis.bezierNode && (posNext.t > posThis.t || posNext.t === posThis.t && posNext.order > posThis.order)) {\n\n\t\t\t\tvar pos = cp0.item.pointOnShape;\n\t\t\t\tvar bezierPiece = new BezierPiece(pos.bezierNode, [pos.t, posNext.t]);\n\t\t\t\tbezierPieces.push(bezierPiece);\n\t\t\t\t//MatLib._debug_.draw.bezierPiece(bezierPiece, 'nofill thin50 red');\t\n\t\t\t} else {\n\t\t\t\tvar _pos = cp0.item.pointOnShape;\n\t\t\t\tvar _bezierPiece = new BezierPiece(_pos.bezierNode, [_pos.t, 1]);\n\t\t\t\tbezierPieces.push(_bezierPiece);\n\t\t\t\t//MatLib._debug_.draw.bezierPiece(bezierPiece, 'nofill thin50 blue');\n\n\t\t\t\taddSkippedBeziers(bezierPieces, posThis.bezierNode, posNext.bezierNode, posNext.t);\n\t\t\t}\n\n\t\t\tcp0 = cp0.next;\n\t\t} else {\n\t\t\tgoStraight = true;\n\n\t\t\t// Actually, next, next, ..., i.e. take last exit\n\t\t\tcp0 = cp0.prevOnCircle;\n\t\t}\n\t} while (cp0 !== cp1);\n\n\treturn bezierPieces;\n\n\t/**\r\n  * Adds pieces of skipped beziers\r\n  */\n\tfunction addSkippedBeziers(bezierPieces, bezierNode0, bezierNode1, t1) {\n\n\t\tvar ii = 0;\n\t\tvar bNode = bezierNode0;\n\t\tdo {\n\t\t\tii++;\n\t\t\tbNode = bNode.next;\n\n\t\t\tif (bNode === bezierNode1) {\n\t\t\t\tvar _bezierPiece2 = new BezierPiece(bNode, [0, t1]);\n\t\t\t\tbezierPieces.push(_bezierPiece2);\n\t\t\t\t//MatLib._debug_.draw.bezierPiece(bezierPiece, 'nofill thin50 green');\n\t\t\t} else {\n\t\t\t\tvar _bezierPiece3 = new BezierPiece(bNode, [0, 1]);\n\t\t\t\tbezierPieces.push(_bezierPiece3);\n\t\t\t\t//MatLib._debug_.draw.bezierPiece(bezierPiece, 'nofill thin50 pink');\n\t\t\t}\n\t\t} while (bNode !== bezierNode1 && ii < 100);\n\n\t\tif (ii === 100) {\n\t\t\tconsole.log('maxed');\n\t\t}\n\t}\n};\n\nmodule.exports = Shape;\n\n},{\"../../geometry/classes/bezier-piece.js\":3,\"../../geometry/classes/bezier.js\":4,\"../../geometry/classes/point-on-shape.js\":6,\"../../linked-loop/linked-loop.js\":13,\"../../ll-rb-tree//ll-rb-tree.js\":15,\"../../mat-constants.js\":16,\"../../mat/classes/contact-point.js\":18,\"../../mat/classes/mat-circle.js\":21,\"../../memoize.js\":36,\"../../polynomial/polynomial.js\":39,\"../../svg/svg.js\":41,\"../../utils.js\":42,\"../../vector/vector.js\":43,\"../functions/get-bezier-osculating-circles.js\":9,\"../functions/get-contact-circles-at-bezier-bezier-interface.js\":11}],8:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Bezier = require('../classes/bezier.js');\n\nvar DELTA = 1e-6;\n\n/** \r\n * @description Calculates the curvature extrema brackets of the given\r\n * bezier.\r\n *  \r\n * @see the paper at: http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * @note Naming conventions roughly as in the paper above.\r\n */\nfunction calcCurvatureExtremaBrackets(bezier) {\n\tvar _bezier$bezierPoints = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints$ = _slicedToArray(_bezier$bezierPoints[0], 2),\n\t    x0 = _bezier$bezierPoints$[0],\n\t    y0 = _bezier$bezierPoints$[1],\n\t    _bezier$bezierPoints$2 = _slicedToArray(_bezier$bezierPoints[1], 2),\n\t    x1 = _bezier$bezierPoints$2[0],\n\t    y1 = _bezier$bezierPoints$2[1],\n\t    _bezier$bezierPoints$3 = _slicedToArray(_bezier$bezierPoints[2], 2),\n\t    x2 = _bezier$bezierPoints$3[0],\n\t    y2 = _bezier$bezierPoints$3[1],\n\t    _bezier$bezierPoints$4 = _slicedToArray(_bezier$bezierPoints[3], 2),\n\t    x3 = _bezier$bezierPoints$4[0],\n\t    y3 = _bezier$bezierPoints$4[1];\n\n\tvar brackets = [];\n\n\t// Bezier points translated to origin;\n\tvar P_1x = x1 - x0;\n\tvar P_1y = y1 - y0;\n\tvar P_2x = x2 - x0;\n\tvar P_2y = y2 - y0;\n\tvar P_3x = x3 - x0;\n\tvar P_3y = y3 - y0;\n\n\t// Distance to consecutive points\n\tvar W_0x = P_1x;\n\tvar W_1x = P_2x - P_1x;\n\tvar W_2x = P_3x - P_2x;\n\tvar W_0y = P_1y;\n\tvar W_1y = P_2y - P_1y;\n\tvar W_2y = P_3y - P_2y;\n\n\t// Check for degenerate case in which cubic curve becomes quadratic. \n\tif (Math.abs(W_0x - 2 * W_1x + W_2x) < DELTA && Math.abs(W_0y - 2 * W_1y + W_2y) < DELTA) {}\n\t// TODO - This case is simpler due to being quadratic but we're \n\t// lazy now and will skip it for the moment. Any takers?\n\n\n\t// See : http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n\t// Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\n\tvar atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\n\tvar atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\n\tvar atan_numer_squared = atan_numer * atan_numer;\n\tvar atan_denom_squared = atan_denom * atan_denom;\n\tvar radpre = atan_numer_squared / atan_denom_squared + 1;\n\tvar rad = Math.sqrt(radpre);\n\tvar cos_theta = 1 / rad;\n\tvar sin_theta = void 0;\n\tif (cos_theta === 0) {\n\t\t// edge case\n\t\tsin_theta = 1;\n\t} else {\n\t\tsin_theta = atan_numer / (atan_denom * rad);\n\t}\n\n\t// For next rotated points see Maxima file bez5 - here we skip \n\t// expensive trig evaluations\n\tvar R_0x = 0;\n\tvar R_0y = 0;\n\tvar R_1x = P_1x * cos_theta - P_1y * sin_theta;\n\tvar R_1y = P_1x * sin_theta + P_1y * cos_theta;\n\tvar R_2x = P_2x * cos_theta - P_2y * sin_theta;\n\tvar R_2y = P_2x * sin_theta + P_2y * cos_theta;\n\tvar R_3x = P_3x * cos_theta - P_3y * sin_theta;\n\tvar R_3y = P_3x * sin_theta + P_3y * cos_theta;\n\n\t// Modify W_0x, etc. to be correct for new rotated curve \n\tW_0x = R_1x;\n\tW_1x = R_2x - R_1x;\n\tW_2x = R_3x - R_2x;\n\tW_0y = R_1y;\n\tW_1y = R_2y - R_1y;\n\tW_2y = R_3y - R_2y;\n\n\tvar a_ = 3 * (W_0y - 2 * W_1y + W_2y);\n\tvar dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\n\tif (dif === 0) {\n\t\t// Case 1 (special) - W_1x - W_0x === 0\n\t\t// Degenerate to cubic function\t\n\n\t\tif (W_0x !== 0) {\n\t\t\t// TODO - FINISH!!!\n\t\t\t// TODO - we also still need to check for degenerate cubic \n\t\t\t// (see start of paper)\n\t\t} else {\n\t\t\t// We have a straight line x=0!\n\t\t\treturn [];\n\t\t}\n\t} else {\n\t\t// Case 2 (usual) - W_1x - W_0x !== 0\n\n\t\tif (dif < 0) {\n\t\t\t// Reflect curve accross y-axis to make dif > 0\n\t\t\tR_1x = -R_1x;\n\t\t\tR_2x = -R_2x;\n\t\t\tR_3x = -R_3x;\n\n\t\t\t// Modify W_0x, etc. to be correct for new reflected \n\t\t\tW_0x = -W_0x;\n\t\t\tW_1x = -W_1x;\n\t\t\tW_2x = -W_2x;\n\n\t\t\tdif = -dif;\n\t\t}\n\n\t\t// From the paper:\n\t\t// ---------------\n\t\t// All curves has exactly one of 4 cases:\n\t\t//\n\t\t// 1. It has a single inflection point and exactly 2 curvature \n\t\t//    maxima (symmetrically positioned about inflection point).\n\t\t//    This is the case if dif === 0 in above code.\n\t\t// 2. It has a single cusp - we ignore this case for now - but \n\t\t//    we must still do it!\n\t\t// 3. It has a point of self-intersection - occurs if d < 0 in \n\t\t//    paper (in code d is called sigd_). \n\t\t// 4. It has 2 inflection points, no cusps, no self-\n\t\t//    intersections.\n\t\t//    It can have either 3 or 5 curvature extrema\n\t\t//    a. The case of 5 curvature extrema is ignored for now - \n\t\t//       in the paper it is mentioned to even find such a curve \n\t\t//       is difficult and it seems such curves have very sharp \n\t\t//       curvature at one point which should not usually occur \n\t\t//       in an SVG shape. \n\t\t//       But this case should later be included or we'll miss \n\t\t//       some points.\n\t\t//    b. There are 3 curvature extrema:\n\t\t//       Extrema occur in the range (-inf, -sqrt(d)), \n\t\t//       (-sqrt(d), sqrt(d)), (sqrt(d), inf). \n\t\t//       Since we dont know how to select -inf and inf we will \n\t\t//       just choose them to be -10 and 11 (remember bezier runs \n\t\t//       from t=0 to t=1). If Brent's method runs out of the \n\t\t//       (0,1) interval we stop and use 0 or 1 as the extremum? \n\t\t//       Remember extrema can also occur at t=0 and t=1!\n\t\t//\n\t\t// At the moment we only test for case 1 and 4b, but in future \n\t\t// we can test and eliminate the other cases.\n\n\n\t\tvar mu = 6 * dif;\n\t\tvar lambda = 3 * a_ * W_0x / (mu * mu);\n\t\tvar gamma1 = 3 * a_ * W_0y / (mu * mu);\n\t\tvar gamma2 = 3 * (W_1y - W_0y) / mu;\n\t\t// This d in the paper\n\t\tvar sigd_ = lambda * lambda - 2 * gamma2 * lambda + gamma1;\n\t\tvar b_ = 2 * (gamma2 - lambda);\n\n\t\tvar deReParamBoundary = deReParameterizeBoundary(lambda, mu, a_);\n\n\t\tif (sigd_ > 0) {\n\t\t\tvar ssigd_ = Math.sqrt(sigd_);\n\n\t\t\t//console.log(ssigd_);\n\t\t\t// de-reparametize\n\t\t\t// Note: the sda and sdb here are the inflection points for \n\t\t\t// a case iv!! there are easier ways to calculate these\n\t\t\tvar sda = -ssigd_;\n\t\t\tvar sdb = ssigd_;\n\t\t\tbrackets = [[Number.NEGATIVE_INFINITY, sda], [sda, sdb], [sdb, Number.POSITIVE_INFINITY]].map(deReParamBoundary).map(clipBoundary);\n\t\t} else if (sigd_ < 0) {\n\t\t\t// Loop \n\t\t\t// Note: The loop intersection may be outside t=[0,1]. \n\t\t\t// In fact, for a well behaved shape this is always the \n\t\t\t// case.\n\t\t\t// But, curvature maxima may still occur inside t=[0,1] \n\t\t\t// of course.\n\t\t\t// There can be 1 or 3 maxima of curvature\n\n\t\t\tvar ksi_pre1 = 2 * b_ * b_ - 8 * sigd_ - 3;\n\n\t\t\tif (ksi_pre1 < 0) {\n\t\t\t\tbrackets = [[0, Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n\t\t\t} else {\n\t\t\t\tvar ksi_pre2 = Math.sqrt(5 * ksi_pre1);\n\t\t\t\tvar ksi1 = (-5 * b_ - ksi_pre2) / 10;\n\t\t\t\tvar ksi2 = (-5 * b_ + ksi_pre2) / 10;\n\n\t\t\t\tbrackets = [[Number.NEGATIVE_INFINITY, ksi1], [ksi1, Math.min(0, ksi2)], [Math.max(0, ksi2), Math.sqrt(-3 * sigd_)]].map(deReParamBoundary).map(clipBoundary);\n\t\t\t}\n\t\t} else if (sigd_ === 0) {\n\t\t\t// TODO Cusp - ignore for now - lazy\n\t\t}\n\t}\n\n\treturn brackets;\n}\n\n/** \r\n * @description Clips to [0,1] or returns false if not within [0,1].\r\n */\nfunction clipBoundary(bound) {\n\tvar b0 = bound[0];\n\tvar b1 = bound[1];\n\n\tif (b0 < 0 && b1 < 0 || b0 > 1 && b1 > 1) {\n\t\treturn false;\n\t}\n\n\tif (b0 < 0) {\n\t\tb0 = 0;\n\t}\n\tif (b0 > 1) {\n\t\tb0 = 1;\n\t}\n\tif (b1 < 0) {\n\t\tb1 = 0;\n\t}\n\tif (b1 > 1) {\n\t\tb1 = 1;\n\t}\n\n\treturn [b0, b1];\n}\n\n/**\r\n * @returns t\r\n */\nfunction deReParameterize(lambda, mu, a_) {\n\treturn function (sigma) {\n\t\treturn (sigma - lambda) * (mu / a_);\n\t};\n};\n\n/**\r\n * \r\n */\nfunction deReParameterizeBoundary(lambda, mu, a_) {\n\treturn function (boundary) {\n\t\treturn boundary.map(deReParameterize(lambda, mu, a_));\n\t};\n};\n\nmodule.exports = calcCurvatureExtremaBrackets;\n\n},{\"../classes/bezier.js\":4}],9:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Bezier = require('../classes/bezier.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Poly = require('../../polynomial/polynomial.js');\n\nvar calcBezierCurvatureExtremaBrackets = require('./calc-bezier-curvature-extrema.js');\n\n/** \r\n * @description Finds the osculating circles for the given bezier. \r\n **/\nfunction getBezierOsculatingCircles(bezierNode) {\n\n\tvar pointsOnShape = [];\n\n\tvar root = void 0;\n\tvar bezier = bezierNode.item;\n\tvar brackets = calcBezierCurvatureExtremaBrackets(bezier);\n\n\tvar lenb = brackets.length;\n\tfor (var k = 0; k < lenb; k++) {\n\t\tvar bracket = brackets[k];\n\t\tif (!bracket) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar _root = lookForRoot(bezier, bracket);\n\t\tif (!_root) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar κ = -Bezier.κ(bezier)(_root);\n\t\t// Check if local extrema is a maximum or minimum.\n\t\tvar κAtMinsd = -Bezier.κ(bezier)(bracket[0]);\n\t\tvar κAtMaxsd = -Bezier.κ(bezier)(bracket[1]);\n\n\t\tif (κ > κAtMinsd && κ > κAtMaxsd) {\n\t\t\t// maximum\n\t\t} else if (κ <= κAtMinsd && κ <= κAtMaxsd) {\n\t\t\t// minimum\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar pos = new PointOnShape(bezierNode, _root, MAT_CONSTANTS.pointType.standard, 0, 0);\n\n\t\tpointsOnShape.push(pos);\n\t}\n\n\tpointsOnShape.sort(PointOnShape.compare);\n\n\treturn pointsOnShape;\n}\n\nfunction lookForRoot(bezier, _ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2),\n\t    minsd = _ref2[0],\n\t    maxsd = _ref2[1];\n\n\t// At this point there can be exactly 0 or 1 roots within \n\t// [minsd, maxsd]\n\tvar c0 = Bezier.dκ(bezier)(minsd);\n\tvar c1 = Bezier.dκ(bezier)(maxsd);\n\n\tif (c0 * c1 >= 0) {\n\t\treturn;\n\t}\n\n\t// There is exactly one root in the interval.\n\tvar root = Poly.brent(Bezier.dκ(bezier), minsd, maxsd);\n\n\treturn root;\n}\n\nmodule.exports = getBezierOsculatingCircles;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../mat-constants.js\":16,\"../../polynomial/polynomial.js\":39,\"../classes/bezier.js\":4,\"./calc-bezier-curvature-extrema.js\":8}],10:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Poly = require('../../polynomial/polynomial.js');\nvar Geometry = require('../geometry.js');\nvar Vector = require('../../vector/vector.js');\n\nvar Bezier = require('../classes/bezier.js');\nvar PointOnShape = require('../classes/Point-on-shape.js');\n\n/**\r\n * Gets the closest boundary point to the given point, limited to the\r\n * given bezier pieces.\r\n * \r\n * @param {BezierPiece[]} bezierPieces\r\n * @param {Number[]} p\r\n * @param {ListNode<Bezier>} touchedBezierNode\r\n * @returns {PointOnShape} The closest point.\r\n */\nfunction getClosestBoundaryPointToPoint(bezierPieces_, point, touchedBezierNode, t) {\n\n\tvar bezierPieces = cullBezierPieces(bezierPieces_, point);\n\n\tvar bestDistance = Number.POSITIVE_INFINITY;\n\tvar pos = void 0;\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar bezierPiece = _step.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar p = closestPointOnBezier(bezierPiece.bezierNode, point, bezierPiece.tRange, touchedBezierNode, t);\n\n\t\t\tvar d = p === undefined ? Number.POSITIVE_INFINITY : Vector.distanceBetween(p.p, point);\n\n\t\t\tif (d < bestDistance) {\n\t\t\t\tpos = new PointOnShape(bezierPiece.bezierNode, p.t, MAT_CONSTANTS.pointType.standard, 0, 0);\n\t\t\t\tbestDistance = d;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pos;\n}\n\nfunction cullBezierPieces(bezierPieces, p) {\n\n\tvar CULL_THRESHOLD = 5; // TODO Put somewhere better.\n\n\tvar shortCircuit = bezierPieces.length > CULL_THRESHOLD;\n\tif (shortCircuit) {\n\t\t// First get an initial point such that the closest point \n\t\t// can not be further than this point.\n\t\tvar bestSquaredDistance = getClosePoint(bezierPieces, p);\n\t\tbezierPieces = cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\n\t\tbezierPieces = cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\n\t}\n\n\treturn bezierPieces;\n}\n\n/**\r\n * Finds an initial point such that the closest point\r\n * can not be further than this point.\r\n */\nfunction getClosePoint(bezierPieces, p) {\n\tvar bestSquaredDistance = Number.POSITIVE_INFINITY;\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = bezierPieces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar bezierPiece = _step2.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar p1 = Bezier.evaluate(bezier)(bezierPiece.tRange[0]);\n\t\t\tvar p2 = Bezier.evaluate(bezier)(bezierPiece.tRange[1]);\n\n\t\t\tvar d1 = Vector.squaredDistanceBetween(p, p1);\n\t\t\tvar d2 = Vector.squaredDistanceBetween(p, p2);\n\t\t\tvar d = Math.min(d1, d2);\n\n\t\t\tif (d < bestSquaredDistance) {\n\t\t\t\tbestSquaredDistance = d;\n\t\t\t}\n\t\t}\n\n\t\t// The extra bit is to account for floating point precision \n\t\t// TODO change 0.01 below to more meaningfull value dependent on \n\t\t// shape dimensions.\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestSquaredDistance + 0.01;\n}\n\n/**\r\n * When checking distances, ignore all those with closest \r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance) {\n\n\tvar candidateBezierPieces = [];\n\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = bezierPieces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar bezierPiece = _step3.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\t//let looseBoundingBox = bezier.getBoundingBox();\n\t\t\tvar looseBoundingBox = Bezier.getBoundingBox(bezier);\n\n\t\t\tvar d = Geometry.getClosestSquareDistanceToRect(looseBoundingBox, p);\n\t\t\tif (d <= bestSquaredDistance) {\n\t\t\t\tcandidateBezierPieces.push(bezierPiece);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn candidateBezierPieces;\n}\n\n/**\r\n * When checking distances, ignore all those with closest \r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n\n\tvar candidateBezierPieces = [];\n\n\tvar _iteratorNormalCompletion4 = true;\n\tvar _didIteratorError4 = false;\n\tvar _iteratorError4 = undefined;\n\n\ttry {\n\t\tfor (var _iterator4 = bezierPieces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\tvar bezierPiece = _step4.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar tightBoundingBox = Bezier.getBoundingBoxTight(bezier);\n\t\t\tvar d = Geometry.closestSquaredDistanceToRotatedRect(bezier, p);\n\t\t\tif (d <= bestSquaredDistance) {\n\t\t\t\tcandidateBezierPieces.push(bezierPiece);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError4 = true;\n\t\t_iteratorError4 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t_iterator4.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError4) {\n\t\t\t\tthrow _iteratorError4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn candidateBezierPieces;\n}\n\n/**\r\n * \r\n */\nfunction closestPointOnBezier(bezierNode, p, tRange, touchedBezierNode, t) {\n\n\tvar bezier = bezierNode.item;\n\tvar touchedBezier = touchedBezierNode ? touchedBezierNode.item : undefined;\n\n\t// TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\n\t// may hint at requiring much fewer assignments?\n\n\tvar _bezier$bezierPoints = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints$ = _slicedToArray(_bezier$bezierPoints[0], 2),\n\t    x0 = _bezier$bezierPoints$[0],\n\t    y0 = _bezier$bezierPoints$[1],\n\t    _bezier$bezierPoints$2 = _slicedToArray(_bezier$bezierPoints[1], 2),\n\t    x1 = _bezier$bezierPoints$2[0],\n\t    y1 = _bezier$bezierPoints$2[1],\n\t    _bezier$bezierPoints$3 = _slicedToArray(_bezier$bezierPoints[2], 2),\n\t    x2 = _bezier$bezierPoints$3[0],\n\t    y2 = _bezier$bezierPoints$3[1],\n\t    _bezier$bezierPoints$4 = _slicedToArray(_bezier$bezierPoints[3], 2),\n\t    x3 = _bezier$bezierPoints$4[0],\n\t    y3 = _bezier$bezierPoints$4[1];\n\n\tvar _p = _slicedToArray(p, 2),\n\t    xp = _p[0],\n\t    yp = _p[1];\n\n\tvar xx0 = x0 - xp;\n\tvar xx1 = x1 - xp;\n\tvar xx2 = x2 - xp;\n\tvar xx3 = x3 - xp;\n\tvar yy0 = y0 - yp;\n\tvar yy1 = y1 - yp;\n\tvar yy2 = y2 - yp;\n\tvar yy3 = y3 - yp;\n\n\tvar x00 = xx0 * xx0;\n\tvar x01 = 6 * xx0 * xx1;\n\tvar x02 = 6 * xx0 * xx2;\n\tvar x03 = 2 * xx0 * xx3;\n\tvar x11 = 9 * xx1 * xx1;\n\tvar x12 = 18 * xx1 * xx2;\n\tvar x13 = 6 * xx1 * xx3;\n\tvar x22 = 9 * xx2 * xx2;\n\tvar x23 = 6 * xx2 * xx3;\n\tvar x33 = xx3 * xx3;\n\n\tvar y00 = yy0 * yy0;\n\tvar y01 = 6 * yy0 * yy1;\n\tvar y02 = 6 * yy0 * yy2;\n\tvar y03 = 2 * yy0 * yy3;\n\tvar y11 = 9 * yy1 * yy1;\n\tvar y12 = 18 * yy1 * yy2;\n\tvar y13 = 6 * yy1 * yy3;\n\tvar y22 = 9 * yy2 * yy2;\n\tvar y23 = 6 * yy2 * yy3;\n\tvar y33 = yy3 * yy3;\n\n\tvar t5 = 6 * (x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00 + (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\n\tvar t4 = 5 * (x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00 + (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\n\tvar t3 = 4 * (x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00 + (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\n\tvar t2 = 3 * (x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00 + (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\n\tvar t1 = 2 * (x02 + x11 - 5 * x01 + 15 * x00 + (y02 + y11 - 5 * y01 + 15 * y00));\n\tvar t0 = x01 - 6 * x00 + (y01 - 6 * y00);\n\n\tvar poly = [t5, t4, t3, t2, t1, t0];\n\n\tif (bezier === touchedBezier) {\n\t\tvar deflatedPoly = Poly.deflate(poly, t);\n\t\tpoly = deflatedPoly;\n\t}\n\n\t//let allRoots = allRootsVAS(poly, tRange);\n\tvar allRoots = Poly.allRoots01(poly);\n\tvar roots = allRoots.filter(function (root) {\n\t\treturn root >= tRange[0] && root <= tRange[1];\n\t});\n\n\tvar push0 = true;\n\tvar push1 = true;\n\tif (t === 1 && bezierNode === touchedBezierNode.next || bezier === touchedBezier && t === 0) {\n\t\tpush0 = false;\n\t}\n\tif (t === 0 && bezierNode === touchedBezierNode.prev || bezier === touchedBezier && t === 1) {\n\t\tpush1 = false;\n\t}\n\n\tif (tRange[0] === 0) {\n\t\tif (push0) {\n\t\t\troots.push(tRange[0]);\n\t\t}\n\t} else if (tRange[0] === 1) {\n\t\tif (push1) {\n\t\t\troots.push(tRange[0]);\n\t\t}\n\t} else {\n\t\troots.push(tRange[0]);\n\t}\n\n\tif (tRange[1] === 0) {\n\t\tif (push0) {\n\t\t\troots.push(tRange[1]);\n\t\t}\n\t} else if (tRange[1] === 1) {\n\t\tif (push1) {\n\t\t\troots.push(tRange[1]);\n\t\t}\n\t} else {\n\t\troots.push(tRange[1]);\n\t}\n\n\tvar ps = roots.map(function (root) {\n\t\treturn { p: Bezier.evaluate(bezier)(root), t: root };\n\t});\n\tvar closestPoint = Vector.getClosestTo(p, ps, function (p1, p2) {\n\t\treturn Vector.squaredDistanceBetween(p1, p2.p);\n\t});\n\n\treturn closestPoint;\n}\n\nmodule.exports = getClosestBoundaryPointToPoint;\n\n},{\"../../mat-constants.js\":16,\"../../polynomial/polynomial.js\":39,\"../../vector/vector.js\":43,\"../classes/Point-on-shape.js\":1,\"../classes/bezier.js\":4,\"../geometry.js\":12}],11:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Vector = require('../../vector/vector.js');\nvar Bezier = require('../classes/bezier.js');\n\n// Angle in degrees\nvar DEGREES = {\n\t'0': 0.0000,\n\t'0.25': 0.0050,\n\t'1': 0.0167,\n\t'4': 0.0698,\n\t'15': 0.2588,\n\t'16': 0.2756\n};\n\nvar CROSS_TANGENT_LIMIT = DEGREES[0.25];\n\n/** \r\n * Get the circles at the bezier-bezier interface points with circle\r\n * curvature coinciding with the bezier curvature at those points. \r\n * \r\n * @param {[ListNode<Bezier>]} bezierNodes - The two bezier nodes.\r\n **/\nfunction getContactCirclesAtBezierBezierInterface(bezierNodes, dullCornerHash) {\n\n\tvar ts = [1, 0];\n\n\tvar beziers = [0, 1].map(function (i) {\n\t\treturn bezierNodes[i].item;\n\t});\n\tvar tans = [0, 1].map(function (i) {\n\t\treturn Bezier.tangent(beziers[i])(ts[i]);\n\t});\n\n\tvar crossTangents = +Vector.cross(tans[0], tans[1]);\n\tvar negDot = -Vector.dot(tans[0], tans[1]);\n\n\t// The if below is important. Due to floating point approximation\n\t// it sometimes happen that crossTangents !== 0 but\n\t// negDot === -1. Remove the if and see what happens. :)\n\tif (crossTangents === 0 || negDot === -1) {\n\t\t// Too close to call \n\t\treturn [];\n\t}\n\n\tvar p = beziers[0].bezierPoints[3];\n\n\tif (crossTangents < -CROSS_TANGENT_LIMIT) {\n\t\t// Sharp corner\n\t\tvar pos = new PointOnShape(bezierNodes[0], 1, MAT_CONSTANTS.pointType.sharp, 0, 0);\n\n\t\treturn [pos];\n\t}\n\n\tif (crossTangents > 0) {\n\t\tvar key = PointOnShape.makeSimpleKey(p);\n\t\tdullCornerHash[key] = { beziers: beziers, tans: tans };\n\t}\n\n\tif (crossTangents <= CROSS_TANGENT_LIMIT) {\n\t\t// The interface is too straight, but put a point close-by.\n\t\t// TODO - this point may be order wrong in the end causing \n\t\t// disaster. Fix.\n\t\tvar _pos = new PointOnShape(bezierNodes[0], 0.9, MAT_CONSTANTS.pointType.standard, 0, 0);\n\n\t\treturn [_pos];\n\t}\n\n\t//---- Dull corner\n\tvar pointsOnShape = [];\n\n\tvar orders = [-1, negDot];\n\tfor (var i = 0; i < 2; i++) {\n\t\tvar _pos2 = new PointOnShape(bezierNodes[i], ts[i], MAT_CONSTANTS.pointType.dull, orders[i], 0);\n\n\t\tpointsOnShape.push(_pos2);\n\t}\n\n\treturn pointsOnShape;\n}\n\nmodule.exports = getContactCirclesAtBezierBezierInterface;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../mat-constants.js\":16,\"../../vector/vector.js\":43,\"../classes/bezier.js\":4}],12:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Util = require('../utils.js');\nvar Poly = require('../polynomial/polynomial.js');\nvar Memoize = require('../memoize.js');\nvar Vector = require('../vector/vector.js');\n\nvar Circle = require('./classes/circle.js');\nvar Shape = require('./classes/shape.js');\nvar Arc = require('./classes/arc.js');\nvar PointOnShape = require('./classes/point-on-shape.js');\nvar Bezier = require('./classes/bezier.js');\n\n/*\r\n * Geometry utility functions\r\n */\nvar Geometry = {};\n\n/**\r\n * Get line shape intersection points.\r\n * \r\n * @param line A simple line described by two points, e.g. [[p0x,p0y],[p1x,p1y]]\r\n * @param shape {Shape} \r\n * @param δ Curve segment described by start and end contact points\r\n *\r\n * Currently not used\r\n */\nGeometry.getLineShapeIntersectionPoints = function (line, shape, δ) {\n\n\tvar points = [];\n\tvar bezierPieces = Shape.getBoundaryPieceBeziers(δ);\n\n\tfor (var i = 0; i < bezierPieces.length; i++) {\n\t\tbezierPiece = bezierPieces[i];\n\n\t\tvar bezier = bezierPiece.bezierNode.item;\n\t\tvar iPoints = Geometry.getLineBezierIntersectionPoints(line, bezier, bezierPiece.tRange);\n\n\t\tfor (var j = 0; j < iPoints.length; j++) {\n\t\t\tpoints.push(iPoints[j].p);\n\t\t}\n\t}\n\n\treturn points;\n};\n\n/**\r\n * @description\r\n */\nGeometry.closestSquaredDistanceToRotatedRect = function (bezier, p) {\n\tvar tightBoundingBox = Bezier.getBoundingBoxTight(bezier);\n\n\tvar ds = [0, 1, 2, 3].map(function (i) {\n\t\treturn Vector.squaredDistanceBetweenPointAndLineSegment(p, [tightBoundingBox[i], tightBoundingBox[(i + 1) % 4]]);\n\t});\n\n\treturn Util.min(ds);\n};\n\n/**\r\n * @description\r\n */\nGeometry.getClosestSquareDistanceToRect = function (box, p) {\n\n\tvar x0 = box[0][0];\n\tvar y0 = box[0][1];\n\tvar x1 = box[1][0];\n\tvar y1 = box[1][1];\n\n\tvar xp = p[0];\n\tvar yp = p[1];\n\n\tif (xp < x0) {\n\t\tif (yp < y0) {\n\t\t\treturn Vector.squaredDistanceBetween(box[0], p);\n\t\t} else if (yp > y1) {\n\t\t\treturn Vector.squaredDistanceBetween([x0, y1], p);\n\t\t} else {\n\t\t\tvar d = x0 - xp;\n\t\t\treturn d * d;\n\t\t}\n\t} else if (xp > x1) {\n\t\tif (yp < y0) {\n\t\t\treturn Vector.squaredDistanceBetween([x1, y0], p);\n\t\t} else if (yp > y1) {\n\t\t\treturn Vector.squaredDistanceBetween(box[1], p);\n\t\t} else {\n\t\t\tvar _d = xp - x1;\n\t\t\treturn _d * _d;\n\t\t}\n\t} else {\n\t\tif (yp < y0) {\n\t\t\tvar _d2 = y0 - yp;\n\t\t\treturn _d2 * _d2;\n\t\t} else if (yp > y1) {\n\t\t\tvar _d3 = yp - y1;\n\t\t\treturn _d3 * _d3;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n};\n\n/**\r\n * @description\r\n */\nGeometry.degAngleFromSinCos = function (sinθ, cosθ) {\n\n\tfunction toDeg(θ) {\n\t\treturn θ * (180 / Math.PI);\n\t}\n\n\tif (cosθ === 0) {\n\t\tif (sinθ > 0) {\n\t\t\treturn 90;\n\t\t}\n\t\treturn 270;\n\t}\n\tif (cosθ > 0) {\n\t\treturn toDeg(Math.atan(sinθ / cosθ));\n\t}\n\treturn 180 + toDeg(Math.atan(sinθ / cosθ));\n};\n\n/** \r\n * @returns A directional arc from 3 ordered points. \r\n */\nGeometry.arcFrom3Points = function (ps) {\n\tvar midPoint1 = Vector.mean([ps[0], ps[1]]);\n\tvar midPoint2 = Vector.mean([ps[1], ps[2]]);\n\n\tvar chord1 = Vector.fromTo(ps[0], ps[1]);\n\tvar chord2 = Vector.fromTo(ps[1], ps[2]);\n\n\tvar perpendicular1 = [chord1[1], -chord1[0]];\n\tvar perpendicular2 = [chord2[1], -chord2[0]];\n\n\tvar l1 = [midPoint1, Vector.translate(perpendicular1, midPoint1)];\n\tvar l2 = [midPoint2, Vector.translate(perpendicular2, midPoint2)];\n\n\tvar circleCenter = Geometry.lineLineIntersection(l1, l2);\n\n\tvar arc = void 0;\n\tif (circleCenter === null) {\n\t\t// The circle is in effect a line segment.\n\t\tif (Vector.equal(ps[0], ps[2])) {\n\t\t\treturn null;\n\t\t}\n\t\tarc = new Arc(null, ps[0], ps[2]);\n\t\treturn arc;\n\t}\n\n\tvar sideVector1 = Vector.fromTo(circleCenter, ps[0]);\n\tvar midVector = Vector.fromTo(circleCenter, ps[1]);\n\tvar sideVector2 = Vector.fromTo(circleCenter, ps[2]);\n\tvar radius = Vector.length(sideVector1);\n\tvar sinθ1 = -sideVector1[1] / radius;\n\tvar cosθ1 = sideVector1[0] / radius;\n\tvar sinθ2 = -sideVector2[1] / radius;\n\tvar cosθ2 = sideVector2[0] / radius;\n\tvar sin_midangle = -midVector[1] / radius;\n\tvar cos_midangle = midVector[0] / radius;\n\n\tif (Geometry.isAngleBetween(sin_midangle, cos_midangle, sinθ1, cosθ1, sinθ2, cosθ2)) {\n\t\tarc = new Arc(new Circle(circleCenter, radius), ps[0], ps[2], sinθ1, cosθ1, sinθ2, cosθ2);\n\t} else {\n\t\tarc = new Arc(new Circle(circleCenter, radius), ps[2], ps[0], sinθ2, cosθ2, sinθ1, cosθ1);\n\t}\n\n\treturn arc;\n};\n\n/**\r\n * @description\r\n */\nGeometry.quadrant = function (sinθ, cosθ) {\n\tif (sinθ >= 0) {\n\t\tif (cosθ >= 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 2;\n\t}\n\tif (cosθ >= 0) {\n\t\treturn 4;\n\t}\n\treturn 3;\n};\n\n/**\r\n * @description\r\n */\nGeometry.isAngle1LargerOrEqual = function (sinθ1, cosθ1, sinθ2, cosθ2) {\n\tvar q1 = Geometry.quadrant(sinθ1, cosθ1);\n\tvar q2 = Geometry.quadrant(sinθ2, cosθ2);\n\n\tif (q1 > q2) {\n\t\treturn true;\n\t}\n\tif (q1 < q2) {\n\t\treturn false;\n\t}\n\n\t// Same quadrant\n\tif (q1 === 1 || q1 === 4) {\n\t\treturn sinθ1 >= sinθ2;\n\t}\n\treturn sinθ1 <= sinθ2;\n};\n\n/** \r\n * Returns true if angle1 < angle < angle2 in the non-trivial sense.\r\n */\nGeometry.isAngleBetween = function (sinθ, cosθ, sinθ1, cosθ1, sinθ2, cosθ2) {\n\n\tvar θ1_larger_θ2 = Geometry.isAngle1LargerOrEqual(sinθ1, cosθ1, sinθ2, cosθ2);\n\n\tvar θ_larger_θ2 = Geometry.isAngle1LargerOrEqual(sinθ, cosθ, sinθ2, cosθ2);\n\n\tvar θ_larger_θ1 = Geometry.isAngle1LargerOrEqual(sinθ, cosθ, sinθ1, cosθ1);\n\n\treturn θ1_larger_θ2 ? θ_larger_θ1 || !θ_larger_θ2 : θ_larger_θ1 && !θ_larger_θ2;\n};\n\n/**\r\n * Find point where two lines intersect.\r\n *  \r\n * @param line1 The first line - given as 2 points \r\n * @param line2 The first line - given as 2 points\r\n * @returns Point where two lines intersect or null if they don't \r\n * intersect or intersect everywhere. \r\n */\nGeometry.lineLineIntersection = function (line1, line2) {\n\tvar _line = _slicedToArray(line1, 2),\n\t    _line$ = _slicedToArray(_line[0], 2),\n\t    p1x = _line$[0],\n\t    p1y = _line$[1],\n\t    _line$2 = _slicedToArray(_line[1], 2),\n\t    p2x = _line$2[0],\n\t    p2y = _line$2[1];\n\n\tvar _line2 = _slicedToArray(line2, 2),\n\t    _line2$ = _slicedToArray(_line2[0], 2),\n\t    p3x = _line2$[0],\n\t    p3y = _line2$[1],\n\t    _line2$2 = _slicedToArray(_line2[1], 2),\n\t    p4x = _line2$2[0],\n\t    p4y = _line2$2[1];\n\n\tvar v1x = p2x - p1x;\n\tvar v1y = p2y - p1y;\n\tvar v2x = p4x - p3x;\n\tvar v2y = p4y - p3y;\n\n\tvar cross = v2x * v1y - v2y * v1x;\n\tif (cross === 0) {\n\t\t// parallel\n\t\treturn undefined;\n\t}\n\n\tvar b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\n\n\treturn [p3x + b * v2x, p3y + b * v2y];\n};\n\n/**\r\n * @description\r\n */\nGeometry.lineThroughPointAtRightAngleTo = function (p, v) {\n\tvar u = [-v[1], v[0]];\n\tvar p20 = p[0] + u[0];\n\tvar p21 = p[1] + u[1];\n\n\treturn [p, [p20, p21]];\n};\n\n/**\r\n * @description Get all intersection points between a line and a bezier \r\n * within a certain t range.\r\n * \r\n * @returns An array of { p, t } \r\n */\nGeometry.getLineBezierIntersectionPoints = function (line, bezier, tRange) {\n\n\tvar t = [-line[0][0], -line[0][1]];\n\tvar p = [line[1][0] + t[0], line[1][1] + t[1]];\n\n\t// Cache\n\tvar lineLength = Vector.length(p);\n\tvar sinθ = -p[1] / lineLength;\n\tvar cosθ = p[0] / lineLength;\n\n\tvar bezierPoints = Vector.translateThenRotatePoints(bezier.bezierPoints, t, sinθ, cosθ);\n\n\tvar newBezier = new Bezier(bezierPoints);\n\n\tvar roots = Poly.findCubicRoots01(newBezier.y);\n\n\treturn roots.map(function (t) {\n\t\treturn { p: Bezier.evaluate(bezier)(t), t: t };\n\t});\n};\n\nmodule.exports = Geometry;\n\n},{\"../memoize.js\":36,\"../polynomial/polynomial.js\":39,\"../utils.js\":42,\"../vector/vector.js\":43,\"./classes/arc.js\":2,\"./classes/bezier.js\":4,\"./classes/circle.js\":5,\"./classes/point-on-shape.js\":6,\"./classes/shape.js\":7}],13:[function(require,module,exports){\n'use strict';\n\nvar LlRbTree = require('../ll-rb-tree/ll-rb-tree.js');\nvar ListNode = require('./list-node.js');\n\n/**\r\n * Represents a two-way linked loop. \r\n * @constructor \r\n *\r\n * @param comparator - Tree item comparator\r\n * @param {number} indx - Loop identifier.\r\n * @note If called with an array, must be called with a sorted array if  \r\n * comparator is not given. \r\n */\nfunction LinkedLoop(array, comparator, indx) {\n\tif (comparator) {\n\t\tthis.cptree = new LlRbTree(comparator);\n\t}\n\n\tthis.indx = indx;\n\n\tthis.addAllFromScratch(array || []);\n}\n\n/**\r\n * Insert an item into the linked loop after specified point \r\n * \r\n * @param item  {*} - Item to insert.\r\n * @param prev - Insert new item right after this item.\r\n * @param coupledNode\r\n */\nLinkedLoop.insert = function (loop, item, prev_, coupledNode) {\n\n\tvar node = new ListNode(loop, item, undefined, undefined);\n\n\tvar prev = void 0;\n\tvar next = void 0;\n\n\tif (!loop.head) {\n\t\tprev = node;\n\t\tnext = node;\n\n\t\tloop.head = node;\n\t} else {\n\t\tprev = prev_;\n\t\tnext = prev.next;\n\t}\n\n\tnext.prev = node;\n\tprev.next = node;\n\tnode.prev = prev;\n\tnode.next = next;\n\n\tnode.coupledNode = coupledNode;\n\n\tif (loop.cptree) {\n\t\tLlRbTree.insert(loop.cptree, node);\n\t};\n\n\treturn node;\n};\n\n/**\r\n * \r\n */\nLinkedLoop.remove = function (loop, node) {\n\n\tvar prev = node.prev;\n\tvar next = node.next;\n\n\tif (node === loop.head) {\n\t\tloop.head = next;\n\t}\n\n\tprev.next = next;\n\tnext.prev = prev;\n\n\tif (loop.cptree) {\n\t\t// TODO - could be made faster by removing on item directly\n\t\t//loop.cptree.remove(item); \n\t\tLlRbTree.remove(loop.cptree, node);\n\t};\n};\n\n/**\r\n * @description \r\n */\nLinkedLoop.getAsArray = function (loop) {\n\tvar nodes = [];\n\n\tvar node = loop.head;\n\tdo {\n\t\tnodes.push(node.item);\n\n\t\tnode = node.next;\n\t} while (node !== loop.head);\n\n\treturn nodes;\n};\n\n/**\r\n * \r\n */\nLinkedLoop.forEach = function (loop, f) {\n\n\tvar node = loop.head;\n\tdo {\n\t\tf(node);\n\n\t\tnode = node.next;\n\t} while (node !== loop.head);\n};\n\n/**\r\n * @description Returns the item at the specified index position.\r\n * @note This is slow ( O(n) ); use in debugging code only.\r\n */\nLinkedLoop.getByIndx = function (linkedLoop, n) {\n\treturn ListNode.advanceNSteps(linkedLoop.head, n);\n};\n\n/**\r\n * \r\n */\nLinkedLoop.prototype.addAllFromScratch = function (arr) {\n\n\tif (arr.length === 0) {\n\t\treturn;\n\t}\n\n\tvar head;\n\tvar prevNode = null;\n\tvar node = void 0;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\n\t\tnode = new ListNode(this, arr[i], prevNode, null, i);\n\n\t\tif (prevNode) {\n\t\t\tprevNode.next = node;\n\t\t}\n\t\tprevNode = node;\n\n\t\tif (i === 0) {\n\t\t\thead = node;\n\t\t}\n\n\t\tif (this.cptree) {\n\t\t\tLlRbTree.insert(this.cptree, node);\n\t\t};\n\t}\n\n\t// Close loop\n\thead.prev = node;\n\tnode.next = head;\n\n\tthis.head = head;\n};\n\nmodule.exports = LinkedLoop;\n\n},{\"../ll-rb-tree/ll-rb-tree.js\":15,\"./list-node.js\":14}],14:[function(require,module,exports){\n\"use strict\";\n\n/**\r\n * Representation of a linked loop vertex (i.e. node) having various  \r\n * edges, two of which enforce an ordering on the nodes, i.e. 'prev'\r\n * and 'next'.\r\n *  \r\n * @constructor\r\n * @param {*} item - The actual item stored at a node.\r\n * @param {ListNode} prev - The previous item.\r\n * @param {ListNode} next - The next item.\r\n */\nfunction ListNode(loop, item, prev, next) {\n\n  this.loop = loop;\n\n  this.item = item;\n  this.prev = prev;\n  this.next = next;\n}\n\n/**\r\n * @description Advances the node by the given number of steps.\r\n * @note This is slow ( O(n) ); use in debugging code only.\r\n */\nListNode.advanceNSteps = function (node, n) {\n  for (var i = 0; i < n; i++) {\n    node = node.next;\n  }\n\n  return node;\n};\n\nmodule.exports = ListNode;\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\n/*\r\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html \r\n */\n\nvar LEFT = false;\nvar RIGHT = true;\n\nvar RED = true;\nvar BLACK = false;\n\n/**\r\n * Red Black Tree node.\r\n * @constructor \r\n * @param {*} data\r\n */\nfunction Node(data) {\n\tthis.data = data;\n\tthis.red = true;\n}\n\nNode.isRed = function (node) {\n\treturn node && node.red;\n};\n\n/** \r\n * @constructor \r\n */\nfunction LlRbTree(comparator) {\n\tthis.comparator = comparator;\n\tthis.root = null;\n}\n\nfunction getMinOrMaxNode(dir, node) {\n\treturn function (node) {\n\t\twhile (node[dir]) {\n\t\t\tnode = node[dir];\n\t\t}\n\t\treturn node;\n\t};\n}\n\nLlRbTree.getMinNode = getMinOrMaxNode(LEFT);\nLlRbTree.getMaxNode = getMinOrMaxNode(RIGHT);\n\nLlRbTree.min = function (node) {\n\treturn LlRbTree.getMinNode(node).data;\n};\n\nLlRbTree.max = function (node) {\n\treturn LlRbTree.getMaxNode(node).data;\n};\n\n/**\r\n * @return The 2 nodes bounding the data. If overflow occurs, min is \r\n * returned as the second one. If bounds cannot be found (tree is empty \r\n * or contains 1 item) returns null. If the data falls on a node, that \r\n * node and the next (to the right) is returned. \r\n */\nLlRbTree.findBounds = function (tree, data) {\n\tvar node = tree.root;\n\n\tif (node === null) {\n\t\treturn null;\n\t}\n\n\tvar bounds = [];\n\twhile (node) {\n\t\tvar c = tree.comparator(data, node.data);\n\t\tif (c >= 0) {\n\t\t\tbounds[0] = node;\n\t\t} else {\n\t\t\tbounds[1] = node;\n\t\t}\n\n\t\tnode = node[c >= 0];\n\t}\n\n\treturn bounds;\n};\n\n/**\r\n * Find the node in the tree with the given data using ===. \r\n * \r\n * @return {Node} node or null if not found.\r\n */\nLlRbTree.find = function (tree, data) {\n\tvar node = tree.root;\n\n\twhile (node) {\n\t\tvar c = tree.comparator(data, node.data);\n\t\tif (c === 0) {\n\t\t\treturn node;\n\t\t} else {\n\t\t\tnode = node[c > 0];\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\r\n * Inserts a node with given data into the tree.\r\n */\nLlRbTree.insert = function (tree, data) {\n\ttree.root = insert(tree.root, data);\n\ttree.root.red = false;\n\n\tfunction insert(h, data) {\n\t\tif (h == null) {\n\t\t\treturn new Node(data);\n\t\t}\n\n\t\tif (Node.isRed(h[LEFT]) && Node.isRed(h[RIGHT])) {\n\t\t\tflipColors(h);\n\t\t}\n\n\t\tvar cmp = tree.comparator(data, h.data);\n\t\tif (cmp === 0) {\n\t\t\th.data = data;\n\t\t} else if (cmp < 0) {\n\t\t\th[LEFT] = insert(h[LEFT], data);\n\t\t} else {\n\t\t\th[RIGHT] = insert(h[RIGHT], data);\n\t\t}\n\n\t\tif (Node.isRed(h[RIGHT]) && !Node.isRed(h[LEFT])) {\n\t\t\th = rotate(LEFT, h);\n\t\t}\n\t\tif (Node.isRed(h[LEFT]) && Node.isRed(h[LEFT][LEFT])) {\n\t\t\th = rotate(RIGHT, h);\n\t\t}\n\n\t\treturn h;\n\t}\n};\n\nfunction rotate(dir, h) {\n\tvar x = h[!dir];\n\th[!dir] = x[dir];\n\tx[dir] = h;\n\tx.red = h.red;\n\th.red = true;\n\n\treturn x;\n}\n\nfunction flipColors(h) {\n\th.red = !h.red;\n\th[LEFT].red = !h[LEFT].red;\n\th[RIGHT].red = !h[RIGHT].red;\n}\n\nfunction moveRedLeft(h) {\n\tflipColors(h);\n\tif (Node.isRed(h[RIGHT][LEFT])) {\n\t\th[RIGHT] = rotate(RIGHT, h[RIGHT]);\n\t\th = rotate(LEFT, h);\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\nfunction moveRedRight(h) {\n\tflipColors(h);\n\tif (Node.isRed(h[LEFT][LEFT])) {\n\t\th = rotate(RIGHT, h);\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\n/**\r\n * Removes an item from the tree based on the given data (using ===). \r\n * \r\n * Note: Currently, a precondition is that the data must exist in the \r\n * tree. In the future we can easily modify the code to relax this \r\n * requirement. \r\n */\nLlRbTree.remove = function (tree, data) {\n\ttree.root = remove(tree.root, data);\n\tif (tree.root) {\n\t\ttree.root.red = false;\n\t}\n\n\tfunction remove(h, data) {\n\t\tif (tree.comparator(data, h.data) < 0) {\n\t\t\tif (!Node.isRed(h[LEFT]) && !Node.isRed(h[LEFT][LEFT])) {\n\t\t\t\th = moveRedLeft(h);\n\t\t\t}\n\t\t\th[LEFT] = remove(h[LEFT], data);\n\n\t\t\treturn fixUp(h);\n\t\t}\n\n\t\tif (Node.isRed(h[LEFT])) {\n\t\t\th = rotate(RIGHT, h);\n\t\t}\n\n\t\tif (!h[RIGHT] && tree.comparator(data, h.data) === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Node.isRed(h[RIGHT]) && !Node.isRed(h[RIGHT][LEFT])) {\n\t\t\th = moveRedRight(h);\n\t\t}\n\n\t\tif (tree.comparator(data, h.data) === 0) {\n\t\t\th.data = LlRbTree.min(h[RIGHT]);\n\t\t\th[RIGHT] = removeMin(h[RIGHT]);\n\t\t} else {\n\t\t\th[RIGHT] = remove(h[RIGHT], data);\n\t\t}\n\n\t\treturn fixUp(h);\n\t}\n\n\tfunction removeMin(h) {\n\t\tif (!h[LEFT]) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Node.isRed(h[LEFT]) && !Node.isRed(h[LEFT][LEFT])) {\n\t\t\th = moveRedLeft(h);\n\t\t}\n\t\th[LEFT] = removeMin(h[LEFT]);\n\n\t\treturn fixUp(h);\n\t}\n};\n\n/**\r\n * Fix right-leaning red nodes.\r\n */\nfunction fixUp(h) {\n\tif (Node.isRed(h[RIGHT])) {\n\t\th = rotate(LEFT, h);\n\t}\n\n\tif (Node.isRed(h[LEFT]) && Node.isRed(h[LEFT][LEFT])) {\n\t\th = rotate(RIGHT, h);\n\t}\n\n\t// Split 4-nodes.\n\tif (Node.isRed(h[LEFT]) && Node.isRed(h[RIGHT])) {\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\nmodule.exports = LlRbTree;\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = {\n\t\t// TODO - should be dynamic and of order of shape dimensions.\n\t\tmaxOsculatingCircleRadius: 800,\n\t\tpointType: {\n\t\t\t\t'standard': 0, // Not special,   \n\t\t\t\t'sharp': 1, // Sharp corner, \n\t\t\t\t'dull': 2, // dull corner,\n\t\t\t\t'extreme': 3 }\n};\n\nmodule.exports = MAT_CONSTANTS;\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\n//---- Constants\nvar MAT_CONSTANTS = require('./mat-constants.js');\n\n//---- Functions \nvar smoothen = require('./mat/functions/smoothen.js');\nvar findMat = require('./mat/functions/find-mat.js');\nvar toScaleAxis = require('./mat/functions/to-scale-axis.js');\n\n//---- Classes - can be instantiated\nvar Bezier = require('./geometry/classes/bezier.js');\nvar MatNode = require('./mat/classes/mat-node.js');\nvar Mat = require('./mat/classes/mat.js');\nvar MatCircle = require('./mat/classes/mat-circle.js');\nvar ContactPoint = require('./mat/classes/contact-point.js');\nvar getNodesAsArray = require('./mat/functions/get-nodes-as-array.js');\nvar PointOnShape = require('./geometry/classes/point-on-shape.js');\nvar LinkedLoop = require('./linked-loop/linked-loop.js');\nvar LlRbTree = require('./ll-rb-tree//ll-rb-tree.js');\nvar Shape = require('./geometry/classes/shape.js');\nvar Circle = require('./geometry/classes/circle.js');\nvar Svg = require('./svg/svg.js');\n\n//---- Namespaced utilities\nvar Geometry = require('./geometry/geometry.js');\nvar Util = require('./utils.js');\nvar Vector = require('./vector/vector.js');\nvar Poly = require('./polynomial/polynomial.js');\n\n//---- Expose our library to the global scope for browsers\n// See: http://www.mattburkedev.com/export-a-global-to-the-window-object-with-browserify/\n\nvar MatLib = window.MatLib || {};\n\nMatLib = Object.assign(MatLib, {\n\t// To be set by the user of the library if required.\n\t_debug_: undefined,\n\n\tfindMat: findMat,\n\tsmoothen: smoothen,\n\ttoScaleAxis: toScaleAxis,\n\n\tBezier: Bezier,\n\tMat: Mat,\n\tMatCircle: MatCircle,\n\tContactPoint: ContactPoint,\n\tPointOnShape: PointOnShape,\n\tLinkedLoop: LinkedLoop,\n\tLlRbTree: LlRbTree,\n\tShape: Shape,\n\tCircle: Circle,\n\tSvg: Svg,\n\n\tGeometry: Geometry,\n\tUtil: Util,\n\tVector: Vector,\n\tPoly: Poly,\n\n\tfs: {\n\t\tgetNodesAsArray: getNodesAsArray\n\t}\n});\n\n//Replace/Create the global namespace\nwindow.MatLib = MatLib;\n\n},{\"./geometry/classes/bezier.js\":4,\"./geometry/classes/circle.js\":5,\"./geometry/classes/point-on-shape.js\":6,\"./geometry/classes/shape.js\":7,\"./geometry/geometry.js\":12,\"./linked-loop/linked-loop.js\":13,\"./ll-rb-tree//ll-rb-tree.js\":15,\"./mat-constants.js\":16,\"./mat/classes/contact-point.js\":18,\"./mat/classes/mat-circle.js\":21,\"./mat/classes/mat-node.js\":22,\"./mat/classes/mat.js\":23,\"./mat/functions/find-mat.js\":30,\"./mat/functions/get-nodes-as-array.js\":31,\"./mat/functions/smoothen.js\":33,\"./mat/functions/to-scale-axis.js\":34,\"./polynomial/polynomial.js\":39,\"./svg/svg.js\":41,\"./utils.js\":42,\"./vector/vector.js\":43}],18:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Vector = require('../../vector/vector.js');\n\n/** \r\n * @description Class representing a single contact point of a MatCircle \r\n * instance. \r\n * @onstructor\r\n *\r\n * @param {PointOnShape} pointOnShape\r\n * @param {MatCircle} matCircle \r\n */\nfunction ContactPoint(pointOnShape, matCircle) {\n\tthis.pointOnShape = pointOnShape;\n\tthis.matCircle = matCircle;\n\tthis.key = PointOnShape.toHumanString(pointOnShape); // TODO\n\n\tthis[0] = pointOnShape[0]; // Shortcut\n\tthis[1] = pointOnShape[1]; // ...\n}\n\nContactPoint.compare = function (a, b) {\n\treturn PointOnShape.compare(a.pointOnShape, b.pointOnShape);\n};\n\nContactPoint.equal = function (a, b) {\n\treturn Vector.equal(a, b);\n};\n\nmodule.exports = ContactPoint;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"../../vector/vector.js\":43}],19:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../../geometry/classes/point-on-shape.js');\n\nfunction ThreeProngForDebugging(threeProng, deltas, bestIndx, candidateThreeProngs) {\n\n\tthis.threeProng = threeProng;\n\tthis.deltas = deltas;\n\tthis.bestIndx = bestIndx;\n\tthis.candidateThreeProngs = candidateThreeProngs;\n\n\tthis.deltasSimple = deltas.map(function (delta) {\n\t\treturn [PointOnShape.toHumanString(delta[0].item.pointOnShape), PointOnShape.toHumanString(delta[1].item.pointOnShape)];\n\t});\n}\n\nmodule.exports = ThreeProngForDebugging;\n\n},{\"../../../geometry/classes/point-on-shape.js\":6}],20:[function(require,module,exports){\n'use strict';\n\nfunction TwoProngForDebugging(pos, δ, y, z, x, circle, xs, failed, holeClosing) {\n\n\tthis.pos = pos;\n\tthis.δ = δ;\n\tthis.y = y;\n\tthis.z = z;\n\tthis.x = x;\n\tthis.circle = circle;\n\tthis.xs = xs;\n\tthis.failed = failed;\n\tthis.holeClosing = holeClosing;\n}\n\nmodule.exports = TwoProngForDebugging;\n\n},{}],21:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\n\n/**\r\n * Medial (or Scale) Axis Transform (MAT) maximal contact circle class, \r\n * i.e. a representative data point of the MAT.\r\n * \r\n * @constructor\r\n * @param {Circle} circle - If null we consider it a virtual circle.\r\n * @param {ListNode<ContactPoint>[]} cpNodes - The contact points of this circle on the shape.\r\n * @note Do not do 'new MatCircle', rather use 'MatCircle.create'.\r\n */\nfunction MatCircle(circle, cpNodes) {\n  this.circle = circle;\n  this.cpNodes = cpNodes;\n  this.visited = 0; // TODO - does not belong inside the class\n}\n\n/** \r\n * MatCircle creator.\r\n * @param {Circle} circle \r\n * @param {ListNode<ContactPoint>[]} cpNodes An array of 'orphaned' \r\n *        (i.e. without belonging to a MatCircle) contact points.\r\n * Notes: Due to the mutual dependency between the matCircle and \r\n * contactPoints fields, a normal constructor can not instantiate a\r\n * MatCircle in one step - hence this creator.\r\n */\nMatCircle.create = function (circle, cpNodes) {\n  var matCircle = new MatCircle(circle, undefined);\n\n  for (var i = 0; i < cpNodes.length; i++) {\n    cpNodes[i].item.matCircle = matCircle;\n  }\n  matCircle.cpNodes = cpNodes;\n\n  return matCircle;\n};\n\nmodule.exports = MatCircle;\n\n},{\"../../geometry/classes/circle.js\":5}],22:[function(require,module,exports){\n'use strict';\n\nvar MatCircle = require('./mat-circle.js');\n\n/**\r\n * @description Representation of a node in the MAT structure.\r\n * @constructor\r\n * @param {MatCircle} matCircle\r\n * @param branches\r\n * @returns\r\n */\nfunction MatNode(matCircle, branches) {\n\tthis.matCircle = matCircle;\n\tthis.branches = branches;\n}\n\nMatNode.copy = function (node) {\n\n\treturn helper(node, undefined);\n\n\tfunction helper(matNode, priorNode, newPriorNode) {\n\n\t\tvar branches = [];\n\t\tvar newNode = new MatNode(matNode.matCircle, branches);\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar _node = _step.value;\n\n\t\t\t\tif (_node === priorNode) {\n\t\t\t\t\t// Don't go back in tracks.\n\t\t\t\t\tbranches.push(newPriorNode);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbranches.push(helper(_node, matNode, newNode));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newNode;\n\t}\n};\n\nmodule.exports = MatNode;\n\n},{\"./mat-circle.js\":21}],23:[function(require,module,exports){\n'use strict';\n\nvar traverse = require('../../mat/functions/traverse.js');\n\n/**\r\n * @description The Mat class represents the end product, the Medial  \r\n * Axis Transform. It is defined recursively as a rooted tree with   \r\n * each node containing a point, a radius and 1, 2 or 3 branches.\r\n * \r\n * @constructor\r\n * @param {MatNode} node - A handle on the MAT tree structure.\r\n */\nfunction Mat(node) {\n  this.startNode = node;\n}\n\nMat = Object.assign(Mat, {\n  traverse: traverse\n});\n\nmodule.exports = Mat;\n\n},{\"../../mat/functions/traverse.js\":35}],24:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar MatCircle = require('../../mat/classes/mat-circle.js');\nvar Shape = require('../../geometry/classes/shape.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n * \r\n * @param shape Shape to add the 2-prong to\r\n * @param circle Circle containing the 2 contact points\r\n * @param {ListNode<ContactPoint>} cp1 - First point\r\n * @param {PointOnShape} pos2 - Second point\r\n * @param delta The boundary piece within which the new contact point should be placed\r\n */\nfunction add2Prong(shape, circle, pos1, pos2, holeClosing) {\n\n\tif (holeClosing) {\n\t\tpos1.order2 = 1;\n\t\tpos2.order2 = -1;\n\t}\n\n\tvar cp2 = new ContactPoint(pos2, undefined);\n\tvar delta2 = Shape.getNeighbouringPoints(shape, pos2);\n\tvar cmp3 = delta2[0] === undefined ? undefined : ContactPoint.compare(delta2[0].item, cp2);\n\tvar cmp4 = delta2[1] === undefined ? undefined : ContactPoint.compare(cp2, delta2[1].item);\n\tif (MatLib._debug_) {\n\t\tif (cmp3 > 0 || cmp4 > 0) {\n\t\t\t//console.log(`2-PRONG 2 Order is wrong 2: ${cmp3}, ${cmp4}`);\n\t\t}\n\t}\n\tif (cmp3 === 0 || cmp4 === 0) {\n\t\t// Should not really be possible with hole-closing 2-prongs.\n\t\treturn undefined;\n\t}\n\tvar k2 = pos2.bezierNode.loop.indx;\n\tvar newCp2Node = LinkedLoop.insert(shape.contactPointsPerLoop[k2], cp2, delta2[0]);\n\n\tvar cp1 = new ContactPoint(pos1, undefined);\n\tvar delta1 = Shape.getNeighbouringPoints(shape, pos1);\n\tvar cmp1 = delta1[0] === undefined ? undefined : ContactPoint.compare(delta1[0].item, cp1);\n\tvar cmp2 = delta1[1] === undefined ? undefined : ContactPoint.compare(cp1, delta1[1].item);\n\tif (MatLib._debug_) {\n\t\tif (cmp1 > 0 || cmp2 > 0) {\n\t\t\t//console.log(`2-PRONG 1 Order is wrong 2: ${cmp1}, ${cmp2}`);\n\t\t}\n\t}\n\t// If they are so close together, don't add it - there's already 1\n\tif (cmp1 === 0 || cmp2 === 0) {\n\t\t// Should not be possible with hole-closing 2-prongs.\n\t\tLinkedLoop.remove(shape.contactPointsPerLoop[k2], newCp2Node);\n\t\treturn undefined;\n\t}\n\tvar k1 = pos1.bezierNode.loop.indx;\n\tvar newCp1Node = LinkedLoop.insert(shape.contactPointsPerLoop[k1], cp1, delta1[0]);\n\n\tvar matCircle = MatCircle.create(circle, [newCp1Node, newCp2Node]);\n\n\tnewCp1Node.prevOnCircle = newCp2Node;\n\tnewCp1Node.nextOnCircle = newCp2Node;\n\n\tnewCp2Node.prevOnCircle = newCp1Node;\n\tnewCp2Node.nextOnCircle = newCp1Node;\n\n\tif (holeClosing) {\n\t\tvar posA1 = pos2;\n\t\tvar posB2 = PointOnShape.copy(posA1);\n\t\tposB2.order2 = 1;\n\t\tvar cpB2 = new ContactPoint(posB2, undefined);\n\t\tvar newCpB2Node = LinkedLoop.insert(shape.contactPointsPerLoop[k2], cpB2, newCp2Node);\n\n\t\tvar posA2 = pos1;\n\t\tvar posB1 = PointOnShape.copy(posA2);\n\t\tposB1.order2 = -1;\n\t\tvar cpB1 = new ContactPoint(posB1, undefined);\n\t\tvar newCpB1Node = LinkedLoop.insert(shape.contactPointsPerLoop[k1], cpB1, newCp1Node.prev);\n\n\t\tMatCircle.create(circle, [newCpB1Node, newCpB2Node]);\n\n\t\tnewCpB1Node.prevOnCircle = newCpB2Node;\n\t\tnewCpB1Node.nextOnCircle = newCpB2Node;\n\t\tnewCpB2Node.prevOnCircle = newCpB1Node;\n\t\tnewCpB2Node.nextOnCircle = newCpB1Node;\n\n\t\tnewCp2Node.next = newCp1Node;\n\t\tnewCp1Node.prev = newCp2Node;\n\n\t\tnewCpB1Node.next = newCpB2Node;\n\t\tnewCpB2Node.prev = newCpB1Node;\n\t}\n\n\tif (MatLib._debug_) {\n\t\t// Add points so when we alt-click shape point is logged.\n\t\tprepForDebug(newCp1Node);\n\t\tprepForDebug(newCp2Node);\n\t}\n\n\treturn;\n}\n\nfunction prepForDebug(contactPoint) {\n\t//---- Prepare debug info for the ContactPoint\n\tvar cpKey = PointOnShape.makeSimpleKey(contactPoint.item.pointOnShape);\n\tvar cpHash = MatLib._debug_.generated.cpHash;\n\tvar cpArr = MatLib._debug_.generated.cpArr;\n\tif (!cpHash[cpKey]) {\n\t\tcpHash[cpKey] = {\n\t\t\tcp: contactPoint,\n\t\t\tarrIndx: cpArr.length\n\t\t};\n\t\tcpArr.push(contactPoint);\n\t}\n\n\tvar cpHashDebugObj = cpHash[cpKey];\n\n\tcpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\n\nmodule.exports = add2Prong;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/classes/shape.js\":7,\"../../linked-loop/linked-loop.js\":13,\"../../mat/classes/contact-point.js\":18,\"../../mat/classes/mat-circle.js\":21}],25:[function(require,module,exports){\n'use strict';\n\nvar MatCircle = require('../../mat/classes/mat-circle.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\n\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given \r\n * (previously calculated) points on the shape. \r\n * \r\n * @param shape\r\n * @param circle\r\n * @param [p1,p2,p3]\r\n * @param deltas\r\n * @returns {MatCircle} matCircle\r\n */\nfunction add3Prong(shape, threeProng) {\n\tvar circle = threeProng.circle,\n\t    ps = threeProng.ps,\n\t    delta3s = threeProng.delta3s;\n\n\n\tvar cps = [0, 1, 2].map(function (i) {\n\t\treturn new ContactPoint(ps[i], undefined);\n\t});\n\n\tif (MatLib._debug_) {\n\t\t// Keep for possible future debugging.\n\t\t/*\r\n  for (let i=0; i<3; i++) {\r\n  \tlet cmpBef = ContactPoint.compare(delta3s[i][0].item, cps[i]);\r\n  \tlet cmpAft = ContactPoint.compare(delta3s[i][1].item, cps[i]); \r\n  \t\t\tlet len = MatLib._debug_.generated.threeProngs.length-1; // Used by debug functions to reference a particular three-prong\r\n  \tif (cmpBef > 0) {\r\n  \t\tconsole.log(`3-PRONG Order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n  \t\tconsole.log(threeProng);\r\n  \t}\r\n  \tif (cmpAft < 0) {\r\n  \t\tconsole.log(`3-PRONG Order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n  \t\tconsole.log(threeProng);\r\n  \t}\r\n  }\r\n  */\n\t}\n\n\tvar cpNodes = [];\n\tfor (var i = 0; i < 3; i++) {\n\t\tvar pos = ps[i];\n\t\tvar k = pos.bezierNode.loop.indx;\n\t\tcpNodes.push(LinkedLoop.insert(shape.contactPointsPerLoop[k], cps[i], delta3s[i][0]));\n\t}\n\n\tvar matCircle = MatCircle.create(circle, cpNodes);\n\n\tvar idxsPrev = [2, 0, 1];\n\tvar idxsNext = [1, 2, 0];\n\tfor (var _i = 0; _i < 3; _i++) {\n\t\tcpNodes[_i].prevOnCircle = cpNodes[idxsPrev[_i]];\n\t\tcpNodes[_i].nextOnCircle = cpNodes[idxsNext[_i]];\n\t}\n\n\treturn matCircle;\n}\n\nmodule.exports = add3Prong;\n\n},{\"../../linked-loop/linked-loop.js\":13,\"../../mat/classes/contact-point.js\":18,\"../../mat/classes/mat-circle.js\":21}],26:[function(require,module,exports){\n'use strict';\n\nvar find3Prong = require('./find-3-prong.js');\nvar add3Prong = require('./add-3-prong.js');\nvar MatNode = require('../../mat/classes/mat-node.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\n/**\r\n * Recursively builds the MAT tree.\r\n * \r\n * @param {ListNode<ContactPoint>} cpNodeStart\r\n * @returns {MatNode}\r\n */\nfunction buildMat(shape, cpNodeStart, fromNode, fromCpNode, isRetry) {\n\n\tvar visitedPoints = void 0;\n\tdo {\n\t\tvisitedPoints = traverseShape(cpNodeStart);\n\t\tif (MatLib._debug_) {\n\t\t\t// Oops - fix\n\t\t\t// cpHashDebugObj.visitedPointsArr.push(visitedPoints);\n\t\t}\n\n\t\tif (visitedPoints.length > 2) {\n\t\t\tfindAndAdd3Prong(shape, visitedPoints);\n\t\t}\n\t} while (visitedPoints.length > 2);\n\n\tif (cpNodeStart.item.matCircle.cpNodes.length === 1) /*&&\r\n                                                      (fromCpNode.nextOnCircle === cpNodeStart.next)*/{\n\n\t\t\t//console.log('terminal 1-prong');\n\n\t\t\tvar matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n\t\t\treturn matNode;\n\t\t}\n\n\tif (visitedPoints.length === 1) {\n\t\t// Terminating 2-prong - should mostly have been eliminated\n\t\t// by osculating circles and points, but can still occur\n\t\t// due to floating point incaccuracies.\n\n\t\t// console.log('terminal 2-prong');\n\n\t\tvar _matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : []);\n\n\t\treturn _matNode;\n\t} else if (visitedPoints.length === 2) {\n\n\t\tvar branches = fromNode ? [fromNode] : [];\n\t\tvar _matNode2 = createMatNode(cpNodeStart, branches);\n\n\t\tvar cpBranches = cpNodeStart;\n\t\tvar i = 0;\n\t\twhile (cpBranches.nextOnCircle !== cpNodeStart && cpBranches.next !== cpBranches.nextOnCircle) {\n\n\t\t\ti++;\n\n\t\t\tvar cpNext = void 0;\n\t\t\tif (i === 1) {\n\t\t\t\tcpNext = cpBranches.next;\n\t\t\t\tcpNodeStart.item.matCircle.visited++;\n\t\t\t} else if (i === 2) {\n\t\t\t\t// TODO - instead of the commented line below working\n\t\t\t\t// perfectly, we must call the few lines below it and\n\t\t\t\t// then later call fixMat. WHY!!!??? does the line\n\t\t\t\t// below not simply work?\n\t\t\t\t// cpNext = cpBranches.next;\n\t\t\t\tcpNext = cpBranches;\n\t\t\t\tif (cpBranches.item.matCircle.visited !== 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar bm = buildMat(shape, cpNext, _matNode2, cpBranches, false);\n\n\t\t\tbranches.push(bm);\n\n\t\t\tcpBranches = cpBranches.nextOnCircle;\n\t\t}\n\n\t\treturn _matNode2;\n\t}\n}\n\nfunction createMatNode(cp, branches) {\n\tvar matNode = new MatNode(cp.item.matCircle, branches);\n\n\tif (MatLib._debug_) {\n\t\tprepDebugHashes(cp, matNode);\n\t}\n\n\treturn matNode;\n}\n\nfunction traverseShape(cpNodeStart) {\n\tvar visitedPoints = void 0;\n\tvar cpNode = cpNodeStart;\n\n\tvisitedPoints = [];\n\tdo {\n\t\t//if ()\n\t\tvisitedPoints.push(cpNode);\n\n\t\tvar next = cpNode.next;\n\t\tcpNode = next.prevOnCircle; // Take last exit\n\t} while (cpNode !== cpNodeStart);\n\n\treturn visitedPoints;\n}\n\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * \r\n * @param {Shape}\r\n *            shape\r\n * @param {[ListNode\r\n *            <ContactPoint>]} visitedPoints\r\n * @returns\r\n * \r\n * MODIFIES: shape\r\n */\nfunction findAndAdd3Prong(shape, visitedPoints) {\n\t/*\r\n  * visitedPoints.sort(function(a,b) { return\r\n  * PointOnShape.compare(a.item.pointOnShape,b.item.pointOnShape); });\r\n  */\n\n\tvar deltas = [];\n\tfor (var i = 0; i < visitedPoints.length; i++) {\n\t\tvar visitedPoint = visitedPoints[i];\n\t\tdeltas.push([visitedPoint, visitedPoint.next]);\n\t}\n\n\t// Check if any deltas are continuous (they should rather be\n\t// disjoint). It should be quite safe to consider points 'equal'\n\t// if they are within a certain threshold of each other, but is it\n\t// necessary? Maybe not.\n\tvar continuous = false;\n\tfor (var _i = 0; _i < deltas.length; _i++) {\n\t\tvar idxi = _i + 1;\n\t\tif (idxi === deltas.length) {\n\t\t\tidxi = 0;\n\t\t}\n\n\t\tvar endP = deltas[_i][1].item;\n\t\tvar startP = deltas[idxi][0].item;\n\t\tif (ContactPoint.equal(endP, startP)) {\n\t\t\tcontinuous = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (continuous) {\n\t\t// aaa\n\t}\n\n\tvar threeProng = find3Prong(shape, deltas);\n\n\tfor (var _i2 = 0; _i2 < 3; _i2++) {\n\t\tPointOnShape.setPointOrder(shape, threeProng.circle, threeProng.ps[_i2]);\n\t}\n\n\tadd3Prong(shape, threeProng);\n}\n\nfunction prepDebugHashes(cpNodeStart, matNode) {\n\t// ---- Prepare debug info for the MatCircle\n\tvar circle = cpNodeStart.item.matCircle.circle;\n\tvar key = PointOnShape.makeSimpleKey(circle.center);\n\tvar nodeHash = MatLib._debug_.generated.nodeHash;\n\tnodeHash[key] = nodeHash[key] || {};\n\tnodeHash[key].matNode = matNode;\n\n\t// ---- Prepare debug info for the ContactPoint\n\tvar cpKey = PointOnShape.makeSimpleKey(cpNodeStart.item.pointOnShape);\n\tvar cpHash = MatLib._debug_.generated.cpHash;\n\tvar cpArr = MatLib._debug_.generated.cpArr;\n\tif (!cpHash[cpKey]) {\n\t\tcpHash[cpKey] = {\n\t\t\tcp: cpNodeStart,\n\t\t\tarrIndx: cpArr.length\n\t\t};\n\t\tcpArr.push(cpNodeStart);\n\t}\n\n\tvar cpHashDebugObj = cpHash[cpKey];\n\tcpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\n\nmodule.exports = buildMat;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"../../mat/classes/contact-point.js\":18,\"../../mat/classes/mat-node.js\":22,\"./add-3-prong.js\":25,\"./find-3-prong.js\":29}],27:[function(require,module,exports){\n'use strict';\n\nvar MatNode = require('../../mat/classes/mat-node.js');\nvar Mat = require('../classes/mat.js');\n\nfunction copyMat(mat) {\n\treturn new Mat(MatNode.copy(mat.startNode));\n}\n\nmodule.exports = copyMat;\n\n},{\"../../mat/classes/mat-node.js\":22,\"../classes/mat.js\":23}],28:[function(require,module,exports){\n'use strict';\n\nvar MAX_ITERATIONS = 50;\n//TODO Change tolerances to take shape dimension into \n// account, e.g. shapeDim / 10000 for SEPERATION_TOLERANCE;\n//CONST SEPERATION_TOLERANCE = 1e-3;\nvar SEPERATION_TOLERANCE = 1e-3;\nvar SQUARED_SEPERATION_TOLERANCE = SEPERATION_TOLERANCE * SEPERATION_TOLERANCE;\nvar _1PRONG_TOLERANCE = 1e-4;\nvar SQUARED_1PRONG_TOLERANCE = _1PRONG_TOLERANCE * _1PRONG_TOLERANCE;\n\n//const ERROR_TOLERANCE = 1e-3;\nvar ERROR_TOLERANCE = SEPERATION_TOLERANCE / 10;\nvar SQUARED_ERROR_TOLERANCE = ERROR_TOLERANCE * ERROR_TOLERANCE;\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar Bezier = require('../../geometry/classes/bezier.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar Shape = require('../../geometry/classes/shape.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar Vector = require('../../vector/vector.js');\nvar PointOnShape = require('../../geometry/classes/Point-on-shape.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar MatCircle = require('../../mat/classes/mat-circle.js');\n\nvar getClosestBoundaryPointToPoint = require('../../geometry/functions/get-closest-boundary-point-to-point.js');\nvar TwoProngForDebugging = require('../classes/debug/two-prong-for-debugging.js');\n\n/**\r\n * Adds a 2-prong to the MAT. The first point is given and the second\r\n * one is found by the algorithm.\r\n * \r\n * A 2-prong is a MAT circle that touches the shape in 2 points.\r\n * \r\n * @param shape\r\n * @param {PointOnShape} y - The first point of the 2-prong.\r\n * \r\n * Before any 2-prongs are added the entire shape is our d-Omega δΩ\r\n * (1-prongs does not reduce the boundary),\r\n * \r\n * As per the paper by Choi, Choi, Moon and Wee: \r\n *   \"The starting point of this algorithm is a choice of a circle\r\n *    Br(x) centered at an interior point x which contains two boundary\r\n *    portions c and d of d-Omega as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary\r\n * beforehand. \r\n */\nvar iii = 0;\nfunction find2Prong(shape, y, holeClosing) {\n\n\t/* The failed flag is set if a 2-prong cannot be found. This occurs\r\n  * when the 2 points are too close together and the 2-prong \r\n  * becomes, in the limit, a 1-prong. We do not want these 2-prongs\r\n  * as they push the floating point precision limits when finding\r\n  * their circle center causing too much inaccuracy. Of course, our\r\n  * entire algorithm's precision is limited by floating point \r\n  * doubles.\r\n  */\n\tvar failed = false;\n\n\t// The first point on the shape of the 2-prong.\n\t//let y = pos;\n\tvar bezierNode = y.bezierNode;\n\tvar t = y.t;\n\tvar oCircle = PointOnShape.getOsculatingCircle(y);\n\tvar x = oCircle.center;\n\n\t/* \r\n  * The shortest distance so far between the first contact point and\r\n  * the circle center - we require this to get shorter on each \r\n  * iteration as convergence occurs. If it does not, oscillation\r\n  * of the algorithm has occured due to floating point inaccuracy\r\n  * and the algorithm must terminate.\r\n  */\n\tvar radius = oCircle.radius;\n\tvar shortestSquaredDistance = radius * radius;\n\n\t/* The boundary piece that should contain the other point of \r\n  * the 2-prong circle. (Defined by start and end points).\r\n  */\n\tvar δ = void 0;\n\tvar bezierPieces = void 0;\n\tvar k = y.bezierNode.loop.indx;\n\tif (holeClosing) {\n\t\tbezierPieces = [];\n\t\tfor (var k2 = 0; k2 < k; k2++) {\n\t\t\tvar pieces = Shape.getBoundaryBeziers(shape, k2);\n\t\t\tArray.prototype.push.apply(bezierPieces, pieces);\n\t\t}\n\t} else {\n\t\t// TODO - getNeighbouringPoints *can* be eliminated (as with 3-prongs)\n\t\t// by keeping track of boundary piece in which is being searched \n\t\t// - not sure if same can be done with hole-closing 2-prongs.\n\t\tvar ps = Shape.getNeighbouringPoints(shape, y);\n\t\tδ = [ps[0], ps[0]];\n\t\tbezierPieces = Shape.getBoundaryPieceBeziers(δ);\n\t}\n\n\tvar xs = []; // Trace the convergence.\n\tvar z = void 0;\n\tvar squaredError = void 0;\n\tvar i = 0;\n\tiii++;\n\tdo {\n\t\ti++;\n\n\t\tvar r = Vector.squaredDistanceBetween(x, y);\n\t\tif (iii === 28) {\n\t\t\t//console.log('a');\n\t\t}\n\t\tbezierPieces = cullBezierPieces(bezierPieces, x, r);\n\n\t\tz = getClosestBoundaryPointToPoint(bezierPieces, x, bezierNode, t);\n\t\tif (!z) {\n\t\t\tconsole.log(iii);\n\t\t}\n\n\t\tif (MatLib._debug_) {\n\t\t\txs.push({ x: x, y: y, z: z, t: t });\n\t\t}\n\n\t\tvar d = Vector.squaredDistanceBetween(x, z);\n\t\tif (i === 1 && d + SQUARED_1PRONG_TOLERANCE >= r) {\n\t\t\t// It is a 1-prong\n\t\t\tadd1Prong(shape, y); // TODO Refactor - adding a 1-prong in a function called 2-prong!?\n\t\t\t//console.log('1-prong added')\n\t\t\t// set point order (if dull corner!)\n\t\t\treturn undefined; // TODO - not pretty - so that we don't add it as a 2-prong\n\t\t}\n\n\t\tvar squaredChordDistance = Vector.squaredDistanceBetween(y, z);\n\t\tif (squaredChordDistance <= SQUARED_SEPERATION_TOLERANCE) {\n\t\t\tfailed = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\r\n   * Find the point on the line connecting y with x that is  \r\n   * equidistant from y and z. This will be our next x.\r\n   */\n\t\tvar nextX = findEquidistantPointOnLine(x, y, z);\n\n\t\tsquaredError = Vector.squaredDistanceBetween(x, nextX);\n\n\t\t/*\r\n   * Prevent oscillation of calculated x (due to floating point\r\n   * inaccuracies). See comment above decleration of \r\n   * shortestSquaredDistance.\r\n   */\n\t\tvar squaredDistance = Vector.squaredDistanceBetween(y, nextX);\n\t\tif (squaredDistance < shortestSquaredDistance) {\n\t\t\tshortestSquaredDistance = squaredDistance;\n\t\t} else {\n\t\t\t//failed = true;\n\t\t\t//break;\n\t\t}\n\n\t\tx = nextX;\n\n\t\t//if (MatLib._debug_) { xs.push({ x, y, z, t });\t}\n\t} while (squaredError > SQUARED_ERROR_TOLERANCE && i < MAX_ITERATIONS);\n\tif (MatLib._debug_) {\n\t\txs.push({ x: x, y: y, z: z, t: t });\n\t}\n\n\tif (i === MAX_ITERATIONS) {\n\t\t// This is simply a case of convergence being too slow. The\n\t\t// gecko, for example, takes a max of 21 iterations.\n\t\t//console.log('max')\n\t\tfailed = true;\n\t}\n\n\tvar circle = new Circle(x, Vector.distanceBetween(x, z));\n\n\tPointOnShape.setPointOrder(shape, circle, y);\n\tPointOnShape.setPointOrder(shape, circle, z);\n\n\tif (MatLib._debug_) {\n\t\trecordForDebugging(failed, y, circle, y, z, δ, xs, holeClosing);\n\t}\n\n\tif (failed) {\n\t\t//console.log('failed');\n\t\treturn undefined;\n\t}\n\n\treturn { circle: circle, z: z };\n}\n\nfunction add1Prong(shape, pos) {\n\tif (pos.type === MAT_CONSTANTS.pointType.dull) {\n\t\t// This is a 1-prong at a dull corner.\n\n\t\t/* TODO IMPORTANT remove this line, uncomment piece below \r\n   * it and implement the following strategy to find the \r\n   * 3-prongs: if deltas are conjoined due to dull corner, \r\n   * split the conjoinment by inserting successively closer \r\n   * (binary division) 2-prongs. If a 2-prong actually fails, \r\n   * simply remove the 1-prong at the dull corner.\r\n   * \r\n   * In this way **all** terminal points are found, e.g.\r\n   * zoom in on top left leg of ant.\r\n   */\n\t\t//console.log(posNode);\n\t\t//toRemove.push(posNode); /* this */\n\n\t\tif (MatLib._debug_) {\n\t\t\t// TODO - why would it be NaN in some cases?\n\t\t\tvar oCircle = PointOnShape.getOsculatingCircle(pos);\n\t\t\tif (!Number.isNaN(oCircle.center[0])) {\n\t\t\t\tMatLib._debug_.generated.oneProngsAtDullCorner.push({ pos: pos });\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tvar cp = new ContactPoint(pos, undefined);\n\tvar delta = Shape.getNeighbouringPoints(shape, pos);\n\tvar cmp1 = ContactPoint.compare(delta[0].item, cp);\n\tvar cmp2 = ContactPoint.compare(cp, delta[1].item);\n\tif (MatLib._debug_) {\n\t\tif (cmp1 > 0 || cmp2 > 0) {\n\t\t\t//console.log(`1-PRONG Order is wrong: ${cmp1}, ${cmp2}`);\n\t\t}\n\t}\n\t// If they are so close together, don't add it - there's already 1\n\tif (cmp1 === 0 || cmp2 === 0) {\n\t\treturn;\n\t}\n\tvar k = pos.bezierNode.loop.indx;\n\tvar newCpNode = LinkedLoop.insert(shape.contactPointsPerLoop[k], cp, delta[0]);\n\n\tvar matCircle = MatCircle.create(\n\t//pos.osculatingCircle,\n\tPointOnShape.getOsculatingCircle(pos), [newCpNode]);\n\n\tnewCpNode.prevOnCircle = newCpNode; // Trivial loop\n\tnewCpNode.nextOnCircle = newCpNode; // ...\n\n\tif (MatLib._debug_) {\n\t\tMatLib._debug_.generated.oneProngs.push({ pos: pos });\n\t}\n\n\treturn;\n}\n\nfunction recordForDebugging(failed, pos, circle, y, z, δ, xs, holeClosing) {\n\n\tvar twoProngForDebugging = new TwoProngForDebugging(pos, δ, y, z, circle.center, circle, xs, failed, holeClosing);\n\n\tMatLib._debug_.generated.twoProngs.push(twoProngForDebugging);\n}\n\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * \r\n * @param {BezierPieces} bezierPieces\r\n * @param {[Number]} p\r\n * @param {Number} r\r\n * @returns\r\n */\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\n\tvar CULL_THRESHOLD = 5;\n\n\tif (bezierPieces.length <= CULL_THRESHOLD) {\n\t\treturn bezierPieces;\n\t}\n\n\tvar newPieces = [];\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar bezierPiece = _step.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\t//let rect = bezier.getBoundingBox();\n\t\t\tvar rect = Bezier.getBoundingBox(bezier);\n\t\t\tvar bd = Geometry.getClosestSquareDistanceToRect(rect, p);\n\t\t\tif (bd <= rSquared + 0.1 /* Make this in relation to shape extents!*/) {\n\t\t\t\t\tnewPieces.push(bezierPiece);\n\t\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPieces;\n}\n\n/**\r\n * \r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from\r\n *          y and z. \r\n *          \r\n * Notes: It is important that this function is numerically stable,\r\n * but this has not been investigated properly yet.\r\n */\nfunction findEquidistantPointOnLine(x, y, z) {\n\t// Some basic algebra (not shown) finds the required point.\n\n\t// Swap axis if x and y are more aligned to y-axis than to x-axis.\n\tvar swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\n\n\t// Cache\n\tvar x1 = void 0,\n\t    x2 = void 0,\n\t    y1 = void 0,\n\t    y2 = void 0,\n\t    z1 = void 0,\n\t    z2 = void 0;\n\n\tif (swapAxes) {\n\t\tx1 = x[1];x2 = x[0];\n\t\ty1 = y[1];y2 = y[0];\n\t\tz1 = z[1];z2 = z[0];\n\t} else {\n\t\tx1 = x[0];x2 = x[1];\n\t\ty1 = y[0];y2 = y[1];\n\t\tz1 = z[0];z2 = z[1];\n\t}\n\n\t// a <= 1 (due to swapped axes)\n\tvar a = (x2 - y2) / (x1 - y1);\n\tvar b = y2 - a * y1;\n\tvar c = y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2 + 2 * b * (z2 - y2);\n\tvar d = y1 - z1 + a * (y2 - z2);\n\tvar t1 = c / (2 * d);\n\tvar t2 = a * t1 + b;\n\n\treturn swapAxes ? [t2, t1] : [t1, t2];\n}\n\nmodule.exports = find2Prong;\n\n// 318\n\n},{\"../../geometry/classes/Point-on-shape.js\":1,\"../../geometry/classes/bezier.js\":4,\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/shape.js\":7,\"../../geometry/functions/get-closest-boundary-point-to-point.js\":10,\"../../geometry/geometry.js\":12,\"../../linked-loop/linked-loop.js\":13,\"../../mat-constants.js\":16,\"../../mat/classes/contact-point.js\":18,\"../../mat/classes/mat-circle.js\":21,\"../../vector/vector.js\":43,\"../classes/debug/two-prong-for-debugging.js\":20}],29:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Util = require('../../utils.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar Vector = require('../../vector/vector.js');\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar Bezier = require('../../geometry/classes/bezier.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Shape = require('../../geometry/classes/shape.js');\n\nvar getClosestBoundaryPointToPoint = require('../../geometry/functions/get-closest-boundary-point-to-point.js');\nvar ThreeProngForDebugging = require('../classes/debug/three-prong-for-debugging.js');\n\n/**\r\n * Look for a 3-prong from the given walked boundary piece.\r\n *\r\n * @param {Shape} shape\r\n * @param {ContactPoint[][]} δs\r\n * \r\n */\nfunction find3Prong(shape, δs) {\n\n\tvar bezierPiecess = δs.map(function (δ) {\n\t\t//MatLib._debug_.draw.crossHair(δ[0].item, 'nofill thin50 green', 1.5);\n\t\t//MatLib._debug_.draw.crossHair(δ[1].item, 'nofill thin50 green', 1.9);\n\t\t//console.log(δ)\n\n\t\treturn Shape.getBoundaryPieceBeziers(δ);\n\t});\n\n\tvar candidateThreeProngs = [];\n\n\t// The best candidate amongst the different 'permutations' of the\n\t// given δs.\n\tvar threeProng = void 0;\n\tvar bestIndx = undefined;\n\tvar smallestError = Number.POSITIVE_INFINITY;\n\tfor (var i = 1; i < δs.length - 1; i++) {\n\t\tvar _find3ProngForDelta3s = find3ProngForDelta3s(shape, δs, i, bezierPiecess),\n\t\t    circle = _find3ProngForDelta3s.circle,\n\t\t    ps = _find3ProngForDelta3s.ps,\n\t\t    error = _find3ProngForDelta3s.error;\n\n\t\tif (MatLib._debug_) {\n\t\t\tcandidateThreeProngs.push({ circle: circle, ps: ps });\n\t\t}\n\n\t\tif (error < smallestError) {\n\t\t\tsmallestError = error;\n\n\t\t\tbestIndx = i - 1;\n\t\t\tthreeProng = { circle: circle, ps: ps };\n\t\t}\n\t}\n\n\t/*\r\n if (MatLib._debug_ && MatLib._debug_.log) { \r\n \tif (smallestError > 0.01) {\r\n \t\tconsole.log('%c' + smallestError, 'color: #f00');\t\r\n \t} else {\r\n \t\tconsole.log(smallestError);\r\n \t} \r\n }\r\n */\n\n\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log('====================='); }\n\n\t//-------------------------------------\n\t//---- Add some additional properties\n\t//-------------------------------------\n\tvar delta3s = [δs[0], δs[bestIndx + 1], δs[δs.length - 1]];\n\tthreeProng.delta3s = delta3s;\n\t//-------------------------------------\n\n\n\tif (MatLib._debug_) {\n\t\tvar threeProngForDebugging = new ThreeProngForDebugging(threeProng, δs, bestIndx, candidateThreeProngs);\n\n\t\tMatLib._debug_.generated.threeProngs.push(threeProngForDebugging);\n\t}\n\n\treturn threeProng;\n}\n\n/**\r\n * Finds a 3-prong using only the 3 given delta's.\r\n * \r\n * @param i - Specific delta indx.\r\n * @returns\r\n */\nfunction find3ProngForDelta3s(shape, deltas, idx, bezierPiecess) {\n\n\t// TODO - Choose a tolerance relative to shape size.\n\tvar TOLERANCE = 1e-7;\n\n\tvar delta3s = [deltas[0], deltas[idx], deltas[deltas.length - 1]];\n\n\tvar bezierPiece3s = [bezierPiecess[0], bezierPiecess[idx], bezierPiecess[deltas.length - 1]];\n\n\tvar ps = void 0;\n\tvar circumCenter = void 0;\n\tvar ii = 0; // Safeguard\n\tvar x = calcInitial3ProngPoint(shape, delta3s, bezierPiece3s);\n\tvar tolerance = Number.POSITIVE_INFINITY;\n\t// TODO 10 below is magic, fix or add somewhere as a constant\n\twhile (tolerance > TOLERANCE && ii < 10) {\n\t\tii++;\n\n\t\tps = getClosestPoints(x, bezierPiece3s);\n\t\tcircumCenter = Vector.circumCenter(ps);\n\n\t\tvar vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter);\n\t\t//let vectorToZeroV = calcVectorToZeroV_AlongMedial (x, circumCenter, ps);\n\n\t\tvar upds = calcBetterX(bezierPiece3s, x, vectorToZeroV);\n\t\tx = upds.newX;\n\n\t\tvar V = Vector.length(vectorToZeroV);\n\t\tps = upds.newPs;\n\n\t\ttolerance = Math.abs(V - upds.newV);\n\t}\n\n\tvar radius = (Vector.distanceBetween(x, ps[0]) + Vector.distanceBetween(x, ps[1]) + Vector.distanceBetween(x, ps[2])) / 3;\n\n\tvar circle = new Circle(x, radius);\n\n\t//-----------------------------------------------------------------\n\t// Calculate the unit tangent vector at 3-prong circle points -\n\t// they should be very close to tangent to the boundary piece \n\t// tangents at those points (up to sign). Sharp corners are a\n\t// common special case.\n\t//-----------------------------------------------------------------\n\tvar totalAngleError = 0;\n\tfor (var i = 0; i < 3; i++) {\n\t\tvar p = ps[i];\n\t\t//----------------------------\n\t\t// Tangent of circle at point\n\t\t//----------------------------\n\t\tvar vv = Vector.toUnitVector(Vector.fromTo(p, x));\n\t\tvar v1 = Vector.rotateBy90Degrees(vv);\n\n\t\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log(p); }\n\n\t\t//-----------------------------------\n\t\t// Check if point is on dull crorner\n\t\t//-----------------------------------\n\t\tvar key = PointOnShape.makeSimpleKey(p);\n\t\tvar dullCorner = shape.dullCornerHash[key];\n\t\tif (dullCorner) {\n\t\t\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log(dullCorner); }\n\n\t\t\tvar tans = dullCorner.tans;\n\t\t\tvar perps = tans.map(Vector.rotateBy90Degrees);\n\n\t\t\tif (MatLib._debug_ && MatLib._debug_.log) {}\n\n\t\t\t/*\r\n   MatLib._debug_.draw.line(\r\n   \t\t[p, Vector.translate(p, perps[0])], \r\n   \t\t'thin10 red'\r\n   );\r\n   MatLib._debug_.draw.line(\r\n   \t\t[p, Vector.translate(p, perps[1])], \r\n   \t\t'thin10 red'\r\n   );\r\n   */\n\n\t\t\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log(perps); }\n\t\t\tif (MatLib._debug_ && MatLib._debug_.log) {\n\t\t\t\t// The below must be elem [0,1].\n\t\t\t\t//console.log(Vector.cross( perps[0], perps[1] )); \n\t\t\t}\n\n\t\t\tvar angleError1Pre = Vector.cross(perps[0], vv);\n\t\t\tvar angleError2Pre = Vector.cross(vv, perps[1]);\n\t\t\tvar angleError1 = Math.asin(angleError1Pre);\n\t\t\tvar angleError2 = Math.asin(angleError2Pre);\n\n\t\t\tvar angleError = 0;\n\t\t\tif (angleError1 > 0) {\n\t\t\t\tangleError += angleError1;\n\t\t\t}\n\t\t\tif (angleError2 > 0) {\n\t\t\t\tangleError += angleError2;\n\t\t\t}\n\n\t\t\ttotalAngleError += angleError;\n\t\t} else {\n\t\t\t//---------------------------\n\t\t\t// Tangent of curve at point\n\t\t\t//---------------------------\n\t\t\tvar bezier = p.bezierNode.item;\n\t\t\tvar v2 = Vector.toUnitVector(Bezier.tangent(bezier)(p.t));\n\n\t\t\t// Cross is more numerically stable than Vector.dot at angles\n\t\t\t// a multiple of Math.PI **and** is close to the actual angle\n\t\t\t// value and can thus just be added to cone method of looking\n\t\t\t// at tolerance.\n\n\t\t\t// Should be close to zero and is close to the actual angle.\n\t\t\tvar cross = Math.abs(Math.asin(Vector.cross(v1, v2)));\n\n\t\t\ttotalAngleError += cross;\n\t\t}\n\t}\n\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log(totalAngleError); }\n\n\t//-----------------------------------------------------------------\n\t// Calculate radiusDelta, the difference between the radius and \n\t// the closest point to the 3-prong. It should be around 0. If not,\n\t// this is not a good candidate for the 3-prong.\n\t//-----------------------------------------------------------------\n\tvar closestDs = [];\n\tfor (var _i = 0; _i < bezierPiecess.length; _i++) {\n\t\tvar _p = getClosestBoundaryPointToPoint(bezierPiecess[_i], x, undefined, // bezierNode\n\t\tundefined // t\n\t\t);\n\n\t\tclosestDs.push(Vector.distanceBetween(_p, x));\n\t}\n\tvar closestD = Util.min(closestDs);\n\tvar radiusDelta = Math.abs(radius - closestD);\n\n\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log(radiusDelta); }\n\t//if (MatLib._debug_ && MatLib._debug_.log) { console.log('---------------------'); }\n\t//-----------------------------------------------------------------\n\n\t// TODO Weights still need to be determined\n\tvar W1 = 1;\n\tvar W2 = 1;\n\tvar error = W1 * radiusDelta + W2 * totalAngleError;\n\n\treturn { ps: ps, circle: circle, error: error };\n}\n\nvar calcVectorToZeroV_StraightToIt = Vector.fromTo;\n\nfunction calcVectorToZeroV_AlongMedial(circleCenter, ps) {\n\tvar v1 = Vector.fromTo(ps[0], ps[2]);\n\tvar v2 = [-v1[1], v1[0]]; // Rotate by 90 degrees\n\tvar l1 = Vector.length(Vector.fromTo(x, circleCenter));\n\tvar v3 = Vector.toUnitVector(v2);\n\tvar v4 = Vector.scale(v3, l1);\n\t/*\r\n if (MatLib._debug_) {\r\n \tMatLib._debug_.draw.line([x, Vector.translate(x,vectorToZeroV)], 'thin10 red');\r\n \tMatLib._debug_.draw.line([x, Vector.translate(x,v4)], 'thin10 blue');\r\n }\r\n */\n\n\treturn v4;\n}\n\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong  \r\n * circle.\r\n * \r\n * The potential function, V, is defined as the distance to the \r\n * actual 3 prong circle center.\r\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\n\n\tvar V = Vector.length(vectorToZeroV);\n\n\tvar nu = 1;\n\tvar better = void 0;\n\tvar newX = void 0;\n\tvar newPs = void 0;\n\tvar newV = void 0;\n\tvar i = 0; // Safeguard\n\tdo {\n\t\tvar shift = Vector.scale(vectorToZeroV, nu);\n\t\tnewX = Vector.translate(x, shift);\n\n\t\tnewPs = getClosestPoints(newX, bezierPiece3s);\n\n\t\t// Point of zero V\n\t\tvar newCircleCenter = Vector.circumCenter(newPs);\n\t\tvar newVectorToZeroV = Vector.fromTo(newX, newCircleCenter);\n\t\tnewV = Vector.length(newVectorToZeroV);\n\n\t\tbetter = newV < V;\n\n\t\tnu = nu / 2;\n\n\t\ti++;\n\t} while (!better && i < 3);\n\n\treturn { newX: newX, newV: newV, newPs: newPs };\n}\n\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate.\r\n * The point must be within the shape. \r\n * \r\n * @param {[ContactPoint]} delta3s - The three boundary pieces of which\r\n *        we need to find the three 3-prong points.\r\n * @returns\r\n */\nfunction calcInitial3ProngPoint(shape, delta3s, bezierPiece3s) {\n\n\t// TODO - No need to calculate, we already have this info somewhere.\n\tvar twoProngCircleCenter = Vector.mean([delta3s[0][0].item, delta3s[2][1].item]);\n\tvar point1 = getClosestBoundaryPointToPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // bezierNode\n\tundefined // t\n\t);\n\n\tvar meanPoints = [delta3s[0][0].item,\n\t//Vector.mean([delta3s[1][0].item, delta3s[1][1].item]),\n\tpoint1, delta3s[2][1].item];\n\n\tvar p = void 0;\n\tif (delta3s[0][0].item.pointOnShape.type === MAT_CONSTANTS.pointType.sharp) {\n\n\t\t// delta3s start and end at sharp corner.\n\t\t// If delta3s start at a sharp corner it will end there also\n\t\t// so no need to check for end point as well.\n\t\tp = Vector.mean([meanPoints[0], meanPoints[1]]);\n\t} else {\n\t\tp = Vector.circumCenter(meanPoints);\n\t}\n\n\tif (!Number.isFinite(p[0])) {\n\t\tif (MatLib._debug_) {\n\t\t\t// TODO - check why this actuall happens sometimes\n\t\t\t//console.log(MatLib._debug_.pointsToNiceStr(meanPoints));\n\t\t\t//console.log(MatLib._debug_.deltasToNiceStr(delta3s));\n\t\t\t//console.log(p, meanPoints);\n\t\t}\n\t}\n\tif (!Number.isFinite(p[0])) {\n\t\tvar sames = whichNotSame(meanPoints);\n\t\treturn Vector.mean([meanPoints[sames[0]], meanPoints[sames[1]]]);\n\t}\n\n\treturn p;\n}\n\nfunction whichNotSame(ps) {\n\tif (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\n\t\treturn [0, 2];\n\t} else if (ps[1][0] === ps[2][0] && ps[1][1] === ps[2][1]) {\n\t\treturn [0, 2];\n\t} else if (ps[2][0] === ps[0][0] && ps[2][1] === ps[0][1]) {\n\t\treturn [1, 2];\n\t};\n\n\treturn [];\n}\n\nfunction getClosestPoints(x, bezierPiece3s) {\n\n\treturn bezierPiece3s.map(function (bezierPieces) {\n\n\t\tvar p = getClosestBoundaryPointToPoint(bezierPieces, x, undefined, // bezierNode\n\t\tundefined // t\n\t\t);\n\n\t\treturn p;\n\t});\n}\n\nmodule.exports = find3Prong;\n\n},{\"../../geometry/classes/bezier.js\":4,\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/classes/shape.js\":7,\"../../geometry/functions/get-closest-boundary-point-to-point.js\":10,\"../../geometry/geometry.js\":12,\"../../mat-constants.js\":16,\"../../utils.js\":42,\"../../vector/vector.js\":43,\"../classes/debug/three-prong-for-debugging.js\":19}],30:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar Mat = require('../classes/mat.js');\nvar ContactPoint = require('../classes/contact-point.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar PointOnShape = require('../../geometry/classes/Point-on-shape.js');\n\nvar add2Prong = require('./add-2-prong.js');\nvar find2Prong = require('./find-2-prong.js');\nvar buildMat = require('./build-mat.js');\n\n/**\r\n * Find the MAT from the given Shape.\r\n */\nfunction findMat(shape) {\n\n\tvar t0 = void 0;\n\t//if (MatLib._debug_) {\n\tt0 = performance.now();\n\t//}\n\n\n\tfindAndAddHoleClosing2Prongs(shape);\n\tfindAndAdd2ProngsOnAllPaths(shape);\n\n\t//if (MatLib._debug_) { \n\tvar t1 = performance.now();\n\n\tif (MatLib._debug_) {\n\t\tMatLib._debug_.add2ProngsDuration = t1 - t0;\n\t}\n\tconsole.log('    2-prongs took ' + (t1 - t0).toFixed(0) + ' milliseconds.');\n\t//}\n\n\t/*\r\n  * Connect the dots and add the 3-prongs.\r\n  * \r\n  * 1. Start with any 2-prong (might not be neccessary, we might be able\r\n  * to start with any contact-point\r\n  * \r\n  */\n\n\t/* ---- \r\n  * Find a good starting point for our tree structure \r\n  * e.g. (first 2-prong).\r\n  * TODO Check if this step is really necessary.  \r\n  */\n\n\tvar ta0 = void 0;\n\tta0 = performance.now();\n\n\tvar contactPoints = shape.contactPointsPerLoop[0];\n\n\tvar cpNode = contactPoints.head;\n\tdo {\n\t\tif (cpNode.item.matCircle.cpNodes.length === 2 && !(cpNode.next.prevOnCircle === cpNode)) {\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcpNode = cpNode.next;\n\t} while (cpNode !== contactPoints.head);\n\n\tvar cptest = cpNode.prevOnCircle;\n\n\tvar branchForth = buildMat(shape, cptest, undefined, undefined, false);\n\tvar branchBack = buildMat(shape, cptest.prevOnCircle, undefined, undefined, false);\n\n\tbranchForth.branches.push(branchBack.branches[0]);\n\tbranchBack.branches[0].branches[0] = branchForth;\n\n\tvar mat = new Mat(branchForth);\n\n\tvar ta1 = performance.now();\n\tif (MatLib._debug_) {\n\t\tMatLib._debug_.add2ProngsDuration = ta1 - ta0;\n\t}\n\tconsole.log('    3-prongs took ' + (ta1 - ta0).toFixed(0) + ' milliseconds.');\n\n\treturn fixMat(mat);\n}\n\n/**\r\n * @description Finds and adds two-prongs that removes any holes in the\r\n * shape.\r\n * @param shape\r\n * @returns\r\n */\nfunction findAndAddHoleClosing2Prongs(shape) {\n\tvar extremes = shape.extremes;\n\n\tfor (var k = 1; k < extremes.length; k++) {\n\n\t\tvar extreme = extremes[k];\n\t\t//console.log(extreme.p)\n\t\tvar r = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t\tvar p = [extreme.p[0], extreme.p[1] - r];\n\t\tvar osculatingCircle = new Circle(p, r);\n\t\tvar posA2 = new PointOnShape(extreme.bezierNode, extreme.t, MAT_CONSTANTS.pointType.extreme, 0, //order \n\t\t0);\n\n\t\t// A normal traversal should give (cyclically) A1->A2->B1->B2\n\t\tvar twoProngInfo = find2Prong(shape, posA2, true);\n\t\tvar circle = twoProngInfo.circle,\n\t\t    z = twoProngInfo.z;\n\n\t\tvar posA1 = z;\n\n\t\tvar key = PointOnShape.makeSimpleKey(posA2);\n\t\tif (shape.straightUpHash[key]) {\n\t\t\t// Skip these when doing normal 2-prong procedure\n\t\t\tshape.skip2ProngHash[key] = posA2;\n\t\t}\n\n\t\tadd2Prong(shape, circle, posA2, posA1, true);\n\t}\n}\n\n/** \r\n * Add 2 prongs.\r\n * \r\n * See comments on the add2Prong function.\r\n */\nfunction findAndAdd2ProngsOnAllPaths(shape) {\n\tvar for2ProngsArray = shape.for2ProngsArray;\n\n\tfor (var k = 0; k < for2ProngsArray.length; k++) {\n\t\tvar for2Prongs = for2ProngsArray[k];\n\n\t\tfindAndAdd2Prongs(shape, k, for2Prongs);\n\t}\n}\n\nfunction findAndAdd2Prongs(shape, k, for2Prongs) {\n\tvar len = for2Prongs.length;\n\t//let index = indexInterlaced(len); // Keep for debuggin.\n\tvar index = indexLinear(len);\n\n\tfor (var i = 0; i < len; i++) {\n\n\t\tvar posNode = for2Prongs[index[i]];\n\t\tvar pos = posNode.item;\n\n\t\tvar key = PointOnShape.makeSimpleKey(pos);\n\t\tif (shape.skip2ProngHash[key]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar twoProngInfo = find2Prong(shape, pos, false);\n\n\t\tif (twoProngInfo) {\n\t\t\tvar circle = twoProngInfo.circle,\n\t\t\t    z = twoProngInfo.z;\n\n\t\t\tadd2Prong(shape, circle, pos, z, false);\n\t\t} else {\n\t\t\t// failed\n\t\t}\n\t}\n\n\t/* \r\n  * Don't delete - keep for future debugging.\r\n  * Check if point orders follow each other - they absolutely must.\r\n  */\n\t/* \r\n if (MatLib._debug_) {\r\n \tlet contactPoints = shape.contactPointsPerLoop[k];\r\n \tlet cpNode = contactPoints.head;\r\n \tlet first = true;\r\n \tlet prev = undefined;\r\n \tdo {\r\n \t\tif (first) {\r\n \t\t\tfirst = false;\r\n \t\t\tprev = cpNode.item;\r\n \t\t\tcpNode = cpNode.next;\r\n \t\t\tcontinue;\r\n \t\t}\r\n \t\r\n \t\tlet cmp = ContactPoint.compare(prev, cpNode.item);\r\n \t\tif (cmp >= 0) {\r\n \t\t\tconsole.log(cmp);\t\r\n \t\t}\r\n \t\t\r\n \t\tprev = cpNode.item;\r\n \t\tcpNode = cpNode.next;\r\n \t} while (cpNode !== contactPoints.head);\r\n }\r\n */\n}\n\n/** \r\n * This is unfortunately currently required since I can't get the\r\n * buildMat recursive algorithm right on the first pass.\r\n * @param mat\r\n * @returns\r\n */\nvar lll = 0;\nfunction fixMat(mat) {\n\n\thelper(mat.startNode, undefined);\n\n\tfunction helper(matNode, priorNode) {\n\n\t\tif (matNode.branches.length === 3 && matNode.branches[2].matCircle === matNode.matCircle) {\n\n\t\t\tvar firstRight = matNode.branches[2];\n\t\t\tvar secondRight = firstRight.branches[1];\n\t\t\tmatNode.branches[2] = secondRight;\n\t\t\tsecondRight.branches[0] = matNode;\n\t\t}\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar node = _step.value;\n\n\t\t\t\tif (node === priorNode) {\n\t\t\t\t\t// Don't go back in tracks.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\thelper(node, matNode);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mat;\n}\n\n/**\r\n * Creates a kind of interlaced index vector, e.g. TODO\r\n * \r\n * @param n\r\n * @returns\r\n */\n/*\r\nfunction indexInterlaced(n) {\r\n\t\r\n\tlet arr = [];\r\n\thelper(0, n, arr);\r\n\t\r\n\treturn arr;\r\n\t\r\n\tfunction helper(start, end) {\r\n\t\t\r\n\t\tif (end === start) { \r\n\t\t\treturn; \r\n\t\t}\r\n\t\t\r\n\t\tif ((end - start) === 1) {\r\n\t\t\tarr.push(start);\r\n\t\t\treturn;\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tlet halfway = start + Math.floor((end-start) / 2);\r\n\t\t\r\n\t\tarr.push(halfway);\r\n\t\thelper(start, halfway);\r\n\t\thelper(halfway+1, end);\r\n\t}\r\n}\r\n*/\n\nfunction indexInterlaced(n) {\n\n\tvar source = {};\n\tvar arr = [];\n\t// l <=> the lowest power of 2 so that 2^l > n\n\tvar l = Math.pow(2, Math.floor(Math.log2(n)));\n\n\twhile (l >= 1) {\n\t\tvar k = 0;\n\t\twhile (k < n) {\n\t\t\tif (!source[k]) {\n\t\t\t\tarr.push(k);\n\t\t\t\tsource[k] = true;\n\t\t\t}\n\t\t\tk = k + l;\n\t\t}\n\t\tl = l / 2;\n\t}\n\n\treturn arr;\n}\n\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n * @returns\r\n */\nfunction indexLinear(n) {\n\tvar arr = [];\n\tfor (var i = 0; i < n; i++) {\n\t\tarr.push(i);\n\t}\n\treturn arr;\n}\n\nmodule.exports = findMat;\n\n},{\"../../geometry/classes/Point-on-shape.js\":1,\"../../geometry/classes/circle.js\":5,\"../../linked-loop/linked-loop.js\":13,\"../../mat-constants.js\":16,\"../classes/contact-point.js\":18,\"../classes/mat.js\":23,\"./add-2-prong.js\":24,\"./build-mat.js\":26,\"./find-2-prong.js\":28}],31:[function(require,module,exports){\n'use strict';\n\nvar traverse = require('./traverse.js');\n\n/**\r\n * @description Returns all the calculated MAT nodes as an array. \r\n */\nfunction getNodesAsArray(mat) {\n\tvar nodes = [];\n\n\ttraverse(mat, function (node) {\n\t\tnodes.push(node);\n\t});\n\n\treturn nodes;\n}\n\nmodule.exports = getNodesAsArray;\n\n},{\"./traverse.js\":35}],32:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\nvar traverse = require('./traverse.js');\n\nfunction getNodesAsHash(mat) {\n\tvar nodes = {};\n\n\ttraverse(mat, function (node) {\n\t\tvar key = PointOnShape.makeSimpleKey(node.matCircle.circle.center);\n\t\tnodes[key] = node;\n\t});\n\n\treturn nodes;\n}\n\nmodule.exports = getNodesAsHash;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"./traverse.js\":35}],33:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Geometry = require('../../geometry/geometry.js');\nvar Bezier = require('../../geometry/classes/bezier.js');\nvar Vector = require('../../vector/vector.js');\nvar Mat = require('../classes/mat.js');\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\n/**\r\n * Smoothens the given MAT by fitting consecutive node links by\r\n * lines, quadratic or cubic beziers. \r\n */\n\nfunction smoothen(mat) {\n\n\t/**\r\n  * Get the linked contact points. TODO This information to be\r\n  * stored in the MatCircle in the future then there is no need\r\n  * to actually search for it! \r\n  */\n\tfunction getLinkedCps(_ref) {\n\t\tvar _ref2 = _slicedToArray(_ref, 2),\n\t\t    prevCpNodes = _ref2[0],\n\t\t    currCpNodes = _ref2[1];\n\n\t\tfor (var i = 0; i < prevCpNodes.length; i++) {\n\t\t\tvar prevCpNode = prevCpNodes[i];\n\n\t\t\tfor (var j = 0; j < currCpNodes.length; j++) {\n\t\t\t\tvar currCpNode = currCpNodes[j];\n\n\t\t\t\tif (prevCpNode.next === currCpNode) {\n\t\t\t\t\treturn [prevCpNode, currCpNode];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar lines = [];\n\tvar quads = [];\n\tvar cubes = [];\n\n\tMat.traverse(mat, function (currNode, prevNode) {\n\t\tif (!prevNode) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar prevMatCircle = prevNode.matCircle;\n\t\tvar prevCc = prevMatCircle.circle.center;\n\t\tvar prevCpNodes = prevMatCircle.cpNodes;\n\n\t\tvar currMatCircle = currNode.matCircle;\n\t\tvar currCc = currMatCircle.circle.center;\n\t\tvar currCpNodes = currMatCircle.cpNodes;\n\n\t\tvar _getLinkedCps = getLinkedCps([prevCpNodes, currCpNodes]),\n\t\t    _getLinkedCps2 = _slicedToArray(_getLinkedCps, 2),\n\t\t    prevCpNode = _getLinkedCps2[0],\n\t\t    currCpNode = _getLinkedCps2[1];\n\n\t\tvar prevL = getDirectionToNextMatCircle(prevCpNode, prevCc, true);\n\t\tvar currL = getDirectionToNextMatCircle(currCpNode, currCc, false);\n\n\t\tfunction getDirectionToNextMatCircle(cpNode, circleCenter, isPrev) {\n\t\t\tvar cp1 = cpNode.item;\n\n\t\t\tvar cp2 = isPrev ? cpNode.nextOnCircle.item : cpNode.prevOnCircle.item;\n\n\t\t\tvar vDir = void 0;\n\t\t\tif (cp1 !== cp2) {\n\t\t\t\t// Not a 1-prong.\n\t\t\t\tvar spanner = Vector.fromTo(cp1, cp2);\n\t\t\t\tvDir = Vector.rotateBy90Degrees(spanner);\n\t\t\t} else {\n\t\t\t\tif (cp1.pointOnShape.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\t\t\tvar bezierNode1 = void 0;\n\t\t\t\t\tvar bezierNode2 = void 0;\n\t\t\t\t\tif (cp1.pointOnShape.t === 0) {\n\t\t\t\t\t\tbezierNode1 = cp1.pointOnShape.bezierNode;\n\t\t\t\t\t\tbezierNode2 = cp1.pointOnShape.bezierNode.prev;\n\t\t\t\t\t} else if (cp1.pointOnShape.t === 1) {\n\t\t\t\t\t\tbezierNode1 = cp1.pointOnShape.bezierNode.next;\n\t\t\t\t\t\tbezierNode2 = cp1.pointOnShape.bezierNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar tan1 = Bezier.tangent(bezierNode1.item)(0);\n\t\t\t\t\tvar tan2 = Vector.reverse(Bezier.tangent(bezierNode2.item)(1));\n\n\t\t\t\t\tvar x = Vector.dot(tan1, tan2);\n\t\t\t\t\t// Recall the identities sin(acos(x)) = sqrt(1-x^2),\n\t\t\t\t\t// etc. Also recall the half angle formulas. Then \n\t\t\t\t\t// the rotation matrix, R, can be calculated.\n\t\t\t\t\tvar cosθ = Math.sqrt((1 + x) / 2);\n\t\t\t\t\tvar sinθ = Math.sqrt((1 - x) / 2);\n\n\t\t\t\t\tvDir = Vector.rotate(tan2, sinθ, cosθ);\n\t\t\t\t} else {\n\t\t\t\t\tvDir = Vector.fromTo(cp1, circleCenter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar v = Vector.translate(circleCenter, Vector.toLength(vDir, 1));\n\t\t\tvar l = [circleCenter, v];\n\n\t\t\treturn l;\n\t\t}\n\n\t\tvar mid = Geometry.lineLineIntersection(prevL, currL);\n\t\tvar twisted = void 0;\n\t\tif (mid) {\n\t\t\tvar a = Vector.fromTo(prevCc, mid);\n\t\t\tvar b = Vector.fromTo(currCc, mid);\n\t\t\tvar c = Vector.fromTo(prevCc, currCc);\n\n\t\t\tvar dot1 = Vector.dot(a, c);\n\t\t\tvar dot2 = Vector.dot(b, c);\n\n\t\t\ttwisted = dot1 < 0 || dot2 > 0;\n\t\t}\n\n\t\tif (!mid) {\n\t\t\tlines.push([prevCc, currCc]);\n\t\t} else if (twisted) {\n\t\t\tvar lp1 = Vector.mean([prevCc, currCc]);\n\t\t\tvar vv1 = Vector.fromTo(prevCc, currCc);\n\t\t\tvar vvv1 = Vector.rotateBy90Degrees(vv1);\n\t\t\tvar lpp1 = Vector.translate(lp1, vvv1);\n\t\t\tvar l = [lp1, lpp1];\n\t\t\tvar mid1 = Geometry.lineLineIntersection(prevL, l);\n\t\t\tvar mid2 = Geometry.lineLineIntersection(currL, l);\n\n\t\t\tcubes.push([prevCc, mid1, mid2, currCc]);\n\t\t} else {\n\t\t\t//console.log(prevCc, mid, currCc);\n\t\t\tquads.push([prevCc, mid, currCc]);\n\t\t}\n\t});\n\n\treturn {\n\t\tlines: lines,\n\t\tquads: quads,\n\t\tcubes: cubes\n\t};\n}\n\nmodule.exports = smoothen;\n\n},{\"../../geometry/classes/bezier.js\":4,\"../../geometry/geometry.js\":12,\"../../mat-constants.js\":16,\"../../vector/vector.js\":43,\"../classes/mat.js\":23}],34:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar copyMat = require('./copy-mat.js');\nvar getNodesAsHash = require('./get-nodes-as-hash.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Mat = require('../classes/mat.js');\n\nvar width = 1620; // TODO change to actual shape coordinates\nvar height = 1560; // ...\n\n\n/**\r\n * Apply the Scale Axis Transform (SAT) to the MAT.\r\n * \r\n * @param {Mat} mat The Medial Axis Transform (MAT) on which to \r\n *        apply the SAT. \r\n * @param {Number} s The scale factor >= 1 (e.g. 1.3)\r\n * @returns {Sat}\r\n */\nfunction toScaleAxis(mat_, s) {\n\t/*\r\n  * This algorithm might be made somewhat faster by building tree  \r\n     * to a depth where there is say less than 4 other circles and then \r\n     * only split the branch once this threshold has been exceeded.\r\n     * \r\n     * Also, when searching, search only in relevant branches even\r\n     * when circle overlaps more than one group.\r\n  */\n\n\tvar mat = copyMat(mat_);\n\t/*\r\n  * Start with the biggest circle (since it is the most likely\r\n  * to eclipse other circles), multiply its radius by s and see\r\n  * which circles are fully contained in it and trim it away in\r\n  * the MAT tree.\r\n  */\n\n\tvar nodeHash = getNodesAsHash(mat);\n\n\tvar biggest = -Number.POSITIVE_INFINITY;\n\tvar biggestNode = void 0;\n\tfor (var key in nodeHash) {\n\t\tvar node = nodeHash[key];\n\t\tvar r = node.matCircle.circle.radius;\n\t\tif (r > biggest) {\n\t\t\tbiggestNode = node;\n\t\t\tbiggest = r;\n\t\t}\n\t}\n\n\tvar t0 = performance.now();\n\tvar tree = createSpacialTree(s, nodeHash);\n\tvar t1 = performance.now();\n\t//console.log((t1 - t0).toFixed(0) + ' milliseconds.');\n\n\tif (MatLib._debug_) {\n\t\t/*\r\n  if (MatLib._debug_.shouldDrawSATTree) {\r\n  \tMatLib._debug_.drawSATTree(tree);\r\n  }\r\n  */\n\t\tMatLib._debug_.generated.sat.tree = tree;\n\t}\n\n\t// Grab the MAT tree at its biggest node.\n\tvar sat = new Mat(biggestNode);\n\n\tvar cullHash = {};\n\n\t// Look at circles in roughly order of size for each tree branch,\n\t// e.g. circles in branch 5 are always larger than in branches 0\n\t// to 4.\n\ttraverseSpacialTree(tree, cullem, { s: s, tree: tree, cullHash: cullHash });\n\n\t// We now walk the MAT tree and keep all non-culled nodes and any\n\t// nodes that have a non-culled node further down the line toward\n\t// the tree leaves.\n\tvar cullNodes = [];\n\tcullIt(cullHash, cullNodes, sat.startNode);\n\n\tcullTheNodes(cullNodes);\n\n\treturn sat;\n}\n\nfunction addToTree(s, tree, coordinate, limits, node, key, depth) {\n\n\t// DEPTH_LIMIT can be anything from 1 to 16, but from 2 to 6 seem \n\t// to be the fastest.\n\tvar DEPTH_LIMIT = 6;\n\n\tvar circle = node.matCircle.circle;\n\n\tvar _calcGroups = calcGroups(s, coordinate, limits, circle),\n\t    groups = _calcGroups.groups,\n\t    newLimits = _calcGroups.newLimits;\n\n\t// Create new branch if it does not exist yet.\n\n\n\tif (groups.length === 1 && depth !== DEPTH_LIMIT) {\n\t\tvar group = groups[0];\n\n\t\tif (!tree[group]) {\n\t\t\ttree[group] = {};\n\t\t}\n\t\tvar _branch = tree[group];\n\n\t\t// Flip coordinates\n\t\tvar newCoordinate = coordinate ? 0 : 1;\n\t\taddToTree(s, _branch, newCoordinate, newLimits, node, key, depth + 1);\n\n\t\treturn;\n\t}\n\n\tif (!tree[5]) {\n\t\ttree[5] = new Map();\n\t}\n\tvar branch = tree[5];\n\tbranch.set(key, node);\n}\n\nfunction createSpacialTree(s, nodeHash) {\n\n\tvar coordinate = 0;\n\tvar limits = [[0, width], [0, height]];\n\n\tvar tree = {};\n\n\tfor (var key in nodeHash) {\n\t\tvar node = nodeHash[key];\n\n\t\taddToTree(s, tree, coordinate, limits, node, key, 0);\n\t}\n\n\treturn tree;\n}\n\nfunction cullem(node, key, _ref) {\n\tvar s = _ref.s,\n\t    tree = _ref.tree,\n\t    cullHash = _ref.cullHash;\n\n\n\tif (node.matCircle.circle.radius === 0) {\n\t\treturn;\n\t}\n\n\tif (cullHash[key]) {\n\t\treturn;\n\t}\n\n\tvar cullNodes = getCullNodes(s, tree, node);\n\tfor (var _key in cullNodes) {\n\t\tif (!cullHash[_key]) {\n\t\t\tcullHash[_key] = node;\n\t\t}\n\t}\n}\n\nfunction traverseSpacialTree(tree, f, extraParams) {\n\n\tfunction helper(tree) {\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (tree.size) {\n\t\t\t//for (let i=0; i<tree.length; i++)\n\t\t\ttree.forEach(function (node, key) {\n\t\t\t\tf(node, key, extraParams);\n\t\t\t});\n\n\t\t\treturn; // Leaf reached \n\t\t}\n\n\t\tif (tree[5]) {\n\t\t\thelper(tree[5]);\n\t\t}\n\t\tif (tree[0]) {\n\t\t\thelper(tree[0]);\n\t\t}\n\t\tif (tree[2]) {\n\t\t\thelper(tree[2]);\n\t\t}\n\t\tif (tree[4]) {\n\t\t\thelper(tree[4]);\n\t\t}\n\t\tif (tree[1]) {\n\t\t\thelper(tree[1]);\n\t\t}\n\t\tif (tree[3]) {\n\t\t\thelper(tree[3]);\n\t\t}\n\t}\n\n\thelper(tree);\n}\n\nfunction getCullNodes(s, tree, testNode) {\n\n\tvar c1 = Circle.scale(testNode.matCircle.circle, s);\n\n\tvar cullNodes = {};\n\n\tvar limits = [[0, width], [0, height]];\n\tvar circle = testNode.matCircle.circle;\n\thelper(tree, 0, limits, 0);\n\n\treturn cullNodes;\n\n\tfunction cullBranch5(tree) {\n\t\tvar branch = tree[5];\n\t\tif (!branch) {\n\t\t\treturn;\n\t\t}\n\n\t\t//console.log(branch);\n\t\tbranch.forEach(function (node, key) {\n\t\t\tvar c2 = Circle.scale(node.matCircle.circle, s);\n\t\t\tif (Circle.engulfsCircle(c1, c2)) {\n\t\t\t\tcullNodes[key] = node;\n\n\t\t\t\tbranch.delete(key);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction helper(tree, coordinate, limits, depth) {\n\n\t\tif (limits === null) {\n\t\t\t// If we already reached a circle which spans multiple\n\t\t\t// groups previously, then check all circles in the \n\t\t\t// tree.\n\t\t\tcullBranch5(tree);\n\n\t\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\t\tvar branch = tree[i];\n\t\t\t\tif (branch) {\n\t\t\t\t\thelper(branch, 0, null, depth + 1);\n\t\t\t\t\t//helper(branch, newCoordinate, null, depth+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar _calcGroups2 = calcGroups(s, coordinate, limits, circle),\n\t\t    groups = _calcGroups2.groups,\n\t\t    newLimits = _calcGroups2.newLimits;\n\n\t\tif (groups.length === 1) {\n\t\t\tcullBranch5(tree);\n\n\t\t\tvar group = groups[0];\n\t\t\tvar newCoordinate = coordinate ? 0 : 1;\n\n\t\t\tif (group === 1 || group === 3) {\n\t\t\t\t// One of the higher priority left/top or \n\t\t\t\t// right/bottom half groups.\n\t\t\t\tvar _branch2 = tree[group];\n\n\t\t\t\tif (_branch2) {\n\t\t\t\t\thelper(_branch2, newCoordinate, newLimits, depth + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// One of the lower priority even \n\t\t\t\t// groups (0,2 or 4).\n\n\t\t\t\tvar branches = [];\n\t\t\t\tbranches.push(tree[group]);\n\t\t\t\tif (group > 0) {\n\t\t\t\t\tbranches.push(tree[group - 1]);\n\t\t\t\t}\n\t\t\t\tif (group < 4) {\n\t\t\t\t\tbranches.push(tree[group + 1]);\n\t\t\t\t}\n\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar _branch3 = _step.value;\n\n\t\t\t\t\t\tif (_branch3) {\n\t\t\t\t\t\t\thelper(_branch3, newCoordinate, newLimits, depth + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tcullBranch5(tree);\n\t\t// Circle spans multiple groups at this level of the \n\t\t// tree. Check all circles in all branches.\n\t\tfor (var _i = 0; _i <= 4; _i++) {\n\t\t\tvar _branch4 = tree[_i];\n\t\t\tif (_branch4) {\n\t\t\t\t//helper(branch, newCoordinate, null, depth+1);\n\t\t\t\thelper(_branch4, 0, null, depth + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\r\n * @returns {Boolean} true if a node should NOT be culled. \r\n */\nfunction cullIt(cullHash, cullNodes, satNode, priorNode) {\n\n\tvar key = PointOnShape.makeSimpleKey(satNode.matCircle.circle.center);\n\n\tvar anyNotCull = !cullHash[key];\n\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = satNode.branches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar node = _step2.value;\n\n\t\t\tif (node === priorNode) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cullIt(cullHash, cullNodes, node, satNode)) {\n\t\t\t\tanyNotCull = true;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (anyNotCull) {\n\t\treturn true; // Don't cull me\n\t}\n\n\tcullNodes.push({ satNode: satNode, priorNode: priorNode });\n\n\treturn false;\n}\n\nfunction cullTheNode(cullNode) {\n\tvar satNode = cullNode.satNode,\n\t    priorNode = cullNode.priorNode;\n\n\n\tvar idx = priorNode.branches.indexOf(satNode);\n\tif (idx >= 0) {\n\t\tpriorNode.branches.splice(idx, 1);\n\t}\n}\n\nfunction cullTheNodes(cullNodes) {\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = cullNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar node = _step3.value;\n\n\t\t\tcullTheNode(node);\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\r\n * Spacially divide into 5 special groups as follows:\r\n * \r\n *   *******||*******|*******|*******|*******||*******\r\n * 0 <--------------->\r\n * 1         <--------------->        \r\n * 2                 <--------------->\r\n * 3                         <--------------->\r\n * 4                                 <--------------->\r\n * 5 - If the circle does not fall in any of above 5 groups.\r\n * \r\n * Note: In the above, the double pipes denote the limits for\r\n *       a coordinate, so as can be seen groups 0 and 4 go outside\r\n *       the limits. Also, groups 1 and 3 are preferred and checked\r\n *       first. \r\n *          \r\n * @param s Scale parameter, e.g. 1.1\r\n * @param {Number} coordinate - 0 -> horizontal or 1 -> vertical.\r\n * @param {[Number]} limits - The limits within which the circle \r\n *        bounds can fall.\r\n * @param {Circle} circle - The circle to categorize into a group. \r\n */\nfunction calcGroups(s, coordinate, limits, circle) {\n\n\tvar limit = limits[coordinate];\n\tvar l1 = limit[0];\n\tvar l2 = limit[1];\n\n\t// Relevant cut-off lines.\n\tvar q = (l2 - l1) / 4;\n\tvar w = q + q;\n\n\t// Shift origin\n\tvar r = circle.radius;\n\tvar x = circle.center[coordinate] - l1;\n\tvar x0 = x - r * s;\n\tvar x1 = x + r * s;\n\n\tvar newLimit = [,];\n\tvar groups = []; // Group to which circle belongs;\n\n\n\t/* This was the old method to get groups and newLimit, but it\r\n  * seems to be only slightly slower so could also be used\r\n let is = [1,3,0,2,4]; // Groups 1 and 3 takes priority. \r\n for (let i=0; i<=4; i++) {\r\n \tlet q0 = q*(is[i]-1);\r\n \tlet q1 = q0 + w;\r\n \tif (x0 > q0 && x1 <= q1) {\r\n \t\tgroups.push(is[i]);\r\n \t\tnewLimit = [l1 + q0, l1 + q1];\r\n \t\tbreak;\r\n \t}\r\n }*/\n\n\tvar qStart = Math.floor(x0 / q);\n\tvar qEnd = Math.floor(x1 / q) + 1;\n\tvar qDiff = qEnd - qStart;\n\n\tvar group = void 0;\n\tif (qDiff === 1) {\n\t\t// If contained in sliver.\n\t\tgroup = 2 * Math.floor(qStart / 2) + 1;\n\t\tgroups.push(group);\n\n\t\tvar lowerLimit = l1 + q * (group - 1);\n\t\tnewLimit = [lowerLimit, lowerLimit + w];\n\t} else if (qDiff === 2) {\n\t\tgroup = qStart + 1;\n\t\tgroups.push(group);\n\n\t\tvar _lowerLimit = l1 + q * (group - 1);\n\t\tnewLimit = [_lowerLimit, _lowerLimit + w];\n\t}\n\n\tvar newLimits = [,];\n\tif (groups.length === 1) {\n\t\tvar otherCoordinate = coordinate ? 0 : 1;\n\n\t\tnewLimits[otherCoordinate] = limits[otherCoordinate];\n\t\tnewLimits[coordinate] = newLimit;\n\t}\n\n\treturn { groups: groups, newLimits: newLimits };\n}\n\nmodule.exports = toScaleAxis;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/geometry.js\":12,\"../classes/mat.js\":23,\"./copy-mat.js\":27,\"./get-nodes-as-hash.js\":32}],35:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\n/**\r\n * Traverses the MAT tree and calls a function on each node. This\r\n * function must have side effects to be useful.\r\n * \r\n * @param {Mat} mat\r\n * @returns undefined\r\n */\nfunction traverse(mat, f) {\n\n\thelper(mat.startNode, undefined, undefined);\n\n\tfunction helper(matNode, priorNode /*, priorIndx*/) {\n\t\tf(matNode, priorNode /*, priorIndx*/);\n\n\t\t//for (let node of matNode.branches) {\n\t\tfor (var i = 0; i < matNode.branches.length; i++) {\n\t\t\tvar node = matNode.branches[i];\n\t\t\tif (node === priorNode) {\n\t\t\t\t// Don't go back in tracks.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thelper(node, matNode, i);\n\t\t}\n\t}\n}\n\nmodule.exports = traverse;\n\n},{\"../../geometry/classes/point-on-shape.js\":6}],36:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Memoization functions\r\n */\n\nvar Memoize = {};\n\nvar SUPPORTED = !!(window.Map && window.WeakMap);\n\nvar resultsPerF = undefined;\nif (SUPPORTED) {\n\tresultsPerF = new Map();\n}\n\n/**\r\n * NOTE: f must have an arity of 1.\r\n */\nMemoize.m1 = function (f) {\n\tif (!SUPPORTED) {\n\t\treturn f;\n\t}\n\n\tvar results = new WeakMap();\n\n\treturn function (param1) {\n\t\tvar result = results.get(param1);\n\t\tif (result !== undefined) {\n\t\t\t//console.log('cache hit');\n\t\t\treturn result;\n\t\t}\n\t\t//console.log('cache miss');\n\n\t\tresult = f(param1);\n\n\t\tresults.set(param1, result);\n\t\treturn result;\n\t};\n};\n\n/**\r\n * \r\n */\n/*\r\nMemoize.memoized = function(f, key) {\r\n\tif (!SUPPORTED) { return undefined; }\r\n\t\r\n\tlet results = resultsPerF.get(f);\r\n\tif (results === undefined) {\r\n\t\tresults = new WeakMap();\r\n\t\tresultsPerF.set(f, results);\r\n\t\treturn undefined;\r\n\t}\r\n\treturn results.get(key);\r\n}\r\n*/\n\n/**\r\n * \r\n */\n/*\r\nMemoize.memoize = function(f, key, val) {\r\n\tif (!SUPPORTED) { return; }\r\n\t\r\n\tlet results = resultsPerF.get(f);\r\n\tif (results === undefined) {\r\n\t\tresults = new WeakMap();\r\n\t\tresultsPerF.set(f, results);\r\n\t}\r\n\t\r\n\tresults.set(key, val);\r\n}\r\n*/\n\nmodule.exports = Memoize;\n\n},{}],37:[function(require,module,exports){\n'use strict';\n\n/** \r\n * The Gaussian Quadrature method to integrate the given\r\n * function. The integral limits are between 0 and 1.\r\n * \r\n * @param {Number} order Can be 2, 4 or 8. \r\n *        Higher values are more accurate. \r\n *        \r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * \r\n * Notes: \r\n * \r\n * - A future improvement can be to use the Gauss–Kronrod rules\r\n * to estimate the error and thus choose a number of constants based\r\n * on the error and not just thumb-suck.\r\n * \r\n * - In future, the constants can be calculated and cached so we can\r\n * chooce any number of constants.\r\n * \r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction gaussQuadrature(f, interval, order_) {\n\tvar order = order_ || 16;\n\n\tvar constants = GAUSS_CONSTANTS[order];\n\tvar weights = constants.weights;\n\tvar abscissas = constants.abscissas;\n\n\tvar _interval = _slicedToArray(interval, 2),\n\t    a = _interval[0],\n\t    b = _interval[1];\n\n\tvar result = 0;\n\tvar m1 = (b - a) / 2;\n\tvar m2 = (b + a) / 2;\n\tfor (var i = 0; i <= order - 1; i++) {\n\t\tresult += weights[i] * f(m1 * abscissas[i] + m2);\n\t}\n\n\treturn m1 * result;\n}\n\n//The Gaussian Legendre Quadrature method constants. \nvar GAUSS_CONSTANTS = {\n\t2: {\n\t\tweights: [1, 1],\n\t\tabscissas: [-0.5773502691896257, 0.5773502691896257]\n\t},\n\t4: {\n\t\tweights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538],\n\t\tabscissas: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526]\n\t},\n\t8: {\n\t\tweights: [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763],\n\t\tabscissas: [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363]\n\t},\n\t// Taken from http://keisan.casio.com/exec/system/1330940731\n\t16: {\n\t\tabscissas: [-0.989400934991649932596, -0.944575023073232576078, -0.86563120238783174388, -0.7554044083550030338951, -0.6178762444026437484467, -0.4580167776572273863424, -0.28160355077925891323, -0.0950125098376374401853, 0.0950125098376374401853, 0.28160355077925891323, 0.4580167776572273863424, 0.617876244402643748447, 0.755404408355003033895, 0.8656312023878317438805, 0.944575023073232576078, 0.989400934991649932596],\n\t\tweights: [0.0271524594117540948518, 0.062253523938647892863, 0.0951585116824927848099, 0.1246289712555338720525, 0.1495959888165767320815, 0.169156519395002538189, 0.182603415044923588867, 0.189450610455068496285, 0.1894506104550684962854, 0.182603415044923588867, 0.1691565193950025381893, 0.149595988816576732081, 0.124628971255533872053, 0.095158511682492784809, 0.062253523938647892863, 0.027152459411754094852]\n\t}\n};\n\nmodule.exports = gaussQuadrature;\n\n},{}],38:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Find the cube roots of the given polynomial between 0 and 1.\r\n * \r\n * This code is from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * Given cubic coordinates {pa, pb, pc, pd} find all\r\n * roots.\r\n * \r\n * TODO Later to be replaced by a more numerically stable version.\r\n */\n\nfunction findCubicRoots01(poly) {\n\n\t// A real-cuberoots-only function:\n\tfunction cuberoot(v) {\n\t\tif (v < 0) {\n\t\t\treturn -Math.pow(-v, 1 / 3);\n\t\t}\n\t\treturn Math.pow(v, 1 / 3);\n\t}\n\n\tfunction rootFilter01(root) {\n\t\treturn root >= 0 && root <= 1;\n\t}\n\n\tvar d = poly[0];\n\tvar a = poly[1] / d;\n\tvar b = poly[2] / d;\n\tvar c = poly[3] / d;\n\n\tvar p = (3 * b - a * a) / 3,\n\t    p3 = p / 3,\n\t    q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n\t    q2 = q / 2,\n\t    discriminant = q2 * q2 + p3 * p3 * p3;\n\n\t// and some variables we're going to use later on:\n\tvar u1, v1, root1, root2, root3;\n\n\t// three possible real roots:\n\tif (discriminant < 0) {\n\t\tvar mp3 = -p / 3,\n\t\t    mp33 = mp3 * mp3 * mp3,\n\t\t    r = Math.sqrt(mp33),\n\t\t    t = -q / (2 * r),\n\t\t    cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n\t\t    phi = Math.acos(cosphi),\n\t\t    crtr = cuberoot(r),\n\t\t    t1 = 2 * crtr;\n\t\troot1 = t1 * Math.cos(phi / 3) - a / 3;\n\t\troot2 = t1 * Math.cos((phi + 2 * Math.PI) / 3) - a / 3;\n\t\troot3 = t1 * Math.cos((phi + 4 * Math.PI) / 3) - a / 3;\n\t\treturn [root1, root2, root3].filter(rootFilter01);\n\t} else if (discriminant === 0) {\n\t\t// three real roots, but two of them are equal:\n\t\tu1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);\n\t\troot1 = 2 * u1 - a / 3;\n\t\troot2 = -u1 - a / 3;\n\t\treturn [root1, root2].filter(rootFilter01);\n\t} else {\n\t\t// one real root, two complex roots\n\t\tvar sd = Math.sqrt(discriminant);\n\t\tu1 = cuberoot(sd - q2);\n\t\tv1 = cuberoot(sd + q2);\n\t\troot1 = u1 - v1 - a / 3;\n\t\treturn [root1].filter(rootFilter01);\n\t}\n}\n\nmodule.exports = findCubicRoots01;\n\n},{}],39:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Util = require('../utils.js');\nvar findCubicRoots01 = require('./functions/find-cubic-roots.js');\n\n/**\r\n* Functional univariate polynomial library functions.\r\n*\r\n* All polinomials are represented as a simple array starting with the \r\n* highest power, e.g. \r\n*   10x^4 + 3x^3 + 5x^2 + 7x + 0 -> [10,3,5,7,0]\r\n*/\nvar Poly = {\n\t// Roots\n\tfindQuadraticRoots01: findQuadraticRoots01,\n\tfindCubicRoots01: findCubicRoots01,\n\tbrent: brent,\n\tpositiveRootLowerBound: positiveRootLowerBound,\n\tpositiveRootUpperBound: positiveRootUpperBound,\n\tzeroRoots: zeroRoots,\n\tnumRootsWithin: numRootsWithin,\n\tallRoots01: allRoots01,\n\tnewton: newton,\n\trootsWithin: rootsWithin,\n\n\t// Operators\n\tmultiplyByConst: multiplyByConst,\n\tnegate: negate,\n\tminus: minus,\n\tmultiply: multiply,\n\tdifferentiate: differentiate,\n\tsturmChain: sturmChain,\n\tdegree: degree,\n\tevaluate: evaluate,\n\tevaluateAt0: evaluateAt0,\n\tsignChanges: signChanges,\n\tinvert: invert,\n\tchangeVariables: changeVariables,\n\tdeflate: deflate,\n\n\tremainder: remainder\n};\n\n/**  \r\n * Differentiation the given polynomial.\r\n **/\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = d; i !== 0; i--) {\n\t\tvar coeff = p[d - i] * i;\n\t\tif (i === d && coeff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(coeff);\n\t}\n\n\tif (result.length === 0) {\n\t\treturn [0];\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Multiplies 2 polynomials \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = d; i >= 0; i--) {\n\t\tresult.push(c * p[d - i]);\n\t}\n\treturn result;\n};\n\nfunction negate(poly) {\n\treturn Poly.multiplyByConst(-1, poly);\n}\n\n/** \r\n * Subtracts second from first polynomial \r\n */\n// TODO - ugly code - improve\nfunction minus(poly1, poly2) {\n\tvar d1 = poly1.length - 1;\n\tvar d2 = poly2.length - 1;\n\tvar dr = Math.max(d1, d2);\n\tvar result = [];\n\tfor (var i = 0; i < dr + 1; i++) {\n\t\tresult.push(0);\n\t}\n\n\tfor (var _i = dr; _i >= 0; _i--) {\n\t\tvar v1 = poly1[dr - _i];\n\t\tvar v2 = poly2[dr - _i];\n\t\tresult[dr - _i] = (v1 ? v1 : 0) - (v2 ? v2 : 0);\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Multiplies poly1 and poly2 \r\n * \r\n * Inefficient O(n^2) \r\n * see https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * \r\n **/\nfunction multiply(poly1, poly2) {\n\tvar d1 = poly1.length - 1;\n\tvar d2 = poly2.length - 1;\n\tvar dr = d1 + d2;\n\tvar result = [];\n\tfor (var i = 0; i < dr + 1; i++) {\n\t\tresult.push(0);\n\t}\n\n\tfor (var _i2 = d1; _i2 >= 0; _i2--) {\n\t\tfor (var j = d2; j >= 0; j--) {\n\t\t\tresult[dr - (_i2 + j)] += poly1[d1 - _i2] * poly2[d2 - j];\n\t\t}\n\t}\n\treturn result;\n}\n\n/** Returns degree of polynomial **/\n// TODO - If leading coefficients are 0 this gives the wrong result\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method  \r\n * See: https://en.wikipedia.org/wiki/Horner%27s_method \r\n **/\nfunction evaluate(p) {\n\treturn function (t) {\n\t\tvar bn = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tbn = p[i] + bn * t;\n\t\t}\n\n\t\treturn bn;\n\t};\n};\n\n/** \r\n * Evaluates a polynomial at 0 \r\n * - this is much faster than at an arbitrary point \r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when order in descending order; zeros are ignored \r\n */\nfunction signChanges(p) {\n\n\tvar result = 0;\n\n\tvar d = p.length - 1;\n\tvar curSign = 0;\n\tfor (var i = d; i >= 0; i--) {\n\t\tvar newSign = Math.sign(p[d - i]);\n\t\tif (newSign === 0) continue;\n\t\tif (curSign !== 0 && curSign !== newSign) {\n\t\t\tresult++;\n\t\t}\n\t\tcurSign = newSign;\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Returns the remainder when dividing poly1 by poly2 \r\n * ASSUMING poly1 is one degree higher than poly2.\r\n */\n// See: https://en.wikipedia.org/wiki/Sturm%27s_theorem\nfunction remainder(p1, p2) {\n\t//console.log(p1,p2)\n\n\tvar d1 = p1.length - 1; // Degree of p1\n\tvar d2 = p2.length - 1; // Degree of p2\n\tvar d = d1 - d2;\n\tfor (var i = 0; i < d - 1; i++) {\n\t\tp2.unshift(0);\n\t}\n\td2 = d1 - 1;\n\n\tvar pre1 = p1[1] / p1[0] - p2[1] / p2[0];\n\tvar pre2 = p1;\n\tvar pre3 = Poly.multiplyByConst(p1[0] / p2[0], p2);\n\tvar pre4 = Poly.multiply(pre3, [1, pre1]);\n\tvar pre5 = Poly.minus(pre4, pre2);\n\n\treturn pre5.slice(2);\n}\n\nfunction deflate(poly, root) {\n\t// Implement as a shortcut (can root === 1 also be a shortcut?)\n\tif (root === 0) {}\n\n\tvar d = poly.length - 1;\n\tvar bs = [poly[0]];\n\tfor (var i = 1; i < poly.length - 1; i++) {\n\t\tbs.push(poly[i] + root * bs[i - 1]);\n\t}\n\n\t//console.log(bs);\n\treturn bs;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial \r\n */\nfunction sturmChain(p) {\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(Poly.differentiate(p));\n\n\tvar i = 1;\n\n\twhile (Poly.degree(m[i]) > 0) {\n\t\tm.push(Poly.remainder(m[i - 1], m[i]));\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/** \r\n * Returns the number of roots in the interval (a,b) of a \r\n * polynomial \r\n */\nfunction numRootsWithin(p, a, b) {\n\n\tvar sturmChain = Poly.sturmChain(p);\n\tvar as = sturmChain.map(function (p) {\n\t\treturn Poly.evaluate(p)(a);\n\t});\n\tvar bs = sturmChain.map(function (p) {\n\t\treturn Poly.evaluate(p)(b);\n\t});\n\n\treturn Poly.signChanges(as) - Poly.signChanges(bs);\n}\n\n/** \r\n * Newton's method - tuned for polynomials \r\n * Currently just doing 10 iterations - only for testing at the\r\n * moment. \r\n */\nfunction newton(p, initialGuess) {\n\tvar dp = Poly.differentiate(p);\n\tvar val = initialGuess;\n\tfor (var i = 1; i <= 10; i++) {\n\t\tval -= Poly.evaluate(p)(val) / Poly.evaluate(dp)(val);\n\t}\n\n\treturn val;\n}\n\n/** \r\n * See algoritm 6 - Vigklas\r\n * Note: Only polynomials that has at least 1 sign change can be \r\n *       used in this algorithm. This is not a problem since if \r\n *       there are no sign changes then there are no roots! \r\n */\nfunction positiveRootUpperBound(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = Poly.negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) continue;\n\n\t\t\t// TODO - Both these pows can easily be replaced with a lookup that will speed things up a lot\n\t\t\t// since (for low order polys) it will most of the time be a square, cube... root or multiplication by 1,2,4,8,...\n\t\t\t// TODO - not 100% sure the timesUsed[k] is used correctly here but seems to give reasonable results\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / Math.pow(2, timesUsed[k])), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * p(x) -> x^deg(p) * p(1/x)\r\n */\nfunction invert(p) {\n\tvar len = p.length;\n\tvar newP = [];\n\n\tfor (var i = len - 1; i >= 0; i--) {\n\t\tnewP.push(p[i]);\n\t}\n\n\treturn newP;\n}\n\n/** \r\n * See http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system \r\n * This is basically just a change of variables (type of Mobius transform) of the type: \r\n *   p(x) <- p(ax + b)\r\n * Currently limited to degree 6 or so (due to binomial coeff lookup), but easiliy extensible to any degree with 1 line of code :)\r\n * \r\n * We let the coefficients of p(ax + b) =def= d_i in the code below. d_i is calculated as d = T*c, where c is the original coefficients \r\n **/\nfunction changeVariables(p, a, b) {\n\tvar deg = p.length - 1;\n\n\tvar d = new Array(deg + 1).fill(0);\n\t//let d = [];\n\t// TODO - better way to fill a matrix with zeros?\n\tvar t = [];\n\tfor (var i = 0; i < deg + 1; i++) {\n\t\tt.push(new Array(deg + 1).fill(0));\n\t\t//d.push(0);\n\t\t/*t.push([]);\r\n  for (let j=0; j<deg+1; j++) {\r\n  \tt[i].push(0);\r\n  }*/\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= deg; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i3 = 1; _i3 <= j; _i3++) {\n\t\t\tt[_i3][j] = b * t[_i3][j - 1] + a * t[_i3 - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tfor (var _i4 = 0; _i4 <= deg; _i4++) {\n\t\td[deg - _i4] = 0;\n\t\tfor (var _j = _i4; _j <= deg; _j++) {\n\t\t\tvar acc = t[_i4][_j] * p[deg - _j];\n\t\t\td[deg - _i4] += acc;\n\t\t}\n\t}\n\n\treturn d;\n}\n\nfunction positiveRootLowerBound(p) {\n\treturn 1 / Poly.positiveRootUpperBound(Poly.invert(p));\n}\n\n/**\r\n * @return { Number, Array } The number of zero roots together with the \r\n * deflated polynomial\r\n *       \r\n */\nfunction zeroRoots(p) {\n\tvar p_ = p.slice();\n\tvar i = 0;\n\twhile (Poly.evaluateAt0(p_) === 0) {\n\t\tvar len = p_.length;\n\t\tp_.splice(len - 1, 1);\n\t\ti++;\n\t}\n\treturn {\n\t\tp: p_,\n\t\tnumZeros: i\n\t};\n}\n\n/**\r\n * Find 2nd order or higher polynomial roots within the \r\n * *specific interval** [0,1]. \r\n */\nfunction allRoots01(poly) {\n\n\tvar deg = poly.length - 1;\n\n\tif (deg === 2) {\n\t\treturn Poly.findQuadraticRoots01(poly);\n\t} else if (deg === 3) {\n\t\treturn Poly.findCubicRoots01(poly).sort(function (a, b) {\n\t\t\treturn a - b;\n\t\t});\n\t}\n\n\tvar diff = Poly.differentiate(poly);\n\tvar roots = allRoots01(diff);\n\tif (roots[0] !== 0) {\n\t\troots.unshift(0);\n\t}\n\tif (roots[roots.length - 1] !== 1) {\n\t\troots.push(1);\n\t}\n\n\treturn rootsWithin(poly, roots);\n}\n\nfunction rootsWithin(poly, intervals) {\n\n\tvar len = intervals.length;\n\tvar roots = [];\n\tvar peval = Poly.evaluate(poly);\n\n\tfor (var i = 0; i < len - 1; i++) {\n\t\tvar a = intervals[i];\n\t\tvar b = intervals[i + 1];\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tif (evA === 0 || evB === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troots.push(a);\n\t\t\t}\n\t\t\tif (evB === 0) {\n\t\t\t\troots.push(b);\n\t\t\t}\n\n\t\t\treturn roots;\n\t\t}\n\n\t\tvar sgn = evA / evB;\n\t\tif (sgn < 0) {\n\t\t\tvar root = Poly.brent(peval, a, b);\n\t\t\troots.push(root);\n\t\t}\n\t}\n\n\treturn roots;\n}\n\n/**\r\n * Returns <em>ordered</em> quadratic roots.\r\n */\nfunction findQuadraticRoots01(q) {\n\tif (q.length === 0) {\n\t\treturn undefined;\n\t}\n\tif (q.length === 1) {\n\t\tif (q[0] === 0) {\n\t\t\treturn [];\n\t\t}\n\t\treturn [];\n\t}\n\tif (q.length === 2) {\n\t\tif (q[0] === 0) {\n\t\t\tif (q[1] === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\t\tvar root = -q[1] / q[0];\n\t\tif (root >= 0 && root <= 1) {\n\t\t\treturn [root];\n\t\t}\n\t\treturn [];\n\t}\n\tif (q.length > 3) {\n\t\t// TODO Can we safely throw and stay optimized?\n\t\treturn undefined;\n\t}\n\n\tvar _q = _slicedToArray(q, 3),\n\t    a = _q[0],\n\t    b = _q[1],\n\t    c = _q[2];\n\n\tvar root1 = void 0;\n\tvar root2 = void 0;\n\tvar delta = b * b - 4 * a * c;\n\tif (delta < 0) {\n\t\t// No real roots;\n\t\treturn [];\n\t}\n\tif (delta === 0) {\n\t\troot1 = -b / (2 * a);\n\t\tif (root1 >= 0 && root1 <= 1) {\n\t\t\treturn [root1];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tdelta = Math.sqrt(delta);\n\tif (b >= 0) {\n\t\troot1 = (-b - delta) / (2 * a);\n\t\troot2 = 2 * c / (-b - delta);\n\t} else {\n\t\troot1 = 2 * c / (-b + delta);\n\t\troot2 = (-b + delta) / (2 * a);\n\t}\n\n\tvar root1InRange = root1 >= 0 && root1 <= 1;\n\tvar root2InRange = root2 >= 0 && root2 <= 1;\n\tif (root1InRange) {\n\t\tif (root2InRange) {\n\t\t\tif (root1 < root2) {\n\t\t\t\treturn [root1, root2];\n\t\t\t}\n\t\t\treturn [root2, root1];\n\t\t}\n\t\treturn [root1];\n\t}\n\tif (root2InRange) {\n\t\treturn [root2];\n\t}\n\treturn [];\n}\n\n/**\r\n * Searches the interval from the given lower limit to the given \r\n * upper limit for a root (i.e., zero) of the given function with \r\n * respect to its first argument using the Brent's Method \r\n * root-finding algorithm.\r\n * \r\n * See: https://en.wikipedia.org/wiki/Brent%27s_method\r\n *\r\n * @param {Function} f function for which the root is sought.\r\n * @param {Number} a the lower point of the interval to be searched.\r\n * @param {Number} b the upper point of the interval to be searched.\r\n * @param {Number} errorTol the desired accuracy (convergence tolerance).\r\n * @return An estimate for the root within accuracy.\r\n * \r\n * NOTE: Brent's Method is optimized for general functions. A more \r\n * specialzed algorithm targeted at polynomials using for example a\r\n * combination of the Secant and Newton methods might be much faster. \r\n */\nvar TOLERANCE = 1e-15;\nfunction brent(f, a, b, errorTol) {\n\tif (a === b) {\n\t\treturn a;\n\t} // Root already found\n\n\tvar fa = f(a);\n\tvar fb = f(b);\n\n\tif (fa * fb >= 0) {\n\t\t// Root is not bracketed - this is a precondition.\n\t\tthrow 'Root not bracketed';\n\t}\n\n\tvar c = void 0;\n\tif (Math.abs(fa) < Math.abs(fb)) {\n\t\t// Swap a,b\n\t\tc = a;a = b;b = c;\n\t}\n\n\tc = a;\n\n\tvar mflag = true;\n\tvar i = 0;\n\n\tvar prevError = void 0;\n\twhile (true) {\n\t\ti++;\n\n\t\tvar fc = f(c);\n\t\tvar s = void 0;\n\n\t\tfa = f(a);\n\t\tfb = f(b);\n\n\t\tif (fa !== fc && fb !== fc) {\n\t\t\t// Inverse quadratic interpolation\n\t\t\tvar fac = fa - fc;\n\t\t\tvar fab = fa - fb;\n\t\t\tvar fbc = fb - fc;\n\n\t\t\t// The below has been multiplied out to speed up the algorithm.\n\t\t\t/*s = ((a * fb * fc) / ( fab * fac)) +\r\n   \t((b * fa * fc) / (-fab * fbc)) +\r\n   \t((c * fa * fb) / ( fac * fbc));*/\n\t\t\ts = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n\t\t} else {\n\t\t\t// Secant method\n\t\t\ts = b - fb * ((b - a) / (fb - fa));\n\t\t}\n\n\t\tvar d = void 0;\n\t\tvar t1 = (3 * a + b) / 4;\n\t\tvar b_c = Math.abs(b - c);\n\t\tvar s_b = Math.abs(s - b);\n\t\tvar c_d = Math.abs(c - d);\n\t\t//let tol1 = Math.abs(b-c); \n\t\t//let tol2 = Math.abs(c-d);\n\n\t\tif (!( // s < t1 || s > b\n\t\ts > t1 && s < b || s < t1 && s > b) || // condition 1\n\t\tmflag && (s_b >= b_c / 2 || // condition 2\n\t\t/*tol1*/b_c < errorTol // condition 4\n\t\t) || !mflag && (s_b >= c_d / 2 || // condition 3\n\t\t/*tol2*/c_d < errorTol // condition 5\n\t\t)) {\n\t\t\t// Bisection method\n\t\t\ts = (a + b) / 2;\n\t\t\tmflag = true;\n\t\t} else {\n\t\t\tmflag = false;\n\t\t}\n\n\t\tvar fs = f(s);\n\n\t\td = c;\n\t\tc = b;\n\n\t\tif (fa * fs < 0) {\n\t\t\tb = s;\n\t\t} else {\n\t\t\ta = s;\n\t\t}\n\n\t\tif (Math.abs(fa) < Math.abs(fb)) {\n\t\t\t// Swap a,b\n\t\t\tvar t3 = a;a = b;b = t3;\n\t\t}\n\n\t\tif (fb === 0) {\n\t\t\t// or fs === 0\n\t\t\treturn b; // or return s!; can be used to select side!  \n\t\t} else if (fs === 0) {\n\t\t\treturn s;\n\t\t}\n\n\t\tvar error = Math.abs(a - b);\n\t\tif (error / a + error / b < TOLERANCE || error === 0 || prevError <= error) {\n\t\t\treturn b; // or return s!; can be used to select side!\n\t\t}\n\t\tprevError = error;\n\n\t\t/*\r\n  if (error < errorTol) {\r\n  \treturn b; // or return s!; can be used to select side!\r\n  }*/\n\t}\n}\n\nmodule.exports = Poly;\n\n// 1052 - 675 -\n\n},{\"../utils.js\":42,\"./functions/find-cubic-roots.js\":38}],40:[function(require,module,exports){\n'use strict';\n\n// @info\n//   Polyfill for SVG 2 getPathData() and setPathData() methods. Based on:\n//   - SVGPathSeg polyfill by Philip Rogers (MIT License)\n//     https://github.com/progers/pathseg\n//   - SVGPathNormalizer by Tadahisa Motooka (MIT License)\n//     https://github.com/motooka/SVGPathNormalizer/tree/master/src\n//   - arcToCubicCurves() by Dmitry Baranovskiy (MIT License)\n//     https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/raphael.core.js#L1837\n// @author\n//   Jarosław Foksa\n// @license\n//   MIT License\n\nfunction svgGetAndSetPathDataPolyFill() {\n\n\t\t\tif (!SVGPathElement.prototype.getPathData || !SVGPathElement.prototype.setPathData) {\n\n\t\t\t\t\t\tapplyPolyFill();\n\t\t\t}\n}\n\nfunction applyPolyFill() {\n\n\t\t\tvar commandsMap = {\n\t\t\t\t\t\tZ: \"Z\", M: \"M\", L: \"L\", C: \"C\", Q: \"Q\", A: \"A\", H: \"H\", V: \"V\", S: \"S\", T: \"T\",\n\t\t\t\t\t\tz: \"Z\", m: \"m\", l: \"l\", c: \"c\", q: \"q\", a: \"a\", h: \"h\", v: \"v\", s: \"s\", t: \"t\"\n\t\t\t};\n\n\t\t\tvar Source = function Source(string) {\n\t\t\t\t\t\tthis._string = string;\n\t\t\t\t\t\tthis._currentIndex = 0;\n\t\t\t\t\t\tthis._endIndex = this._string.length;\n\t\t\t\t\t\tthis._prevCommand = null;\n\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t};\n\n\t\t\tvar isIE = window.navigator.userAgent.indexOf(\"MSIE \") !== -1;\n\n\t\t\tSource.prototype = {\n\t\t\t\t\t\tparseSegment: function parseSegment() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\tvar command = commandsMap[char] ? commandsMap[char] : null;\n\n\t\t\t\t\t\t\t\t\tif (command === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Possibly an implicit command. Not allowed if this is the first command.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._prevCommand === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// Check for remaining coordinates in the current command.\n\t\t\t\t\t\t\t\t\t\t\t\tif ((char === \"+\" || char === \"-\" || char === \".\" || char >= \"0\" && char <= \"9\") && this._prevCommand !== \"Z\") {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this._prevCommand === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = \"L\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (this._prevCommand === \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = \"l\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = this._prevCommand;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (command === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex++;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._prevCommand = command;\n\n\t\t\t\t\t\t\t\t\tvar values = null;\n\t\t\t\t\t\t\t\t\tvar cmd = command.toUpperCase();\n\n\t\t\t\t\t\t\t\t\tif (cmd === \"H\" || cmd === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"S\" || cmd === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseArcFlag(), this._parseArcFlag(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"Z\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (values === null || values.indexOf(null) >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Unknown command or known command with invalid values\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\treturn { type: command, values: values };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\thasMoreData: function hasMoreData() {\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpeekSegmentType: function peekSegmentType() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\treturn commandsMap[char] ? commandsMap[char] : null;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tinitialCommandIsMoveTo: function initialCommandIsMoveTo() {\n\t\t\t\t\t\t\t\t\t// If the path is empty it is still valid, so return true.\n\t\t\t\t\t\t\t\t\tif (!this.hasMoreData()) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar command = this.peekSegmentType();\n\t\t\t\t\t\t\t\t\t// Path must start with moveTo.\n\t\t\t\t\t\t\t\t\treturn command === \"M\" || command === \"m\";\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_isCurrentSpace: function _isCurrentSpace() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\treturn char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_skipOptionalSpaces: function _skipOptionalSpaces() {\n\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_skipOptionalSpacesOrDelimiter: function _skipOptionalSpacesOrDelimiter() {\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string[this._currentIndex] !== \",\") {\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._skipOptionalSpaces()) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n\t\t\t\t\t\t// Source/core/svg/SVGParserUtilities.cpp.\n\t\t\t\t\t\t// Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n\t\t\t\t\t\t_parseNumber: function _parseNumber() {\n\t\t\t\t\t\t\t\t\tvar exponent = 0;\n\t\t\t\t\t\t\t\t\tvar integer = 0;\n\t\t\t\t\t\t\t\t\tvar frac = 1;\n\t\t\t\t\t\t\t\t\tvar decimal = 0;\n\t\t\t\t\t\t\t\t\tvar sign = 1;\n\t\t\t\t\t\t\t\t\tvar expsign = 1;\n\t\t\t\t\t\t\t\t\tvar startIndex = this._currentIndex;\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\n\t\t\t\t\t\t\t\t\t// Read the sign.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"+\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t} else if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tsign = -1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._currentIndex === this._endIndex || (this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") && this._string[this._currentIndex] !== \".\") {\n\t\t\t\t\t\t\t\t\t\t\t\t// The first character of a number must be one of [0-9+-.].\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the integer part, build right-to-left.\n\t\t\t\t\t\t\t\t\tvar startIntPartIndex = this._currentIndex;\n\n\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1; // Advance to first non-digit.\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._currentIndex !== startIntPartIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar scanIntPartIndex = this._currentIndex - 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar multiplier = 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (scanIntPartIndex >= startIntPartIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinteger += multiplier * (this._string[scanIntPartIndex] - \"0\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscanIntPartIndex -= 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmultiplier *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the decimals.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \".\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// There must be a least one digit following the .\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdecimal += (this._string[this._currentIndex] - \"0\") * (frac *= 0.1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the exponent part.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex !== startIndex && this._currentIndex + 1 < this._endIndex && (this._string[this._currentIndex] === \"e\" || this._string[this._currentIndex] === \"E\") && this._string[this._currentIndex + 1] !== \"x\" && this._string[this._currentIndex + 1] !== \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Read the sign of the exponent.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._string[this._currentIndex] === \"+\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (this._string[this._currentIndex] === \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpsign = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// There must be an exponent.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texponent *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texponent += this._string[this._currentIndex] - \"0\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar number = integer + decimal;\n\t\t\t\t\t\t\t\t\tnumber *= sign;\n\n\t\t\t\t\t\t\t\t\tif (exponent) {\n\t\t\t\t\t\t\t\t\t\t\t\tnumber *= Math.pow(10, expsign * exponent);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (startIndex === this._currentIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpacesOrDelimiter();\n\n\t\t\t\t\t\t\t\t\treturn number;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_parseArcFlag: function _parseArcFlag() {\n\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar flag = null;\n\t\t\t\t\t\t\t\t\tvar flagChar = this._string[this._currentIndex];\n\n\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\tif (flagChar === \"0\") {\n\t\t\t\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t\t} else if (flagChar === \"1\") {\n\t\t\t\t\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpacesOrDelimiter();\n\t\t\t\t\t\t\t\t\treturn flag;\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar parsePathDataString = function parsePathDataString(string) {\n\t\t\t\t\t\tif (!string || string.length === 0) return [];\n\n\t\t\t\t\t\tvar source = new Source(string);\n\t\t\t\t\t\tvar pathData = [];\n\n\t\t\t\t\t\tif (source.initialCommandIsMoveTo()) {\n\t\t\t\t\t\t\t\t\twhile (source.hasMoreData()) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathSeg = source.parseSegment();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (pathSeg === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData.push(pathSeg);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn pathData;\n\t\t\t};\n\n\t\t\tvar setAttribute = SVGPathElement.prototype.setAttribute;\n\t\t\tvar removeAttribute = SVGPathElement.prototype.removeAttribute;\n\t\t\tvar symbols;\n\n\t\t\tif (window.Symbol) {\n\t\t\t\t\t\tsymbols = { cachedPathData: Symbol(), cachedNormalizedPathData: Symbol() };\n\t\t\t} else {\n\t\t\t\t\t\tsymbols = { cachedPathData: \"__cachedPathData\", cachedNormalizedPathData: \"__cachedNormalizedPathData\" };\n\t\t\t}\n\n\t\t\t// @info\n\t\t\t//   Get an array of corresponding cubic bezier curve parameters for given arc curve paramters.\n\t\t\tvar arcToCubicCurves = function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, _recursive) {\n\t\t\t\t\t\tvar degToRad = function degToRad(degrees) {\n\t\t\t\t\t\t\t\t\treturn Math.PI * degrees / 180;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar rotate = function rotate(x, y, angleRad) {\n\t\t\t\t\t\t\t\t\tvar X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n\t\t\t\t\t\t\t\t\tvar Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n\t\t\t\t\t\t\t\t\treturn { x: X, y: Y };\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar angleRad = degToRad(angle);\n\t\t\t\t\t\tvar params = [];\n\t\t\t\t\t\tvar f1, f2, cx, cy;\n\n\t\t\t\t\t\tif (_recursive) {\n\t\t\t\t\t\t\t\t\tf1 = _recursive[0];\n\t\t\t\t\t\t\t\t\tf2 = _recursive[1];\n\t\t\t\t\t\t\t\t\tcx = _recursive[2];\n\t\t\t\t\t\t\t\t\tcy = _recursive[3];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar p1 = rotate(x1, y1, -angleRad);\n\t\t\t\t\t\t\t\t\tx1 = p1.x;\n\t\t\t\t\t\t\t\t\ty1 = p1.y;\n\n\t\t\t\t\t\t\t\t\tvar p2 = rotate(x2, y2, -angleRad);\n\t\t\t\t\t\t\t\t\tx2 = p2.x;\n\t\t\t\t\t\t\t\t\ty2 = p2.y;\n\n\t\t\t\t\t\t\t\t\tvar x = (x1 - x2) / 2;\n\t\t\t\t\t\t\t\t\tvar y = (y1 - y2) / 2;\n\t\t\t\t\t\t\t\t\tvar h = x * x / (r1 * r1) + y * y / (r2 * r2);\n\n\t\t\t\t\t\t\t\t\tif (h > 1) {\n\t\t\t\t\t\t\t\t\t\t\t\th = Math.sqrt(h);\n\t\t\t\t\t\t\t\t\t\t\t\tr1 = h * r1;\n\t\t\t\t\t\t\t\t\t\t\t\tr2 = h * r2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar sign;\n\n\t\t\t\t\t\t\t\t\tif (largeArcFlag === sweepFlag) {\n\t\t\t\t\t\t\t\t\t\t\t\tsign = -1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tsign = 1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar r1Pow = r1 * r1;\n\t\t\t\t\t\t\t\t\tvar r2Pow = r2 * r2;\n\n\t\t\t\t\t\t\t\t\tvar left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n\t\t\t\t\t\t\t\t\tvar right = r1Pow * y * y + r2Pow * x * x;\n\n\t\t\t\t\t\t\t\t\tvar k = sign * Math.sqrt(Math.abs(left / right));\n\n\t\t\t\t\t\t\t\t\tcx = k * r1 * y / r2 + (x1 + x2) / 2;\n\t\t\t\t\t\t\t\t\tcy = k * -r2 * x / r1 + (y1 + y2) / 2;\n\n\t\t\t\t\t\t\t\t\tf1 = Math.asin(((y1 - cy) / r2).toFixed(9));\n\t\t\t\t\t\t\t\t\tf2 = Math.asin(((y2 - cy) / r2).toFixed(9));\n\n\t\t\t\t\t\t\t\t\tif (x1 < cx) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = Math.PI - f1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (x2 < cx) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = Math.PI - f2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (f1 < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = Math.PI * 2 + f1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (f2 < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = Math.PI * 2 + f2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (sweepFlag && f1 > f2) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = f1 - Math.PI * 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!sweepFlag && f2 > f1) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f2 - Math.PI * 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar df = f2 - f1;\n\n\t\t\t\t\t\tif (Math.abs(df) > Math.PI * 120 / 180) {\n\t\t\t\t\t\t\t\t\tvar f2old = f2;\n\t\t\t\t\t\t\t\t\tvar x2old = x2;\n\t\t\t\t\t\t\t\t\tvar y2old = y2;\n\n\t\t\t\t\t\t\t\t\tif (sweepFlag && f2 > f1) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f1 + Math.PI * 120 / 180 * 1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f1 + Math.PI * 120 / 180 * -1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tx2 = cx + r1 * Math.cos(f2);\n\t\t\t\t\t\t\t\t\ty2 = cy + r2 * Math.sin(f2);\n\t\t\t\t\t\t\t\t\tparams = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdf = f2 - f1;\n\n\t\t\t\t\t\tvar c1 = Math.cos(f1);\n\t\t\t\t\t\tvar s1 = Math.sin(f1);\n\t\t\t\t\t\tvar c2 = Math.cos(f2);\n\t\t\t\t\t\tvar s2 = Math.sin(f2);\n\t\t\t\t\t\tvar t = Math.tan(df / 4);\n\t\t\t\t\t\tvar hx = 4 / 3 * r1 * t;\n\t\t\t\t\t\tvar hy = 4 / 3 * r2 * t;\n\n\t\t\t\t\t\tvar m1 = [x1, y1];\n\t\t\t\t\t\tvar m2 = [x1 + hx * s1, y1 - hy * c1];\n\t\t\t\t\t\tvar m3 = [x2 + hx * s2, y2 - hy * c2];\n\t\t\t\t\t\tvar m4 = [x2, y2];\n\n\t\t\t\t\t\tm2[0] = 2 * m1[0] - m2[0];\n\t\t\t\t\t\tm2[1] = 2 * m1[1] - m2[1];\n\n\t\t\t\t\t\tif (_recursive) {\n\t\t\t\t\t\t\t\t\treturn [m2, m3, m4].concat(params);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparams = [m2, m3, m4].concat(params).join().split(\",\");\n\n\t\t\t\t\t\t\t\t\tvar curves = [];\n\t\t\t\t\t\t\t\t\tvar curveParams = [];\n\n\t\t\t\t\t\t\t\t\tparams.forEach(function (param, i) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (i % 2) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams.push(rotate(params[i - 1], params[i], angleRad).y);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams.push(rotate(params[i], params[i + 1], angleRad).x);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (curveParams.length === 6) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurves.push(curveParams);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn curves;\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar clonePathData = function clonePathData(pathData) {\n\t\t\t\t\t\treturn pathData.map(function (seg) {\n\t\t\t\t\t\t\t\t\treturn { type: seg.type, values: Array.prototype.slice.call(seg.values) };\n\t\t\t\t\t\t});\n\t\t\t};\n\n\t\t\t// @info\n\t\t\t//   Takes any path data, returns path data that consists only from absolute commands.\n\t\t\tvar absolutizePathData = function absolutizePathData(pathData) {\n\t\t\t\t\t\tvar absolutizedPathData = [];\n\n\t\t\t\t\t\tvar currentX = null;\n\t\t\t\t\t\tvar currentY = null;\n\n\t\t\t\t\t\tvar subpathX = null;\n\t\t\t\t\t\tvar subpathY = null;\n\n\t\t\t\t\t\tpathData.forEach(function (seg) {\n\t\t\t\t\t\t\t\t\tvar type = seg.type;\n\n\t\t\t\t\t\t\t\t\tif (type === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"L\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"l\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"c\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = currentY + seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"A\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"a\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"A\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"H\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"H\", values: [x] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (type === \"h\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"H\", values: [x] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (type === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"V\", values: [y] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"v\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"V\", values: [y] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"s\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"T\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"t\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"T\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"Z\" || type === \"z\") {\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Z\", values: [] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = subpathX;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = subpathY;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn absolutizedPathData;\n\t\t\t};\n\n\t\t\t// @info\n\t\t\t//   Takes path data that consists only from absolute commands, returns path data that consists only from\n\t\t\t//   \"M\", \"L\", \"C\" and \"Z\" commands.\n\t\t\tvar reducePathData = function reducePathData(pathData) {\n\t\t\t\t\t\tvar reducedPathData = [];\n\t\t\t\t\t\tvar lastType = null;\n\n\t\t\t\t\t\tvar lastControlX = null;\n\t\t\t\t\t\tvar lastControlY = null;\n\n\t\t\t\t\t\tvar currentX = null;\n\t\t\t\t\t\tvar currentY = null;\n\n\t\t\t\t\t\tvar subpathX = null;\n\t\t\t\t\t\tvar subpathY = null;\n\n\t\t\t\t\t\tpathData.forEach(function (seg) {\n\t\t\t\t\t\t\t\t\tif (seg.type === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x2;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y2;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"L\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"H\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [x, currentY] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [currentX, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1, cy1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lastType === \"C\" || lastType === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcx1 = currentX + (currentX - lastControlX);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcy1 = currentY + (currentY - lastControlY);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcx1 = currentX;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcy1 = currentY;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x2;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y2;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1, y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lastType === \"Q\" || lastType === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx1 = currentX + (currentX - lastControlX);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty1 = currentY + (currentY - lastControlY);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx1 = currentX;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty1 = currentY;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1 = currentX + 2 * (x1 - currentX) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy1 = currentY + 2 * (y1 - currentY) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx2 = x + 2 * (x1 - x) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy2 = y + 2 * (y1 - y) / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x1;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1 = currentX + 2 * (x1 - currentX) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy1 = currentY + 2 * (y1 - currentY) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx2 = x + 2 * (x1 - x) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy2 = y + 2 * (y1 - y) / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x1;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar r1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar r2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar angle = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar largeArcFlag = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar sweepFlag = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (r1 === 0 || r2 === 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [currentX, currentY, x, y, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentX !== x || currentY !== y) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar curves = arcToCubicCurves(currentX, currentY, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurves.forEach(function (curve) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: curve });\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"Z\") {\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push(seg);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = subpathX;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = subpathY;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tlastType = seg.type;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn reducedPathData;\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.setAttribute = function (name, value) {\n\t\t\t\t\t\tif (name === \"d\") {\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = null;\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsetAttribute.call(this, name, value);\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.removeAttribute = function (name, value) {\n\t\t\t\t\t\tif (name === \"d\") {\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = null;\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoveAttribute.call(this, name);\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.getPathData = function (options) {\n\t\t\t\t\t\tif (options && options.normalize) {\n\t\t\t\t\t\t\t\t\tif (this[symbols.cachedNormalizedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn clonePathData(this[symbols.cachedNormalizedPathData]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathData;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this[symbols.cachedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData = clonePathData(this[symbols.cachedPathData]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = clonePathData(pathData);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normalizedPathData = reducePathData(absolutizePathData(pathData));\n\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = clonePathData(normalizedPathData);\n\t\t\t\t\t\t\t\t\t\t\t\treturn normalizedPathData;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (this[symbols.cachedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn clonePathData(this[symbols.cachedPathData]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = clonePathData(pathData);\n\t\t\t\t\t\t\t\t\t\t\t\treturn pathData;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.setPathData = function (pathData) {\n\t\t\t\t\t\tif (pathData.length === 0) {\n\t\t\t\t\t\t\t\t\tif (isIE) {\n\t\t\t\t\t\t\t\t\t\t\t\t// @bugfix https://github.com/mbostock/d3/issues/1737\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setAttribute(\"d\", \"\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.removeAttribute(\"d\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar d = \"\";\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = pathData.length; i < l; i += 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar seg = pathData[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td += \" \";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\td += seg.type;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (seg.values) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td += \" \" + seg.values.join(\" \");\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.setAttribute(\"d\", d);\n\t\t\t\t\t\t}\n\t\t\t};\n}\n\nmodule.exports = svgGetAndSetPathDataPolyFill;\n\n// 1014\n\n},{}],41:[function(require,module,exports){\n'use strict';\n\nvar Bezier = require('../geometry/classes/bezier.js');\nvar LinkedLoop = require('../linked-loop/linked-loop.js');\nvar Geometry = require('../geometry/geometry.js');\nvar Vector = require('../vector/vector.js');\nvar svgGetAndSetPathDataPolyFill = require('./path-data-polyfill/path-data-polyfill.js');\n\nvar Svg = {};\n\nvar DELTA = 1e-6; // TODO - must be replaced with value relative to image size.\n\n/**\r\n * Get the cubic beziers from the given SVG DOM element. If a path\r\n * data tag is not \"C\", i.e. if it is not an absolute cubic bezier\r\n * coordinate then it is converted into one.\r\n */\nSvg.getBeziersFromSvgElem = function (elem) {\n\n\tfunction pushBezier(arr, bezierPoints_, j) {\n\t\t// TODO \n\t\t// We check if any of the bezierPoints are coincident and thus\n\t\t// that the bezier is degenerate in some sense. If that is the\n\t\t// case we apply a heuristic to get a new similar bezier by \n\t\t// respacing the points. This entire function is very \n\t\t// convoluted.\n\t\t// We should investigate a better mathematical solution.\n\n\t\t// Currently if the bezier degenerates more or less into a point\n\t\t// we make the next bezier start at the previous bezier's end\n\t\t// point else we adjust the bezier to be less pathological.\n\n\t\tvar ds = [[0, Vector.manhattanDistanceBetween(bezierPoints_[0], bezierPoints_[1]), Vector.manhattanDistanceBetween(bezierPoints_[0], bezierPoints_[2]), Vector.manhattanDistanceBetween(bezierPoints_[0], bezierPoints_[3])], [Vector.manhattanDistanceBetween(bezierPoints_[1], bezierPoints_[0]), 0, Vector.manhattanDistanceBetween(bezierPoints_[1], bezierPoints_[2]), Vector.manhattanDistanceBetween(bezierPoints_[1], bezierPoints_[3])], [Vector.manhattanDistanceBetween(bezierPoints_[2], bezierPoints_[0]), Vector.manhattanDistanceBetween(bezierPoints_[2], bezierPoints_[1]), 0, Vector.manhattanDistanceBetween(bezierPoints_[2], bezierPoints_[3])], [Vector.manhattanDistanceBetween(bezierPoints_[3], bezierPoints_[0]), Vector.manhattanDistanceBetween(bezierPoints_[3], bezierPoints_[1]), Vector.manhattanDistanceBetween(bezierPoints_[3], bezierPoints_[2]), 0]];\n\n\t\tvar bezierPoints = bezierPoints_;\n\n\t\tvar SHIFT = 0.1;\n\t\t// Check if first or last 3 points are coincident\n\t\tif (ds[0][1] < DELTA && ds[1][2] < DELTA || ds[1][2] < DELTA && ds[2][3] < DELTA) {\n\t\t\tbezierPoints = [bezierPoints_[0], Vector.interpolate(bezierPoints_[0], bezierPoints_[3], 1 / 3), Vector.interpolate(bezierPoints_[0], bezierPoints_[3], 2 / 3), bezierPoints_[3]];\n\t\t}\n\n\t\t// Check if first 2 points are coincident\n\t\tif (ds[0][1] < DELTA) {\n\t\t\tbezierPoints[1] = Vector.interpolate(bezierPoints_[0], bezierPoints_[2], SHIFT);\n\t\t}\n\n\t\t// Check if last 2 points are coincident\n\t\tif (ds[2][3] < DELTA) {\n\t\t\tbezierPoints[2] = Vector.interpolate(bezierPoints_[1], bezierPoints_[3], 1 - SHIFT);\n\t\t}\n\n\t\t// Check if middle 2 points are coincident\n\t\tif (ds[1][2] < DELTA) {\n\t\t\tbezierPoints[1] = Vector.interpolate(bezierPoints_[0], bezierPoints_[1], 1 - SHIFT);\n\t\t\tbezierPoints[2] = Vector.interpolate(bezierPoints_[2], bezierPoints_[3], SHIFT);\n\t\t}\n\n\t\tarr.push(new Bezier(bezierPoints, j));\n\t}\n\n\tvar MUST_START_WITH_M = 'Invalid SVG - every new path must start with an M or m.';\n\tvar INVALID_COMMAND = 'Invalid SVG - command not recognized.';\n\n\tsvgGetAndSetPathDataPolyFill(); // Ensure polyfill is applied.\n\n\tvar paths = elem.getPathData();\n\n\t//console.log(paths);\n\n\tif (paths.length < 2) {\n\t\t// A shape is not described   \n\t\treturn [];\n\t}\n\n\tvar pathStarted = false;\n\n\t// Used in conjunction with \"S\" and \"s\"\n\tvar prev2ndCubicControlPoint = undefined;\n\tvar prev2ndQuadraticControlPoint = undefined;\n\n\tvar bezierArrays = [];\n\tvar bezierArray = [];\n\t//let j = 0;\n\tvar j = void 0;\n\tvar type = undefined;\n\tvar initialPoint = undefined;\n\tvar x0 = undefined;\n\tvar y0 = undefined;\n\tfor (var i = 0; i < paths.length; i++) {\n\t\tvar path = paths[i];\n\t\tvar vals = path.values;\n\n\t\tvar addX = 0;\n\t\tvar addY = 0;\n\t\tif (path.type == path.type.toLowerCase()) {\n\t\t\taddX = x0;\n\t\t\taddY = y0;\n\t\t}\n\t\tvar prevType = type;\n\t\ttype = path.type.toUpperCase();\n\n\t\tvar bezierPoints = void 0;\n\t\tswitch (type) {\n\t\t\t/* \r\n    * M and m: (from www.w3.org) \r\n    * --------------------------\r\n    * Start a new sub-path at the given (x,y) coordinate. \r\n    * M (uppercase) indicates that absolute coordinates will \r\n    * follow; m (lowercase) indicates that relative coordinates \r\n    * will follow. If a moveto is followed by multiple pairs of \r\n    * coordinates, the subsequent pairs are treated as implicit \r\n    * lineto commands. Hence, implicit lineto commands will be \r\n    * relative if the moveto is relative, and absolute if the \r\n    * moveto is absolute. If a relative moveto (m) appears as the \r\n    * first element of the path, then it is treated as a pair of \r\n    * absolute coordinates. In this case, subsequent pairs of \r\n    * coordinates are treated as relative even though the initial \r\n    * moveto is interpreted as an absolute moveto. \r\n    */\n\t\t\tcase 'M':\n\t\t\t\t{\n\t\t\t\t\t// Note: A valid SVG path must start with \"M\" or \"m\".\n\n\t\t\t\t\tif (pathStarted) {\n\t\t\t\t\t\t// This is a subpath, close as if a Z or z was the\n\t\t\t\t\t\t// previous command.\n\t\t\t\t\t\tif (prevType !== 'Z') {\n\t\t\t\t\t\t\tvar _xInterval = (vals[0] + addX - x0) / 3;\n\t\t\t\t\t\t\tvar _yInterval = (vals[1] + addY - y0) / 3;\n\t\t\t\t\t\t\tbezierPoints = [[x0, y0], [x0 + _xInterval * 1, y0 + _yInterval * 1], [x0 + _xInterval * 2, y0 + _yInterval * 2], [x0 + _xInterval * 3, y0 + _yInterval * 3]];\n\t\t\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t\t\tif (!isCloseToOrigin([_xInterval, _yInterval])) {\n\t\t\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bezierArray.length) {\n\t\t\t\t\t\tbezierArrays.push(bezierArray);\n\t\t\t\t\t\tbezierArray = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tpathStarted = true;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = vals[0];\n\t\t\t\t\ty0 = vals[1];\n\n\t\t\t\t\t// Update initial point of current path/sub-path.\n\t\t\t\t\tinitialPoint = [x0, y0];\n\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * C and c: (from www.w3.org) \r\n    * params: x1 y1 x2 y2 x y\r\n    * --------------------------\r\n    * Draws a cubic Bézier curve from the current point to (x,y) \r\n    * using (x1,y1) as the control point at the beginning of the \r\n    * curve and (x2,y2) as the control point at the end of the \r\n    * curve. C (uppercase) indicates that absolute coordinates \r\n    * will follow; c (lowercase) indicates that relative \r\n    * coordinates will follow. Multiple sets of coordinates may \r\n    * be specified to draw a polybézier. At the end of the \r\n    * command, the new current point becomes the final (x,y) \r\n    * coordinate pair used in the polybézier.\r\n    */\n\t\t\tcase 'C':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tbezierPoints = [[x0, y0], [addX + vals[0], addY + vals[1]], [addX + vals[2], addY + vals[3]], [addX + vals[4], addY + vals[5]]];\n\t\t\t\t\tprev2ndCubicControlPoint = bezierPoints[2];\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (!isAlmostZeroLength(bezierPoints)) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* \r\n    * S and s: (from www.w3.org) \r\n    * params: x2 y2 x y\r\n    * --------------------------\r\n    * Draws a cubic Bézier curve from the current point to \r\n    * (x,y). The first control point is assumed to be the \r\n    * reflection of the second control point on the previous \r\n    * command relative to the current point. (If there is no \r\n    * previous command or if the previous command was not an \r\n    * C, c, S or s, assume the first control point is \r\n    * coincident with the current point.) (x2,y2) is the \r\n    * second control point (i.e., the control point at the end \r\n    * of the curve). S (uppercase) indicates that absolute \r\n    * coordinates will follow; s (lowercase) indicates that \r\n    * relative coordinates will follow. Multiple sets of \r\n    * coordinates may be specified to draw a polybézier. \r\n    * At the end of the command, the new current point becomes \r\n    * the final (x,y) coordinate pair used in the polybézier.\r\n    */\n\t\t\tcase 'S':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar x1 = void 0;\n\t\t\t\t\tvar y1 = void 0;\n\t\t\t\t\tif (prev2ndCubicControlPoint) {\n\t\t\t\t\t\tx1 = x0 - prev2ndCubicControlPoint[0] + x0;\n\t\t\t\t\t\ty1 = y0 - prev2ndCubicControlPoint[1] + y0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = x0;\n\t\t\t\t\t\ty1 = y0;\n\t\t\t\t\t}\n\t\t\t\t\tbezierPoints = [[x0, y0], [x1, y1], [addX + vals[0], addY + vals[1]], [addX + vals[2], addY + vals[3]]];\n\t\t\t\t\tprev2ndCubicControlPoint = bezierPoints[2];\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (!isAlmostZeroLength(bezierPoints)) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* \r\n    * L and l: (from www.w3.org)\r\n    * params: x y \r\n    * --------------------------\r\n    * Draw a line from the current point to the given (x,y) \r\n    * coordinate which becomes the new current point. L \r\n    * (uppercase) indicates that absolute coordinates will \r\n    * follow; l (lowercase) indicates that relative \r\n    * coordinates will follow. A number of coordinates pairs \r\n    * may be specified to draw a polyline. At the end of the \r\n    * command, the new current point is set to the final set \r\n    * of coordinates provided.\r\n    */\n\t\t\tcase 'L':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _xInterval2 = (vals[0] + addX - x0) / 3;\n\t\t\t\t\tvar _yInterval2 = (vals[1] + addY - y0) / 3;\n\t\t\t\t\tbezierPoints = [[x0, y0], [x0 + _xInterval2 * 1, y0 + _yInterval2 * 1], [x0 + _xInterval2 * 2, y0 + _yInterval2 * 2], [x0 + _xInterval2 * 3, y0 + _yInterval2 * 3]];\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (!isCloseToOrigin([_xInterval2, _yInterval2])) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * H and h: (from www.w3.org) \r\n    * params: x\r\n    * --------------------------\r\n    * Draws a horizontal line from the current point (cpx, cpy) \r\n    * to (x, cpy). H (uppercase) indicates that absolute \r\n    * coordinates will follow; h (lowercase) indicates that \r\n    * relative coordinates will follow. Multiple x values can \r\n    * be provided (although usually this doesn't make sense). \r\n    * At the end of the command, the new current point becomes \r\n    * (x, cpy) for the final value of x.\r\n    */\n\t\t\tcase 'H':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _xInterval3 = (vals[0] + addX - x0) / 3;\n\t\t\t\t\tbezierPoints = [[x0, y0], [x0 + _xInterval3 * 1, y0], [x0 + _xInterval3 * 2, y0], [x0 + _xInterval3 * 3, y0]];\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (Math.abs(_xInterval3) > DELTA) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * V and v: (from www.w3.org) \r\n    * params: y\r\n    * --------------------------\r\n    * Draws a vertical line from the current point (cpx, cpy) \r\n    * to (cpx, y). V (uppercase) indicates that absolute \r\n    * coordinates will follow; v (lowercase) indicates that \r\n    * relative coordinates will follow. Multiple y values can \r\n    * be provided (although usually this doesn't make sense). \r\n    * At the end of the command, the new current point becomes \r\n    * (cpx, y) for the final value of y.\r\n    */\n\t\t\tcase 'V':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _yInterval3 = (vals[1] + addY - y0) / 3;\n\t\t\t\t\tbezierPoints = [[x0, y0], [x0, y0 + _yInterval3 * 1], [x0, y0 + _yInterval3 * 2], [x0, y0 + _yInterval3 * 3]];\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (Math.abs(_yInterval3) > DELTA) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * Q and q: (from www.w3.org) \r\n    * params: x1 y1 x y\r\n    * --------------------------\r\n    * Draws a quadratic Bézier curve from the current point to \r\n    * (x,y) using (x1,y1) as the control point. Q (uppercase) \r\n    * indicates that absolute coordinates will follow; q \r\n    * (lowercase) indicates that relative coordinates will \r\n    * follow. Multiple sets of coordinates may be specified \r\n    * to draw a polybézier. At the end of the command, the new \r\n    * current point becomes the final (x,y) coordinate pair \r\n    * used in the polybézier.\r\n    */\n\t\t\tcase 'Q':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\t//---------------------------------------------------\n\t\t\t\t\t// Convert quadratic to cubic\n\t\t\t\t\t// see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n\t\t\t\t\t//---------------------------------------------------\n\n\t\t\t\t\tvar QP0 = [x0, y0];\n\t\t\t\t\tvar QP1 = [addX + vals[0], addY + vals[1]];\n\t\t\t\t\tvar QP2 = [addX + vals[2], addY + vals[3]];\n\n\t\t\t\t\t// Endpoints stay the same\n\t\t\t\t\tvar CP0 = QP0;\n\t\t\t\t\tvar CP3 = QP2;\n\n\t\t\t\t\t// CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\t\tvar CP1 = [QP0[0] + 2 / 3 * (QP1[0] - QP0[0]), QP0[1] + 2 / 3 * (QP1[1] - QP0[1])];\n\t\t\t\t\t// CP2 = QP2 + 2/3 *(QP1-QP2)\n\t\t\t\t\tvar CP2 = [QP2[0] + 2 / 3 * (QP1[0] - QP2[0]), QP2[1] + 2 / 3 * (QP1[1] - QP2[1])];\n\n\t\t\t\t\tbezierPoints = [CP0, CP1, CP2, CP3];\n\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = QP1;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (!isAlmostZeroLength(bezierPoints)) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * T and t: (from www.w3.org) \r\n    * params: x y\r\n    * --------------------------\r\n    * Draws a quadratic Bézier curve from the current point to \r\n    * (x,y). The control point is assumed to be the reflection \r\n    * of the control point on the previous command relative to \r\n    * the current point. (If there is no previous command or if \r\n    * the previous command was not a Q, q, T or t, assume the \r\n    * control point is coincident with the current point.) T \r\n    * (uppercase) indicates that absolute coordinates will \r\n    * follow; t (lowercase) indicates that relative coordinates \r\n    * will follow. At the end of the command, the new current \r\n    * point becomes the final (x,y) coordinate pair used in the \r\n    * polybézier.\r\n    */\n\t\t\tcase 'T':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _x = void 0;\n\t\t\t\t\tvar _y = void 0;\n\t\t\t\t\tif (prev2ndQuadraticControlPoint) {\n\t\t\t\t\t\t_x = x0 - prev2ndQuadraticControlPoint[0] + x0;\n\t\t\t\t\t\t_y = y0 - prev2ndQuadraticControlPoint[1] + y0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_x = x0;\n\t\t\t\t\t\t_y = y0;\n\t\t\t\t\t}\n\n\t\t\t\t\t//---------------------------------------------------\n\t\t\t\t\t// Convert quadratic to cubic\n\t\t\t\t\t// see https://stackoverflow.com/questions/3162645/convert-a-quadratic-bezier-to-a-cubic/3162732#3162732\n\t\t\t\t\t//---------------------------------------------------\n\n\t\t\t\t\tvar _QP = [x0, y0];\n\t\t\t\t\tvar _QP2 = [_x, _y];\n\t\t\t\t\tvar _QP3 = [addX + vals[0], addY + vals[1]];\n\n\t\t\t\t\t// Endpoints stay the same\n\t\t\t\t\tvar _CP = _QP;\n\t\t\t\t\tvar _CP2 = _QP3;\n\n\t\t\t\t\t// CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\t\tvar _CP3 = [_QP[0] + 2 / 3 * (_QP2[0] - _QP[0]), _QP[1] + 2 / 3 * (_QP2[1] - _QP[1])];\n\t\t\t\t\t// CP2 = QP2 + 2/3 *(QP1-QP2)\n\t\t\t\t\tvar _CP4 = [_QP3[0] + 2 / 3 * (_QP2[0] - _QP3[0]), _QP3[1] + 2 / 3 * (_QP2[1] - _QP3[1])];\n\n\t\t\t\t\tbezierPoints = [_CP, _CP3, _CP4, _CP2];\n\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = _QP2;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\t\tif (!isAlmostZeroLength(bezierPoints)) {\n\t\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * A and a: (from www.w3.org) \r\n    * params: rx ry x-axis-rotation large-arc-flag \r\n    *         sweep-flag x y\r\n    * --------------------------------------------\r\n    * Draws an elliptical arc from the current point to (x, y). \r\n    * The size and orientation of the ellipse are defined by \r\n    * two radii (rx, ry) and an x-axis-rotation, which \r\n    * indicates how the ellipse as a whole is rotated relative \r\n    * to the current coordinate system. The center (cx, cy) of \r\n    * the ellipse is calculated automatically to satisfy the \r\n    * constraints imposed by the other parameters. \r\n    * large-arc-flag and sweep-flag contribute to the automatic \r\n    * calculations and help determine how the arc is drawn.\r\n    */\n\t\t\tcase 'A':\n\t\t\t\t{\n\t\t\t\t\tif (!pathStarted) {\n\t\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t\t}\n\n\t\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t\t// Update current point\n\t\t\t\t\t//x0 = ? bezierPoints[3][0]; \n\t\t\t\t\t//y0 = ? bezierPoints[3][1];\n\n\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* \r\n    * Z and z: (from www.w3.org) \r\n    * params: (none)\r\n    * --------------------------\r\n    * Close the current subpath by drawing a straight line \r\n    * from the current point to current subpath's initial \r\n    * point. Since the Z and z commands take no parameters, \r\n    * they have an identical effect.\r\n    */\n\t\t\tcase 'Z':\n\t\t\t\tif (!pathStarted) {\n\t\t\t\t\tthrow new Error(MUST_START_WITH_M);\n\t\t\t\t}\n\n\t\t\t\tvar xInterval = (initialPoint[0] + addX - x0) / 3;\n\t\t\t\tvar yInterval = (initialPoint[1] + addY - y0) / 3;\n\n\t\t\t\tbezierPoints = [[x0, y0], [x0 + xInterval * 1, y0 + yInterval * 1], [x0 + xInterval * 2, y0 + yInterval * 2], [x0 + xInterval * 3, y0 + yInterval * 3]];\n\t\t\t\tprev2ndCubicControlPoint = undefined;\n\t\t\t\tprev2ndQuadraticControlPoint = undefined;\n\n\t\t\t\t// Update current point\n\t\t\t\tx0 = bezierPoints[3][0];\n\t\t\t\ty0 = bezierPoints[3][1];\n\n\t\t\t\tif (!isCloseToOrigin([xInterval, yInterval])) {\n\t\t\t\t\t//bezierArray.push( new Bezier(bezierPoints, j++) );\n\t\t\t\t\tpushBezier(bezierArray, bezierPoints, j++);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(INVALID_COMMAND);\n\t\t}\n\t}\n\n\tif (bezierArray.length) {\n\t\tbezierArrays.push(bezierArray);\n\t\tbezierArray = [];\n\t}\n\n\treturn bezierArrays;\n};\n\n/**\r\n * Check if distance between consecutive points are somewhere not \r\n * relatively 'very small'.\r\n * @param points\r\n * @returns\r\n */\nfunction isAlmostZeroLength(ps) {\n\treturn false;\n\n\tfor (var i = 1; i < ps.length; i++) {\n\t\tvar p1 = ps[i - 1];\n\t\tvar p2 = ps[i];\n\n\t\tif (Vector.manhattanDistanceBetween(p1, p2) > DELTA) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\r\n * @param point\r\n * @returns\r\n */\n// TODO - we can use Manhattan distance in many places instead of \n// Euclidian distance (much faster and simpler to calculate)\nfunction isCloseToOrigin(p) {\n\treturn Vector.manhattanLength(p) < DELTA;\n}\n\n/**\r\n * Takes the given beziers and creates a path string which will consist\r\n * only out of 'C' elements. \r\n */\nSvg.getPathStrFromBezierLoop = function (bezierLoop) {\n\tvar DEC = 10;\n\n\tvar node = bezierLoop.head;\n\tvar isFirst = true;\n\tvar prevPoint = undefined;\n\tvar str = '';\n\tdo {\n\t\tvar points = node.item.bezierPoints;\n\n\t\tif (isFirst) {\n\t\t\tisFirst = false;\n\t\t\tstr = 'M ' + points[0][0].toFixed(DEC) + ' ' + points[0][1].toFixed(DEC) + '\\n';\n\t\t\tprevPoint = points[0];\n\t\t}\n\n\t\tstr += 'C ' + points[1][0].toFixed(DEC) + ' ' + points[1][1].toFixed(DEC) + ' ' + points[2][0].toFixed(DEC) + ' ' + points[2][1].toFixed(DEC) + ' ' + points[3][0].toFixed(DEC) + ' ' + points[3][1].toFixed(DEC) + ' ' + '\\n';\n\n\t\tnode = node.next;\n\t} while (node !== bezierLoop.head);\n\n\treturn str;\n};\n\nmodule.exports = Svg;\n\n},{\"../geometry/classes/bezier.js\":4,\"../geometry/geometry.js\":12,\"../linked-loop/linked-loop.js\":13,\"../vector/vector.js\":43,\"./path-data-polyfill/path-data-polyfill.js\":40}],42:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Utililty class\r\n */\n\nvar Util = {};\n\nUtil.min = function (xs) {\n\treturn Math.min.apply(null, xs);\n};\n\nUtil.max = function (xs) {\n\treturn Math.max.apply(null, xs);\n};\n\n/**\r\n * Floating-point safer version of acos. If θ is only slightly larger\r\n * than 1 (or smaller than -1), still return 0 (or Math.Pi) instead of \r\n * NAN. \r\n */\nUtil.acos = function (θ) {\n\tvar SLIGHTLY = 0.01;\n\n\tif (θ > 1 && θ < 1 + SLIGHTLY) {\n\t\treturn 0;\n\t} else if (θ < -1 && θ > -1 - SLIGHTLY) {\n\t\treturn Math.PI;\n\t}\n\n\treturn Math.acos(θ);\n};\n\nmodule.exports = Util;\n\n},{}],43:[function(require,module,exports){\n'use strict';\n\n/*\r\n * Vector utilities, mostly 2-vectors (represented as arrays).\r\n */\n\nvar Vector = {};\n\n/** \r\n * @return The dot (inner) product between 2 2-vectors \r\n */\n\nVector.dot = function (a, b) {\n\treturn a[0] * b[0] + a[1] * b[1];\n};\n\n/** \r\n * @return The cross product magnitude between 2 2-vectors \r\n */\nVector.cross = function (a, b) {\n\treturn a[0] * b[1] - a[1] * b[0];\n},\n\n/** \r\n * @return {Number} The squared distance between 2 points.\r\n */\nVector.squaredDistanceBetween = function (p1, p2) {\n\tvar x = p2[0] - p1[0];\n\tvar y = p2[1] - p1[1];\n\n\treturn x * x + y * y;\n};\n\nVector.scale = function (p, factor) {\n\treturn [p[0] * factor, p[1] * factor];\n};\n\nVector.reverse = function (p) {\n\treturn [p[0] * -1, p[1] * -1];\n};\n\nVector.toUnitVector = function (p) {\n\tvar scaleFactor = 1 / Vector.length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n};\n\nVector.toLength = function (p, length) {\n\tvar scaleFactor = length / Vector.length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n};\n\n/** \r\n * @return The vector from one point to another. \r\n */\nVector.fromTo = function (p1, p2) {\n\treturn [p2[0] - p1[0], p2[1] - p1[1]];\n};\n\n/**\r\n * @description Performs linear interpolation between two points.\r\n * @param {Number[]} p1 - The first point.\r\n * @param {Number[]} p2 - The second point.\r\n * @param {Number} t - The interpolation fraction (usually in [0,1]).  \r\n * @returns The interpolated point.\r\n */\nVector.interpolate = function (p1, p2, t) {\n\treturn [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];\n};\n\n/** \r\n * @param {[[Number, Number]]} ps \r\n * \r\n * @return The mean value of the provided array of points.\r\n */\nVector.mean = function (ps) {\n\tvar p1 = ps[0];\n\tvar p2 = ps[1];\n\n\treturn [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n};\n\n/** \r\n * @return The distance between 2 points \r\n */\nVector.distanceBetween = function (p1, p2) {\n\treturn Math.sqrt(Vector.squaredDistanceBetween(p1, p2));\n};\n\n/** \r\n * Returns the distance from the origin. \r\n */\nVector.length = function (p) {\n\treturn Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n};\n\nVector.lengthSquared = function (p) {\n\treturn p[0] * p[0] + p[1] * p[1];\n};\n\nVector.manhattanDistanceBetween = function (p1, p2) {\n\treturn Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n};\n\nVector.manhattanLength = function (p) {\n\treturn Math.abs(p[0]) + Math.abs(p[1]);\n};\n\n/**\r\n * @return The distance between the given point and line. \r\n * \r\n * See https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points \r\n */\nVector.distanceBetweenPointAndLine = function (p, l) {\n\tvar x0 = p[0];\n\tvar y0 = p[1];\n\tvar x1 = l[0][0];\n\tvar y1 = l[0][1];\n\tvar x2 = l[1][0];\n\tvar y2 = l[1][1];\n\n\tvar y2_y1 = y2 - y1;\n\tvar x2_x1 = x2 - x1;\n\n\tvar numerator = y2_y1 * x0 - x2_x1 * y0 + x2 * y1 - y2 * x1;\n\tvar denominator = Math.sqrt(y2_y1 * y2_y1 + x2_x1 * x2_x1);\n\n\treturn Math.abs(numerator / denominator);\n};\n\n/**\r\n * @return The distance between the given point and line. \r\n */\nVector.squaredDistanceBetweenPointAndLineSegment = function (p, l) {\n\tvar v = l[0];\n\tvar w = l[1];\n\n\tvar l2 = Vector.squaredDistanceBetween(v, w);\n\tif (l2 == 0) {\n\t\treturn Vector.squaredDistanceBetween(p, v);\n\t}\n\n\tvar t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n\tt = Math.max(0, Math.min(1, t));\n\n\tvar d2 = Vector.squaredDistanceBetween(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n\n\treturn d2;\n};\n\nVector.circumCenter = function (triangle) {\n\t// See wikipedia\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar Sx = 0.5 * det3([squaredNorm(p1), p1[1], 1], [squaredNorm(p2), p2[1], 1], [squaredNorm(p3), p3[1], 1]);\n\n\tvar Sy = 0.5 * det3([p1[0], squaredNorm(p1), 1], [p2[0], squaredNorm(p2), 1], [p3[0], squaredNorm(p3), 1]);\n\n\tvar a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n\n\tvar b = det3([p1[0], p1[1], squaredNorm(p1)], [p2[0], p2[1], squaredNorm(p2)], [p3[0], p3[1], squaredNorm(p3)]);\n\n\treturn [Sx / a, Sy / a];\n};\n\n/** \r\n * @description Returns the incenter of 3 points (seen as a triangle).\r\n * @see Wikipedia - https://en.wikipedia.org/wiki/Incenter \r\n */\nVector.inCenter = function (triangle) {\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar l1 = Vector.distanceBetween(p2, p3);\n\tvar l2 = Vector.distanceBetween(p1, p3);\n\tvar l3 = Vector.distanceBetween(p1, p2);\n\tvar lengthSum = l1 + l2 + l3;\n\treturn [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n};\n\n/**\r\n * @description\r\n */\nVector.centroid = function (polygon) {\n\tif (polygon.length === 3) {\n\t\tvar p1 = polygon[0];\n\t\tvar p2 = polygon[1];\n\t\tvar p3 = polygon[2];\n\n\t\tvar x = p1[0] + p2[0] + p3[0];\n\t\tvar y = p1[1] + p2[1] + p3[1];\n\n\t\treturn [x / 3, y / 3];\n\t}\n\n\t// polygon.length assumed > 3 and assumed to be non-self-intersecting\n\t// See wikipedia\n\n\t// First calculate the area, A, of the polygon\n\tvar A = 0;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar p0 = polygon[i];\n\t\tvar _p = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n\t\tA = A + (p0[0] * _p[1] - _p[0] * p0[1]);\n\t}\n\tA = A / 2;\n\n\tvar C = [0, 0];\n\tfor (var _i = 0; _i < polygon.length; _i++) {\n\t\tvar _p2 = polygon[_i];\n\t\tvar _p3 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n\n\t\tC[0] = C[0] + (_p2[0] + _p3[0]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t\tC[1] = C[1] + (_p2[1] + _p3[1]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t}\n\n\treturn [C[0] / (6 * A), C[1] / (6 * A)];\n};\n\n/**\r\n * Calculate the determinant of 3 3-vectors, i.e. 3x3 matrix\r\n * \r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns\r\n */\nfunction det3(x, y, z) {\n\treturn x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n}\n\nfunction squaredNorm(x) {\n\treturn x[0] * x[0] + x[1] * x[1];\n}\n\nVector.translate = function (p, t) {\n\treturn [p[0] + t[0], p[1] + t[1]];\n};\n\nVector.equal = function (p1, p2) {\n\treturn p1[0] === p2[0] && p1[1] === p2[1];\n};\n\nVector.rotate = function (p, sinAngle, cosAngle) {\n\treturn [p[0] * cosAngle - p[1] * sinAngle, p[0] * sinAngle + p[1] * cosAngle];\n};\n\nVector.reverseRotate = function (p, sinAngle, cosAngle) {\n\treturn [+p[0] * cosAngle + p[1] * sinAngle, -p[0] * sinAngle + p[1] * cosAngle];\n};\n\nVector.rotateBy90Degrees = function (p) {\n\treturn [-p[1], p[0]];\n};\n\nVector.rotateByNeg90Degrees = function (p) {\n\treturn [p[1], -p[0]];\n};\n\nVector.transform = function (p, f) {\n\treturn [f(p[0]), f(p[1])];\n};\n\n/**\r\n * @param point        The point\r\n * @param points       The points \r\n * @param distanceFunc Distance function - if null, uses Vector.squaredDistanceBetween\r\n */\nVector.getClosestTo = function (point, points, distanceFunc) {\n\tvar f = distanceFunc || Vector.squaredDistanceBetween;\n\n\t//if (points.length === 0) { console.log(point)}\n\tvar cp = undefined;\n\tvar bestd = Number.POSITIVE_INFINITY;\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar p = points[i];\n\n\t\tvar d = f(point, p);\n\t\tif (d < bestd) {\n\t\t\tcp = p;\n\t\t\tbestd = d;\n\t\t}\n\t}\n\n\treturn cp;\n};\n\nVector.translatePoints = function (ps, v) {\n\t// SLOW!\n\t/*return ps.map(function(p) {\r\n \t//return Vector.translate(p, v);\r\n \treturn [p[0]+v[0], p[1]+v[1]]; \r\n });*/\n\n\t// FAST! (at least on V8, BUT WHY?!)\n\tvar result = [];\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tresult.push([ps[i][0] + v[0], ps[i][1] + v[1]]);\n\t}\n\n\treturn result;\n};\n\nVector.rotatePoints = function (ps, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.rotate(p, sinAngle, cosAngle);\n\t});\n};\n\n/** Applies a translation and then rotation to to each point.\r\n * @returns transformed points \r\n **/\nVector.translateThenRotatePoints = function (ps, trans, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.rotate(Vector.translate(p, trans), sinAngle, cosAngle);\n\t});\n};\n\n/** Applies a rotation and then translation to each point.\r\n * @returns transformed points \r\n **/\nVector.rotateThenTranslatePoints = function (ps, trans, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.translate(Vector.rotate(p, sinAngle, cosAngle), trans);\n\t});\n};\n\nmodule.exports = Vector;\n\n},{}]},{},[17]);\n"]}
{"version":3,"sources":["mat-lib.min.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","MatDebug","draw","drawStuff","run","setViewBox","Vector","beziersToDraw","shouldDrawSATTree","this","elems","elemCount","twoProngs","threeProngs","nProngs","cpCalcs","rootsSkipped","rootsNotSkipped","skipped","stage0","stage1","stage2","stage3","notSkipped","generated","nodeHash","cpHash","cpArr","mat","sat","state","selectedCp","undefined","fs","threeProng","drawSpokes","_drawSpokes","cp","log","selectNext","next","selectPrevOnCircle","prevOnCircle","deltasToNiceStr","pointsToNiceStr","deltaToNiceString","delta","map","cpNode","item","key","pToStr5","p","toFixed","ps","deltas","debug","nProng","console","cc","circle","center","line","getClosestPointToPoints","minD","Number","POSITIVE_INFINITY","closestPoint","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","Symbol","iterator","done","q","value","_d","distanceBetween","err","return","Circle","getNodesAsArray","LinkedLoop","PointOnShape","_debug_","toString","pointOnShape","crossHair","prototype","drawSATTree","tree","getNodeStructure","type","size","bucketSizes","push","node","text","name","children","_key","chart","container","nodeStructure","sort","b","getDistanceBetween","_len","arguments","args","Array","_key2","drawDot","color","dot","testNProng_1","test2Prong_2","traceNProng","test2Prong_1","d","trace2ProngConvergence","$timeout","drawBezierArcs","bezArr","shape","beziers","nodeArr","bezier","logBezierInterfaceAngles","tan1","tangent","tan2","crossTangents","cross","Util","radToDeg","Math","asin","remove","log2ProngDelta","log2Prong","twoProng","draw2ProngNormal","y","x","log2ProngDeltaBasic","bez","bezierNode","indx","order","dbgInfo","cs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","c","radius","ccr","logNProngDelta","logNProngDeltaBasic","testNProng_2","testNProng_3","highlightBeziers","rangeStr","COLORS","indxs","rangeStrToIndxArray","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_bezier","getByIndx","drawSomeStuff","looseBoundingBoxes","tightBoundingBoxes","nodeStart","nodeEnd","n_","failedOnly","j","_twoProngInfo","failed","twoProngInfo","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","xs","z","squaredDistanceBetween","logNearestNProng","twoProngsOnly","_this","matNodes","filter","matCircle","cpNodes","makeSimpleKey","nodeHashDebugObj","matNode","cpHashDebugObjs","simpleKey","visitedPointsArr","pos","0","MatLib","./geometry/classes/circle.js","./geometry/classes/point-on-shape.js","./linked-loop/linked-loop.js","./linked-loop/list-node.js","./mat/functions/get-nodes-as-array.js","./vector/vector.js","2","dullCornerAt","dullCornerHash","result","typeToStr","MAT_CONSTANTS","pointType","osculatingCircle","sharpness","setPointOrder","dullCorner","tan1pre","toUnitVector","fromTo","shift","Δt","newBezierNode","prev","evaluate","standard","cloneAndAdv","split","splitForward","splitBack","toHumanString","str","compare","res","../../mat-constants.js","../../vector/vector.js","3","Arc","startpoint","endpoint","sin_angle1","cos_angle1","sin_angle2","cos_angle2","4","Bezier","bezierPoints","ds","dx_","evaluateDx","dy_","evaluateDy","sqrt","getCurveLength","curveLength","gaussQuadrature","κ","ddx_","evaluateDdx","ddy_","evaluateDdy","denom","κTimesSDiff","getTotalAbsoluteCurvature","interval_","interval","totalAbsoluteCurvature","abs","getTotalCurvature","totalCurvature","dκ","ts","omt","x3","y3","x2","x1","x0","y2","y1","y0","g","h","pow","evaluateX","evaluateY","normal","tangent_","getBoundingBoxTight","boundingBoxTight","box","getNormalizedBoundingBox","p0x","p0y","p1x","p1y","axisAlignedBox","rotateThenTranslatePoints","sinAngle","cosAngle","normalizedBoundingBox","vectorToOrigin","transform","normalizedBezier","translateThenRotatePoints","getBoundingBox","boundingBox","dx","dy","roots","Poly","findQuadraticRoots01","testPointsY","minX","maxX","NEGATIVE_INFINITY","xx","tAtMaxX","min","max","_bezierPoints","_slicedToArray","_bezierPoints$","_bezierPoints$2","_bezierPoints$3","_bezierPoints$4","differentiate","ddx","ddy","straightLength","sliceIterator","arr","_arr","_n","_e","_s","_i","isArray","Object","TypeError","splitAt","_bezierPoints2","_bezierPoints2$","_bezierPoints2$2","_bezierPoints2$3","_bezierPoints2$4","t2","t3","s2","s3","part1","part2","../../numerical/functions/gaussian-quadrature.js","../../polynomial/polynomial.js","../../utils.js","5","scale","6","7","determineUsedPoints","pointsOnShape","usedPointsOnShape","intersects","Geometry","doesCircleIntersectShape","dull","createCoupledCpLoops","contactPointArr","cpLoop","ContactPoint","denseContactPoints","prevCpNode","prevCoupledCpNode","insert","acos","PI","sharp","coupledNode","addPrelimMatCircles_CullPoints_AndGetPotential2Prongs","contactPoints","head","for2Prongs","toRemove","MatCircle","create","osculating","nextOnCircle","_cpNode","respacePoints","maxAbsCurvatureInDegrees","recheck","totalCurvatures","denseCpNode","getTotalAbsCurvatureBetweenCps","sumCurvatures","totalInDegrees","accumTot","tc","bestIndx","leftDenseIndx","rightDenseIndx","accumTotAtLeft","accumTotAtRight","bestDiff","_c","cTot","totalTurn","absDiff","tcInfo","newCpNode","slice","leftTcInfo","rightTcInfo","leftCpNode","rightCpNode","getCPointBetweenCps","leftCp","rightCp","totAtMid","accumTo","posStart","posEnd","bezierNodeStart","bezierNodeEnd","turn","getCurvatureAtInterface","curvature","totalBoth","curvatures","total","_ref","_ref2","cpStart","cpEnd","debugActionsOnShapeCreate","contactPoint","getInterestingPointsOnShape","allPoints","getContactCirclesAtBezierBezierInterface","apply","getBezierOsculatingCircles","firstPoint","lastPoint","splice","getTotalBy","tans","cosθ","sinθ","θ","LlRbTree","Shape","createContactPoint","getNeighbouringPoints","cptree","cps","findBounds","data","root","forAllBeziers","../../geometry/classes/bezier.js","../../geometry/classes/point-on-shape.js","../../geometry/geometry.js","../../linked-loop/linked-loop.js","../../ll-rb-tree//ll-rb-tree.js","../../mat/classes/contact-point.js","../../mat/classes/mat-circle.js","../../svg/svg.js","../functions/get-bezier-osculating-circles.js","../functions/get-contact-circles-at-bezier-bezier-interface.js","8","calcCurvatureExtremaBrackets","sin_theta","_bezier$bezierPoints","_bezier$bezierPoints$","_bezier$bezierPoints$2","_bezier$bezierPoints$3","_bezier$bezierPoints$4","brackets","P_1x","P_1y","P_2x","P_2y","P_3x","P_3y","W_0x","W_1x","W_2x","W_0y","W_1y","W_2y","atan_numer","atan_denom","atan_numer_squared","atan_denom_squared","radpre","rad","cos_theta","R_1x","R_1y","R_2x","R_2y","R_3x","R_3y","a_","dif","mu","lambda","gamma1","gamma2","sigd_","b_","ssigd_","sda","sdb","ksi_pre1","ksi_pre2","ksi1","ksi2","deReParameterize","sigma","deReParameterizeBoundary","boundary","fixBoundary","bound","b0","b1","../classes/bezier.js","9","calcBezierCurvatureExtremaBrackets","lenb","k","bracket","_root","lookForRoot","pointDetails","getCircleAtRoot","minsd","maxsd","c0","c1","brent","_ref3","_ref4","κAtMinsd","κAtMaxsd","maxOsculatingCircleRadius","reverseOsculating","../../geometry/classes/circle.js","./calc-bezier-curvature-extrema.js","10","getClosestBoundaryPointToPoint","bezierPieces_","point","exclPoint","touchedBezierNode","slog_","tGap","bezierPieces","cullBezierPieces","bestDistance","ii","bezierPiece","slog","closestPointAndDistance","getClosestPointOnBezierPiece","CULL_THRESHOLD","shortCircuit","bestSquaredDistance","getClosePoint","cullByLooseBoundingBox","cullByTightBoundingBox","p1","tRange","p2","d1","d2","candidateBezierPieces","looseBoundingBox","getClosestSquareDistanceToRect","closestSquaredDistanceToRotatedRect","../classes/Point-on-shape.js","../geometry.js","./get-closest-point-on-bezier-piece.js","11","closestPointBetween_PointAndBezier","12","bezierNodes","negDot","CROSS_TANGENT_LIMIT","orders","_pos","13","BezierPiece","getTRanges","isP0OnBezier","isP1OnBezier","crossT1","isBezierBoxWhollyOutsideCircleBox","ox","oy","boxTight","translatePoints","boxDiagonal","rotate","anyBoxVerticalInside","boxVerticalsCapture","anyBoxHorizontalInside","boxHorizontalsCapture","doesCircleEngulfCircle","c2","dr","δ","doesLineIntersectCircle","p0","cx","cy","fx","fy","discriminant","t1","getBoundaryPieceBeziers","addSkippedBeziers","pThis","pNext","bNode","goStraight","cp0","cp1","pos_start","newPos","getLineShapeIntersectionPoints","points","iPoints","getLineBezierIntersectionPoints","tightBoundingBox","squaredDistanceBetweenPointAndLineSegment","bestBy","xp","yp","_d2","_d3","getShapeRightMostInfo","bezierArr","maxBezier","rightMost","isShapePositivelyOrientated","_Geometry$getShapeRig","tan","prevBezier","prevP","prevT","memClosestPoint","prevTRange","prevTouchedBezier","touchedBezier","_p","xx0","xx1","xx2","xx3","yy0","yy1","yy2","yy3","x00","x01","x02","x03","x11","x12","x13","x22","x23","x33","y00","y01","y02","y03","y11","y12","y13","y22","y23","y33","t5","t4","t0","poly","deflatedPoly","deflate","allRoots","allRoots01","push0","push1","getClosestTo","degAngleFromSinCos","toDeg","atan","closestPointOnArc","arc","arco","translate","pp","sin_pp","cos_pp","isAngleBetween","r_o_l","position","asp","aep","distanceBetweenPointAndLineSegment","v","l1p2","lineLineIntersection","arcFrom3Points","circlePoints","midPoint1","mean","midPoint2","chord1","chord2","perpendicular1","perpendicular2","line1","line2","circleCenter","equal","sideVector1","midVector","sideVector2","sin_midangle","cos_midangle","quadrant","sin_angle","cos_angle","isAngle1LargerOrEqual","q1","q2","t1_larger_t2","a_larger_t2","a_larger_t1","p2x","p2y","p3x","p3y","p4x","p4y","v1x","v1y","v2x","v2y","lineThroughPointAtRightAngleTo","vv","p20","p21","lineLength","findCubicRoots01","candidateBeziers","candidateBezier","x0_2","x1_2","x2_2","x3_2","y0_2","y1_2","y2_2","y3_2","t6","tRanges","peval","totalRoots","rootsWithin","../polynomial/functions/all-roots-vas.js","../polynomial/polynomial.js","../utils.js","../vector/vector.js","./classes/arc.js","./classes/bezier.js","./classes/circle.js","./classes/point-on-shape.js","14","array","comparator","addAllFromScratch","ListNode","loop","prev_","linkedLoop","advanceNSteps","prevNode","../ll-rb-tree/ll-rb-tree.js","./list-node.js","15","16","Node","red","getMinOrMaxNode","dir","flipColors","LEFT","RIGHT","moveRedLeft","isRed","moveRedRight","fixUp","getMinNode","getMaxNode","bounds","find","cmp","removeMin","17","18","smoothen","findMat","toScaleAxis","Mat","Svg","window","assign","./debug.js","./geometry/classes/bezier.js","./geometry/classes/shape.js","./geometry/geometry.js","./ll-rb-tree//ll-rb-tree.js","./mat-constants.js","./mat/classes/contact-point.js","./mat/classes/mat-circle.js","./mat/classes/mat-node.js","./mat/classes/mat.js","./mat/functions/find-mat.js","./mat/functions/smoothen.js","./mat/functions/to-scale-axis.js","./polynomial/polynomial.js","./svg/svg.js","./utils.js","19","20","visited","copy","21","MatNode","branches","helper","priorNode","newPriorNode","newNode","_node","./mat-circle.js","22","startNode","traverse","../../mat/functions/traverse.js","23","add2Prong","cp1Node","cp2","cmp1","cmp2","prepForDebug","cpKey","arrIndx","cpHashDebugObj","../../geometry/classes/shape.js","24","add3Prong","delta3s","cmps","_i2","idxsPrev","idxsNext","_i3","25","buildMat","cpNodeStart","fromNode","fromCpNode","isRetry","visitedPoints","traverseShape","findAndAdd3Prong","createMatNode","_matNode","_matNode2","cpBranches","cpNext","bm","prepDebugHashes","visitedPoint","continuous","idxi","endP","startP","find3Prong","../../mat/classes/mat-node.js","./add-3-prong.js","./find-3-prong.js","26","copyMat","../classes/mat.js","27","find2Prong","shortestSquaredDistance","squaredError","squaredChordDistance","SQUARED_SEPERATION_TOLERANCE","nextX","findEquidistantPointOnLine","squaredDistance","SQUARED_ERROR_TOLERANCE","MAX_ITERATIONS","recordForDebugging","rSquared","newPieces","rect","bd","swapAxes","z1","z2","SEPERATION_TOLERANCE","ERROR_TOLERANCE","../../geometry/classes/Point-on-shape.js","../../geometry/functions/get-closest-boundary-point-to-point.js","28","bezierPiecess","bps","bx","iindx","smallestRadiusDelta","_find3ProngForDelta3s","find3ProngForDelta3s","radiusDelta","_x","totDist","add3ProngForDebugging","idx","TOLERANCE","bezierPiece3s","calcInitial3ProngPoint","tolerance","getClosestPoints","myCircumCenter","_vectorToZeroV","calcVectorToZeroV_StraightToIt","upds","calcBetterX","newX","V","newPs","newV","closestDs","closestD","indxi","vectorToZeroV","nu","better","newCircleCenter","newVectorToZeroV","twoProngCircleCenter","point1","meanPoints","circumCenter","isFinite","sames","whichNotSame","deltasSimple","l1","l2","l3","ccs","newP","_minD","../..//utils.js","29","performance","now","add2Prongs","add2ProngsDuration","ta0","cptest","branchBack","branchForth","ta1","matFixed","fixMat","len","index","indexLinear","failCount","firstRight","secondRight","./add-2-prong.js","./build-mat.js","./find-2-prong.js","30","nodes","./traverse.js","31","getNodesAsHash","32","getLinkedCps","prevCpNodes","currCpNodes","currCpNode","currNode","getDirectionToNextMatCircle","isPrev","vDir","spanner","rotateBy90Degrees","bezierNode1","bezierNode2","reverse","toLength","prevMatCircle","prevCc","currMatCircle","currCc","_getLinkedCps","_getLinkedCps2","prevL","currL","mid","twisted","dot1","dot2","lp1","vv1","vvv1","lpp1","mid1","mid2","DRAW_CLASS_CUBE","quadBezier","DRAW_CLASS_QUAD","DRAW_CLASS_LINE","33","mat_","biggest","biggestNode","createSpacialTree","cullHash","traverseSpacialTree","cullem","cullNodes","cullIt","cullTheNodes","addToTree","coordinate","limits","depth","DEPTH_LIMIT","_calcGroups","calcGroups","groups","newLimits","group","_branch","newCoordinate","Map","branch","set","width","height","getCullNodes","extraParams","forEach","testNode","cullBranch5","delete","_calcGroups2","_branch4","_branch2","_branch3","satNode","anyNotCull","cullTheNode","cullNode","indexOf","limit","w","newLimit","qStart","floor","qEnd","qDiff","lowerLimit","_lowerLimit","otherCoordinate","./copy-mat.js","./get-nodes-as-hash.js","34","35","Mobius","numer","changeVariables","mobius","invert","evaluateAt0","evaluateAtInf","36","order_","constants","GAUSS_CONSTANTS","weights","abscissas","_interval","m1","m2","37","allRootsVAS","zeroRoots","numZeros","p_","vasRoots","vasRootIntervals","notOverlap","positiveIntervals","vasRootIntervalsHelper","intervals","concat","signVariations","signChanges","M0","MI","MM0","MMI","positiveRootUpperBound","lb","positiveRootLowerBound","p01","M01","m","p1inf","M1inf","intervals1","intervals3","../../mobius/mobius.js","38","cuberoot","rootFilter01","u1","v1","root1","root2","root3","p3","mp3","mp33","cosphi","phi","crtr","cos","sd","39","_defineProperty","obj","defineProperty","enumerable","configurable","writable","coeff","multiplyByConst","negate","minus","poly1","poly2","v2","multiply","degree","bn","curSign","newSign","sign","remainder","unshift","pre1","pre2","pre3","pre4","pre5","bs","sturmChain","as","newton","initialGuess","dp","val","deg","timesUsed","ub","tempub","any","temp","fill","_j","acc","diff","evA","evB","sgn","root1InRange","root2InRange","errorTol","uuu","fa","fb","mflag","prevError","fc","fac","fab","fbc","b_c","s_b","c_d","error","_Poly","./functions/find-cubic-roots.js","40","svgGetAndSetPathDataPolyFill","SVGPathElement","getPathData","setPathData","applyPolyFill","commandsMap","Z","M","L","C","Q","A","H","S","T","Source","string","_string","_currentIndex","_endIndex","_prevCommand","_skipOptionalSpaces","isIE","navigator","userAgent","parseSegment","char","command","values","cmd","toUpperCase","_parseNumber","_parseArcFlag","hasMoreData","peekSegmentType","initialCommandIsMoveTo","_isCurrentSpace","_skipOptionalSpacesOrDelimiter","exponent","integer","frac","decimal","expsign","startIndex","startIntPartIndex","scanIntPartIndex","multiplier","number","flag","flagChar","symbols","parsePathDataString","source","pathData","pathSeg","setAttribute","removeAttribute","cachedPathData","cachedNormalizedPathData","arcToCubicCurves","r1","r2","angle","largeArcFlag","sweepFlag","_recursive","f1","f2","degToRad","degrees","angleRad","X","sin","Y","params","r1Pow","r2Pow","left","right","df","f2old","x2old","y2old","s1","hx","hy","m3","m4","join","curves","curveParams","param","clonePathData","seg","absolutizePathData","absolutizedPathData","currentX","currentY","subpathX","subpathY","reducePathData","reducedPathData","lastType","lastControlX","lastControlY","cx1","cy1","cx2","cy2","curve","options","normalize","getAttribute","normalizedPathData","41","reverseBeziersOrientation","bezies","reverseBez","newBezier","getBeziersFromSvgElem","elem","paths","bezierArray","path","bezArray","../geometry/classes/bezier.js","../geometry/geometry.js","../linked-loop/linked-loop.js","./path-data-polyfill/path-data-polyfill.js","42","f_","best","43","det3","squaredNorm","factor","scaleFactor","lengthSquared","distanceBetweenPointAndLine","y2_y1","x2_x1","numerator","denominator","triangle","Sx","Sy","inCenter","lengthSum","centroid","polygon","_p2","_p3","reverseRotate","rotateByNeg90Degrees","distanceFunc","bestd","rotatePoints","trans"],"mappings":"CAAA,QAAUA,GAAEC,EAAEC,EAAEC,GAAG,QAASC,GAAEC,EAAEC,GAAG,IAAIJ,EAAEG,GAAG,CAAC,IAAIJ,EAAEI,GAAG,CAAC,GAAIE,GAAkB,kBAATC,UAAqBA,OAAQ,KAAIF,GAAGC,EAAE,MAAOA,GAAEF,GAAE,EAAI,IAAGI,EAAE,MAAOA,GAAEJ,GAAE,EAAI,IAAIK,GAAE,GAAIC,OAAM,uBAAuBN,EAAE,IAAK,MAAMK,GAAEE,KAAK,mBAAmBF,EAAE,GAAIG,GAAEX,EAAEG,IAAIS,WAAYb,GAAEI,GAAG,GAAGU,KAAKF,EAAEC,QAAQ,SAASd,GAAG,GAAIE,GAAED,EAAEI,GAAG,GAAGL,EAAG,OAAOI,GAAEF,EAAEA,EAAEF,IAAIa,EAAEA,EAAEC,QAAQd,EAAEC,EAAEC,EAAEC,GAAG,MAAOD,GAAEG,GAAGS,QAAkD,IAAI,GAA1CL,GAAkB,kBAATD,UAAqBA,QAAgBH,EAAE,EAAEA,EAAEF,EAAEa,OAAOX,IAAID,EAAED,EAAEE,GAAI,OAAOD,KAAKa,GAAG,SAAST,EAAQU,EAAOJ,GACvd,YA2BA,SAASK,GAASC,EAAMC,EAAWC,EAAKC,EAAYC,EAAQC,EAAeC,GAE1EC,KAAKP,KAAOA,EACZO,KAAKN,UAAYA,EACjBM,KAAKL,IAAMA,EACXK,KAAKJ,WAAaA,EAClBI,KAAKH,OAASA,EACdG,KAAKF,cAAgBA,EACrBE,KAAKD,kBAAoBA,EAGzBC,KAAKC,SACLD,KAAKE,UAAY,EACjBF,KAAKG,aACLH,KAAKI,eACLJ,KAAKK,WACLL,KAAKM,QAAU,EACfN,KAAKO,aAAe,EACpBP,KAAKQ,gBAAkB,EACvBR,KAAKS,SACJC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,GAETb,KAAKc,YACJJ,OAAQ,EACRC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,GAGTb,KAAKe,WACJC,YACAC,UACAC,UAGDlB,KAAKmB,IACLnB,KAAKoB,IAELpB,KAAKqB,OACJC,WAAYC,QAIbvB,KAAKwB,IACJC,YACCC,WAAY,SAAoBnD,GAC/B,MAAOoD,GAAY3B,KAAMzB,KAG3BqD,IACCC,IAAKD,EAAGC,IAAI7B,MACZP,KAAMmC,EAAGnC,KAAKO,MACd8B,WAAYF,EAAGG,KAAK/B,MACpBgC,mBAAoBJ,EAAGK,aAAajC,QAKtCA,KAAKkC,gBAAkBA,EACvBlC,KAAKmC,gBAAkBA,EAGxB,QAASC,GAAkBC,GAC1B,MAAOA,GAAMC,IAAI,SAAUC,GAC1B,MAAOA,GAAOC,KAAKC,MAIrB,QAASC,GAAQC,GAChB,MAAOA,GAAE,GAAGC,QAAQ,GAAK,KAAOD,EAAE,GAAGC,QAAQ,GAG9C,QAAST,GAAgBU,GACxB,MAAOA,GAAGP,IAAII,GAGf,QAASR,GAAgBY,GACxB,MAAOA,GAAOR,IAAIF,GAoRnB,QAAST,GAAYoB,EAAOxE,GAC3B,GAAIyE,GAASD,EAAM1C,QAAQ9B,GACvBkD,EAAauB,EAAOvB,UAExBwB,SAAQpB,IAAIJ,EACZ,IAAIyB,GAAKzB,EAAW0B,OAAOC,OACvBP,EAAKpB,EAAWoB,EACpBE,GAAMtD,KAAK4D,MAAMR,EAAG,GAAIK,GAAK,aAC7BH,EAAMtD,KAAK4D,MAAMR,EAAG,GAAIK,GAAK,aAC7BH,EAAMtD,KAAK4D,MAAMR,EAAG,GAAIK,GAAK,aA+M9B,QAASI,GAAwBT,EAAIF,GACpC,GAAIY,GAAOC,OAAOC,kBACdC,EAAe,OAEfC,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkBtC,MAEtB,KACC,IAAK,GAAwCuC,GAApCC,EAAalB,EAAGmB,OAAOC,cAAuBN,GAA8BG,EAASC,EAAWhC,QAAQmC,MAAOP,GAA6B,EAAM,CAC1J,GAAIQ,GAAIL,EAAOM,MAEXC,EAAKxE,EAAOyE,gBAAgBH,EAAGxB,EAE/B0B,GAAKd,IACRA,EAAOc,EAEPX,EAAeS,IAGhB,MAAOI,GACRX,GAAqB,EACrBC,EAAkBU,EACjB,QACD,KACMZ,GAA8BI,EAAWS,QAC7CT,EAAWS,SAEX,QACD,GAAIZ,EACH,KAAMC,IAKT,MAAOH,GAxnBR,GAAIe,GAAS5F,EAAQ,gCACjB6F,EAAkB7F,EAAQ,yCAE1B8F,GADW9F,EAAQ,8BACNA,EAAQ,iCACrBgB,EAAShB,EAAQ,sBACjB+F,EAAe/F,EAAQ,wCAuGvB+C,GACHC,IAAK,SAAagD,GACjB,MAAO,YACN,GAAItC,GAASsC,EAAQxD,MAAMC,WACvBM,EAAKW,EAAOC,IAChBS,SAAQpB,IAAIU,GACZU,QAAQpB,IAAI+C,EAAaE,SAASlD,EAAGmD,iBAGvChD,KAAM,SAAc8C,GACnB,MAAO,YACNA,EAAQxD,MAAMC,WAAauD,EAAQxD,MAAMC,WAAWS,OAGtDE,aAAc,SAAsB4C,GACnC,MAAO,YACNA,EAAQxD,MAAMC,WAAauD,EAAQxD,MAAMC,WAAWW,eAGtDxC,KAAM,SAAcoF,GACnB,MAAO,YACNA,EAAQpF,KAAKuF,UAAUH,EAAQxD,MAAMC,WAAWkB,KAAM,oBAAqB,KAe9EhD,GAASyF,UAAUC,YAAc,SAAUC,GAI1C,QAASC,GAAiB3C,EAAKnE,GAE9B,GAAI+G,GAAe,MAAR5C,EAAc,IAAMA,CAElB,OAAT4C,IACHA,EAAO,KAAO/G,EAAEgH,KAEhBC,EAAYC,KAAKlH,EAAEgH,MAGpB,IAAIG,IACHC,MAAQC,KAAMN,GACdO,YAGD,KAAK,GAAIC,KAAQvH,GAAG,CACnB,GAAIC,GAAID,EAAEuH,EAEVJ,GAAKG,SAASJ,KAAKJ,EAAiBS,EAAMtH,IAG3C,MAAOkH,GAvBR,GAAIF,QA2BHO,OAASC,UAAW,aACpBC,cAAeZ,EAAiB,OAAQD,IAMzCI,GAAYU,KAAK,SAAUrH,EAAGsH,GAC7B,MAAOtH,GAAIsH,KAIb1G,EAASyF,UAAUkB,mBAAqB,WACvC,IAAK,GAAIC,GAAOC,UAAUhH,OAAQiH,EAAOC,MAAMH,GAAOI,EAAQ,EAAGA,EAAQJ,EAAMI,IAC9EF,EAAKE,GAASH,UAAUG,EAGzB,OAAO3G,GAAOyE,gBAAgBgC,IAG/B9G,EAASyF,UAAUwB,QAAU,SAAU9D,EAAGnE,EAAGkI,GAC5C,MAAO1G,MAAKP,KAAKkH,IAAIhE,EAAGnE,EAAGkI,IAG5BlH,EAASyF,UAAU2B,aAAe,WACjC5G,KAAKJ,YAAY,GAAI,IAAK,GAAI,MAI/BJ,EAASyF,UAAU4B,aAAe,WACjC7G,KAAK8G,YAAY,IACjB9G,KAAKyG,SAAS,OAAQ,QAAS,GAAK,SACpCzG,KAAKyG,SAAS,OAAQ,QAAS,GAAK,SACpCzG,KAAKyG,SAAS,kBAAmB,mBAAoB,GAAK,SAC1DzG,KAAKyG,SAAS,mBAAoB,oBAAqB,GAAK,SAE5DzG,KAAKyG,SAAS,mBAAoB,oBAAqB,GAAK,UAC5DzG,KAAKyG,SAAS,OAAQ,QAAS,GAAK,WAGrCjH,EAASyF,UAAU8B,aAAe,WACjC/G,KAAKJ,YAAY,IAAK,IAAK,IAAK,MAChCoH,EAAEC,uBAAuB,GAMzBC,aAOD1H,EAASyF,UAAUkC,eAAiB,SAAU5I,GAC7C,GAEI6I,IAFQpH,KAAKqH,MAEJC,QAAQC,SACjBC,EAASJ,EAAO7I,EAEpB0E,SAAQpB,IAAI2F,IAGbhI,EAASyF,UAAUwC,yBAA2B,WAE7C,GAAIC,GAAOF,OAAOG,QAAQ,GACtBC,EAAOnC,KAAK1D,KAAKS,KAAKmF,QAAQ,GAC9BE,EAAgBhI,EAAOiI,MAAMJ,EAAME,EAE7B,wBAAyBG,KAAKC,SAASC,KAAKC,KAAKL,IAAgBjF,QAAQ,IAGpFpD,EAASyF,UAAUkD,OAAS,SAAU5J,GACrCyB,KAAKC,MAAM1B,GAAG4J,UAGf3I,EAASyF,UAAUmD,eAAiB,SAAU7J,GAC7C,GAAI8D,GAAQrC,KAAKG,UAAU5B,GAAG8D,KAE9BY,SAAQpB,IAAIQ,IAGb7C,EAASyF,UAAUoD,UAAY,SAAU9J,GACxC,GAAI+J,GAAWtI,KAAKG,UAAU5B,EAE9B0E,SAAQpB,IAAIyG,IAGb9I,EAASyF,UAAUsD,iBAAmB,SAAUhK,GAE/C,GAAUgD,SAANhD,EACH,IAAK,GAAIO,GAAI,EAAGA,EAAIkB,KAAKG,UAAUd,OAAQP,IAC1CkB,KAAKuI,iBAAiBzJ,EAIxB,IAAIwJ,GAAWtI,KAAKG,UAAU5B,EAEzB+J,IAILtI,KAAKP,KAAK4D,MAAMiF,EAASE,EAAGF,EAASG,GAAI,gBAG1CjJ,EAASyF,UAAUyD,oBAAsB,SAAUnK,GAClD,GAAI8D,GAAQrC,KAAKG,UAAU5B,GAAG8D,MAE1BtD,EAAI,SAAW0J,GAClB,OACCE,IAAKF,EAAEjG,KAAKuC,aAAa6D,WAAWpG,KAAKqG,KACzCvK,EAAGmK,EAAEjG,KAAKuC,aAAazG,EACvBwK,MAAOL,EAAEjG,KAAKuC,aAAa+D,OAI7B7F,SAAQpB,IAAI9C,EAAEsD,EAAM,KACpBY,QAAQpB,IAAI9C,EAAEsD,EAAM,MAGrB7C,EAASyF,UAAU6B,YAAc,SAAUvI,GAI1C,GAAIkD,GAAazB,KAAKK,QAAQ9B,GAE1BwK,EAAUtH,EAAWsH,QACrBC,EAAKD,EAAQC,EAEjB/F,SAAQpB,IAAIJ,EACZ,IAAIwH,IAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAuC6H,GAAnCC,EAAYL,EAAGhF,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CACpJ,GAAIK,GAAIF,EAAMhF,KAEdpE,MAAKP,KAAKkH,IAAI2C,EAAEb,EAAG,GAAK,QACxBa,EAAEC,OAASD,EAAEE,IACbF,EAAElG,OAASkG,EAAEb,EACbzI,KAAKP,KAAK0D,OAAOmG,EAAG,uBAGpB,MAAO/E,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,MAMV3J,EAASyF,UAAUwE,eAAiB,SAAUlL,GAC7C,GAAIyE,GAAShD,KAAKK,QAAQ9B,EAE1B0E,SAAQpB,IAAImB,EAAOF,SAGpBtD,EAASyF,UAAUyE,oBAAsB,SAAUnL,GAWlD,IAAK,GAVDyE,GAAShD,KAAKK,QAAQ9B,GAEtBQ,EAAI,SAAW0J,GAClB,OACCE,IAAKF,EAAEjG,KAAKuC,aAAa6D,WAAWpG,KAAKqG,KACzCvK,EAAGmK,EAAEjG,KAAKuC,aAAazG,EACvBwK,MAAOL,EAAEjG,KAAKuC,aAAa+D,QAIpBhK,EAAI,EAAGA,EAAIkE,EAAOF,OAAOzD,OAAQP,IAAK,CAC9C,GAAIuD,GAAQW,EAAOF,OAAOhE,EAE1BmE,SAAQpB,IAAI9C,EAAEsD,EAAM,IAAKtD,EAAEsD,EAAM,OAKnC7C,EAASyF,UAAU0E,aAAe,WACjC3J,KAAKJ,YAAY,GAAI,IAAK,GAAI,KAE9BoH,EAAEuB,iBAAiB,IACnBvB,EAAEuB,iBAAiB,IACnBvB,EAAE0C,oBAAoB,GAEtBxC,YAGD1H,EAASyF,UAAU2E,aAAe,WACjC5J,KAAKL,MACLK,KAAKJ,YAAY,GAAI,IAAK,GAAI,KAK9BoH,EAAE0C,oBAAoB,GAEtBxC,YAeD1H,EAASyF,UAAU4E,iBAAmB,SAAUC,GAC/C,GAAIC,IAAU,MAAO,QAAS,QAE1BC,EAAQjC,KAAKkC,oBAAoBH,GAEjChL,EAAI,EACJoL,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkB7I,MAEtB,KACC,IAAK,GAA2C8I,GAAvCC,EAAaN,EAAMhG,OAAOC,cAAuBiG,GAA8BG,EAASC,EAAWvI,QAAQmC,MAAOgG,GAA6B,EAAM,CAC7J,GAAIrB,GAAOwB,EAAOjG,KAElBtF,IAEA,IAAIyL,GAAU5F,EAAW6F,UAAUnD,MAAMC,QAASuB,GAE9CnC,EAAQqD,EAAOjL,EAAIiL,EAAO1K,OAC9BI,MAAK+H,OAAO+C,EAAS,iBAAmB7D,IAExC,MAAOnC,GACR4F,GAAqB,EACrBC,EAAkB7F,EACjB,QACD,KACM2F,GAA8BI,EAAW9F,QAC7C8F,EAAW9F,SAEX,QACD,GAAI2F,EACH,KAAMC,MAMV5K,EAASyF,UAAUwF,cAAgB,SAAUpD,GAG5CrH,KAAKP,KAAKiL,mBAAmBrD,EAAO,sBACpCrH,KAAKP,KAAKkL,mBAAmBtD,EAAO,qBAEpC,IAAIvH,GAAgBE,KAAKF,cAErB8K,EAAYjG,EAAW6F,UAAUnD,EAAMC,QAASxH,EAAc,IAC9D+K,EAAUlG,EAAW6F,UAAUnD,EAAMC,QAASxH,EAAc,GAAK,EAErEE,MAAKP,KAAK6H,QAAQD,EAAOuD,EAAWC,IAGrCrL,EAASyF,UAAUgC,uBAAyB,SAAU6D,EAAIC,GAEzD,GAAIxM,GAAI,MACR,IAAIwM,EAEH,IAAK,GADDC,GAAI,EACClM,EAAI,EAAGA,EAAIkB,KAAKG,UAAUd,OAAQP,IAAK,CAC/C,GAAImM,GAAgBjL,KAAKG,UAAUrB,EACnC,IAAImM,EAAcC,OAAQ,CACzB,GAAIJ,IAAOE,EAAG,CACbzM,EAAIO,EACJmE,QAAQpB,IAAItD,EACZ,OAGDyM,SAIFzM,GAAIuM,CAGL,IAAKvM,EAAL,CAIA,GAAI4M,GAAenL,KAAKG,UAAU5B,GAG9B6M,GAFWD,EAAa7C,UAEK,GAC7B+C,GAAqB,EACrBC,EAAkB/J,MAEtB,KACC,IAAK,GAAqDgK,GAAjDC,EAAaL,EAAaM,GAAGzH,OAAOC,cAAuBmH,GAA8BG,EAASC,EAAWzJ,QAAQmC,MAAOkH,GAA6B,EAAM,CACvK,GAAI3C,GAAI8C,EAAOnH,KAEfpE,MAAKP,KAAKuF,UAAUyD,EAAEA,EAAG,qBACzB,IAAItF,GAAS,GAAIsB,GAAOgE,EAAEA,EAAG5I,EAAOyE,gBAAgBmE,EAAEA,EAAGA,EAAED,GAC3DxI,MAAKP,KAAK0D,OAAOA,EAAQ,sBACzBnD,KAAKP,KAAKuF,UAAUyD,EAAEiD,EAAG,uBAAwB,IAEjD,MAAOnH,GACR8G,GAAqB,EACrBC,EAAkB/G,EACjB,QACD,KACM6G,GAA8BI,EAAWhH,QAC7CgH,EAAWhH,SAEX,QACD,GAAI6G,EACH,KAAMC,IAiBT,MAZArI,SAAQpB,IAAIsJ,EAAaM,GAAGnJ,IAAI,SAAUmG,GACzC,OACCA,EAAGA,EAAEA,EACLD,EAAGC,EAAED,EACLkD,EAAGjD,EAAEiD,EACL1E,EAAGnH,EAAO8L,uBAAuBlD,EAAED,EAAGC,EAAEiD,GACxCpN,EAAGmK,EAAEnK,MAIP0B,KAAKuI,iBAAiBhK,GAEf,WAAa4M,EAAaD,SAGlC1L,EAASyF,UAAU2G,iBAAmB,SAAUjJ,EAAGkJ,GAClD,GAAIC,GAAQ9L,KAER+L,EAAWrH,EAAgB1E,KAAKmB,KAEhC0B,EAAKkJ,EAASC,OAAO,SAAUvG,GAClC,MAAIoG,GACsC,IAAlCpG,EAAKwG,UAAUC,QAAQ7M,OAEW,IAAlCoG,EAAKwG,UAAUC,QAAQ7M,SAE7BiD,IAAI,SAAUmD,GAChB,MAAOA,GAAKwG,UAAU9I,OAAOC,SAE1Be,EAAIb,EAAwBT,EAAIF,GAEhCF,EAAMmC,EAAauH,cAAchI,GACjCiI,EAAmBpM,KAAKe,UAAUC,SAASyB,GAC3C4J,EAAUD,EAAiBC,QAC3BJ,EAAYI,EAAQJ,UAEpBK,EAAkBL,EAAUC,QAAQ5J,IAAI,SAAUC,GACrD,MAAOuJ,GAAM/K,UAAUE,OAAOsB,EAAOC,KAAK+J,YAG3CtJ,SAAQpB,IAAIuK,GACZnJ,QAAQpB,IAAIyK,GACZrJ,QAAQpB,IAAIyK,EAAgBhK,IAAI,SAAUmG,GACzC,GAAKA,EAGL,MAAOA,GAAE+D,iBAAiBlK,IAAI,SAAUmG,GACvC,MAAOA,GAAEnG,IAAI,SAAUmG,GACtB,OACClG,OAAQkG,EACR7G,GAAI6G,EAAEjG,KACNiK,IAAKhE,EAAEjG,KAAKuC,aACZ2H,EAAGjE,EAAEjG,KAAKuC,aAAa,GACvBzF,EAAGmJ,EAAEjG,KAAKuC,aAAa,WAM3B9B,QAAQpB,IAAIyK,EAAgBhK,IAAI,SAAUmG,GACzC,GAAKA,EAGL,MAAOA,GAAE+D,iBAAiBlK,IAAI,SAAUmG,GACvC,MAAOA,GAAEnG,IAAI,SAAUmG,GACtB,MAAOkE,QAAO/H,aAAaE,SAAS2D,EAAEjG,KAAKuC,oBAKjC,IAAIN,GAAOwH,EAAU9I,OAAOC,OAAQ6I,EAAU9I,OAAOoG,QAAU,EAK5E,IAAIsC,EAAe,CAElB,IAAK,GADDtN,GAAI,OACCO,EAAI,EAAGA,EAAIkB,KAAKG,UAAUd,OAAQP,IAAK,CAC/C,GAAIqM,GAAenL,KAAKG,UAAUrB,GAC9BwJ,EAAW6C,EAAa7C,SACxBpF,EAAKoF,EAAS9F,KAAKyJ,UAAU9I,OAAOC,MAExC,IAAIe,EAAE,KAAOjB,EAAG,IAAMiB,EAAE,KAAOjB,EAAG,GAAI,CACrC3E,EAAIO,CACJ,QAIEP,GACHyB,KAAKiH,uBAAuB1I,KA8C/BgB,EAAOJ,QAAUK,IAEdoN,+BAA+B,EAAEC,uCAAuC,EAAEC,+BAA+B,GAAGC,6BAA6B,GAAGC,wCAAwC,GAAGC,qBAAqB,KAAKC,GAAG,SAASrO,EAAQU,EAAOJ,GAC/O,YA+CA,SAASgO,GAAa9F,EAAO1E,GAE5B,GAAIyK,GAAiB/F,EAAM+F,eACvB3K,EAAMmC,EAAauH,cAAcxJ,GAEjC0K,EAASD,EAAe3K,IAAQ,IAIpC,OAAO4K,GAqGR,QAASC,GAAUjI,GAClB,IAAK,GAAI5C,KAAO8K,GAAcC,UAC7B,GAAID,EAAcC,UAAU/K,KAAS4C,EACpC,MAAO5C,GA9JV,GAAI8K,GAAgB1O,EAAQ,0BACxBgB,EAAShB,EAAQ,0BAsBjB+F,EAAe,QAASA,GAAajC,EAAGiG,EAAYtK,EAAG+G,EAAMyD,EAAO2E,EAAkBC,GAEzF1N,KAAK4I,WAAaA,EAClB5I,KAAK1B,EAAIA,EACT0B,KAAKqF,KAAOA,EACZrF,KAAK8I,MAAQA,EACb9I,KAAKyN,iBAAmBA,EACxBzN,KAAK0N,UAAYA,EAGjB1N,KAAKuM,UAAY3H,EAAauH,cAAcxJ,GAO5C3C,KAAK,GAAK2C,EAAE,GACZ3C,KAAK,GAAK2C,EAAE,GACZ3C,KAAKyC,IAAMmC,EAAaE,SAAS9E,MAwBlC4E,GAAa+I,cAAgB,SAAUtG,EAAOlE,EAAQR,EAAGkC,GAExD,GAAI+I,GAAaT,EAAa9F,EAAO1E,EAErC,IAAKiL,EAAL,CAKA,GAAIjF,GAAMiF,EAAWpG,OACjBqG,EAAUlF,EAAIhB,QAAQ,GAEtBD,GAAQmG,EAAQ,IAAKA,EAAQ,IAC7BjG,EAAO/H,EAAOiO,aAAajO,EAAOkO,OAAOpL,EAAGQ,EAAOC,SAEnDyE,GAAiBhI,EAAO8G,IAAIe,EAAME,EActC,OAZAjF,GAAEmG,MAAQjB,EACVlF,EAAEF,IAAMmC,EAAaE,SAASnC,GAE1BkC,GAECA,EAAQnF,UAONiD,EAAEmG,QAUVlE,EAAaoJ,MAAQ,SAAUrL,EAAGsL,GAEjC,GAAIA,IAAM,GAAMA,GAAM,EAErB,KAAM,mCAAqCA,CAG5C,IAAIC,GAAgBvL,EAAEiG,WAElBtK,EAAIqE,EAAErE,EAAI2P,CAWd,OAVI3P,GAAI,GACPA,GAAQ,EACR4P,EAAgBA,EAAcC,MACpB7P,EAAI,IACdA,GAAQ,EACR4P,EAAgBA,EAAcnM,MAKxB,GAAI6C,GAAasJ,EAAc1L,KAAK4L,SAAS9P,GAAI4P,EAAe5P,EAAGiP,EAAcC,UAAUa,SAAU,IAI7GzJ,EAAa0J,YAAc,SAAU3L,GACpC,MAAO,IAAIiC,GAAajC,EAAEiG,WAAWpG,KAAK4L,SAASzL,EAAErE,GAAIqE,EAAEiG,WAAYjG,EAAErE,EAAGqE,EAAE0C,KAAM1C,EAAEmG,MAAQnG,EAAEmG,MAAQ,eAazGlE,EAAa2J,MAAQ,SAAU5L,EAAGsL,GACjC,OAAQrJ,EAAaoJ,MAAMrL,GAAIsL,GAAKrJ,EAAaoJ,MAAMrL,GAAIsL,KAG5DrJ,EAAa4J,aAAe,SAAU7L,EAAGsL,GACxC,OAAQtL,EAAGiC,EAAaoJ,MAAMrL,EAAG,EAAKsL,KAGvCrJ,EAAa6J,UAAY,SAAU9L,EAAGsL,GACrC,OAAQrJ,EAAaoJ,MAAMrL,GAAG,EAAKsL,GAAKtL,IAazCiC,EAAaE,SAAW,SAAUnC,GACjC,MAAO,GAAKA,EAAE,GAAK,KAAOA,EAAE,GAAK,IAAMA,EAAEmG,MAAQ,IAAMnG,EAAE0C,MAG1DT,EAAa8J,cAAgB,SAAU/L,GACtC,GAAIgM,GAAM,GAAKhM,EAAE,GAAK,KAAOA,EAAE,GAAK,UAAYA,EAAEiG,WAAWpG,KAAKqG,KAAO,SAAWlG,EAAErE,EAAI,WAAaqE,EAAEmG,MAAQ,KACjH,OAAO6F,GAAMrB,EAAU3K,EAAE0C,OAG1BT,EAAauH,cAAgB,SAAUxJ,GACtC,MAAO,GAAKA,EAAE,GAAK,KAAOA,EAAE,IAG7BiC,EAAagK,QAAU,SAAUhQ,EAAGsH,GACnC,GAAI2I,GAAMjQ,EAAEgK,WAAWpG,KAAKqG,KAAO3C,EAAE0C,WAAWpG,KAAKqG,IAErD,OAAY,KAARgG,EACIA,GAGRA,EAAMjQ,EAAEN,EAAI4H,EAAE5H,EACF,IAARuQ,EACIA,EAGDjQ,EAAEkK,MAAQ5C,EAAE4C,QAGpBvJ,EAAOJ,QAAUyF,IAEdkK,yBAAyB,GAAGC,yBAAyB,KAAKC,GAAG,SAASnQ,EAAQU,EAAOJ,GACxF,YAaA,IAAI8P,GAAM,SAAa9L,EAAQ+L,EAAYC,EAAUC,EAAYC,EAAYC,EAAYC,GAExFvP,KAAKmD,OAASA,EACdnD,KAAKkP,WAAaA,EAClBlP,KAAKmP,SAAWA,EAChBnP,KAAKoP,WAAaA,EAClBpP,KAAKsP,WAAaA,EAClBtP,KAAKqP,WAAaA,EAClBrP,KAAKuP,WAAaA,EAGnBhQ,GAAOJ,QAAU8P,OAEXO,GAAG,SAAS3Q,EAAQU,EAAOJ,GACjC,YAiBA,SAASsQ,GAAOC,EAAc7G,GAuD7B,QAAS8G,GAAGrR,GACX,GAAIsR,GAAMC,EAAWvR,GACjBwR,EAAMC,EAAWzR,EAErB,OAAO2J,MAAK+H,KAAKJ,EAAMA,EAAME,EAAMA,GAIpC,QAASG,KACR,GAAIC,EACH,MAAOA,EAIR,IAAI7C,GAAS8C,EAAgBR,GAAK,EAAG,GAGrC,OAFAO,GAAc7C,EAEPA,EAGR,QAAS+C,GAAE9R,GACV,GAAIsR,GAAMC,EAAWvR,GACjBwR,EAAMC,EAAWzR,GACjB+R,EAAOC,EAAYhS,GACnBiS,EAAOC,EAAYlS,GACnBmS,EAAQb,EAAMA,EAAME,EAAMA,CAE9B,QAAQF,EAAMW,EAAOT,EAAMO,GAAQpI,KAAK+H,KAAKS,EAAQA,EAAQA,GAG9D,QAASC,GAAYpS,GACpB,GAAIsR,GAAMC,EAAWvR,GACjBwR,EAAMC,EAAWzR,GACjB+R,EAAOC,EAAYhS,GACnBiS,EAAOC,EAAYlS,GACnBmS,EAAQb,EAAMA,EAAME,EAAMA,CAE9B,QAAQF,EAAMW,EAAOT,EAAMO,GAAQI,EAIpC,QAASE,GAA0BC,GAClC,GAAIC,GAAWD,IAAc,EAAG,GAC5BnO,EAAM,GAAKoO,EAAS,GAAK,KAAOA,EAAS,EAC7C,IAAIC,EAAuBrO,GAC1B,MAAOqO,GAAuBrO,EAI/B,IAAI4K,GAAS8C,EAAgB,SAAU7R,GACtC,MAAO2J,MAAK8I,IAAIL,EAAYpS,KAC1BuS,EAGH,OAFAC,GAAuBrO,GAAO4K,EAEvBA,EAIR,QAAS2D,KACR,GAAIC,EACH,MAAOA,EAIR,IAAI5D,GAAS8C,EAAgBO,GAAc,EAAG,GAG9C,OAFAO,GAAiB5D,EAEVA,EAUR,QAAS6D,GAAG5S,GACX,GAAI6S,GAAK7S,EAAIA,EACT8S,EAAM,EAAI9S,EAEVM,EAAIuS,EAAKE,EACTvS,EAAIqS,EAAKG,EACTpL,EAAI,EAAI5H,EAAI,EAAI6S,EAChB7H,GAAK,EAAIhL,EAAI,GAAK8S,EAClBpK,EAAIoK,EAAMA,EACV/S,EAAI,GAAKO,EAAIsH,EAAIqL,EAAKjI,EAAIkI,EAAKxK,EAAIyK,GACnC1S,EAAI,GAAKD,EAAIoH,EAAIwL,EAAKpI,EAAIqI,EAAK3K,EAAI4K,GACnCC,EAAI,GAAKvT,EAAIgT,GAAM,EAAIhT,EAAI,GAAKoT,GAAM,EAAIpT,EAAI,GAAKqT,EAAKP,EAAMQ,GAC9DE,EAAI,GAAKxT,EAAI+S,GAAM,EAAI/S,EAAI,GAAKiT,GAAM,EAAIjT,EAAI,GAAKkT,EAAKJ,EAAMK,EAElE,OAAO,IAAKpT,GAAKiT,EAAK,EAAII,EAAK,EAAIC,EAAKC,GAAM7S,GAAKsS,EAAK,EAAIE,EAAK,EAAIC,EAAKC,IAAOxJ,KAAK8J,IAAIhT,EAAIA,EAAIV,EAAIA,EAAG,MAAUA,EAAIwT,EAAIC,EAAI/S,IAAM,EAAI8S,EAAI9S,EAAI,EAAI+S,EAAIzT,GAAK4J,KAAK+H,KAAKjR,EAAIA,EAAIV,EAAIA,GAQrL,QAAS+P,GAAS9P,GACjB,MAAU,KAANA,GACKmT,EAAIG,GACI,IAANtT,GACF+S,EAAIC,IAGLU,EAAU1T,GAAI2T,EAAU3T,IAGjC,QAASqJ,GAAQrJ,GAChB,GAAIsR,GAAMC,EAAWvR,GACjBwR,EAAMC,EAAWzR,GACjB0I,EAAIiB,KAAK+H,KAAKJ,EAAMA,EAAME,EAAMA,EAEpC,QAAQF,EAAM5I,EAAG8I,EAAM9I,GAGxB,QAASkL,GAAO5T,GACf,GAAI6T,GAAWxK,EAAQrJ,EACvB,QAAQ6T,EAAS,IAAKA,EAAS,IAIhC,QAASC,KACR,GAAIC,EACH,MAAOA,EAGR,IAAIC,GAAMC,IAENC,EAAMF,EAAI,GAAG,GACbG,EAAMH,EAAI,GAAG,GACbI,EAAMJ,EAAI,GAAG,GACbK,EAAML,EAAI,GAAG,GAEbM,GAAkBN,EAAI,IAAKI,EAAKD,GAAMH,EAAI,IAAKE,EAAKG,GAIxD,OAFAN,GAAmBxS,EAAOgT,0BAA0BD,EAAgBlD,EAAa,GAAIoD,EAAUC,GAOhG,QAASR,KACR,GAAIS,EACH,MAAOA,EAIR,IAAIC,GAAiBpT,EAAOqT,UAAUxD,EAAa,GAAI,SAAUjH,GAChE,OAAQA,IAEL0K,EAAmB,GAAI1D,GAAO5P,EAAOuT,0BAA0B1D,EAAcuD,GAAiBH,EAAUC,IAAWxR,QAIvH,OAFAyR,GAAwBG,EAAiBE,iBAO1C,QAASA,KACR,GAAIC,GACH,MAAOA,GAMR,IAAI3D,IAAM4D,EAAIC,GAEVC,EAAQ9D,EAAGrN,IAAIoR,EAAKC,qBAGxBF,GAAM,GAAGjO,KAAK,GAAGiO,EAAM,GAAGjO,KAAK,GAC/BiO,EAAM,GAAGjO,KAAK,GAAGiO,EAAM,GAAGjO,KAAK,EAQ/B,KAAK,GAJDoO,IADcH,EAAM,GAAGnR,IAAI0P,GACbyB,EAAM,GAAGnR,IAAI2P,IAE3B4B,EAAOrQ,OAAOC,kBACdqQ,EAAOtQ,OAAOuQ,kBACTjV,EAAI,EAAGA,EAAI2U,EAAM,GAAGpU,OAAQP,IAAK,CACzC,GAAIkV,GAAKhC,EAAUyB,EAAM,GAAG3U,GACxBkV,GAAKF,IACRA,EAAOE,EACPhU,KAAKiU,QAAUR,EAAM,GAAG3U,IAErBkV,EAAKH,IACRA,EAAOG,GAMT,MAFAV,MAAgBO,EAAM9L,EAAKmM,IAAIN,KAAgBE,EAAM/L,EAAKoM,IAAIP,KAxP/D5T,KAAK6I,KAAOA,CAIZ,IAAIuL,GAAgBC,EAAe3E,EAAc,GAC7C4E,EAAiBD,EAAeD,EAAc,GAAI,GAClD3C,EAAK6C,EAAe,GACpB1C,EAAK0C,EAAe,GACpBC,EAAkBF,EAAeD,EAAc,GAAI,GACnD5C,EAAK+C,EAAgB,GACrB5C,EAAK4C,EAAgB,GACrBC,EAAkBH,EAAeD,EAAc,GAAI,GACnD7C,EAAKiD,EAAgB,GACrB9C,EAAK8C,EAAgB,GACrBC,EAAkBJ,EAAeD,EAAc,GAAI,GACnD/C,EAAKoD,EAAgB,GACrBnD,EAAKmD,EAAgB,GAKrBhM,GAAK4I,EAAK,EAAIE,EAAK,EAAIC,EAAKC,EAChC,EAAIF,EAAK,EAAIC,EAAK,EAAIC,EACtB,EAAID,EAAK,EAAIC,EACbA,GACIjJ,GAAK8I,EAAK,EAAII,EAAK,EAAIC,EAAKC,EAChC,EAAIF,EAAK,EAAIC,EAAK,EAAIC,EACtB,EAAID,EAAK,EAAIC,EACbA,GAEII,EAAY0B,EAAKtF,SAAS3F,GAC1BwJ,EAAYyB,EAAKtF,SAAS5F,GAE1B+K,EAAKG,EAAKgB,cAAcjM,GACxB+K,EAAKE,EAAKgB,cAAclM,GAExBqH,EAAa6D,EAAKtF,SAASmF,GAC3BxD,EAAa2D,EAAKtF,SAASoF,GAE3BmB,EAAMjB,EAAKgB,cAAcnB,GACzBqB,EAAMlB,EAAKgB,cAAclB,GAEzBlD,EAAcoD,EAAKtF,SAASuG,GAC5BnE,EAAckD,EAAKtF,SAASwG,GAG5BC,EAAiB5M,KAAK+H,MAAMqB,EAAKI,IAAOJ,EAAKI,IAAOH,EAAKM,IAAON,EAAKM,IACrEkB,GAAYxB,EAAKM,GAAMiD,EACvB9B,GAAY1B,EAAKI,GAAMoD,EAYvB3E,EAAc3O,OAiCduP,KAiBAG,EAAiB1P,OAiEjB8Q,EAAmB,KAoBnBW,EAAwB,KAkBxBM,GAAc/R,MAClBvB,MAAKiU,QAAU1S,OAwCfvB,KAAK0P,aAAeA,EAEpB1P,KAAK2H,QAAUA,EACf3H,KAAKkS,OAASA,EAEdlS,KAAKqT,eAAiBA,EACtBrT,KAAKoS,oBAAsBA,EAC3BpS,KAAK2Q,0BAA4BA,EACjC3Q,KAAKgR,kBAAoBA,EACzBhR,KAAKiQ,eAAiBA,EACtBjQ,KAAKoQ,EAAIA,EACTpQ,KAAKkR,GAAKA,EAEVlR,KAAKoO,SAAWA,EA5RjB,GAAIiG,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAEllBxN,EAAOlJ,EAAQ,kBACf6U,EAAO7U,EAAQ,kCACfsR,EAAkBtR,EAAQ,oDAC1BgB,EAAShB,EAAQ,yBA8RrB4Q,GAAO+F,QAAU,SAAUhO,EAAQlJ,GAClC,GAAIoR,GAAelI,EAAOkI,aAEtB+F,EAAiBpB,EAAe3E,EAAc,GAC9CgG,EAAkBrB,EAAeoB,EAAe,GAAI,GACpDhE,EAAKiE,EAAgB,GACrB9D,EAAK8D,EAAgB,GACrBC,EAAmBtB,EAAeoB,EAAe,GAAI,GACrDjE,EAAKmE,EAAiB,GACtBhE,EAAKgE,EAAiB,GACtBC,EAAmBvB,EAAeoB,EAAe,GAAI,GACrDlE,EAAKqE,EAAiB,GACtBlE,EAAKkE,EAAiB,GACtBC,EAAmBxB,EAAeoB,EAAe,GAAI,GACrDpE,EAAKwE,EAAiB,GACtBvE,EAAKuE,EAAiB,GAEtBpX,EAAI,EAAIH,EACRwX,EAAKxX,EAAIA,EACTyX,EAAKD,EAAKxX,EACV0X,EAAKvX,EAAIA,EACTwX,EAAKD,EAAKvX,EAEVyX,IAAUzE,EAAIG,IAAMtT,EAAIkT,EAAK/S,EAAIgT,EAAInT,EAAIqT,EAAKlT,EAAImT,IAAMkE,EAAKvE,EAAK,EAAI9S,EAAIH,EAAIkT,EAAKwE,EAAKvE,EAAIqE,EAAKpE,EAAK,EAAIjT,EAAIH,EAAIqT,EAAKqE,EAAKpE,IAAMmE,EAAK1E,EAAK,EAAI5S,EAAIqX,EAAKvE,EAAK,EAAIyE,EAAK1X,EAAIkT,EAAKyE,EAAKxE,EAAIsE,EAAKzE,EAAK,EAAI7S,EAAIqX,EAAKpE,EAAK,EAAIsE,EAAK1X,EAAIqT,EAAKsE,EAAKrE,IAE5OuE,GAASD,EAAM,IAAKJ,EAAKzE,EAAK,EAAI/S,EAAIG,EAAI8S,EAAKyE,EAAKxE,EAAIsE,EAAKxE,EAAK,EAAIhT,EAAIG,EAAIiT,EAAKsE,EAAKrE,IAAMrT,EAAI+S,EAAK5S,EAAI8S,EAAIjT,EAAIgT,EAAK7S,EAAIiT,IAAML,EAAIC,GAE1I,QAAQ,GAAI7B,GAAOyG,GAAQ,GAAIzG,GAAO0G,KAGvC5W,EAAOJ,QAAUsQ,IAEd2G,mDAAmD,GAAGC,iCAAiC,GAAGC,iBAAiB,GAAGvH,yBAAyB,KAAKwH,GAAG,SAAS1X,EAAQU,EAAOJ,GAC1K,YAKA,SAASsF,GAAOrB,EAAQmG,GACvBvJ,KAAKoD,OAASA,EACdpD,KAAKuJ,OAASA,EAGf9E,EAAO+R,MAAQ,SAAUrT,EAAQ1E,GAChC,MAAO,IAAIgG,GAAOtB,EAAOC,OAAQD,EAAOoG,OAAS9K,IAGlDc,EAAOJ,QAAUsF,OAEXgS,GAAG,SAAS5X,EAAQU,EAAOJ,GACjC,YA+CA,SAASgO,GAAa9F,EAAO1E,GAE5B,GAAIyK,GAAiB/F,EAAM+F,eACvB3K,EAAMmC,EAAauH,cAAcxJ,GAEjC0K,EAASD,EAAe3K,IAAQ,IAIpC,OAAO4K,GAqGR,QAASC,GAAUjI,GAClB,IAAK,GAAI5C,KAAO8K,GAAcC,UAC7B,GAAID,EAAcC,UAAU/K,KAAS4C,EACpC,MAAO5C,GA9JV,GAAI8K,GAAgB1O,EAAQ,0BACxBgB,EAAShB,EAAQ,0BAsBjB+F,EAAe,QAASA,GAAajC,EAAGiG,EAAYtK,EAAG+G,EAAMyD,EAAO2E,EAAkBC,GAEzF1N,KAAK4I,WAAaA,EAClB5I,KAAK1B,EAAIA,EACT0B,KAAKqF,KAAOA,EACZrF,KAAK8I,MAAQA,EACb9I,KAAKyN,iBAAmBA,EACxBzN,KAAK0N,UAAYA,EAGjB1N,KAAKuM,UAAY3H,EAAauH,cAAcxJ,GAO5C3C,KAAK,GAAK2C,EAAE,GACZ3C,KAAK,GAAK2C,EAAE,GACZ3C,KAAKyC,IAAMmC,EAAaE,SAAS9E,MAwBlC4E,GAAa+I,cAAgB,SAAUtG,EAAOlE,EAAQR,EAAGkC,GAExD,GAAI+I,GAAaT,EAAa9F,EAAO1E,EAErC,IAAKiL,EAAL,CAKA,GAAIjF,GAAMiF,EAAWpG,OACjBqG,EAAUlF,EAAIhB,QAAQ,GAEtBD,GAAQmG,EAAQ,IAAKA,EAAQ,IAC7BjG,EAAO/H,EAAOiO,aAAajO,EAAOkO,OAAOpL,EAAGQ,EAAOC,SAEnDyE,GAAiBhI,EAAO8G,IAAIe,EAAME,EActC,OAZAjF,GAAEmG,MAAQjB,EACVlF,EAAEF,IAAMmC,EAAaE,SAASnC,GAE1BkC,GAECA,EAAQnF,UAONiD,EAAEmG,QAUVlE,EAAaoJ,MAAQ,SAAUrL,EAAGsL,GAEjC,GAAIA,IAAM,GAAMA,GAAM,EAErB,KAAM,mCAAqCA,CAG5C,IAAIC,GAAgBvL,EAAEiG,WAElBtK,EAAIqE,EAAErE,EAAI2P,CAWd,OAVI3P,GAAI,GACPA,GAAQ,EACR4P,EAAgBA,EAAcC,MACpB7P,EAAI,IACdA,GAAQ,EACR4P,EAAgBA,EAAcnM,MAKxB,GAAI6C,GAAasJ,EAAc1L,KAAK4L,SAAS9P,GAAI4P,EAAe5P,EAAGiP,EAAcC,UAAUa,SAAU,IAI7GzJ,EAAa0J,YAAc,SAAU3L,GACpC,MAAO,IAAIiC,GAAajC,EAAEiG,WAAWpG,KAAK4L,SAASzL,EAAErE,GAAIqE,EAAEiG,WAAYjG,EAAErE,EAAGqE,EAAE0C,KAAM1C,EAAEmG,MAAQnG,EAAEmG,MAAQ,eAazGlE,EAAa2J,MAAQ,SAAU5L,EAAGsL,GACjC,OAAQrJ,EAAaoJ,MAAMrL,GAAIsL,GAAKrJ,EAAaoJ,MAAMrL,GAAIsL,KAG5DrJ,EAAa4J,aAAe,SAAU7L,EAAGsL,GACxC,OAAQtL,EAAGiC,EAAaoJ,MAAMrL,EAAG,EAAKsL,KAGvCrJ,EAAa6J,UAAY,SAAU9L,EAAGsL,GACrC,OAAQrJ,EAAaoJ,MAAMrL,GAAG,EAAKsL,GAAKtL,IAazCiC,EAAaE,SAAW,SAAUnC,GACjC,MAAO,GAAKA,EAAE,GAAK,KAAOA,EAAE,GAAK,IAAMA,EAAEmG,MAAQ,IAAMnG,EAAE0C,MAG1DT,EAAa8J,cAAgB,SAAU/L,GACtC,GAAIgM,GAAM,GAAKhM,EAAE,GAAK,KAAOA,EAAE,GAAK,UAAYA,EAAEiG,WAAWpG,KAAKqG,KAAO,SAAWlG,EAAErE,EAAI,WAAaqE,EAAEmG,MAAQ,KACjH,OAAO6F,GAAMrB,EAAU3K,EAAE0C,OAG1BT,EAAauH,cAAgB,SAAUxJ,GACtC,MAAO,GAAKA,EAAE,GAAK,KAAOA,EAAE,IAG7BiC,EAAagK,QAAU,SAAUhQ,EAAGsH,GACnC,GAAI2I,GAAMjQ,EAAEgK,WAAWpG,KAAKqG,KAAO3C,EAAE0C,WAAWpG,KAAKqG,IAErD,OAAY,KAARgG,EACIA,GAGRA,EAAMjQ,EAAEN,EAAI4H,EAAE5H,EACF,IAARuQ,EACIA,EAGDjQ,EAAEkK,MAAQ5C,EAAE4C,QAGpBvJ,EAAOJ,QAAUyF,IAEdkK,yBAAyB,GAAGC,yBAAyB,KAAK2H,GAAG,SAAS7X,EAAQU,EAAOJ,GACxF,YAiDA,SAASwX,GAAoBtP,EAAOuP,GACnC,GAAIC,MAEA5N,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAkD6H,GAA9CC,EAAYuN,EAAc5S,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAC/J,GAAIwD,GAAMrD,EAAMhF,MAEZ0S,EAAaC,EAASC,yBAAyB3P,EAAOoF,EAAIgB,iBAAkBhB,EAEhFA,GAAIqK,WAAaA,EAEbrK,EAAIpH,OAASkI,EAAcC,UAAUyJ,KACpCH,EACHD,EAAkBrR,KAAKiH,GAEvBoK,EAAkBrR,KAAKiH,GAEdqK,EAEVD,EAAkBrR,KAAKiH,GACbA,EAAIpH,OAASkI,EAAcC,UAAUyJ,OAC1CH,GACJD,EAAkBrR,KAAKiH,KAIzB,MAAOlI,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,IAKT,MAAO0N,GAGR,QAASK,GAAqBC,GAU7B,IAAK,GARDC,GAAS,GAAIzS,MAAe,SAAU/F,EAAGsH,GAC5C,MAAOmR,GAAazI,QAAQhQ,EAAE4D,KAAM0D,EAAE1D,QAGnC8U,EAAqB,GAAI3S,OAAepD,SAExCgW,EAAahW,OACbiW,EAAoBjW,OACfzC,EAAI,EAAGA,EAAIqY,EAAgB9X,OAAQP,IAAK,CAChD,GAAI8C,GAAKuV,EAAgBrY,GACrB2N,EAAM7K,EAAGmD,YAEbyS,GAAoB7S,EAAW8S,OAAOH,EAAoB1V,EAAI4V,GAE1D/K,EAAIpH,OAASkI,EAAcC,UAAUyJ,KACL,IAA/BhP,KAAKyP,KAAK,EAAIjL,EAAIiB,WAAmBzF,KAAK0P,GAAK,KAClDJ,EAAa5S,EAAW8S,OAAOL,EAAQxV,EAAI2V,EAAYC,IAE9C/K,EAAIpH,OAASkI,EAAcC,UAAUoK,MACZ,IAA/B3P,KAAKyP,KAAK,EAAIjL,EAAIiB,WAAmBzF,KAAK0P,GAAK,KAClDJ,EAAa5S,EAAW8S,OAAOL,EAAQxV,EAAI2V,EAAYC,IAGxDD,EAAa5S,EAAW8S,OAAOL,EAAQxV,EAAI2V,EAAYC,GAGxDA,EAAkBK,YAAcN,EAGjC,MAAOH,GAQR,QAASU,GAAsDC,EAAelT,GAE7E,GAAItC,GAASwV,EAAcC,KACvBC,KACAC,IACJ,GAAG,CACF,GAAItW,GAAKW,EAAOC,KACZiK,EAAM7K,EAAGmD,YACCoT,GAAUC,OAAO3L,EAAIgB,kBAAmBlL,GAElDkK,GAAIqK,WACPmB,EAAWzS,KAAKjD,GACNkK,EAAIpH,OAASkI,EAAcC,UAAUyJ,KAS/CiB,EAAS1S,KAAKjD,GAQJkK,EAAIpH,OAASkI,EAAcC,UAAU6K,YAC3CxT,IACHA,EAAQpF,KAAKkH,IAAI/E,EAAI,GAAK,QAC1BiD,EAAQpF,KAAKkH,IAAI/E,EAAGqK,UAAU9I,OAAOC,OAAQ,GAAK,QAClDyB,EAAQpF,KAAK0D,OAAOvB,EAAGqK,UAAU9I,OAAQ,uBAI3CZ,EAAON,aAAeM,EACtBA,EAAO+V,aAAe/V,EAEtBA,EAASA,EAAOR,WACRQ,IAAWwV,EAAcC,KAElC,KAAK,GAAIlZ,GAAI,EAAGA,EAAIoZ,EAAS7Y,OAAQP,IAAK,CACzC,GAAIyZ,GAAUL,EAASpZ,EACvB6F,GAAWwD,OAAO4P,EAAeQ,GAGlC,MAAON,GAYR,QAASO,GAAcT,EAAeU,GAIrC,GAAIlW,GAASwV,EAAcC,KACvBU,EAAU,MACd,GAAG,CACFA,GAAU,CAEV,IAAIC,MACAC,EAAcrW,EAAOsV,WAEzB,GAAG,CACF,GAAIvO,GAAIuP,GAAgCD,EAAYpW,KAAMoW,EAAY7W,KAAKS,MAE3EmW,GAAgBnT,MAAOjD,OAAQqW,EAAatP,EAAGA,IAE/CsP,EAAcA,EAAY7W,WAClB6W,EAAYf,cAAgBtV,EAAOR,KAE5C,IAAIkP,GAAiB6H,EAAcH,EAEnCpW,GAAOoW,gBAAkBA,EACzBpW,EAAO0O,eAAiBA,CAExB,IAAI8H,GAAkC,IAAjB9H,EAAuBhJ,KAAK0P,EAEjD,IAAIoB,EAAiBN,EAA0B,CAY9C,IAAK,GARDO,GAAW,EACXC,EAAK1W,EAAO0O,eACZiI,EAAW3X,OACX4X,EAAgB,EAChBC,EAAiB,OACjBC,EAAiB,EACjBC,EAAkB/X,OAClBgY,EAAW/V,OAAOC,kBACb3E,EAAI,EAAGA,EAAI6Z,EAAgBtZ,OAAQP,IAAK,CAEhD,GAAI0a,GAAKb,EAAgB7Z,GAAGwK,EACxBmQ,EAAOD,EAAGvI,eAAiBuI,EAAGE,SAClCV,IAAYS,CAEFd,GAAgB7Z,GAAGyD,MACzByW,IAAYC,EAAK,IACpBE,EAAgBra,EAChBua,EAAiBL,IAGbI,GAAkBJ,EAAWC,EAAK,IAEtCG,EAAiBta,EACjBwa,EAAkBN,EAGnB,IAAIW,GAAU1R,KAAK8I,IAAIkI,EAAK,EAAID,EAO5BA,GAAWC,EAAK,GAAKD,EAAW,EAAIC,EAAK,GAAKM,EAAWI,IAG5DT,EAAWpa,EACXya,EAAWI,GAMb,GAAiBpY,SAAb2X,EAAwB,CAE3B,GAAIU,GAASjB,EAAgBO,GAIzBW,EAAYlV,EAAW8S,OAAOM,EAAe6B,EAAOrX,OAAOR,KAAKS,KAAMD,EAAQqX,EAAOrX,OAAOR,KAChG6X,GAAOrX,OAAOR,KAAK8V,YAAcgC,EAEjCtX,EAAOoW,gBAAkBpW,EAAOoW,gBAAgBmB,MAAM,EAAGZ,EAAW,GACpE3W,EAAO0O,eAAiB6H,EAAcvW,EAAOoW,iBAE7CD,GAAU,MAWV,CAAA,GAAIqB,GAAapB,EAAgBQ,GAC7Ba,EAAcrB,EAAgBS,GAE9Ba,EAAaF,EAAWxX,OACxB2X,EAAcF,EAAYzX,MAElBwX,GAAWzQ,EAEVyQ,EAAWxX,OAAOR,KACjBiY,EAAYzX,OAAOR,KAKvBoY,EAAoBF,EAAWzX,KAAM0X,EAAY1X,KAAM6W,EAAgBC,EAAiBL,EAAK,IAuCpGP,IACJnW,EAASA,EAAOR,YAETQ,IAAWwV,EAAcC,MAiBnC,QAASmC,GAAoBC,EAAQC,EAAShB,EAAgBC,EAAiBgB,GAE9E,GAAIC,GAAUD,EAAWjB,EAErBmB,EAAWJ,EAAOrV,aAClB0V,EAASJ,EAAQtV,aAEjB2V,EAAkBF,EAAS5R,WAC3B+R,EAAgBF,EAAO7R,WAEvBA,EAAa8R,EAEbhB,EAAY,EACZzI,EAAiB,CACrB,GAAG,CACF,GAAI2J,GAAO,MAEVA,GADGhS,IAAe+R,EACX1S,KAAK8I,IAAI8J,EAAwBjS,IAEjC,CAGR,IAAIkS,GAAY,OACZjK,GAAY,EAAG,EACfjI,KAAe8R,IAClB7J,EAAS,GAAK2J,EAASlc,GAEpBsK,IAAe+R,IAClB9J,EAAS,GAAK4J,EAAOnc,GAEtBwc,EAAYlS,EAAWpG,KAAKmO,0BAA0BE,GAEtD6I,GAAakB,EACb3J,GAAkB6J,CAElB,IAAIC,GAAYrB,EAAYzI,CAC5B,IAAI8J,GAAaR,EAEhB,KAGD3R,GAAaA,EAAW7G,WAChB6G,EAAWuF,OAASwM,GAK9B,QAAS7B,GAAckC,GAGtB,IAAK,GAFDC,GAAQ,EAEHnc,EAAI,EAAGA,EAAIkc,EAAW3b,OAAQP,IAAK,CAC3C,GAAIwK,GAAI0R,EAAWlc,GAAGwK,CAEtB2R,IAAS3R,EAAEoQ,UAAYpQ,EAAE2H,eAG1B,MAAOgK,GAQR,QAASpC,GAA+BqC,GACvC,GAAIC,GAAQ9G,EAAe6G,EAAM,GAC7BE,EAAUD,EAAM,GAChBE,EAAQF,EAAM,GAEdX,EAAWY,EAAQrW,aACnB0V,EAASY,EAAMtW,aAEf2V,EAAkBF,EAAS5R,WAC3B+R,EAAgBF,EAAO7R,WAEvBA,EAAa8R,EAEbhB,EAAY,EACZzI,EAAiB,CACrB,GAAG,CACF,GAAI2J,GAAO,MAEVA,GADGhS,IAAe+R,EACX1S,KAAK8I,IAAI8J,EAAwBjS,IAEjC,CAGR,IAAIkS,GAAY,OACZjK,GAAY,EAAG,EACfjI,KAAe8R,IAClB7J,EAAS,GAAK2J,EAASlc,GAEpBsK,IAAe+R,IAClB9J,EAAS,GAAK4J,EAAOnc,GAEtBwc,EAAYlS,EAAWpG,KAAKmO,0BAA0BE,GAEtD6I,GAAakB,EACb3J,GAAkB6J,EAElBlS,EAAaA,EAAW7G,WAChB6G,EAAWuF,OAASwM,EAE7B,QAASjB,UAAWA,EAAWzI,eAAgBA,GAGhD,QAASqK,GAA0BjU,EAAO8P,EAAiBtS,GAC1D,GAAIqF,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkB7I,MAEtB,KACC,IAAK,GAAqD8I,GAAjDC,EAAa6M,EAAgBnT,OAAOC,cAAuBiG,GAA8BG,EAASC,EAAWvI,QAAQmC,MAAOgG,GAA6B,EAAM,CACvK,GAAIqR,GAAelR,EAAOjG,KAEtBmX,GAAaxW,aAAaM,OAASkI,EAAcC,UAAUoK,OAC9D/S,EAAQpF,KAAKkH,IAAI4U,EAAaxW,aAAc,GAAK,SAE9CwW,EAAaxW,aAAaM,OAASkI,EAAcC,UAAUyJ,MAC9DpS,EAAQpF,KAAKkH,IAAI4U,EAAaxW,aAAc,GAAK,WAIlD,MAAOR,GACR4F,GAAqB,EACrBC,EAAkB7F,EACjB,QACD,KACM2F,GAA8BI,EAAW9F,QAC7C8F,EAAW9F,SAEX,QACD,GAAI2F,EACH,KAAMC,IAKTvF,EAAQwC,MAAQA,EACZxC,EAAQnF,WACXmF,EAAQ4F,cAAcpD,GAUxB,QAASmU,GAA4BnU,GACpC,GAAIC,GAAUD,EAAMC,QAChB8F,EAAiB/F,EAAM+F,eAGvBqO,KAEAhW,EAAO6B,EAAQ0Q,IACnB,GAAG,CACF,GAEIpB,IAFSnR,EAAKjD,KAEE,OACpBoU,GAAgB8E,GAA0CjW,EAAK0I,KAAM1I,GAAO2H,GAC5E7G,MAAMtB,UAAUO,KAAKmW,MAAMF,EAAW7E,GACtCA,EAAgBgF,EAA2BnW,GAC3Cc,MAAMtB,UAAUO,KAAKmW,MAAMF,EAAW7E,GAEtCnR,EAAOA,EAAK1D,WACJ0D,IAAS6B,EAAQ0Q,KAG1B,IAAI6D,GAAaJ,EAAU,GACvBK,EAAYL,EAAUA,EAAUpc,OAAS,EAM7C,OALIuF,GAAagK,QAAQiN,EAAYC,GAAa,IACjDL,EAAUjW,KAAKqW,GACfJ,EAAUM,OAAO,EAAG,IAGdN,EA6BR,QAASO,GAAWjd,EAAGsI,GAEtB,MAAO,UAAUA,GAChB,GAAIC,GAAUD,EAAMC,QAEhB7B,EAAO6B,EAAQ0Q,KACfiD,EAAQ,CACZ,GACCA,IAASlc,EAAE0G,GAEXA,EAAOA,EAAK1D,WACJ0D,IAAS6B,EAAQ0Q,KAE1B,OAAOiD,IAUT,QAASJ,GAAwBjS,GAChC,GAEItB,KAEJA,GAAQ9B,KAAKoD,EAAWpG,MACxB8E,EAAQ9B,KAAKoD,EAAW7G,KAAKS,KAC7B,IAAIyZ,IAAQ3U,EAAQ,GAAGK,QAAQ,GAAIL,EAAQ,GAAGK,QAAQ,IAGlDuU,EAAOrc,EAAO8G,IAAIsV,EAAK,GAAIA,EAAK,IAChCE,EAAOtc,EAAOiI,MAAMmU,EAAK,GAAIA,EAAK,IAClCG,EAAInU,KAAKyP,KAAKwE,EAElB,OAAOC,IAAQ,EAAIC,GAAKA,EAhmBzB,GAAI/H,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAEllBmG,EAA2C7c,EAAQ,kEACnD+c,EAA6B/c,EAAQ,iDAErCkY,GADOlY,EAAQ,kBACJA,EAAQ,+BACnBwd,EAAWxd,EAAQ,mCACnB8F,EAAa9F,EAAQ,oCAErBwY,GADSxY,EAAQ,oCACFA,EAAQ,uCACvB+F,EAAe/F,EAAQ,4CAEvBsZ,GADMtZ,EAAQ,oBACFA,EAAQ,oCACpBgB,EAAShB,EAAQ,0BACjB0O,EAAgB1O,EAAQ,0BAQxByd,EAAQ,SAAehV,EAASzC,GAoBnC,QAAS0X,GAAmB9P,GAC3B,MAAO,IAAI4K,GAAa5K,GAAKlL,SAnB9BvB,KAAKsH,QAAUA,EACftH,KAAKoN,iBAEL,IAAIwJ,GAAgB4E,EAA4Bxb,MAC5C6W,EAAoBF,EAAoB3W,KAAM4W,GAC9CO,EAAkBN,EAAkBvU,IAAIia,EAE5Cvc,MAAK+X,cAAgBb,EAAqBC,GAG1CqB,EAAcxY,KAAK+X,cAAe,IAElC/X,KAAKiY,WAAaH,EAAsD9X,KAAK+X,cAAelT,GAExFA,GACHyW,EAA0Btb,KAAMmX,EAAiBtS,GAkgBnDyX,GAAME,sBAAwB,SAAUnV,EAAOtC,GAE9C,GAAI0X,GAASpV,EAAM0Q,cAAc0E,OAE7BC,EAAML,EAASM,WAAWF,GAAUja,KAAM,GAAI6U,GAAatS,IAE/D,OAAK2X,GAAI,IAIJA,EAAI,IAKDA,EAAI,GAAGE,KAAMF,EAAI,GAAGE,OAPnBP,EAASlI,IAAIsI,EAAOI,MAAOR,EAASnI,IAAIuI,EAAOI,QAkDzDP,EAAMtL,kBAAoBgL,EAAW,SAAUpT,GAC9C,OAAQA,EAAWpG,KAAKwO,oBAAsB6J,EAAwBjS,KAGvE0T,EAAM3L,0BAA4BqL,EAAW,SAAUpT,GACtD,MAAOA,GAAWpG,KAAKmO,4BAA8B1I,KAAK8I,IAAI8J,EAAwBjS,MAGvF0T,EAAMQ,cAAgB,SAAUzV,EAAOtI,GACtC,GAAI0G,GAAO4B,EAAMC,QAAQ0Q,IACzB,GAAG,CACF,GAAIxQ,GAAS/B,EAAKjD,IAElBzD,GAAEyI,GAEF/B,EAAOA,EAAK1D,WACJ0D,IAAS4B,EAAMC,QAAQ0Q,OAGjCzY,EAAOJ,QAAUmd,IAIdS,mCAAmC,EAAEC,2CAA2C,EAAEC,6BAA6B,GAAGC,mCAAmC,GAAGC,kCAAkC,GAAGrO,yBAAyB,GAAGsO,qCAAqC,GAAGC,kCAAkC,GAAGC,mBAAmB,GAAGhH,iBAAiB,GAAGvH,yBAAyB,GAAGwO,gDAAgD,EAAEC,iEAAiE,KAAKC,GAAG,SAAS5e,EAAQU,EAAOJ,GAClgB,YAcA,SAASue,GAA6BlW,GACrC,GAgDImW,GAhDAC,EAAuBvJ,EAAe7M,EAAOkI,aAAc,GAC3DmO,EAAwBxJ,EAAeuJ,EAAqB,GAAI,GAChEnM,EAAKoM,EAAsB,GAC3BjM,EAAKiM,EAAsB,GAC3BC,EAAyBzJ,EAAeuJ,EAAqB,GAAI,GACjEpM,EAAKsM,EAAuB,GAC5BnM,EAAKmM,EAAuB,GAC5BC,EAAyB1J,EAAeuJ,EAAqB,GAAI,GACjErM,EAAKwM,EAAuB,GAC5BrM,EAAKqM,EAAuB,GAC5BC,EAAyB3J,EAAeuJ,EAAqB,GAAI,GACjEvM,EAAK2M,EAAuB,GAC5B1M,EAAK0M,EAAuB,GAE5BC,KAGAC,EAAO1M,EAAKC,EACZ0M,EAAOxM,EAAKC,EACZwM,EAAO7M,EAAKE,EACZ4M,EAAO3M,EAAKE,EACZ0M,EAAOjN,EAAKI,EACZ8M,EAAOjN,EAAKM,EAGZ4M,EAAON,EACPO,EAAOL,EAAOF,EACdQ,EAAOJ,EAAOF,EACdO,EAAOR,EACPS,EAAOP,EAAOF,EACdU,EAAON,EAAOF,EAWdS,EAAaR,EAAO,EAAIF,EAAO,EAAIF,EACnCa,EAAaR,EAAO,EAAIF,EAAO,EAAIF,EACnCa,EAAqBF,EAAaA,EAClCG,EAAqBF,EAAaA,EAClCG,EAASF,EAAqBC,EAAqB,EACnDE,EAAMlX,KAAK+H,KAAKkP,GAChBE,EAAY,EAAID,CAInBxB,GAFiB,IAAdyB,EAES,EAEAN,GAAcC,EAAaI,EAIxC,IAEIE,GAAOnB,EAAOkB,EAAYjB,EAAOR,EACjC2B,EAAOpB,EAAOP,EAAYQ,EAAOiB,EACjCG,EAAOnB,EAAOgB,EAAYf,EAAOV,EACjC6B,EAAOpB,EAAOT,EAAYU,EAAOe,EACjCK,EAAOnB,EAAOc,EAAYb,EAAOZ,EACjC+B,EAAOpB,EAAOX,EAAYY,EAAOa,CAGrCZ,GAAOa,EACPZ,EAAOc,EAAOF,EACdX,EAAOe,EAAOF,EACdZ,EAAOW,EACPV,EAAOY,EAAOF,EACdT,EAAOa,EAAOF,CAEd,IAAIG,GAAK,GAAKhB,EAAO,EAAIC,EAAOC,GAC5Be,EAAML,EAAO,EAAIF,CACrB,IAAY,IAARO,OAQG,CACN,GAAIC,GACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACAC,GACAC,IAEJ,WAGKb,EAAM,IAETP,GAAQA,EACRE,GAAQA,EACRE,GAAQA,EAGRjB,GAAQA,EACRC,GAAQA,EACRC,GAAQA,EAERkB,GAAOA,GAyBRC,EAAK,EAAID,EACTE,EAAS,EAAIH,EAAKnB,GAAQqB,EAAKA,GAC/BE,EAAS,EAAIJ,EAAKhB,GAAQkB,EAAKA,GAC/BG,EAAS,GAAKpB,EAAOD,GAAQkB,EAC7BI,EAAQH,EAASA,EAAS,EAAIE,EAASF,EAASC,EAEhDG,EAAK,GAAKF,EAASF,EAInB,IAAIY,GAAmB,SAA0BC,GAChD,OAAQA,EAAQb,IAAWD,EAAKF,IAG7BiB,EAA2B,SAAkCC,GAChE,OAAQH,EAAiBG,EAAS,IAAKH,EAAiBG,EAAS,MAI9DC,EAAc,SAAqBC,GACtC,GAAIC,GAAKD,EAAM,GACXE,EAAKF,EAAM,EAEf,SAAIC,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,KAInCD,EAAK,IACRA,EAAK,GAEFA,EAAK,IACRA,EAAK,GAEFC,EAAK,IACRA,EAAK,GAEFA,EAAK,IACRA,EAAK,IAGED,EAAIC,IAGThB,GAAQ,GACXE,EAASlY,KAAK+H,KAAKiQ,GAOnBG,GAAOD,EACPE,EAAMF,EAGNlC,IAAaza,OAAOuQ,kBAAmBqM,IAAOA,EAAKC,IAAOA,EAAK7c,OAAOC,oBAAoBnB,IAAIse,GAA0Bte,IAAIwe,IAClHb,EAAQ,IAOlBK,EAAW,EAAIJ,EAAKA,EAAK,EAAID,EAAQ,EAGjCK,EAAW,EACdrC,IAAa,EAAGhW,KAAK+H,MAAK,EAAKiQ,KAAS3d,IAAIse,GAA0Bte,IAAIwe,IAE1EP,GAAWtY,KAAK+H,KAAK,EAAIsQ,GACzBE,KAAQ,EAAKN,EAAKK,IAAY,GAC9BE,KAAQ,EAAKP,EAAKK,IAAY,GAG9BtC,IAAaza,OAAOuQ,kBAAmByM,KAAQA,GAAMvY,KAAKiM,IAAI,EAAGuM,MAASxY,KAAKkM,IAAI,EAAGsM,IAAOxY,KAAK+H,MAAK,EAAKiQ,KAAS3d,IAAIse,GAA0Bte,IAAIwe,QAQ3J,MAAO7C,GAzOR,GAAI5J,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,2DAEzkB1W,GAAQ,uBA0OrBU,GAAOJ,QAAUue,IAEdwD,uBAAuB,IAAIC,GAAG,SAAStiB,EAAQU,EAAOJ,GACzD,YAgBA,SAASyc,GAA2BhT,GASnC,IAAK,GAPDgO,MAGApP,EAASoB,EAAWpG,KACpByb,EAAWmD,EAAmC5Z,GAE9C6Z,EAAOpD,EAAS5e,OACXiiB,EAAI,EAAGA,EAAID,EAAMC,IAAK,CAC9B,GAAIC,GAAUtD,EAASqD,EACvB,IAAKC,EAAL,CAIA,GAAIC,GAAQC,EAAYja,EAAQ+Z,EAChC,IAAKC,EAAL,CAIA,GAAIE,GAAeC,EAAgBna,EAAQga,EAAOD,EAClD,IAAKG,EAAL,CAIA,GAAI/e,GAAI+e,EAAa/e,EACjBQ,EAASue,EAAave,OACtBkC,EAAOqc,EAAarc,KAEpBoH,EAAM,GAAI7H,GAAajC,EAAGiG,EAAY4Y,EAAOnc,EAAM,EAAGlC,EAG1DyT,GAAcpR,KAAKiH,MAYpB,MAHAmK,GAAc3Q,KAAKrB,EAAagK,SAGzBgI,EAGR,QAAS6K,GAAYja,EAAQ0T,GAC5B,GAAIC,GAAQ9G,EAAe6G,EAAM,GAC7B0G,EAAQzG,EAAM,GACd0G,EAAQ1G,EAAM,GAGd2G,EAAKta,EAAO0J,GAAG0Q,GACfG,EAAKva,EAAO0J,GAAG2Q,EAEnB,MAAIC,EAAKC,GAAM,GAAf,CAKA,GAAIlF,GAAOnJ,EAAKsO,MAAMxa,EAAO0J,GAAI0Q,EAAOC,EAIxC,OAAOhF,IAGR,QAAS8E,GAAgBna,EAAQqV,EAAMoF,GACtC,GAAIC,GAAQ7N,EAAe4N,EAAO,GAC9BL,EAAQM,EAAM,GACdL,EAAQK,EAAM,GAGd9R,GAAK5I,EAAO4I,EAAEyM,EAElB,IAAIzM,EAAI,EAAG,CAIV,GAAI+R,IAAY3a,EAAO4I,EAAEwR,GACrBQ,GAAY5a,EAAO4I,EAAEyR,EAEzB,IAAIzR,EAAI+R,GAAY/R,EAAIgS,OAEjB,IAAIhS,GAAK+R,GAAY/R,GAAKgS,EAGhC,OAIF,GAAI7Y,GAAS,OACTlE,EAAO,MACP+K,GAAI,GAGP7G,EAASgE,EAAc8U,0BACvBhd,EAAOkI,EAAcC,UAAU8U,oBAE/B/Y,EAAStB,KAAKiM,IAAI,EAAI9D,EAAG7C,EAAc8U,2BACvChd,EAAOkI,EAAcC,UAAU6K,WAGhC,IAAInG,GAAS1K,EAAO0K,OAAO2K,GACvBla,EAAI6E,EAAO4G,SAASyO,GACpB3Z,GAAMP,EAAE,GAAKuP,EAAO,GAAK3I,EAAQ5G,EAAE,GAAKuP,EAAO,GAAK3I,GAEpDpG,EAAS,GAAIsB,GAAOvB,EAAIqG,EAE5B,QAAS5G,EAAGA,EAAGQ,OAAQA,EAAQkC,KAAMA,GA5HtC,GAAIgP,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAGllB6L,GADSviB,EAAQ,wBACoBA,EAAQ,uCAC7C0O,EAAgB1O,EAAQ,0BACxB4F,EAAS5F,EAAQ,oCACjB+F,EAAe/F,EAAQ,4CACvB6U,EAAO7U,EAAQ,iCAwHnBU,GAAOJ,QAAUyc,IAEd2G,mCAAmC,EAAEvF,2CAA2C,EAAElO,yBAAyB,GAAGuH,iCAAiC,GAAG6K,uBAAuB,EAAEsB,qCAAqC,IAAIC,IAAI,SAAS5jB,EAAQU,EAAOJ,GACnP,YAqBA,SAASujB,GAA+BC,EAAeC,EAAOC,EAAWC,EAAmBxkB,EAAGuG,EAASke,GAKvG,GAAIC,GAAO,KAGPC,EAAeC,EAAiBP,EAAeC,GAE/CO,EAAe3f,OAAOC,kBACtBgJ,EAAM,OAEN2W,EAAK,EAELna,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAiD6H,GAA7CC,EAAY4Z,EAAajf,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAC9J,GAAIoa,GAAcja,EAAMhF,KAGxBgf,IAEA,IAAIE,GAAOP,GAAgB,IAAPK,EAGhBG,GAFSF,EAAYza,WAAWpG,KAENghB,EAA6BH,EAAaT,EAAOC,EAAWG,EAAMF,EAAmBxkB,EAAGuG,EAASye,IAE3Htc,EAAIuc,EAAwBvc,EAC5BrE,EAAI4gB,EAAwB5gB,CAG5BqE,GAAImc,IAEP1W,EAAM,GAAI7H,GAAajC,EAAEA,EAAG0gB,EAAYza,WAAYjG,EAAErE,EAAGiP,EAAcC,UAAUa,SAAU,GAAG9M,SAE9F4hB,EAAenc,IAKhB,MAAOzC,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,IAKT,MAAOsD,GAGR,QAASyW,GAAiBD,EAActgB,GAEvC,GAAI8gB,GAAiB,EAEjBC,EAAeT,EAAa5jB,OAASokB,CACzC,IAAIC,EAAc,CAGjB,GAAIC,GAAsBC,EAAcX,EAActgB,EACtDsgB,GAAeY,EAAuBZ,EAActgB,EAAGghB,GACvDV,EAAea,EAAuBb,EAActgB,EAAGghB,GAGxD,MAAOV,GAOR,QAASW,GAAcX,EAActgB,GACpC,GAAIghB,GAAsBngB,OAAOC,kBAC7ByG,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkB7I,MAEtB,KACC,IAAK,GAAkD8I,GAA9CC,EAAa2Y,EAAajf,OAAOC,cAAuBiG,GAA8BG,EAASC,EAAWvI,QAAQmC,MAAOgG,GAA6B,EAAM,CACpK,GAAImZ,GAAchZ,EAAOjG,MAErBoD,EAAS6b,EAAYza,WAAWpG,KAEhCuhB,EAAKvc,EAAO4G,SAASiV,EAAYW,OAAO,IACxCC,EAAKzc,EAAO4G,SAASiV,EAAYW,OAAO,IAExCE,EAAKrkB,EAAO8L,uBAAuBhJ,EAAGohB,GACtCI,EAAKtkB,EAAO8L,uBAAuBhJ,EAAGshB,GACtCjd,EAAIiB,KAAKiM,IAAIgQ,EAAIC,EAEjBnd,GAAI2c,IACPA,EAAsB3c,IAOvB,MAAOzC,GACR4F,GAAqB,EACrBC,EAAkB7F,EACjB,QACD,KACM2F,GAA8BI,EAAW9F,QAC7C8F,EAAW9F,SAEX,QACD,GAAI2F,EACH,KAAMC,IAKT,MAAOuZ,GAAsB,IAQ9B,QAASE,GAAuBZ,EAActgB,EAAGghB,GAEhD,GAAIS,MAEAhZ,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkB/J,MAEtB,KACC,IAAK,GAAkDgK,GAA9CC,EAAayX,EAAajf,OAAOC,cAAuBmH,GAA8BG,EAASC,EAAWzJ,QAAQmC,MAAOkH,GAA6B,EAAM,CACpK,GAAIiY,GAAc9X,EAAOnH,MAErBoD,EAAS6b,EAAYza,WAAWpG,KAEhC6hB,EAAmB7c,EAAO6L,iBAC1BrM,EAAI+P,EAASuN,+BAA+BD,EAAkB1hB,EAC9DqE,IAAK2c,GACRS,EAAsB5e,KAAK6d,IAG5B,MAAO9e,GACR8G,GAAqB,EACrBC,EAAkB/G,EACjB,QACD,KACM6G,GAA8BI,EAAWhH,QAC7CgH,EAAWhH,SAEX,QACD,GAAI6G,EACH,KAAMC,IAKT,MAAO8Y,GAQR,QAASN,GAAuBb,EAActgB,EAAGghB,GAEhD,GAAIS,MAEAzgB,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkBtC,MAEtB,KACC,IAAK,GAAkDuC,GAA9CC,EAAakf,EAAajf,OAAOC,cAAuBN,GAA8BG,EAASC,EAAWhC,QAAQmC,MAAOP,GAA6B,EAAM,CACpK,GAAI0f,GAAcvf,EAAOM,MAErBoD,EAAS6b,EAAYza,WAAWpG,KAGhCwE,GADmBQ,EAAO4K,sBACtB2E,EAASwN,oCAAoC/c,EAAQ7E,GACzDqE,IAAK2c,GACRS,EAAsB5e,KAAK6d,IAG5B,MAAO9e,GACRX,GAAqB,EACrBC,EAAkBU,EACjB,QACD,KACMZ,GAA8BI,EAAWS,QAC7CT,EAAWS,SAEX,QACD,GAAIZ,EACH,KAAMC,IAKT,MAAOugB,GArOR,GAAIZ,GAA+B3kB,EAAQ,0CACvCkY,EAAWlY,EAAQ,kBACnBgB,EAAShB,EAAQ,0BACjB+F,EAAe/F,EAAQ,gCACvB0O,EAAgB1O,EAAQ,yBAoO5BU,GAAOJ,QAAUujB,IAEd5T,yBAAyB,GAAGC,yBAAyB,GAAGyV,+BAA+B,EAAEC,iBAAiB,GAAGC,yCAAyC,KAAKC,IAAI,SAAS9lB,EAAQU,EAAOJ,GAC1L,YAQA,SAASqkB,GAA6BH,EAAaT,EAAOC,EAAWG,EAAMF,EAAmBxkB,EAAGuG,EAASye,GAErGze,GACHA,EAAQvE,SAGT,IAAIsI,GAAaya,EAAYza,WAIzBjG,IAFW0gB,EAAYW,QAEnBjN,EAAS6N,mCAAmChc,EAAYga,EAAOS,EAAYW,OAAQlB,EAAmBxkB,EAAGuG,EAASye,GAE1H,KAAK3gB,EACJ,OAASqE,EAAGxD,OAAOC,kBAAmBd,EAAGpB,OAG1C,IAAIyF,GAAInH,EAAOyE,gBAAgB3B,EAAEA,EAAGigB,EAEpC,QAAS5b,EAAGA,EAAGrE,EAAGA,GAxBnB,GAAIoU,GAAWlY,EAAQ,kBACnBgB,EAAShB,EAAQ,yBA0BrBU,GAAOJ,QAAUqkB,IAEdzU,yBAAyB,GAAG0V,iBAAiB,KAAKI,IAAI,SAAShmB,EAAQU,EAAOJ,GACjF,YAqBA,SAASuc,GAAyCoJ,EAAa1X,GAE9D,GAAI+D,IAAM,EAAG,GAET7J,GAAW,EAAG,GAAGhF,IAAI,SAAUxD,GAClC,MAAOgmB,GAAYhmB,GAAG0D,OAEnByZ,GAAQ,EAAG,GAAG3Z,IAAI,SAAUxD,GAC/B,MAAOwI,GAAQxI,GAAG6I,QAAQwJ,EAAGrS,MAG1B+I,GAAiBhI,EAAOiI,MAAMmU,EAAK,GAAIA,EAAK,IAC5C8I,GAAUllB,EAAO8G,IAAIsV,EAAK,GAAIA,EAAK,GAIvC,IAAsB,IAAlBpU,GAAuBkd,KAAW,EAGrC,QAGD,IAAIpiB,GAAI2E,EAAQ,GAAGoI,aAAa,EAEhC,IAAI7H,GAAiBmd,EAAqB,CAGzC,GAAIvY,GAAM,GAAI7H,GAAajC,EAAGmiB,EAAY,GAAI,EAAGvX,EAAcC,UAAUoK,MAAO,EAAG,GAAInT,GAAO9B,EAAG,GAAI,EAAIoiB,EAGzG,QAAQtY,GAGT,GAAI5E,EAAgB,EAAG,CACtB,GAAIpF,GAAMmC,EAAauH,cAAcxJ,EACrCyK,GAAe3K,IAAS+E,OAAQF,EAAQ,IAIzC,GAAIO,GAAiBmd,EACpB,QAQD,KAAK,GAHDpO,MAEAqO,IAAU,EAAIF,GACTjmB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAE3B,GAAIsR,IAAK9I,EAAQxI,GAAGsR,EAAEe,EAAGrS,IAErByK,EAAStB,KAAKiM,IAAI,EAAI9D,EAAG7C,EAAc8U,0BACvC9Y,GAAS,IAEZA,EAASgE,EAAc8U,0BAGxB,IAAInQ,GAAS5K,EAAQxI,GAAGoT,OAAOf,EAAGrS,IAE9BoE,GAAMP,EAAE,GAAKuP,EAAO,GAAK3I,EAAQ5G,EAAE,GAAKuP,EAAO,GAAK3I,GAEpD2b,EAAO,GAAItgB,GAAajC,EAAGmiB,EAAYhmB,GAAIqS,EAAGrS,GAAIyO,EAAcC,UAAUyJ,KAAMgO,EAAOnmB,GAAI,GAAI2F,GAAOvB,EAAIqG,GAAS,EAAIwb,EAE3HnO,GAAcpR,KAAK0f,GAGpB,MAAOtO,GAtFR,GAAIrJ,GAAgB1O,EAAQ,0BACxB4F,EAAS5F,EAAQ,oCACjB+F,EAAe/F,EAAQ,4CACvBgB,EAAShB,EAAQ,0BAOjBmmB,EAAsB,CA+E1BzlB,GAAOJ,QAAUuc,IAEd6G,mCAAmC,EAAEvF,2CAA2C,EAAElO,yBAAyB,GAAGC,yBAAyB,KAAKoW,IAAI,SAAStmB,EAAQU,EAAOJ,GAC3K,YA4KA,SAASimB,GAAYxc,EAAYob,GAChChkB,KAAK4I,WAAaA,EAClB5I,KAAKgkB,OAASA,EA+Bf,QAASqB,GAAWxiB,EAAI2E,GACvB,GAAIwc,GAAS3d,UAAUhH,OAAS,GAAsBkC,SAAjB8E,UAAU,GAAmBA,UAAU,IAAM,EAAG,GAKjFif,EAAeziB,EAAG,GAAG+F,WAAWpG,OAASgF,EACzC+d,EAAe1iB,EAAG,GAAG+F,WAAWpG,OAASgF,CAE7C,KAAK8d,IAAiBC,EACrB,OAAQvB,EAKT,IAAIwB,GAAUF,IAAiBC,EAG3B3mB,EAAI0mB,EAAeziB,EAAG,GAAGvE,EAAI,EAC7B4H,EAAIqf,EAAe1iB,EAAG,GAAGvE,EAAI,EAC7BgL,EAAI0a,EAAO,GACXhd,EAAIgd,EAAO,EAEf,IAAI9d,GAAKoD,EAMR,MAAIA,KAAMtC,GAAKwe,MAGNxB,EAEH,IAAIplB,GAAK0K,GAAKpD,GAAKc,EAEzB,QACM,IAAIsC,GAAK1K,GAAKoI,GAAKd,EAAG,CAE5B,GAAI2I,KAOJ,OANIvF,KAAM1K,GACTiQ,EAAIrJ,MAAM8D,EAAG1K,IAEVsH,IAAMc,GACT6H,EAAIrJ,MAAMU,EAAGc,IAEP6H,EACD,MAAIjQ,IAAK0K,GAAKpD,GAAKc,IAEhBd,EAAGc,IACFsC,GAAK1K,GAAKoI,GAAKd,IAEhBoD,EAAG1K,IAFN,OAghBR,QAAS6mB,GAAkCje,EAAQrE,GAGlD,GAAI3E,GAAI2E,EAAOoG,OACXmc,EAAKviB,EAAOC,OAAO,GACnBuiB,EAAKxiB,EAAOC,OAAO,GAInBwiB,EAAW/lB,EAAOgmB,gBAAgBre,EAAO4K,wBAAyBsT,GAAKC,IAGvEG,EAAcjmB,EAAOkO,OAAO6X,EAAS,GAAIA,EAAS,IAClD1mB,EAAIW,EAAOR,OAAOymB,GAClBhT,EAAWgT,EAAY,GAAK5mB,EAC5B6T,EAAW+S,EAAY,GAAK5mB,EAC5B8hB,EAAKnhB,EAAOkmB,OAAOH,EAAS,GAAI9S,GAAWC,GAC3CkO,EAAKphB,EAAOkmB,OAAOH,EAAS,GAAI9S,GAAWC,GAE3CiT,EAAuBhF,EAAG,IAAMxiB,GAAKwiB,EAAG,GAAKxiB,GAAKyiB,EAAG,IAAMziB,GAAKyiB,EAAG,GAAKziB,EACxEynB,EAAsBjF,EAAG,IAAMxiB,GAAKyiB,EAAG,GAAKziB,GAAKyiB,EAAG,IAAMziB,GAAKwiB,EAAG,GAAKxiB,EAEvE0nB,EAAyBlF,EAAG,IAAMxiB,GAAKwiB,EAAG,GAAKxiB,GAAKyiB,EAAG,IAAMziB,GAAKyiB,EAAG,GAAKziB,EAC1E2nB,EAAwBnF,EAAG,IAAMxiB,GAAKyiB,EAAG,GAAKziB,GAAKyiB,EAAG,IAAMziB,GAAKwiB,EAAG,GAAKxiB,CAC7E,SAAIwnB,IAAyBE,GAA0BC,IAA0BD,IAA2BF,GAAwBC,IAAwBA,GAAuBE,GAryBpL,GAAI9R,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAEllBxN,EAAOlJ,EAAQ,eACf6U,EAAO7U,EAAQ,+BACf4F,EAAS5F,EAAQ,uBACjBoQ,EAAMpQ,EAAQ,oBACd+F,EAAe/F,EAAQ,+BAGvBgB,GAFShB,EAAQ,uBACHA,EAAQ,4CACbA,EAAQ,wBAEjBkY,IAKJA,GAASqP,uBAAyB,SAAUrE,EAAIsE,GAC/C,GAAItE,EAAGxY,QAAU8c,EAAG9c,OACnB,OAAO,CAGR,IAAIvC,GAAInH,EAAO8L,uBAAuBoW,EAAG3e,OAAQijB,EAAGjjB,QAChDkjB,EAAKvE,EAAGxY,OAAS8c,EAAG9c,OACpBgd,EAAID,EAAKA,CAEb,OAAOC,GAAIvf,GAOZ+P,EAASyP,wBAA0B,SAAUrjB,EAAQsjB,EAAI1C,GACxD,GAAItS,GAAKgV,EAAG,GACR7U,EAAK6U,EAAG,GACRjV,EAAKuS,EAAG,GACRpS,EAAKoS,EAAG,GACRxa,EAASpG,EAAOoG,OAChBmd,EAAKvjB,EAAOC,OAAO,GACnBujB,EAAKxjB,EAAOC,OAAO,GAEnBmQ,EAAK/B,EAAKC,EACV+B,EAAK7B,EAAKC,EACVgV,EAAKnV,EAAKiV,EACVG,EAAKjV,EAAK+U,EAEV/nB,EAAI2U,EAAKA,EAAKC,EAAKA,EACnBtN,EAAI,GAAK0gB,EAAKrT,EAAKsT,EAAKrT,GACxBlK,EAAIsd,EAAKA,EAAKC,EAAKA,EAAKtd,EAASA,EAEjCud,EAAe5gB,EAAIA,EAAI,EAAItH,EAAI0K,CACnC,IAAIwd,EAAe,EAElB,OAAO,CAMPA,GAAe7e,KAAK+H,KAAK8W,EAKzB,IAAIC,KAAO7gB,EAAI4gB,IAAiB,EAAIloB,GAChCkX,IAAO5P,EAAI4gB,IAAiB,EAAIloB,EAUpC,OAAImoB,IAAM,GAAKA,GAAM,GASjBjR,GAAM,GAAKA,GAAM,GAgBvBiB,EAASiQ,wBAA0B,SAAU3f,EAAOkf,GAsDnD,QAASU,GAAkBhE,EAAciE,EAAOC,GAG/C,IADA,GAAIC,GAAQF,EAAMte,WACXwe,IAAUD,EAAMve,YAEtBwe,EAAQA,EAAMrlB,KAEVqlB,IAAUD,EAAMve,WACnBqa,EAAazd,KAAK,GAAI4f,GAAYgC,GAAQ,EAAG,KAE7CnE,EAAazd,KAAK,GAAI4f,GAAYgC,GAAQ,EAAGD,EAAM7oB,KA9DtD,GAAI+oB,IAAa,EAEbC,EAAMf,EAAE,GACRgB,EAAMhB,EAAE,GAERtD,KAEAuE,EAAYF,EAAI9kB,KAAKuC,aACrBse,EAAc,GAAI+B,GAAYoC,EAAU5e,YAAa4e,EAAUlpB,EAAGkpB,EAAUlpB,IAE5E8kB,EAAK,CACT,GAAG,CACF,GAAIiE,EAAY,CAKfA,GAAa,CAEb,IAAIH,GAAQI,EAAI9kB,KAAKuC,aACjBoiB,EAAQG,EAAIvlB,KAAKS,KAAKuC,YAEtBoiB,GAAMve,aAAese,EAAMte,YAC9Bya,EAAYW,OAAO,GAAKmD,EAAM7oB,EAC9B2kB,EAAazd,KAAK6d,KAElBA,EAAYW,OAAO,GAAK,EACxBf,EAAazd,KAAK6d,GAElB4D,EAAkBhE,EAAciE,EAAOC,IAGxCG,EAAMA,EAAIvlB,SACJ,CACNslB,GAAa,EAEbC,EAAMA,EAAIrlB,YAEV,IAAIwlB,GAASH,EAAI9kB,KAAKuC,YACtBse,GAAc,GAAI+B,GAAYqC,EAAO7e,YAAa6e,EAAOnpB,EAAGmpB,EAAOnpB,IAGpE8kB,UACQkE,IAAQC,EAIjB,OAFAtE,GAAazd,KAAK6d,GAEXJ,GAmCRlM,EAAS2Q,+BAAiC,SAAUrkB,EAAMgE,EAAOkf,GAKhE,IAAK,GAHDoB,MACA1E,EAAelM,EAASiQ,wBAAwB3f,EAAOkf,GAAG,GAErDznB,EAAI,EAAGA,EAAImkB,EAAa5jB,OAAQP,IAAK,CAC7CukB,YAAcJ,EAAankB,EAK3B,KAAK,GAHD0I,GAAS6b,YAAYza,WAAWpG,KAChColB,EAAU7Q,EAAS8Q,gCAAgCxkB,EAAMmE,EAAQ6b,YAAYW,QAExEhZ,EAAI,EAAGA,EAAI4c,EAAQvoB,OAAQ2L,IACnC2c,EAAOniB,KAAKoiB,EAAQ5c,GAAGrI,GAIzB,MAAOglB,IA2DR5Q,EAASwN,oCAAsC,SAAU/c,EAAQ7E,GAChE,GAAImlB,GAAmBtgB,EAAO4K,sBAE1BzC,GAAM,EAAG,EAAG,EAAG,GAAGrN,IAAI,SAAUxD,GACnC,MAAOe,GAAOkoB,0CAA0CplB,GAAImlB,EAAiBhpB,GAAIgpB,GAAkBhpB,EAAI,GAAK,MAG7G,OAAOiJ,GAAKigB,OAAOrY,IAGpBoH,EAASuN,+BAAiC,SAAUhS,EAAK3P,GAExD,GAAI8O,GAAKa,EAAI,GAAG,GACZV,EAAKU,EAAI,GAAG,GACZd,EAAKc,EAAI,GAAG,GACZX,EAAKW,EAAI,GAAG,GAEZ2V,EAAKtlB,EAAE,GACPulB,EAAKvlB,EAAE,EAEX,IAAIslB,EAAKxW,EAAI,CACZ,GAAIyW,EAAKtW,EACR,MAAO/R,GAAO8L,uBAAuB2G,EAAI,GAAI3P,EACvC,IAAIulB,EAAKvW,EACf,MAAO9R,GAAO8L,wBAAwB8F,EAAIE,GAAKhP,EAE/C,IAAIqE,GAAIyK,EAAKwW,CACb,OAAOjhB,GAAIA,EAEN,GAAIihB,EAAKzW,EAAI,CACnB,GAAI0W,EAAKtW,EACR,MAAO/R,GAAO8L,wBAAwB6F,EAAII,GAAKjP,EACzC,IAAIulB,EAAKvW,EACf,MAAO9R,GAAO8L,uBAAuB2G,EAAI,GAAI3P,EAE7C,IAAI0B,GAAK4jB,EAAKzW,CACd,OAAOnN,GAAKA,EAGb,GAAI6jB,EAAKtW,EAAI,CACZ,GAAIuW,GAAMvW,EAAKsW,CACf,OAAOC,GAAMA,EACP,GAAID,EAAKvW,EAAI,CACnB,GAAIyW,GAAMF,EAAKvW,CACf,OAAOyW,GAAMA,EAEb,MAAO,IAKVrR,EAASsR,sBAAwB,SAAUC,EAAWzjB,GAIrD,IAAK,GAFDiP,GAAOtQ,OAAOuQ,kBACdwU,EAAYhnB,OACPzC,EAAI,EAAGA,EAAIwpB,EAAUjpB,OAAQP,IAAK,CAC1C,GAAI0I,GAAS8gB,EAAUxpB,GAEnB0pB,EAAYhhB,EAAO6L,iBAAiB,GAAG,EACvCmV,GAAY1U,IACfA,EAAO0U,EACPD,EAAY/gB,GAId,OAASsM,KAAMA,EAAMyU,UAAWA,IAMjCxR,EAAS0R,4BAA8B,SAAUH,EAAWzjB,GAM3D,GAAI6jB,GAAwB3R,EAASsR,sBAAsBC,EAAWzjB,GAElE0jB,GADOG,EAAsB5U,KACjB4U,EAAsBH,WAIlCI,EAAMJ,EAAU5gB,QAAQ4gB,EAAUtU,QAItC,OAAO0U,GAAI,GAAK,EAGjB,IAAIC,GAAarnB,OACbsnB,EAAQtnB,OACRunB,EAAQvnB,OACRwnB,EAAkBxnB,OAClBynB,EAAaznB,OACb0nB,EAAoB1nB,MAExBwV,GAAS6N,mCAAqC,SAAUhc,EAAYjG,EAAGqhB,EAAQlB,EAAmBxkB,EAAGuG,EAASye,GAE7G,GAAI9b,GAASoB,EAAWpG,KACpB0mB,EAAgBpG,EAAoBA,EAAkBtgB,KAAOjB,MAEjE,IAAIqnB,IAAephB,GAAUqhB,IAAUlmB,GAAKmmB,IAAUxqB,GAAK0lB,EAAO,KAAOgF,EAAW,IAAMhF,EAAO,KAAOgF,EAAW,IAAMC,IAAsBC,EAC9I,MAAOH,EAERH,GAAaphB,EACbqhB,EAAQlmB,EACRmmB,EAAQxqB,EACR0qB,EAAahF,EACbiF,EAAoBC,CAKpB,IAAItL,GAAuBvJ,EAAe7M,EAAOkI,aAAc,GAC3DmO,EAAwBxJ,EAAeuJ,EAAqB,GAAI,GAChEnM,EAAKoM,EAAsB,GAC3BjM,EAAKiM,EAAsB,GAC3BC,EAAyBzJ,EAAeuJ,EAAqB,GAAI,GACjEpM,EAAKsM,EAAuB,GAC5BnM,EAAKmM,EAAuB,GAC5BC,EAAyB1J,EAAeuJ,EAAqB,GAAI,GACjErM,EAAKwM,EAAuB,GAC5BrM,EAAKqM,EAAuB,GAC5BC,EAAyB3J,EAAeuJ,EAAqB,GAAI,GACjEvM,EAAK2M,EAAuB,GAC5B1M,EAAK0M,EAAuB,GAE5BmL,EAAK9U,EAAe1R,EAAG,GACvBslB,EAAKkB,EAAG,GACRjB,EAAKiB,EAAG,GAERC,EAAM3X,EAAKwW,EACXoB,EAAM7X,EAAKyW,EACXqB,EAAM/X,EAAK0W,EACXsB,EAAMlY,EAAK4W,EACXuB,EAAM5X,EAAKsW,EACXuB,EAAM9X,EAAKuW,EACXwB,EAAMhY,EAAKwW,EACXyB,EAAMrY,EAAK4W,EAEX0B,EAAMR,EAAMA,EACZS,EAAM,EAAIT,EAAMC,EAChBS,EAAM,EAAIV,EAAME,EAChBS,EAAM,EAAIX,EAAMG,EAChBS,EAAM,EAAIX,EAAMA,EAChBY,EAAM,GAAKZ,EAAMC,EACjBY,EAAM,EAAIb,EAAME,EAChBY,EAAM,EAAIb,EAAMA,EAChBc,EAAM,EAAId,EAAMC,EAChBc,EAAMd,EAAMA,EAEZe,EAAMd,EAAMA,EACZe,EAAM,EAAIf,EAAMC,EAChBe,GAAM,EAAIhB,EAAME,EAChBe,GAAM,EAAIjB,EAAMG,EAChBe,GAAM,EAAIjB,EAAMA,EAChBkB,GAAM,GAAKlB,EAAMC,EACjBkB,GAAM,EAAInB,EAAME,EAChBkB,GAAM,EAAInB,EAAMA,EAChBoB,GAAM,EAAIpB,EAAMC,EAChBoB,GAAMpB,EAAMA,EAEZqB,GAAK,GAAKX,EAAMD,EAAMF,EAAMH,EAAMI,EAAMF,EAAMH,EAAME,EAAMH,EAAMD,GAAOmB,GAAMD,GAAMF,GAAMH,GAAMI,GAAMF,GAAMH,GAAME,GAAMH,EAAMD,IAC7HW,GAAK,GAAKb,EAAM,EAAIF,EAAM,EAAIH,EAAM,EAAII,EAAM,EAAIF,EAAM,EAAIH,EAAM,EAAIE,EAAM,EAAIH,EAAM,EAAID,GAAOkB,GAAM,EAAIF,GAAM,EAAIH,GAAM,EAAII,GAAM,EAAIF,GAAM,EAAIH,GAAM,EAAIE,GAAM,EAAIH,EAAM,EAAID,IACjLvU,GAAK,GAAKmU,EAAM,EAAIH,EAAMI,EAAM,EAAIF,EAAM,EAAIH,EAAM,EAAIE,EAAM,GAAKH,EAAM,GAAKD,GAAOgB,GAAM,EAAIH,GAAMI,GAAM,EAAIF,GAAM,EAAIH,GAAM,EAAIE,GAAM,GAAKH,EAAM,GAAKD,IACzJxU,GAAK,GAAKiU,EAAME,EAAM,EAAIH,EAAM,EAAIE,EAAM,GAAKH,EAAM,GAAKD,GAAOa,GAAME,GAAM,EAAIH,GAAM,EAAIE,GAAM,GAAKH,EAAM,GAAKD,IACjHvD,GAAK,GAAK+C,EAAME,EAAM,EAAIH,EAAM,GAAKD,GAAOY,GAAME,GAAM,EAAIH,EAAM,GAAKD,IACvEY,GAAKrB,EAAM,EAAID,GAAOW,EAAM,EAAID,GAEhCa,IAAQH,GAAIC,GAAIlV,GAAID,GAAIiR,GAAImE;AAEhC,GAAI1jB,IAAW0hB,EAAe,CAC7B,GAAIkC,IAAe1X,EAAK2X,QAAQF,GAAM7sB,EAKtC6sB,IAAOC,GAIR,GAAIE,IAAW5X,EAAK6X,WAAWJ,IAC3B1X,GAAQ6X,GAAStf,OAAO,SAAU6Q,GACrC,MAAOA,IAAQmH,EAAO,IAAMnH,GAAQmH,EAAO,KAOxCwH,IAAQ,EACRC,IAAQ,GACF,IAANntB,GAAWsK,IAAeka,EAAkB/gB,MAAQyF,IAAW0hB,GAAuB,IAAN5qB,KACnFktB,IAAQ,IAEC,IAANltB,GAAWsK,IAAeka,EAAkB3U,MAAQ3G,IAAW0hB,GAAuB,IAAN5qB,KACnFmtB,IAAQ,GAQS,IAAdzH,EAAO,GACNwH,IACH/X,GAAMjO,KAAKwe,EAAO,IAEK,IAAdA,EAAO,GACbyH,IACHhY,GAAMjO,KAAKwe,EAAO,IAGnBvQ,GAAMjO,KAAKwe,EAAO,IAGD,IAAdA,EAAO,GACNwH,IACH/X,GAAMjO,KAAKwe,EAAO,IAEK,IAAdA,EAAO,GACbyH,IACHhY,GAAMjO,KAAKwe,EAAO,IAGnBvQ,GAAMjO,KAAKwe,EAAO,GAGnB,IAAInhB,IAAK4Q,GAAMnR,IAAI,SAAUua,GAC5B,OAASla,EAAG6E,EAAO4G,SAASyO,GAAOve,EAAGue,KAEnCnZ,GAAe7D,EAAO6rB,aAAa/oB,EAAGE,GAAI,SAAUkhB,EAAIE,GAC3D,MAAOpkB,GAAO8L,uBAAuBoY,EAAIE,EAAGthB,IAI7C,OADAomB,GAAkBrlB,GACXA,IAGRqT,EAAS4U,mBAAqB,SAAU7Y,EAAUC,GAEjD,GAGI6Y,GAAQ,SAAehtB,GAC1B,MAAOA,IAAK,IAAMqJ,KAAK0P,IAGxB,OAAiB,KAAb5E,EACCD,EAAW,EACP,GAED,IAEJC,EAAW,EACP6Y,EAAM3jB,KAAK4jB,KAAK/Y,EAAWC,IAE5B,IAAM6Y,EAAM3jB,KAAK4jB,KAAK/Y,EAAWC,KAYzCgE,EAAS+U,kBAAoB,SAAUnpB,EAAGopB,GAGzC,GAAmB,OAAfA,EAAI5oB,OAAiB,CAGxB,GAAIsF,GAAIsjB,EAAI5oB,OAAOC,OAAO,GACtBoF,EAAIujB,EAAI5oB,OAAOC,OAAO,GAEtB4oB,EAAO,GAAI/c,GAAI,GAAIxK,IAAQ,EAAG,GAAIsnB,EAAI5oB,OAAOoG,QAAS1J,EAAOosB,UAAUF,EAAI7c,aAAczG,GAAID,IAAK3I,EAAOosB,UAAUF,EAAI5c,WAAY1G,GAAID,IAAKujB,EAAI3c,WAAY2c,EAAI1c,WAAY0c,EAAIzc,WAAYyc,EAAIxc,YAEhM2c,EAAKrsB,EAAOosB,UAAUtpB,IAAK8F,GAAID,IAC/BtJ,EAAIW,EAAOR,OAAO6sB,GAClBC,GAAUD,EAAG,GAAKhtB,EAClBktB,EAASF,EAAG,GAAKhtB,CAErB,IAAI6X,EAASsV,eAAeF,EAAQC,EAAQJ,EAAK5c,WAAY4c,EAAK3c,WAAY2c,EAAK1c,WAAY0c,EAAKzc,YAAa,CAChH,GAAI+c,GAAQN,EAAK7oB,OAAOoG,OACpBsF,GAAQlM,EAAG9C,EAAOosB,WAAWK,EAAQF,EAAQE,GAASH,IAAU1jB,EAAGD,IAAK+jB,SAAU,EACtF,OAAO1d,GAEP,GAAI2d,GAAMT,EAAI7c,WACVud,EAAMV,EAAI5c,SAEV+U,EAAKrkB,EAAOyE,gBAAgBkoB,EAAK7pB,GACjCwhB,EAAKtkB,EAAOyE,gBAAgBmoB,EAAK9pB,EAErC,OAAIuhB,GAAKC,GACCxhB,EAAG6pB,EAAKD,SAAU,IAEnB5pB,EAAG8pB,EAAKF,SAAU,GAM7B,GAAIC,GAAMT,EAAI7c,WACVud,EAAMV,EAAI5c,SAEV+U,EAAKrkB,EAAOyE,gBAAgBkoB,EAAK7pB,GACjCwhB,EAAKtkB,EAAOyE,gBAAgBmoB,EAAK9pB,GACjCgN,EAAK1H,KAAK+H,KAAKnQ,EAAO6sB,mCAAmC/pB,GAAI6pB,EAAKC,IAEtE,IAAIvI,GAAMC,GAAMD,GAAMvU,EACrB,OAAShN,EAAG6pB,EAAKD,SAAU,EACrB,IAAIpI,GAAMD,GAAMC,GAAMxU,EAC5B,OAAShN,EAAG8pB,EAAKF,SAAU,EAI5B,IAAII,GAAI9sB,EAAOkO,OAAOye,EAAKC,GAEvBG,GAAQjqB,EAAE,GAAKgqB,EAAE,GAAIhqB,EAAE,IAAMgqB,EAAE,IAC/B9d,GACHlM,EAAGoU,EAAS8V,sBAAsBlqB,EAAGiqB,IAAQJ,EAAKC,IAClDF,SAAU,EAGX,OAAO1d,IAMRkI,EAAS+V,eAAiB,SAAUC,GACnC,GAcIhB,GAdAiB,EAAYntB,EAAOotB,MAAMF,EAAa,GAAIA,EAAa,KACvDG,EAAYrtB,EAAOotB,MAAMF,EAAa,GAAIA,EAAa,KAEvDI,EAASttB,EAAOkO,OAAOgf,EAAa,GAAIA,EAAa,IACrDK,EAASvtB,EAAOkO,OAAOgf,EAAa,GAAIA,EAAa,IAErDM,GAAkBF,EAAO,IAAKA,EAAO,IACrCG,GAAkBF,EAAO,IAAKA,EAAO,IAErCG,GAASP,EAAWntB,EAAOosB,UAAUoB,EAAgBL,IACrDQ,GAASN,EAAWrtB,EAAOosB,UAAUqB,EAAgBJ,IAErDO,EAAe1W,EAAS8V,qBAAqBU,EAAOC,EAGxD,IAAqB,OAAjBC,EAEH,MAAI5tB,GAAO6tB,MAAMX,EAAa,GAAIA,EAAa,IACvC,KAERhB,EAAM,GAAI9c,GAAI,KAAM8d,EAAa,GAAIA,EAAa,GAInD,IAAIY,GAAc9tB,EAAOkO,OAAO0f,EAAcV,EAAa,IACvDa,EAAY/tB,EAAOkO,OAAO0f,EAAcV,EAAa,IACrDc,EAAchuB,EAAOkO,OAAO0f,EAAcV,EAAa,IACvDxjB,EAAS1J,EAAOR,OAAOsuB,GACvBve,GAAcue,EAAY,GAAKpkB,EAC/B8F,EAAase,EAAY,GAAKpkB,EAC9B+F,GAAcue,EAAY,GAAKtkB,EAC/BgG,EAAase,EAAY,GAAKtkB,EAC9BukB,GAAgBF,EAAU,GAAKrkB,EAC/BwkB,EAAeH,EAAU,GAAKrkB,CAQlC,OALCwiB,GADGhV,EAASsV,eAAeyB,EAAcC,EAAc3e,EAAYC,EAAYC,EAAYC,GACrF,GAAIN,GAAI,GAAIxK,GAAOgpB,EAAclkB,GAASwjB,EAAa,GAAIA,EAAa,GAAI3d,EAAYC,EAAYC,EAAYC,GAEhH,GAAIN,GAAI,GAAIxK,GAAOgpB,EAAclkB,GAASwjB,EAAa,GAAIA,EAAa,GAAIzd,EAAYC,EAAYH,EAAYC,IAMxH0H,EAASiX,SAAW,SAAUC,EAAWC,GACxC,MAAID,IAAa,EACZC,GAAa,EACT,EAED,EAEJA,GAAa,EACT,EAED,GAGRnX,EAASoX,sBAAwB,SAAU/e,EAAYC,EAAYC,EAAYC,GAC9E,GAAI6e,GAAKrX,EAASiX,SAAS5e,EAAYC,GACnCgf,EAAKtX,EAASiX,SAAS1e,EAAYC,EAEvC,OAAI6e,GAAKC,KAGLD,EAAKC,KAKE,IAAPD,GAAmB,IAAPA,EACRhf,GAAcE,EAEfF,GAAcE,IAMtByH,EAASsV,eAAiB,SAAU4B,EAAWC,EAAW9e,EAAYC,EAAYC,EAAYC,GAC7F,GAIIV,GAJAyf,EAAevX,EAASoX,sBAAsB/e,EAAYC,EAAYC,EAAYC,GAClFgf,EAAcxX,EAASoX,sBAAsBF,EAAWC,EAAW5e,EAAYC,GAC/Eif,EAAczX,EAASoX,sBAAsBF,EAAWC,EAAW9e,EAAYC,EASnF,OALCR,GADGyf,EACGE,IAAgBD,EAEhBC,IAAgBD,GAaxBxX,EAAS8V,qBAAuB,SAAUU,EAAOC,GAChD,GAAI9a,GAAM6a,EAAM,GAAG,GACf5a,EAAM4a,EAAM,GAAG,GACfkB,EAAMlB,EAAM,GAAG,GACfmB,EAAMnB,EAAM,GAAG,GACfoB,EAAMnB,EAAM,GAAG,GACfoB,EAAMpB,EAAM,GAAG,GACfqB,EAAMrB,EAAM,GAAG,GACfsB,EAAMtB,EAAM,GAAG,GACfuB,EAAMN,EAAM/b,EACZsc,EAAMN,EAAM/b,EACZsc,EAAMJ,EAAMF,EACZO,EAAMJ,EAAMF,EAEZ9mB,EAAQmnB,EAAMD,EAAME,EAAMH,CAC9B,IAAc,IAAVjnB,EAAJ,CAKA,GAAI5B,KAAM0oB,EAAMjc,GAAOoc,GAAOJ,EAAMjc,GAAOsc,GAAOlnB,CAElD,QAAQ6mB,EAAMzoB,EAAI+oB,EAAKL,EAAM1oB,EAAIgpB,KAGlCnY,EAASoY,+BAAiC,SAAUxsB,EAAGgqB,GACtD,GAAIyC,KAAOzC,EAAE,GAAIA,EAAE,IACf0C,EAAM1sB,EAAE,GAAKysB,EAAG,GAChBE,EAAM3sB,EAAE,GAAKysB,EAAG,EAEpB,QAAQzsB,GAAI0sB,EAAKC,KAQlBvY,EAAS8Q,gCAAkC,SAAUxkB,EAAMmE,EAAQwc,GAClE,GAAI1lB,KAAM+E,EAAK,GAAG,IAAKA,EAAK,GAAG,IAC3BV,GAAKU,EAAK,GAAG,GAAK/E,EAAE,GAAI+E,EAAK,GAAG,GAAK/E,EAAE,IAGvCixB,EAAa1vB,EAAOR,OAAOsD,GAC3BmQ,GAAYnQ,EAAE,GAAK4sB,EACnBxc,EAAWpQ,EAAE,GAAK4sB,EAElB7f,EAAe7P,EAAOuT,0BAA0B5L,EAAOkI,aAAcpR,EAAGwU,EAAUC,GAGlFnB,GADKlC,EAAa,GAAG,GAChBA,EAAa,GAAG,IAErBiC,GADKjC,EAAa,GAAG,GAChBA,EAAa,GAAG,IAErBgC,GADKhC,EAAa,GAAG,GAChBA,EAAa,GAAG,IAErB4B,GADK5B,EAAa,GAAG,GAChBA,EAAa,GAAG,IAMrBlH,GAAK8I,EAAK,EAAII,EAAK,EAAIC,EAAKC,EAChC,EAAIF,EAAK,EAAIC,EAAK,EAAIC,EACtB,EAAID,EAAK,EAAIC,EACbA,GAEI6B,EAAQC,EAAK8b,iBAAiBhnB,GAE9BqG,EAAM4E,EAITnR,IAAI,SAAUhE,GACd,OAASqE,EAAG6E,EAAO4G,SAAS9P,GAAIA,EAAGA,IAGpC,OAAOuQ,IAmDRkI,EAASC,yBAA2B,SAAU3P,EAAOlE,EAAQ0f,GAI5D,GAAIG,GAAO,GAGX,IAAsB,IAAlB7f,EAAOoG,OACV,OAAO,CAIR,IAAIA,GAASpG,EAAOoG,OAChBmc,EAAKviB,EAAOC,OAAO,GACnBuiB,EAAKxiB,EAAOC,OAAO,GAGnBqsB,KAEAhqB,EAAO4B,EAAMC,QAAQ0Q,KAErBnV,EAAK+B,EAAa2J,MAAMsU,EAAWG,EAEvC,GAAG,CACF,GAAIxb,GAAS/B,EAAKjD,IAIbijB,GAAkCje,EAAQrE,IAC9CssB,EAAiBjqB,KAAKgC,GAGvB/B,EAAOA,EAAK1D,WACJ0D,IAAS4B,EAAMC,QAAQ0Q,KAEhC,KAAK,GAAIlZ,GAAI,EAAGA,EAAI2wB,EAAiBpwB,OAAQP,IAAK,CAiBjD,GAAI4wB,GAAkBD,EAAiB3wB,GACnC4Q,EAAe7P,EAAOgmB,gBAAgB6J,EAAgBhgB,eAAgBgW,GAAKC,IAG3ElU,EAAK/B,EAAa,GAAG,GACrBkC,EAAKlC,EAAa,GAAG,GACrB8B,EAAK9B,EAAa,GAAG,GACrBiC,EAAKjC,EAAa,GAAG,GACrB6B,EAAK7B,EAAa,GAAG,GACrBgC,EAAKhC,EAAa,GAAG,GACrB2B,EAAK3B,EAAa,GAAG,GACrB4B,EAAK5B,EAAa,GAAG,GAMrBigB,EAAOle,EAAKA,EAAOme,EAAOpe,EAAKA,EAC/Bqe,EAAOte,EAAKA,EAAOue,EAAOze,EAAKA,EAC/B0e,EAAOne,EAAKA,EAAOoe,EAAOre,EAAKA,EAC/Bse,EAAOve,EAAKA,EAAOwe,EAAO5e,EAAKA,EAE/B6e,EAAKD,EAAO,EAAIxe,EAAKJ,EAAK,EAAIK,EAAKL,EAAK,EAAIM,EAAKN,EAAK,EAAI2e,EAAO,GAAKte,EAAKD,EAAK,EAAIE,EAAKF,EAAK,EAAIse,EAAO,EAAIpe,EAAKD,EAAKoe,EAAOD,EAAO,EAAIve,EAAKF,EAAK,EAAIG,EAAKH,EAAK,EAAII,EAAKJ,EAAK,EAAIwe,EAAO,GAAKre,EAAKD,EAAK,EAAIE,EAAKF,EAAK,EAAIqe,EAAO,EAAIne,EAAKD,EAAKme,EAChP3E,EAAK,EAAItZ,EAAKJ,EAAK,GAAKK,EAAKL,EAAK,EAAIM,EAAKN,EAAK,GAAK2e,EAAO,GAAKte,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKse,EAAO,GAAKpe,EAAKD,EAAK,EAAIoe,EAAO,EAAIxe,EAAKF,EAAK,GAAKG,EAAKH,EAAK,EAAII,EAAKJ,EAAK,GAAKwe,EAAO,GAAKre,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKqe,EAAO,GAAKne,EAAKD,EAAK,EAAIme,EACpP1E,EAAK,EAAItZ,EAAKL,EAAK,EAAIM,EAAKN,EAAK,EAAI2e,EAAO,GAAKte,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKse,EAAO,GAAKpe,EAAKD,EAAK,GAAKoe,EAAO,EAAIve,EAAKH,EAAK,EAAII,EAAKJ,EAAK,EAAIwe,EAAO,GAAKre,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKqe,EAAO,GAAKne,EAAKD,EAAK,GAAKme,EACtN5Z,EAAK,EAAInE,EAAKN,EAAK,GAAKK,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKse,EAAO,GAAKpe,EAAKD,EAAK,GAAKoe,EAAO,EAAIte,EAAKJ,EAAK,GAAKG,EAAKD,EAAK,GAAKE,EAAKF,EAAK,GAAKqe,EAAO,GAAKne,EAAKD,EAAK,GAAKme,EACpK7Z,EAAK,EAAIlE,EAAKF,EAAK,EAAIse,EAAO,GAAKpe,EAAKD,EAAK,GAAKoe,EAAO,EAAIte,EAAKF,EAAK,EAAIqe,EAAO,GAAKne,EAAKD,EAAK,GAAKme,EACtG5I,EAAK,EAAInV,EAAKD,EAAK,EAAIoe,EAAO,EAAIte,EAAKD,EAAK,EAAIme,EAChDzE,EAAK6E,EAAOJ,EAAOpmB,EAASA,EAE5B4hB,GAAQgF,EAAInF,EAAIC,EAAIlV,EAAID,EAAIiR,EAAImE,GAEhCkF,EAAU/K,EAAWxiB,EAAI6sB,EAAiBnuB,QAAW,GAAM,GAE3D8uB,EAAQ3c,EAAKtF,SAAS+c,GACtBliB,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAA4C6H,GAAxCC,EAAY+mB,EAAQpsB,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CACzJ,GAAI+a,GAAS5a,EAAMhF,KAOnB,IAAIisB,EAAMrM,EAAO,IAAMqM,EAAMrM,EAAO,IAAM,EACzC,OAAO,CAYR,IAAIsM,GAAa5c,EAAK6c,YAAYpF,EAAMnH,EAAO,GAAIA,EAAO,GAC1D,IAAIsM,EAAa,EAChB,OAAO,GAGR,MAAO/rB,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,KAMV,OAAO,GAGR5J,EAAOJ,QAAU4X,IAEdyZ,2CAA2C,GAAGC,8BAA8B,GAAGC,cAAc,GAAGC,sBAAsB,GAAGC,mBAAmB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,8BAA8B,IAAIC,IAAI,SAASnyB,EAAQU,EAAOJ,GAC/P,YAcA,SAASwF,GAAWssB,EAAOC,GACtBA,IACHlxB,KAAKyc,OAAS,GAAIJ,GAAS6U,IAG5BlxB,KAAKmxB,kBAAkBF,OAjBxB,GAAI5U,GAAWxd,EAAQ,+BACnBuyB,EAAWvyB,EAAQ,iBA0BvB8F,GAAW8S,OAAS,SAAU4Z,EAAM7uB,EAAM8uB,EAAOzZ,GAEhD,GAAIpS,GAAO,GAAI2rB,GAAS5uB,GAAMjB,SAAWA,SAErC4M,EAAO,OACPpM,EAAO,MAuBX,OArBKsvB,GAAKrZ,MAMT7J,EAAOmjB,EACPvvB,EAAOoM,EAAKpM,OANZoM,EAAO1I,EACP1D,EAAO0D,EAEP4rB,EAAKrZ,KAAOvS,GAMb1D,EAAKoM,KAAO1I,EACZ0I,EAAKpM,KAAO0D,EACZA,EAAK0I,KAAOA,EACZ1I,EAAK1D,KAAOA,EAEZ0D,EAAKoS,YAAcA,EAEfwZ,EAAK5U,QACRJ,EAAS5E,OAAO4Z,EAAK5U,OAAQhX,GAGvBA,GAGRd,EAAWwD,OAAS,SAAUkpB,EAAM7uB,GAEnC,GAAI2L,GAAO3L,EAAK2L,KACZpM,EAAOS,EAAKT,IAEZS,KAAS6uB,EAAKrZ,OACjBqZ,EAAKrZ,KAAOjW,GAGboM,EAAKpM,KAAOA,EACZA,EAAKoM,KAAOA,EAERkjB,EAAK5U,QAGRJ,EAASlU,OAAOkpB,EAAK5U,OAAQja,IAS/BmC,EAAW6F,UAAY,SAAU+mB,EAAYhzB,GAC5C,MAAO6yB,GAASI,cAAcD,EAAWvZ,KAAMzZ,IAGhDoG,EAAWM,UAAUksB,kBAAoB,SAAUpc,GAElD,GAAmB,IAAfA,EAAI1V,OAAR,CAWA,IAAK,GAJD2Y,GAFAzQ,KAGAkqB,EAAW,KACXhsB,EAAO,OAEF3G,EAAI,EAAGA,EAAIiW,EAAI1V,OAAQP,IAE/B2G,EAAO,GAAI2rB,GAASrc,EAAIjW,GAAI2yB,EAAU,KAAM3yB,GAE5CyI,EAAQ/B,KAAKC,GAETgsB,IACHA,EAAS1vB,KAAO0D,GAEjBgsB,EAAWhsB,EAED,IAAN3G,IACHkZ,EAAOvS,GAGJzF,KAAKyc,QACRJ,EAAS5E,OAAOzX,KAAKyc,OAAQhX,EAK/BuS,GAAK7J,KAAO1I,EACZA,EAAK1D,KAAOiW,EAEZhY,KAAKgY,KAAOA,EACZhY,KAAKuH,QAAUA,IAGhBhI,EAAOJ,QAAUwF,IAEd+sB,8BAA8B,GAAGC,iBAAiB,KAAKC,IAAI,SAAS/yB,EAAQU,EAAOJ,GACtF,YAYA,SAASiyB,GAAS5uB,EAAM2L,EAAMpM,GAE5B/B,KAAKwC,KAAOA,EACZxC,KAAKmO,KAAOA,EACZnO,KAAK+B,KAAOA,EAQdqvB,EAASI,cAAgB,SAAU/rB,EAAMlH,GACvC,IAAK,GAAIO,GAAI,EAAGA,EAAIP,EAAGO,IACrB2G,EAAOA,EAAK1D,IAGd,OAAO0D,IAGTlG,EAAOJ,QAAUiyB,OAEXS,IAAI,SAAShzB,EAAQU,EAAOJ,GAClC,YAoBA,SAAS2yB,GAAKlV,GACb5c,KAAK4c,KAAOA,EACZ5c,KAAK+xB,KAAM,EAUZ,QAAS1V,GAAS6U,GACjBlxB,KAAKkxB,WAAaA,EAClBlxB,KAAK6c,KAAO,KAGb,QAASmV,GAAgBC,EAAKxsB,GAC7B,MAAO,UAAUA,GAChB,KAAOA,EAAKwsB,IACXxsB,EAAOA,EAAKwsB,EAEb,OAAOxsB,IAmGT,QAASsgB,GAAOkM,EAAKngB,GACpB,GAAIrJ,GAAIqJ,GAAGmgB,EAMX,OALAngB,IAAGmgB,GAAOxpB,EAAEwpB,GACZxpB,EAAEwpB,GAAOngB,EACTrJ,EAAEspB,IAAMjgB,EAAEigB,IACVjgB,EAAEigB,KAAM,EAEDtpB,EAGR,QAASypB,GAAWpgB,GACnBA,EAAEigB,KAAOjgB,EAAEigB,IACXjgB,EAAEqgB,GAAMJ,KAAOjgB,EAAEqgB,GAAMJ,IACvBjgB,EAAEsgB,GAAOL,KAAOjgB,EAAEsgB,GAAOL,IAG1B,QAASM,GAAYvgB,GAQpB,MAPAogB,GAAWpgB,GACPggB,EAAKQ,MAAMxgB,EAAEsgB,GAAOD,MACvBrgB,EAAEsgB,GAASrM,EAAOqM,EAAOtgB,EAAEsgB,IAC3BtgB,EAAIiU,EAAOoM,EAAMrgB,GACjBogB,EAAWpgB,IAGLA,EAGR,QAASygB,GAAazgB,GAOrB,MANAogB,GAAWpgB,GACPggB,EAAKQ,MAAMxgB,EAAEqgB,GAAMA,MACtBrgB,EAAIiU,EAAOqM,EAAOtgB,GAClBogB,EAAWpgB,IAGLA,EA+DR,QAAS0gB,GAAM1gB,GAcd,MAbIggB,GAAKQ,MAAMxgB,EAAEsgB,MAChBtgB,EAAIiU,EAAOoM,EAAMrgB,IAGdggB,EAAKQ,MAAMxgB,EAAEqgB,KAAUL,EAAKQ,MAAMxgB,EAAEqgB,GAAMA,MAC7CrgB,EAAIiU,EAAOqM,EAAOtgB,IAIfggB,EAAKQ,MAAMxgB,EAAEqgB,KAAUL,EAAKQ,MAAMxgB,EAAEsgB,KACvCF,EAAWpgB,GAGLA,EAnPR,GAAIqgB,IAAO,EACPC,GAAQ,CAeZN,GAAKQ,MAAQ,SAAU7sB,GACtB,MAAOA,IAAQA,EAAKssB,KAoBrB1V,EAASoW,WAAaT,EAAgBG,GACtC9V,EAASqW,WAAaV,EAAgBI,GAEtC/V,EAASnI,IAAM,SAAUzO,GACxB,MAAO4W,GAASoW,WAAWhtB,GAAMmX,MAGlCP,EAASlI,IAAM,SAAU1O,GACxB,MAAO4W,GAASqW,WAAWjtB,GAAMmX,MASlCP,EAASM,WAAa,SAAUxX,EAAMyX,GACrC,GAAInX,GAAON,EAAK0X,IAEhB,IAAa,OAATpX,EACH,MAAO,KAIR,KADA,GAAIktB,MACGltB,GAAM,CACZ,GAAI6D,GAAInE,EAAK+rB,WAAWtU,EAAMnX,EAAKmX,KAC/BtT,IAAK,EACRqpB,EAAO,GAAKltB,EAEZktB,EAAO,GAAKltB,EAGbA,EAAOA,EAAK6D,GAAK,GAGlB,MAAOqpB,IAQRtW,EAASuW,KAAO,SAAUztB,EAAMyX,GAG/B,IAFA,GAAInX,GAAON,EAAK0X,KAETpX,GAAM,CACZ,GAAI6D,GAAInE,EAAK+rB,WAAWtU,EAAMnX,EAAKmX,KACnC,IAAU,IAANtT,EACH,MAAO7D,EAEPA,GAAOA,EAAK6D,EAAI,GAIlB,MAAO,OAMR+S,EAAS5E,OAAS,SAAUtS,EAAMyX,GAIjC,QAASnF,GAAO3F,EAAG8K,GAClB,GAAS,MAAL9K,EACH,MAAO,IAAIggB,GAAKlV,EAGbkV,GAAKQ,MAAMxgB,EAAEqgB,KAAUL,EAAKQ,MAAMxgB,EAAEsgB,KACvCF,EAAWpgB,EAGZ,IAAI+gB,GAAM1tB,EAAK+rB,WAAWtU,EAAM9K,EAAE8K,KAgBlC,OAfY,KAARiW,EACH/gB,EAAE8K,KAAOA,EACCiW,EAAM,EAChB/gB,EAAEqgB,GAAQ1a,EAAO3F,EAAEqgB,GAAOvV,GAE1B9K,EAAEsgB,GAAS3a,EAAO3F,EAAEsgB,GAAQxV,GAGzBkV,EAAKQ,MAAMxgB,EAAEsgB,MAAYN,EAAKQ,MAAMxgB,EAAEqgB,MACzCrgB,EAAIiU,EAAOoM,EAAMrgB,IAEdggB,EAAKQ,MAAMxgB,EAAEqgB,KAAUL,EAAKQ,MAAMxgB,EAAEqgB,GAAMA,MAC7CrgB,EAAIiU,EAAOqM,EAAOtgB,IAGZA,EA5BR3M,EAAK0X,KAAOpF,EAAOtS,EAAK0X,KAAMD,GAC9BzX,EAAK0X,KAAKkV,KAAM,GA2EjB1V,EAASlU,OAAS,SAAUhD,EAAMyX,GAMjC,QAASzU,GAAO2J,EAAG8K,GAClB,MAAIzX,GAAK+rB,WAAWtU,EAAM9K,EAAE8K,MAAQ,GAC9BkV,EAAKQ,MAAMxgB,EAAEqgB,KAAWL,EAAKQ,MAAMxgB,EAAEqgB,GAAMA,MAC/CrgB,EAAIugB,EAAYvgB,IAEjBA,EAAEqgB,GAAQhqB,EAAO2J,EAAEqgB,GAAOvV,GAEnB4V,EAAM1gB,KAGVggB,EAAKQ,MAAMxgB,EAAEqgB,MAChBrgB,EAAIiU,EAAOqM,EAAOtgB,IAGdA,EAAEsgB,IAA4C,IAAlCjtB,EAAK+rB,WAAWtU,EAAM9K,EAAE8K,OAGpCkV,EAAKQ,MAAMxgB,EAAEsgB,KAAYN,EAAKQ,MAAMxgB,EAAEsgB,GAAOD,MACjDrgB,EAAIygB,EAAazgB,IAGoB,IAAlC3M,EAAK+rB,WAAWtU,EAAM9K,EAAE8K,OAC3B9K,EAAE8K,KAAOP,EAASnI,IAAIpC,EAAEsgB,IACxBtgB,EAAEsgB,GAASU,EAAUhhB,EAAEsgB,KAEvBtgB,EAAEsgB,GAASjqB,EAAO2J,EAAEsgB,GAAQxV,GAGtB4V,EAAM1gB,IAbL,MAgBT,QAASghB,GAAUhhB,GAClB,MAAKA,GAAEqgB,IAGFL,EAAKQ,MAAMxgB,EAAEqgB,KAAWL,EAAKQ,MAAMxgB,EAAEqgB,GAAMA,MAC/CrgB,EAAIugB,EAAYvgB,IAEjBA,EAAEqgB,GAAQW,EAAUhhB,EAAEqgB,IAEfK,EAAM1gB,IAPL,KAtCT3M,EAAK0X,KAAO1U,EAAOhD,EAAK0X,KAAMD,GAC1BzX,EAAK0X,OACR1X,EAAK0X,KAAKkV,KAAM,IAmElBxyB,EAAOJ,QAAUkd,OAEX0W,IAAI,SAASl0B,EAAQU,EAAOJ,GAClC,YAEA,IAAIoO,IAEF8U,0BAA2B,IAC3B7U,WACE6K,WAAc,EACdT,MAAS,EACTX,KAAQ,EACRqL,kBAAqB,EACrBjU,SAAY,GAGhB9O,GAAOJ,QAAUoO,OAEXylB,IAAI,SAASn0B,EAAQU,EAAOJ,GAClC,YAGA,IAGI8zB,IAHgBp0B,EAAQ,sBAGbA,EAAQ,gCACnBq0B,EAAUr0B,EAAQ,+BAClBs0B,EAAct0B,EAAQ,oCAGtBW,EAAWX,EAAQ,cACnB4Q,EAAS5Q,EAAQ,gCAEjBu0B,GADUv0B,EAAQ,6BACZA,EAAQ,yBACdsZ,EAAYtZ,EAAQ,+BACpBwY,EAAexY,EAAQ,kCACvB+F,EAAe/F,EAAQ,wCACvB8F,EAAa9F,EAAQ,gCACrBwd,EAAWxd,EAAQ,+BACnByd,EAAQzd,EAAQ,+BAChBw0B,EAAMx0B,EAAQ,gBAGdkY,EAAWlY,EAAQ,0BACnBkJ,EAAOlJ,EAAQ,cACfgB,EAAShB,EAAQ,sBACjB6U,EAAO7U,EAAQ,8BAKf8N,EAAS2mB,OAAO3mB,UAEpBA,GAAS2I,OAAOie,OAAO5mB,GACtBumB,QAASA,EACTD,SAAUA,EACVE,YAAaA,EAEb1jB,OAAQA,EACR2jB,IAAKA,EACLjb,UAAWA,EACXd,aAAcA,EACdzS,aAAcA,EACdD,WAAYA,EACZ0X,SAAUA,EACVC,MAAOA,EACP+W,IAAKA,EAEL7zB,SAAUA,EAEVuX,SAAUA,EACVhP,KAAMA,EACNlI,OAAQA,EACR6T,KAAMA,IAIP4f,OAAO3mB,OAASA,IAEb6mB,aAAa,EAAEC,+BAA+B,EAAE5mB,uCAAuC,EAAE6mB,8BAA8B,EAAEC,yBAAyB,GAAG7mB,+BAA+B,GAAG8mB,8BAA8B,GAAGC,qBAAqB,GAAGC,iCAAiC,GAAGC,8BAA8B,GAAGC,4BAA4B,GAAGC,uBAAuB,GAAGC,8BAA8B,GAAGC,8BAA8B,GAAGC,mCAAmC,GAAGC,6BAA6B,GAAGC,eAAe,GAAGC,aAAa,GAAGtnB,qBAAqB,KAAKunB,IAAI,SAAS31B,EAAQU,EAAOJ,GACjlB,YAYA,SAASkY,GAAatS,EAAckH,GACnCjM,KAAK+E,aAAeA,EACpB/E,KAAKiM,UAAYA,EACjBjM,KAAKyC,IAAMmC,EAAa8J,cAAc3J,GACtC/E,KAAKuM,UAAYxH,EAAawH,UAE9BvM,KAAK,GAAK+E,EAAa,GACvB/E,KAAK,GAAK+E,EAAa,GAjBxB,GAAIH,GAAe/F,EAAQ,4CACvBgB,EAAShB,EAAQ,yBAmBrBwY,GAAazI,QAAU,SAAUhQ,EAAGsH,GACnC,MAAOtB,GAAagK,QAAQhQ,EAAEmG,aAAcmB,EAAEnB,eAG/CsS,EAAaqW,MAAQ,SAAU9uB,EAAGsH,GACjC,MAAOrG,GAAO6tB,MAAM9uB,EAAGsH,IAGxB3G,EAAOJ,QAAUkY,IAEd2F,2CAA2C,EAAEjO,yBAAyB,KAAK0lB,IAAI,SAAS51B,EAAQU,EAAOJ,GAC1G,YAEA,IAUIgZ,IAVStZ,EAAQ,oCAUL,SAAmBsE,EAAQ+I,GAC1ClM,KAAKmD,OAASA,EACdnD,KAAKkM,QAAUA,EACflM,KAAK00B,QAAU,GAGhBvc,GAAUwc,KAAO,SAAU1oB,GAC1B,MAAO,IAAIkM,GAAUlM,EAAU9I,OAAQ8I,EAAUC,UAYlDiM,EAAUC,OAAS,SAAUjV,EAAQ+I,GAGpC,IAAK,GAFDD,GAAY,GAAIkM,GAAUhV,GAAQ5B,SAE7BzC,EAAI,EAAGA,EAAIoN,EAAQ7M,OAAQP,IACnCoN,EAAQpN,GAAG0D,KAAKyJ,UAAYA,CAI7B,OAFAA,GAAUC,QAAUA,EAEbD,GAGR1M,EAAOJ,QAAUgZ,IAEdoK,mCAAmC,IAAIqS,IAAI,SAAS/1B,EAAQU,EAAOJ,GACtE,YAYA,SAAS01B,GAAQ5oB,EAAW6oB,GAC3B90B,KAAKiM,UAAYA,EACjBjM,KAAK80B,SAAWA,EAJDj2B,EAAQ,kBAOxBg2B,GAAQF,KAAO,SAAUlvB,GAIxB,QAASsvB,GAAO1oB,EAAS2oB,EAAWC,GAEnC,GAAIH,MAEAI,EAAU,GAAIL,GAAQxoB,EAAQJ,UAAW6oB,GAEzC7rB,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAqD6H,GAAjDC,EAAYgD,EAAQyoB,SAAS9wB,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAClK,GAAIksB,GAAQ/rB,EAAMhF,KAEd+wB,KAAUH,EAMdF,EAAStvB,KAAKuvB,EAAOI,EAAO9oB,EAAS6oB,IAJpCJ,EAAStvB,KAAKyvB,IAQf,MAAO1wB,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,IAKT,MAAO+rB,GAzCR,MAAOH,GAAOtvB,EAAMlE,SA6CrBhC,EAAOJ,QAAU01B,IAEdO,kBAAkB,KAAKC,IAAI,SAASx2B,EAAQU,EAAOJ,GACtD,YAYA,SAASi0B,GAAI3tB,GACXzF,KAAKs1B,UAAY7vB,EAXnB,GAAI8vB,GAAW12B,EAAQ,kCAgBvBu0B,GAAM9d,OAAOie,OAAOH,GAClBmC,SAAUA,IAGZh2B,EAAOJ,QAAUi0B,IAEdoC,kCAAkC,KAAKC,IAAI,SAAS52B,EAAQU,EAAOJ,GACtE,YAsBA,SAASu2B,GAAUruB,EAAOlE,EAAQwyB,EAAS1R,EAAIpf,GAE9C,GACI+wB,IADMD,EAAQnzB,KACR,GAAI6U,GAAa4M,GAAI1iB,UAE3Bc,EAAQia,EAAME,sBAAsBnV,EAAO4c,GAE3C4R,EAAOxe,EAAazI,QAAQvM,EAAM,GAAGG,KAAMozB,GAC3CE,EAAOze,EAAazI,QAAQgnB,EAAKvzB,EAAM,GAAGG,KAU9C,IARIqC,IACCgxB,EAAO,GAAKC,EAAO,IACtB7yB,QAAQpB,IAAI,6BAA+Bg0B,EAAO,KAAOC,GAMvDD,GAAQ,GAAKC,GAAQ,EAExB,WADAnxB,GAAWwD,OAAOd,EAAM0Q,cAAe4d,EAIxC,IAAI9b,GAAYlV,EAAW8S,OAAOpQ,EAAM0Q,cAAe6d,EAAKvzB,EAAM,GAElD8V,GAAUC,OAAOjV,GAASwyB,EAAS9b,GAcnD,OAZA8b,GAAQ1zB,aAAe4X,EACvBA,EAAU5X,aAAe0zB,EAEzBA,EAAQrd,aAAeuB,EACvBA,EAAUvB,aAAeqd,EAErB9wB,IAEHkxB,EAAaJ,EAAS9wB,GACtBkxB,EAAalc,EAAWhV,IAGlBgV,EAGR,QAASkc,GAAaxa,EAAc1W,GAEnC,GAAImxB,GAAQza,EAAa/Y,KAAKuC,aAAawH,UACvCtL,EAAS4D,EAAQ9D,UAAUE,OAC3BC,EAAQ2D,EAAQ9D,UAAUG,KACzBD,GAAO+0B,KACX/0B,EAAO+0B,IACNp0B,GAAI2Z,EACJ0a,QAAS/0B,EAAM7B,QAEhB6B,EAAMsE,KAAK+V,GAGZ,IAAI2a,GAAiBj1B,EAAO+0B,EAE5BE,GAAe1pB,iBAAmB0pB,EAAe1pB,qBA7ElD,GACI6K,IADSxY,EAAQ,oCACFA,EAAQ,uCACvB8F,EAAa9F,EAAQ,oCACrBsZ,EAAYtZ,EAAQ,mCACpByd,EAAQzd,EAAQ,kCA4EpBU,GAAOJ,QAAUu2B,IAEdnT,mCAAmC,EAAE4T,kCAAkC,EAAEjZ,mCAAmC,GAAGE,qCAAqC,GAAGC,kCAAkC,KAAK+Y,IAAI,SAASv3B,EAAQU,EAAOJ,GAC7N,YAiBA,SAASk3B,GAAUhvB,EAAO5F,EAAYoD,GAOrC,IAAK,GAND1B,GAAS1B,EAAW0B,OACpBN,EAAKpB,EAAWoB,GAChByzB,EAAU70B,EAAW60B,QAGrB5Z,KACK5d,EAAI,EAAGA,EAAI,EAAGA,IACtB4d,EAAIlX,KAAK,GAAI6R,GAAaxU,EAAG/D,IAAIyC,SAGlC,IAAIsD,EACH,CAAWwS,EAAazI,QAAQ8N,EAAI,GAAIA,EAAI,IACjCrF,EAAazI,QAAQ8N,EAAI,GAAIA,EAAI,IAW7C,GAAI7X,EAEH,IAAK,GADD0xB,MACKnhB,EAAK,EAAGA,EAAK,EAAGA,IACxBmhB,EAAK/wB,KAAK6R,EAAazI,QAAQ0nB,EAAQlhB,GAAI,GAAG5S,KAAMka,EAAItH,KAEpDmhB,EAAKnhB,GAAM,IACdnS,QAAQpB,IAAI,+BAAiCuT,EAAK,WAAamhB,EAAKnhB,IACpEnS,QAAQpB,IAAIJ,GAMf,KAAK,GADDyK,MACKsqB,EAAM,EAAGA,EAAM,EAAGA,IAC1BtqB,EAAQ1G,KAAKb,EAAW8S,OAAOpQ,EAAM0Q,cAAe2E,EAAI8Z,GAAMF,EAAQE,GAAK,IAO5E,KAAK,GAJDvqB,GAAYkM,EAAUC,OAAOjV,EAAQ+I,GAErCuqB,GAAY,EAAG,EAAG,GAClBC,GAAY,EAAG,EAAG,GACbC,EAAM,EAAGA,EAAM,EAAGA,IAC1BzqB,EAAQyqB,GAAK10B,aAAeiK,EAAQuqB,EAASE,IAC7CzqB,EAAQyqB,GAAKre,aAAepM,EAAQwqB,EAASC,GAG9C,OAAO1qB,GAjER,GAAIkM,GAAYtZ,EAAQ,mCACpBwY,EAAexY,EAAQ,sCACvB8F,EAAa9F,EAAQ,mCAkEzBU,GAAOJ,QAAUk3B,IAEdnZ,mCAAmC,GAAGE,qCAAqC,GAAGC,kCAAkC,KAAKuZ,IAAI,SAAS/3B,EAAQU,EAAOJ,GACpJ,YAcA,SAAS03B,GAASxvB,EAAOyvB,EAAaC,EAAUC,EAAYC,EAASpyB,GAIpE,GAAIqyB,GAAgB,MACpB,GACCA,GAAgBC,EAAcL,GAM1BI,EAAc73B,OAAS,GAC1B+3B,EAAiB/vB,EAAO6vB,EAAeryB,SAEhCqyB,EAAc73B,OAAS,EAEhC,IAAkD,IAA9Cy3B,EAAYt0B,KAAKyJ,UAAUC,QAAQ7M,QAAgB23B,EAAW1e,eAAiBwe,EAAY/0B,KAAM,CAIpG,GAAIsK,GAAUgrB,EAAcP,EAAaC,GAAYA,MAAgBlyB,EACrE,OAAOwH,GAGR,GAA6B,IAAzB6qB,EAAc73B,OAAc,CAO/B,GAAIi4B,GAAWD,EAAcP,EAAaC,GAAYA,MAAgBlyB,EAEtE,OAAOyyB,GACD,GAA6B,IAAzBJ,EAAc73B,OAAc,CAOtC,IALA,GAAIy1B,GAAWiC,GAAYA,MACvBQ,EAAYF,EAAcP,EAAahC,EAAUjwB,GAEjD2yB,EAAaV,EACbh4B,EAAI,EACD04B,EAAWlf,eAAiBwe,GAAeU,EAAWz1B,OAASy1B,EAAWlf,cAAc,CAE9FxZ,GAEA,IAAI24B,GAAS,MACb,IAAU,IAAN34B,EACH24B,EAASD,EAAWz1B,KACpB+0B,EAAYt0B,KAAKyJ,UAAUyoB,cACrB,IAAU,IAAN51B,IAMV24B,EAASD,EACiC,IAAtCA,EAAWh1B,KAAKyJ,UAAUyoB,SAC7B,KAIF,IAAIgD,GAAKb,EAASxvB,EAAOowB,EAAQF,EAAWC,GAAY,EAAO3yB,EAE/DiwB,GAAStvB,KAAKkyB,GAEdF,EAAaA,EAAWlf,aAGzB,MAAOif,IAIT,QAASF,GAAcz1B,EAAIkzB,EAAUjwB,GACpC,GAAIwH,GAAU,GAAIwoB,GAAQjzB,EAAGY,KAAKyJ,UAAW6oB,EAM7C,OAJIjwB,IACH8yB,EAAgB/1B,EAAIyK,EAASxH,GAGvBwH,EAGR,QAAS8qB,GAAcL,GACtB,GAAII,GAAgB,OAChB30B,EAASu0B,CAEbI,KACA,GAAG,CACFA,EAAc1xB,KAAKjD,EAEnB,IAAIR,GAAOQ,EAAOR,IAClBQ,GAASR,EAAKE,mBACNM,IAAWu0B,EAEpB,OAAOI,GAcR,QAASE,GAAiB/vB,EAAO6vB,EAAeryB,GAO/C,IAAK,GADD/B,MACKhE,EAAI,EAAGA,EAAIo4B,EAAc73B,OAAQP,IAAK,CAC9C,GAAI84B,GAAeV,EAAcp4B,EACjCgE,GAAO0C,MAAMoyB,EAAcA,EAAa71B,OAQzC,IAAK,GADD81B,IAAa,EACRziB,EAAK,EAAGA,EAAKtS,EAAOzD,OAAQ+V,IAAM,CAC1C,GAAI0iB,GAAO1iB,EAAK,CACZ0iB,KAASh1B,EAAOzD,SACnBy4B,EAAO,EAGR,IAAIC,GAAOj1B,EAAOsS,GAAI,GAAG5S,KACrBw1B,EAASl1B,EAAOg1B,GAAM,GAAGt1B,IAC7B,IAAI6U,EAAaqW,MAAMqK,EAAMC,GAAS,CAErCH,GAAa,CACb,QAUF,IAAK,GAFDp2B,GAAaw2B,EAAW5wB,EAAOvE,EAAQ+B,GAElC2xB,EAAM,EAAGA,EAAM,EAAGA,IAC1B5xB,EAAa+I,cAActG,EAAO5F,EAAW0B,OAAQ1B,EAAWoB,GAAG2zB,GAAM3xB,EAG1EwxB,GAAUhvB,EAAO5F,EAAYoD,GAG9B,QAAS8yB,GAAgBb,EAAazqB,EAASxH,GAE9C,GAAI1B,GAAS2zB,EAAYt0B,KAAKyJ,UAAU9I,OACpCV,EAAMmC,EAAauH,cAAchJ,EAAOC,QACxCpC,EAAW6D,EAAQ9D,UAAUC,QACjCA,GAASyB,GAAOzB,EAASyB,OACzBzB,EAASyB,GAAK4J,QAAUA,CAGxB,IAAI2pB,GAAQc,EAAYt0B,KAAKuC,aAAawH,UACtCtL,EAAS4D,EAAQ9D,UAAUE,OAC3BC,EAAQ2D,EAAQ9D,UAAUG,KACzBD,GAAO+0B,KACX/0B,EAAO+0B,IACNp0B,GAAIk1B,EACJb,QAAS/0B,EAAM7B,QAEhB6B,EAAMsE,KAAKsxB,GAGZ,IAAIZ,GAAiBj1B,EAAO+0B,EAC5BE,GAAe1pB,iBAAmB0pB,EAAe1pB,qBA3LlD,GAAIyrB,GAAap5B,EAAQ,qBACrBw3B,EAAYx3B,EAAQ,oBACpBg2B,EAAUh2B,EAAQ,iCAClBwY,EAAexY,EAAQ,sCACvB+F,EAAe/F,EAAQ,2CA0L3BU,GAAOJ,QAAU03B,IAEd7Z,2CAA2C,EAAEI,qCAAqC,GAAG8a,gCAAgC,GAAGC,mBAAmB,GAAGC,oBAAoB,KAAKC,IAAI,SAASx5B,EAAQU,EAAOJ,GACtM,YAKA,SAASm5B,GAAQn3B,GAChB,MAAO,IAAIiyB,GAAIyB,EAAQF,KAAKxzB,EAAIm0B,YAJjC,GAAIT,GAAUh2B,EAAQ,iCAClBu0B,EAAMv0B,EAAQ,oBAMlBU,GAAOJ,QAAUm5B,IAEdJ,gCAAgC,GAAGK,oBAAoB,KAAKC,IAAI,SAAS35B,EAAQU,EAAOJ,GAC3F,YAwCA,SAASs5B,GAAWpxB,EAAO9E,EAAQsC,GAGlC,GAAI2D,GAAIjG,EAAOC,KAAKuC,aAKhBwhB,GAAKhkB,EAAQA,GAUb2I,GAAS,EASTwtB,EAA0Bl1B,OAAOC,kBAEjCgJ,EAAMlK,EAAOC,KAAKuC,aAClB6D,EAAa6D,EAAI7D,WACjBtK,EAAImO,EAAInO,EAERmK,EAAIlG,EAAOC,KAAKyJ,UAAU9I,OAAOC,OACjC6f,EAAelM,EAASiQ,wBAAwB3f,EAAOkf,GACvD9a,EAAK,OACLC,EAAI,OACJitB,EAAe,OAGf75B,EAAI,CAKR,GAAG,CAEFA,GAEA,IAAIN,GAAIqB,EAAO8L,uBAAuBlD,EAAGD,EACzCya,GAAeC,EAAiBD,EAAcxa,EAAGjK,EAAGqG,GAEpD6G,EAAIgX,EAA+BO,EAAcxa,EAAGD,EAAGI,EAAYtK,EAAGuG,EAMtE,IAAI+zB,GAAuB/4B,EAAO8L,uBAAuBnD,EAAGkD,EAI5D,IAAIktB,GAAwBC,EAA8B,CACzD3tB,GAAS,CAET,OAOD,GAAI4tB,GAAQC,EAA2BtwB,EAAGD,EAAGkD,EAE7CitB,GAAe94B,EAAO8L,uBAAuBlD,EAAGqwB,EAOhD,IAAIE,GAAkBn5B,EAAO8L,uBAAuBnD,EAAGswB,EACnDE,GAAkBN,IACrBA,EAA0BM,GAM3BvwB,EAAIqwB,EAEAj0B,IACH4G,EAAKA,MAASA,EAAGjG,MAAOiD,EAAGA,EAAGD,EAAGA,EAAGkD,EAAGA,EAAGpN,EAAGA,WAEtCq6B,EAAeM,GAA2Bn6B,EAAIo6B,EAEnDp6B,KAAMo6B,IAGThuB,GAAS,EAGV,IAAI/H,GAAS,GAAIsB,GAAOgE,EAAG5I,EAAOyE,gBAAgBmE,EAAGiD,GAMrD,OAJI7G,IACHs0B,EAAmBt0B,EAASqG,EAAQ3I,EAAQY,EAAQqF,EAAGkD,EAAG6a,EAAG9a,GAG1DP,MAEHvG,GAAWwD,OAAOd,EAAM0Q,cAAexV,IAIxCqC,EAAa+I,cAActG,EAAOlE,EAAQuI,EAAG7G,IACpC1B,OAAQA,EAAQuI,EAAGA,IAG7B,QAASytB,GAAmBt0B,EAASqG,EAAQ3I,EAAQY,EAAQqF,EAAGkD,EAAG6a,EAAG9a,GAGjEP,GAEHrG,EAAQpF,KAAKkH,IAAIpE,EAAOC,KAAM,EAAG,SACjCqC,EAAQpF,KAAKkH,IAAIpE,EAAOC,KAAM,GAAK,YAKnCqC,EAAQpF,KAAKkH,IAAIxD,EAAOC,OAAQ,GAAK,UACjCyB,EAAQnF,YACXmF,EAAQpF,KAAK0D,OAAOA,EAAQ,oBAC5B0B,EAAQpF,KAAKkH,IAAIpE,EAAOC,KAAM,IAAM,OACpCqC,EAAQpF,KAAKkH,IAAI+E,EAAG,GAAK,SAI3B7G,EAAQ1E,UAAUqF,MACjB8C,SAAU/F,EACVgkB,IAAGA,EACH/d,EAAGA,EACHC,EAAGtF,EAAOC,OACVqI,GAAIA,EACJP,OAAQA,IAYV,QAASgY,GAAiBD,EAActgB,EAAGy2B,EAAUv0B,GACpD,GAAI4e,GAAiB,CAErB,IAAIR,EAAa5jB,QAAUokB,EAC1B,MAAOR,EAGR,IAAIoW,MACApwB,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAiD6H,GAA7CC,EAAY4Z,EAAajf,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAC9J,GAAIoa,GAAcja,EAAMhF,MAEpBoD,EAAS6b,EAAYza,WAAWpG,KAEhC82B,EAAO9xB,EAAO6L,iBACdkmB,EAAKxiB,EAASuN,+BAA+BgV,EAAM32B,EACnD42B,IAAMH,GACTC,EAAU7zB,KAAK6d,IAGhB,MAAO9e,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,IAKT,MAAOkwB,GAcR,QAASN,GAA2BtwB,EAAGD,EAAGkD,GAIzC,GAAI8tB,GAAWvxB,KAAK8I,KAAKtI,EAAE,GAAKD,EAAE,KAAOC,EAAE,GAAKD,EAAE,KAAO,EAGrDgJ,EAAK,OACLD,EAAK,OACLI,EAAK,OACLD,EAAK,OACL+nB,EAAK,OACLC,EAAK,MAELF,IACHhoB,EAAK/I,EAAE,GAAG8I,EAAK9I,EAAE,GACjBkJ,EAAKnJ,EAAE,GAAGkJ,EAAKlJ,EAAE,GACjBixB,EAAK/tB,EAAE,GAAGguB,EAAKhuB,EAAE,KAEjB8F,EAAK/I,EAAE,GAAG8I,EAAK9I,EAAE,GACjBkJ,EAAKnJ,EAAE,GAAGkJ,EAAKlJ,EAAE,GACjBixB,EAAK/tB,EAAE,GAAGguB,EAAKhuB,EAAE,GAIlB,IAAI9M,IAAK2S,EAAKG,IAAOF,EAAKG,GACtBzL,EAAIwL,EAAK9S,EAAI+S,EACbrI,EAAIqI,EAAKA,EAAKD,EAAKA,EAAK+nB,EAAKA,EAAKC,EAAKA,EAAK,EAAIxzB,GAAKwzB,EAAKhoB,GAC1D1K,EAAI2K,EAAK8nB,EAAK76B,GAAK8S,EAAKgoB,GACxB3S,EAAKzd,GAAK,EAAItC,GACd8O,EAAKlX,EAAImoB,EAAK7gB,CAElB,OAAOszB,IAAY1jB,EAAIiR,IAAOA,EAAIjR,GAtRnC,GAAIojB,GAAiB,GAIjBS,EAAuB,IACvBd,EAA+Bc,EAAuBA,EAEtDC,EAAkBD,EAAuB,GACzCV,EAA0BW,EAAkBA,EAE5Cn1B,EAAS5F,EAAQ,oCACjBkY,EAAWlY,EAAQ,8BAEnB8F,GADQ9F,EAAQ,mCACHA,EAAQ,qCACrB6jB,EAAiC7jB,EAAQ,mEACzCgB,EAAShB,EAAQ,0BACjB+F,EAAe/F,EAAQ,2CAyQ3BU,GAAOJ,QAAUs5B,IAIdoB,2CAA2C,EAAEtX,mCAAmC,EAAE4T,kCAAkC,EAAE2D,kEAAkE,GAAG7c,6BAA6B,GAAGC,mCAAmC,GAAGnO,yBAAyB,KAAKgrB,IAAI,SAASl7B,EAAQU,EAAOJ,GAC9T,YAgCA,SAAS84B,GAAW5wB,EAAOvE,EAAQ+B,GAElC,GAAIm1B,GAAgBl3B,EAAOR,IAAI,SAAUikB,GACxC,MAAOxP,GAASiQ,wBAAwB3f,EAAOkf,KAG5C0T,EAAM,OACNC,EAAK,OAELnxB,EAAU,MACVlE,KACHkE,GAAYC,OAKb,KAAK,GAFDmxB,GAAQ,OACRC,EAAsB52B,OAAOC,kBACxB3E,EAAI,EAAGA,EAAIgE,EAAOzD,OAAS,EAAGP,IAAK,CAC3C,GAAIu7B,GAAwBC,EAAqBjzB,EAAOvE,EAAQhE,EAAGk7B,EAAejxB,EAASlE,GACvF01B,EAAcF,EAAsBE,YACpC13B,EAAKw3B,EAAsBx3B,GAC3B23B,EAAKH,EAAsB5xB,CAE3B8xB,GAAcH,IACjBA,EAAsBG,EACtBJ,EAAQr7B,EACRm7B,EAAMp3B,EACNq3B,EAAKM,GAIP,GAAIC,GAAU56B,EAAOyE,gBAAgB41B,EAAID,EAAI,IAAMp6B,EAAOyE,gBAAgB41B,EAAID,EAAI,IAAMp6B,EAAOyE,gBAAgB41B,EAAID,EAAI,IAEnH92B,EAAS,GAAIsB,GAAOy1B,EAAIO,EAAU,GAElCnE,GAAWxzB,EAAO,GAAIA,EAAOq3B,GAAQr3B,EAAOA,EAAOzD,OAAS,IAE5DoC,GAAe60B,QAASA,EAASnzB,OAAQA,EAAQN,GAAIo3B,EAMzD,OAJIp1B,IACH61B,EAAsBj5B,EAAYqB,EAAQq3B,EAAOpxB,EAASkxB,EAAKp1B,GAGzDpD,EASR,QAAS64B,GAAqBjzB,EAAOvE,EAAQ63B,EAAKX,EAAejxB,EAASlE,GAezE,IAZA,GAAI+1B,GAAY,KAEZtE,GAAWxzB,EAAO,GAAIA,EAAO63B,GAAM73B,EAAOA,EAAOzD,OAAS,IAE1Dw7B,GAAiBb,EAAc,GAAIA,EAAcW,GAAMX,EAAcl3B,EAAOzD,OAAS,IAErFwD,EAAK,OACL4qB,EAAe,OACfrK,EAAK,EACL3a,EAAIqyB,EAAuBzzB,EAAOivB,EAASuE,EAAeh2B,GAC1Dk2B,EAAYv3B,OAAOC,kBAEhBs3B,EAAYH,GAAaxX,EAAK,IAAI,CACxCA,IAEAvgB,EAAKm4B,EAAiBvyB,EAAGoyB,EAAeh2B,GACxC4oB,EAAewN,EAAep4B,EAAIgC,EAElC,IAAIq2B,GAAiBC,EAA+B1yB,EAAGglB,GAGnD2N,EAAOC,EAAYR,EAAepyB,EAAGyyB,EAAgBr2B,EACzD4D,GAAI2yB,EAAKE,IAET,IAAIC,GAAI17B,EAAOR,OAAO67B,EACtBr4B,GAAKu4B,EAAKI,MAEVT,EAAY9yB,KAAK8I,IAAIwqB,EAAIH,EAAKK,MAO/B,IAAK,GAHDlyB,GAAS1J,EAAOR,OAAOQ,EAAOkO,OAAOlL,EAAG,GAAI4qB,IAE5CiO,KACK58B,EAAI,EAAGA,EAAIk7B,EAAc36B,OAAQP,IAAK,CAC9C,GAAI6D,GAAI+f,EAA+BsX,EAAcl7B,GAAI2uB,EAAclsB,OACvEA,OACAA,OACAsD,EAEA62B,GAAUl2B,KAAK3F,EAAOR,OAAOQ,EAAOkO,OAAOpL,EAAG8qB,KAG/C,GAAIkO,GAAW5zB,EAAKigB,OAAO0T,GACvBnB,EAAchxB,EAASoyB,CAM3B,OAJI92B,IACHkE,EAAQC,GAAGxD,MAAO3C,GAAIA,EAAI4F,EAAGA,EAAGe,IAAKD,EAAQqyB,MAAOjB,KAG5CJ,YAAaA,EAAa13B,GAAIA,EAAI4F,EAAGA,GAU/C,QAAS4yB,GAAYR,EAAepyB,EAAGozB,EAAeh3B,GAErD,GAAI02B,GAAI17B,EAAOR,OAAOw8B,GAElBC,EAAK,EACLC,EAAS,OACTT,EAAO,OACPE,EAAQ,OACRC,EAAO,OACP38B,EAAI,CACR,GAAG,CACF,GAAIkP,GAAQnO,EAAO2W,MAAMqlB,EAAeC,EACxCR,GAAOz7B,EAAOosB,UAAUxjB,EAAGuF,GAE3BwtB,EAAQR,EAAiBM,EAAMT,EAAeh2B,EAG9C,IAAIm3B,GAAkBf,EAAeO,EAAO32B,GACxCo3B,EAAmBp8B,EAAOkO,OAAOutB,EAAMU,EAC3CP,GAAO57B,EAAOR,OAAO48B,GAErBF,EAASN,EAAOF,EAEhBO,GAAU,EAEVh9B,WACSi9B,GAAUj9B,EAAI,EAGxB,QAASw8B,KAAMA,EAAMG,KAAMA,EAAMD,MAAOA,GAWzC,QAASV,GAAuBzzB,EAAOivB,EAASuE,EAAeh2B,GAG9D,GAAIq3B,GAAuBr8B,EAAOotB,MAAMqJ,EAAQ,GAAG,GAAG9zB,KAAM8zB,EAAQ,GAAG,GAAG9zB,OACtE25B,EAASzZ,EAA+BmY,EAAc,GAAIqB,EAAsB36B,OACpFA,OACAA,OACAsD,GAEIu3B,GAAc9F,EAAQ,GAAG,GAAG9zB,KAEhC25B,EAAQ7F,EAAQ,GAAG,GAAG9zB,MAElBG,EAAI,MAkBR,IAbCA,EAJ4C,IAAzC2zB,EAAQ,GAAG,GAAG9zB,KAAKuC,aAAaM,KAI/BxF,EAAOotB,MAAMmP,EAAW,GAAIA,EAAW,KAEvCv8B,EAAOw8B,aAAaD,IAGpB54B,OAAO84B,SAAS35B,EAAE,KAQlBa,OAAO84B,SAAS35B,EAAE,IAAK,CAC3B,GAAI45B,GAAQC,EAAaJ,EACzB,OAAOv8B,GAAOotB,MAAMmP,EAAWG,EAAM,IAAKH,EAAWG,EAAM,MAG5D,MAAO55B,GAGR,QAAS+3B,GAAsBj5B,EAAYqB,EAAQq3B,EAAOpxB,EAASkxB,EAAKp1B,GAUvE,GARAA,EAAQxE,QAAQmF,KAAK/D,GAErBsH,EAAQjG,OAASA,EACjBiG,EAAQ0zB,aAAe35B,EAAOR,IAAI,SAAUD,GAC3C,OAAQuC,EAAa8J,cAAcrM,EAAM,GAAGG,KAAKuC,cAAeH,EAAa8J,cAAcrM,EAAM,GAAGG,KAAKuC,iBAE1GgE,EAAQoxB,MAAQA,EAEZt1B,EAAQnF,UACX,IAAK,GAAIZ,GAAI,EAAGA,EAAIm7B,EAAI56B,OAAQP,IAAK,CACpC,GAAI6D,GAAIs3B,EAAIn7B,EACZ+F,GAAQpF,KAAKkH,IAAIhE,EAAG,IAAO7D,EAAI,GAAI,QAIjC+F,EAAQnF,YAEXmF,EAAQpF,KAAKkH,IAAIlF,EAAW0B,OAAOC,OAAQ,GAAK,QAEhDyB,EAAQpF,KAAK0D,OAAO1B,EAAW0B,OAAQ,sBAIzC,QAASq5B,GAAa35B,GACrB,MAAIA,GAAG,GAAG,KAAOA,EAAG,GAAG,IAAMA,EAAG,GAAG,KAAOA,EAAG,GAAG,IACvC,EAAG,GACDA,EAAG,GAAG,KAAOA,EAAG,GAAG,IAAMA,EAAG,GAAG,KAAOA,EAAG,GAAG,IAC9C,EAAG,GACDA,EAAG,GAAG,KAAOA,EAAG,GAAG,IAAMA,EAAG,GAAG,KAAOA,EAAG,GAAG,IAC9C,EAAG,MAMb,QAASm4B,GAAiBvyB,EAAGoyB,EAAeh2B,GAE3C,MAAOg2B,GAAcv4B,IAAI,SAAU2gB,GAElC,GAAItgB,GAAI+f,EAA+BO,EAAcxa,EAAGlH,OACxDA,OACAA,OACAsD,EAEA,OAAOlC,KAaT,QAASs4B,GAAep4B,EAAIgC,GAI3B,GAAItB,GAAO,KACPyf,EAAO,KAEP0Z,EAAK78B,EAAOyE,gBAAgBzB,EAAG,GAAIA,EAAG,IACtC85B,EAAK98B,EAAOyE,gBAAgBzB,EAAG,GAAIA,EAAG,IACtC+5B,EAAK/8B,EAAOyE,gBAAgBzB,EAAG,GAAIA,EAAG,IAEtCmH,EAAQ,MASZ,IARI0yB,EAAKn5B,EACRyG,GAAS,EAAG,EAAG,GACL2yB,EAAKp5B,EACfyG,GAAS,EAAG,EAAG,GACL4yB,EAAKr5B,IACfyG,GAAS,EAAG,EAAG,IAGZA,EAAO,CAaV,IAAK,GAXDwxB,IAAS52B,EAAa6J,UAAU5L,EAAGmH,EAAM,IAAKgZ,GAAOpe,EAAa2J,MAAM1L,EAAGmH,EAAM,IAAKgZ,GAAOpe,EAAa4J,aAAa3L,EAAGmH,EAAM,IAAKgZ,IAKrI6Z,EAAMrB,EAAMl5B,IAAI,SAAUw6B,GAC7B,MAAOj9B,GAAOw8B,cAAcS,EAAK,GAAIA,EAAK,GAAIj6B,EAAGmH,EAAM,QAGpD2wB,EAAM,EACNoC,EAAQv5B,OAAOC,kBACV3E,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC3B,GAAIkI,GAAInH,EAAOyE,gBAAgBu4B,EAAI/9B,GAAI+D,EAAGmH,EAAM,IAC5ChD,GAAI+1B,IACPA,EAAQ/1B,EACR2zB,EAAM77B,GAIR,MAAO+9B,GAAIlC,GAGZ,MAAO96B,GAAOw8B,aAAax5B,GAtU5B,GAAIkF,GAAOlJ,EAAQ,mBACf4F,EAAS5F,EAAQ,oCACjBkY,EAAWlY,EAAQ,8BACnBgB,EAAShB,EAAQ,0BACjB6jB,EAAiC7jB,EAAQ,mEACzC+F,EAAe/F,EAAQ,4CAEvBs8B,EAAiCt7B,EAAOkO,MA6Y5CxO,GAAOJ,QAAU84B,IAId+E,kBAAkB,GAAGza,mCAAmC,EAAEvF,2CAA2C,EAAE8c,kEAAkE,GAAG7c,6BAA6B,GAAGlO,yBAAyB,KAAKkuB,IAAI,SAASp+B,EAAQU,EAAOJ,GACzQ,YAUA,SAAS+zB,GAAQ7rB,EAAOxC,GAKvB,GAAIqmB,GAAK,MAETA,GAAKgS,YAAYC,MAGjBC,EAAW/1B,EAAOxC,EAIlB,IAAIkiB,GAAKmW,YAAYC,KAEjBt4B,KACHA,EAAQw4B,mBAAqBtW,EAAKmE,GAEnCjoB,QAAQpB,IAAI,sBAAwBklB,EAAKmE,GAAItoB,QAAQ,GAAK,iBAiB1D,IAAI06B,GAAM,MACVA,GAAMJ,YAAYC,KAElB,IAAIplB,GAAgB1Q,EAAM0Q,cACtBxV,EAASwV,EAAcC,IAC3B,GAAG,CACF,GAA6C,IAAzCzV,EAAOC,KAAKyJ,UAAUC,QAAQ7M,OACjC,KAGDkD,GAASA,EAAOR,WACRQ,IAAWwV,EAAcC,KAElC,IAAIulB,GAASh7B,EAAON,aAEhBu7B,EAAa3G,EAASxvB,EAAOk2B,EAAOt7B,aAAcV,OAAWA,QAAW,EAAOsD,GAC/E44B,EAAc5G,EAASxvB,EAAOk2B,EAAQh8B,OAAWA,QAAW,EAAOsD,EAEvE44B,GAAY3I,SAAStvB,KAAKi4B,EAAY3I,SAAS,IAC/C2I,EAAY3I,SAAS,GAAK0I,EAAW1I,SAAS,GAC9C0I,EAAW1I,SAAS,GAAGA,SAAS,GAAK2I,CAErC,IAAIt8B,GAAM,GAAIiyB,GAAIqK,GAEdC,EAAMR,YAAYC,KAClBt4B,KACHA,EAAQw4B,mBAAqBK,EAAMJ,GAEpCr6B,QAAQpB,IAAI,sBAAwB67B,EAAMJ,GAAK16B,QAAQ,GAAK,iBAI5D,IAAI+6B,GAAWC,EAAOz8B,EAEtB,OAAOw8B,GASR,QAASP,GAAW/1B,EAAOxC,GAU1B,IAAK,GARDoT,GAAa5Q,EAAM4Q,WAEnB4lB,EAAM5lB,EAAW5Y,OAGjBy+B,EAAQC,EAAYF,GAGf/+B,EAAI,EAAGA,EAAI++B,EAAK/+B,IAAK,CAC7B,GAAIyD,GAAS0V,EAAW6lB,EAAMh/B,IAC1BqM,EAAestB,EAAWpxB,EAAO9E,EAAQsC,EAE7C,IAAIsG,EACH,CAAA,GAAIhI,GAASgI,EAAahI,OACtBuI,EAAIP,EAAaO,CAELgqB,GAAUruB,EAAOlE,EAAQZ,EAAQmJ,EAAG7G,OAKpDm5B,KAIF/6B,QAAQpB,IAAI,kBAAoBm8B,GAUjC,QAASJ,GAAOz8B,GAIf,QAAS4zB,GAAO1oB,EAAS2oB,GAExB,GAAgC,IAA5B3oB,EAAQyoB,SAASz1B,QAAgBgN,EAAQyoB,SAAS,GAAG7oB,YAAcI,EAAQJ,UAAW,CAEzF,GAAIgyB,GAAa5xB,EAAQyoB,SAAS,GAC9BoJ,EAAcD,EAAWnJ,SAAS,EACtCzoB,GAAQyoB,SAAS,GAAKoJ,EACtBA,EAAYpJ,SAAS,GAAKzoB,EAG3B,GAAIpD,IAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAqD6H,GAAjDC,EAAYgD,EAAQyoB,SAAS9wB,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAClK,GAAIxD,GAAO2D,EAAMhF,KAEbqB,KAASuvB,GAKbD,EAAOtvB,EAAM4G,IAEb,MAAO9H,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,KAMV,MA3CA4rB,GAAO5zB,EAAIm0B,UAAW/zB,QA2CfJ,EAiER,QAAS48B,GAAYx/B,GAEpB,IAAK,GADDwW,MACKjW,EAAI,EAAGA,EAAIP,EAAGO,IACtBiW,EAAIvP,KAAK1G,EAEV,OAAOiW,GA/OR,GAAI2gB,GAAY72B,EAAQ,oBACpB45B,EAAa55B,EAAQ,qBACrBg4B,EAAWh4B,EAAQ,kBACnBu0B,EAAMv0B,EAAQ,qBAmFdm/B,EAAY,CA4JhBz+B,GAAOJ,QAAU+zB,IAEdqF,oBAAoB,GAAG4F,mBAAmB,GAAGC,iBAAiB,GAAGC,oBAAoB,KAAKC,IAAI,SAASz/B,EAAQU,EAAOJ,GACzH,YAIA,SAASuF,GAAgBvD,GACxB,GAAIo9B,KAMJ,OAJAhJ,GAASp0B,EAAK,SAAUsE,GACvB84B,EAAM/4B,KAAKC,KAGL84B,EATR,GAAIhJ,GAAW12B,EAAQ,gBAYvBU,GAAOJ,QAAUuF,IAEd85B,gBAAgB,KAAKC,IAAI,SAAS5/B,EAAQU,EAAOJ,GACpD,YAMA,SAASu/B,GAAev9B,GACvB,GAAIo9B,KAOJ,OALAhJ,GAASp0B,EAAK,SAAUsE,GACvB,GAAIhD,GAAMmC,EAAauH,cAAc1G,EAAKwG,UAAU9I,OAAOC,OAC3Dm7B,GAAM97B,GAAOgD,IAGP84B,EAZR,GAAI35B,GAAe/F,EAAQ,4CAEvB02B,EAAW12B,EAAQ,gBAavBU,GAAOJ,QAAUu/B,IAEd1hB,2CAA2C,EAAEwhB,gBAAgB,KAAKG,IAAI,SAAS9/B,EAAQU,EAAOJ,GACjG,YAmBA,SAAS8zB,GAAS9xB,EAAK0D,GAOtB,QAAS+5B,GAAa1jB,GAKrB,IAAK,GAJDC,GAAQ9G,EAAe6G,EAAM,GAC7B2jB,EAAc1jB,EAAM,GACpB2jB,EAAc3jB,EAAM,GAEfrc,EAAI,EAAGA,EAAI+/B,EAAYx/B,OAAQP,IAGvC,IAAK,GAFDyY,GAAasnB,EAAY//B,GAEpBkM,EAAI,EAAGA,EAAI8zB,EAAYz/B,OAAQ2L,IAAK,CAC5C,GAAI+zB,GAAaD,EAAY9zB,EAE7B,IAAIuM,EAAWxV,OAASg9B,EACvB,OAAQxnB,EAAYwnB,IAMxB3L,EAAImC,SAASp0B,EAAK,SAAU69B,EAAUvN,GAqBrC,QAASwN,GAA4B18B,EAAQkrB,EAAcyR,GAC1D,GAAI3X,GAAMhlB,EAAOC,KAEbozB,EAAMsJ,EAAS38B,EAAO+V,aAAa9V,KAAOD,EAAON,aAAaO,KAE9D28B,EAAO,MACX,IAAI5X,IAAQqO,EAAK,CAEhB,GAAIwJ,GAAUv/B,EAAOkO,OAAOwZ,EAAKqO,EACjCuJ,GAAOt/B,EAAOw/B,kBAAkBD,OAEhC,IAAI7X,EAAIxiB,aAAaM,OAASkI,EAAcC,UAAUoK,MAAO,CAC5D,GAAI0nB,GAAc,OACdC,EAAc,MACS,KAAvBhY,EAAIxiB,aAAazG,GACpBghC,EAAc/X,EAAIxiB,aAAa6D,WAC/B22B,EAAchY,EAAIxiB,aAAa6D,WAAWuF,MACT,IAAvBoZ,EAAIxiB,aAAazG,IAC3BghC,EAAc/X,EAAIxiB,aAAa6D,WAAW7G,KAC1Cw9B,EAAchY,EAAIxiB,aAAa6D,WAGhC,IAAIlB,GAAO43B,EAAY98B,KAAKmF,QAAQ,GAChCC,EAAO/H,EAAO2/B,QAAQD,EAAY/8B,KAAKmF,QAAQ,IAE/Cc,EAAI5I,EAAO8G,IAAIe,EAAME,GAIrBsU,EAAOjU,KAAK+H,MAAM,EAAIvH,GAAK,GAC3B0T,EAAOlU,KAAK+H,MAAM,EAAIvH,GAAK,EAE/B02B,GAAOt/B,EAAOkmB,OAAOne,EAAMuU,EAAMD,OAEjCijB,GAAOt/B,EAAOkO,OAAOwZ,EAAKkG,EAG5B,IAAId,GAAI9sB,EAAOosB,UAAUwB,EAAc5tB,EAAO4/B,SAASN,EAAM,IACzDjgC,GAAKuuB,EAAcd,EAEvB,OAAOztB,GA5DR,GAAKuyB,EAAL,CAIA,GAAIiO,GAAgBjO,EAASxlB,UACzB0zB,EAASD,EAAcv8B,OAAOC,OAC9By7B,EAAca,EAAcxzB,QAE5B0zB,EAAgBZ,EAAS/yB,UACzB4zB,EAASD,EAAcz8B,OAAOC,OAC9B07B,EAAcc,EAAc1zB,QAE5B4zB,EAAgBlB,GAAcC,EAAaC,IAC3CiB,EAAiB1rB,EAAeyrB,EAAe,GAC/CvoB,EAAawoB,EAAe,GAC5BhB,EAAagB,EAAe,GAE5BC,EAAQf,EAA4B1nB,EAAYooB,GAAQ,GACxDM,EAAQhB,EAA4BF,EAAYc,GAAQ,GA6CxDK,EAAMnpB,EAAS8V,qBAAqBmT,EAAOC,GAC3CE,EAAU,MACd,IAAID,EAAK,CACR,GAAIthC,GAAIiB,EAAOkO,OAAO4xB,EAAQO,GAC1Bh6B,EAAIrG,EAAOkO,OAAO8xB,EAAQK,GAC1B52B,EAAIzJ,EAAOkO,OAAO4xB,EAAQE,GAE1BO,EAAOvgC,EAAO8G,IAAI/H,EAAG0K,GACrB+2B,EAAOxgC,EAAO8G,IAAIT,EAAGoD,EAEzB62B,GAAUC,EAAO,GAAKC,EAAO,EAG9B,GAAKH,EAIE,GAAIC,EAAS,CACnB,GAAIG,GAAMzgC,EAAOotB,MAAM0S,EAAQE,IAC3BU,EAAM1gC,EAAOkO,OAAO4xB,EAAQE,GAC5BW,EAAO3gC,EAAOw/B,kBAAkBkB,GAChCE,EAAO5gC,EAAOosB,UAAUqU,EAAKE,GAC7BthC,GAAKohC,EAAKG,GACVC,EAAO3pB,EAAS8V,qBAAqBmT,EAAO9gC,GAC5CyhC,EAAO5pB,EAAS8V,qBAAqBoT,EAAO/gC,EAC5C2F,IACHA,EAAQpF,KAAK+H,QAASkI,cAAeiwB,EAAQe,EAAMC,EAAMd,IAAWe,OAIjE/7B,IACHA,EAAQpF,KAAKohC,YAAYlB,EAAQO,EAAKL,GAASiB,OAjB5Cj8B,IACHA,EAAQpF,KAAK4D,MAAMs8B,EAAQE,GAASkB,MAzHxC,GAAI1sB,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAEllBwB,EAAWlY,EAAQ,8BACnBgB,EAAShB,EAAQ,0BACjBu0B,EAAMv0B,EAAQ,qBACd0O,EAAgB1O,EAAQ,0BAExBkiC,EAAkB,qBAClBD,EAAkB,qBAClBF,EAAkB,oBAsItBrhC,GAAOJ,QAAU8zB,IAEdhW,6BAA6B,GAAGnO,yBAAyB,GAAGC,yBAAyB,GAAGwpB,oBAAoB,KAAKyI,IAAI,SAASniC,EAAQU,EAAOJ,GAChJ,YAqBA,SAASg0B,GAAY8N,EAAMxiC,EAAGoG,GAU7B,GAAI1D,GAAMm3B,EAAQ2I,GAQdjgC,EAAW09B,EAAev9B,GAE1B+/B,GAAW19B,OAAOC,kBAClB09B,EAAc,MAClB,KAAK,GAAI1+B,KAAOzB,GAAU,CACzB,GAAIyE,GAAOzE,EAASyB,GAChBjE,EAAIiH,EAAKwG,UAAU9I,OAAOoG,MAC1B/K,GAAI0iC,IACPC,EAAc17B,EACdy7B,EAAU1iC,GAIZ,GACI2G,IADK+3B,YAAYC,MACViE,EAAkB3iC,EAAGuC,GACvBk8B,aAAYC,KAGjBt4B,IACCA,EAAQ9E,mBACX8E,EAAQK,YAAYC,EAKtB,IAAI/D,GAAM,GAAIgyB,GAAI+N,GAEdE,IAKJC,GAAoBn8B,EAAMo8B,GAAU9iC,EAAGA,EAAG0G,KAAMA,EAAMk8B,SAAUA,GAKhE,IAAIG,KAKJ,OAJAC,GAAOJ,EAAUG,EAAWpgC,EAAIk0B,WAEhCoM,EAAaF,GAENpgC,EAGR,QAASugC,GAAUljC,EAAG0G,EAAMy8B,EAAYC,EAAQp8B,EAAMhD,EAAKq/B,GAI1D,GAAIC,GAAc,EAEd5+B,EAASsC,EAAKwG,UAAU9I,OAExB6+B,EAAcC,EAAWxjC,EAAGmjC,EAAYC,EAAQ1+B,GAChD++B,EAASF,EAAYE,OACrBC,EAAYH,EAAYG,SAK5B,IAAsB,IAAlBD,EAAO7iC,QAAgByiC,IAAUC,EAAa,CACjD,GAAIK,GAAQF,EAAO,EAEd/8B,GAAKi9B,KACTj9B,EAAKi9B,MAEN,IAAIC,GAAUl9B,EAAKi9B,GAGfE,EAAgBV,EAAa,EAAI,CAGrC,YAFAD,GAAUljC,EAAG4jC,EAASC,EAAeH,EAAW18B,EAAMhD,EAAKq/B,EAAQ,GAK/D38B,EAAK,KACTA,EAAK,GAAK,GAAIo9B,KAEf,IAAIC,GAASr9B,EAAK,EAClBq9B,GAAOC,IAAIhgC,EAAKgD,GAGjB,QAAS27B,GAAkB3iC,EAAGuC,GAE7B,GAAI4gC,GAAa,EACbC,IAAW,EAAGa,IAAS,EAAGC,IAE1Bx9B,IAEJ,KAAK,GAAI1C,KAAOzB,GAAU,CACzB,GAAIyE,GAAOzE,EAASyB,EAEpBk/B,GAAUljC,EAAG0G,EAAMy8B,EAAYC,EAAQp8B,EAAMhD,EAAK,GAGnD,MAAO0C,GAGR,QAASo8B,GAAO97B,EAAMhD,EAAKyY,GAC1B,GAAIzc,GAAIyc,EAAKzc,EACT0G,EAAO+V,EAAK/V,KACZk8B,EAAWnmB,EAAKmmB,QAGpB,IAAqC,IAAjC57B,EAAKwG,UAAU9I,OAAOoG,SAItB83B,EAAS5+B,GAAb,CAIA,GAAI++B,GAAYoB,EAAankC,EAAG0G,EAAMM,EACtC,KAAK,GAAII,KAAQ27B,GACXH,EAASx7B,KACbw7B,EAASx7B,GAAQJ,IAKpB,QAAS67B,GAAoBn8B,EAAMpG,EAAG8jC,GAErC,QAAS9N,GAAO5vB,GACf,GAAKA,EAAL,CAIA,GAAIA,EAAKG,KAMR,WAJAH,GAAK29B,QAAQ,SAAUr9B,EAAMhD,GAC5B1D,EAAE0G,EAAMhD,EAAKogC,IAMX19B,GAAK,IACR4vB,EAAO5vB,EAAK,IAETA,EAAK,IACR4vB,EAAO5vB,EAAK,IAETA,EAAK,IACR4vB,EAAO5vB,EAAK,IAETA,EAAK,IACR4vB,EAAO5vB,EAAK,IAETA,EAAK,IACR4vB,EAAO5vB,EAAK,IAETA,EAAK,IACR4vB,EAAO5vB,EAAK,KAId4vB,EAAO5vB,GAGR,QAASy9B,GAAankC,EAAG0G,EAAM49B,GAY9B,QAASC,GAAY79B,GACpB,GAAIq9B,GAASr9B,EAAK,EACbq9B,IAILA,EAAOM,QAAQ,SAAUr9B,EAAMhD,GAC9B,GAAI4jB,GAAK5hB,EAAO+R,MAAM/Q,EAAKwG,UAAU9I,OAAQ1E,EACzCsY,GAASqP,uBAAuBrE,EAAIsE,KACvCmb,EAAU/+B,GAAOgD,EAEjB+8B,EAAOS,OAAOxgC,MAKjB,QAASsyB,GAAO5vB,EAAMy8B,EAAYC,EAAQC,GAEzC,GAAe,OAAXD,EAAJ,CAiBA,GAAIqB,GAAejB,EAAWxjC,EAAGmjC,EAAYC,EAAQ1+B,GACjD++B,EAASgB,EAAahB,OACtBC,EAAYe,EAAaf,SAE7B,IAAsB,IAAlBD,EAAO7iC,OAAX,CA0DA2jC,EAAY79B,EAGZ,KAAK,GAAIiQ,GAAK,EAAGA,GAAM,EAAGA,IAAM,CAC/B,GAAI+tB,GAAWh+B,EAAKiQ,EAChB+tB,IAEHpO,EAAOoO,EAAU,EAAG,KAAMrB,EAAQ,QAjEpC,CACCkB,EAAY79B,EAEZ,IAAIi9B,GAAQF,EAAO,GACfI,EAAgBV,EAAa,EAAI,CAErC,IAAc,IAAVQ,GAAyB,IAAVA,EAAa,CAG/B,GAAIgB,GAAWj+B,EAAKi9B,EAEhBgB,IACHrO,EAAOqO,EAAUd,EAAeH,EAAWL,EAAQ,OAE9C,CAIN,GAAIhN,KACJA,GAAStvB,KAAKL,EAAKi9B,IACfA,EAAQ,GACXtN,EAAStvB,KAAKL,EAAKi9B,EAAQ,IAExBA,EAAQ,GACXtN,EAAStvB,KAAKL,EAAKi9B,EAAQ,GAG5B,IAAIn5B,IAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAA6C6H,GAAzCC,EAAYyrB,EAAS9wB,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CAC1J,GAAIo6B,GAAWj6B,EAAMhF,KAEjBi/B,IACHtO,EAAOsO,EAAUf,EAAeH,EAAWL,EAAQ,IAGpD,MAAOv9B,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,WAtEX,CAIC65B,EAAY79B,EAEZ,KAAK,GAAIrG,GAAI,EAAGA,GAAK,EAAGA,IAAK,CAC5B,GAAI0jC,GAASr9B,EAAKrG,EACd0jC,IACHzN,EAAOyN,EAAQ,EAAG,KAAMV,EAAQ,KArCpC,GAAI/f,GAAKtd,EAAO+R,MAAMusB,EAAS92B,UAAU9I,OAAQ1E,GAE7C+iC,KAEAK,IAAW,EAAGa,IAAS,EAAGC,IAC1Bx/B,EAAS4/B,EAAS92B,UAAU9I,MAGhC,OAFA4xB,GAAO5vB,EAAM,EAAG08B,EAAQ,GAEjBL,EAmHR,QAASC,GAAOJ,EAAUG,EAAW8B,EAAStO,GAE7C,GAAIvyB,GAAMmC,EAAauH,cAAcm3B,EAAQr3B,UAAU9I,OAAOC,QAE1DmgC,GAAclC,EAAS5+B,GAEvByH,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkB7I,MAEtB,KACC,IAAK,GAAsD8I,GAAlDC,EAAag5B,EAAQxO,SAAS9wB,OAAOC,cAAuBiG,GAA8BG,EAASC,EAAWvI,QAAQmC,MAAOgG,GAA6B,EAAM,CACxK,GAAIzE,GAAO4E,EAAOjG,KAEdqB,KAASuvB,GAITyM,EAAOJ,EAAUG,EAAW/7B,EAAM69B,KACrCC,GAAa,IAGd,MAAOh/B,GACR4F,GAAqB,EACrBC,EAAkB7F,EACjB,QACD,KACM2F,GAA8BI,EAAW9F,QAC7C8F,EAAW9F,SAEX,QACD,GAAI2F,EACH,KAAMC,IAKT,QAAIm5B,IAIJ/B,EAAUh8B,MAAO89B,QAASA,EAAStO,UAAWA,KAEvC,GAGR,QAASwO,GAAYC,GACpB,GAAIH,GAAUG,EAASH,QACnBtO,EAAYyO,EAASzO,UAGrB2F,EAAM3F,EAAUF,SAAS4O,QAAQJ,EACjC3I,IAAO,GACV3F,EAAUF,SAAS/Y,OAAO4e,EAAK,GAIjC,QAAS+G,GAAaF,GACrB,GAAIp2B,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkB/J,MAEtB,KACC,IAAK,GAA+CgK,GAA3CC,EAAag2B,EAAUx9B,OAAOC,cAAuBmH,GAA8BG,EAASC,EAAWzJ,QAAQmC,MAAOkH,GAA6B,EAAM,CACjK,GAAI3F,GAAO8F,EAAOnH,KAElBo/B,GAAY/9B,IAEZ,MAAOlB,GACR8G,GAAqB,EACrBC,EAAkB/G,EACjB,QACD,KACM6G,GAA8BI,EAAWhH,QAC7CgH,EAAWhH,SAEX,QACD,GAAI6G,EACH,KAAMC,KA4BV,QAAS22B,GAAWxjC,EAAGmjC,EAAYC,EAAQ1+B,GAE1C,GAAIwgC,GAAQ9B,EAAOD,GACflF,EAAKiH,EAAM,GACXhH,EAAKgH,EAAM,GAGXx/B,GAAKw4B,EAAKD,GAAM,EAChBkH,EAAIz/B,EAAIA,EAGR3F,EAAI2E,EAAOoG,OACXd,EAAItF,EAAOC,OAAOw+B,GAAclF,EAChCjrB,EAAKhJ,EAAIjK,EAAIC,EACb+S,EAAK/I,EAAIjK,EAAIC,EAEbolC,GAAY,GACZ3B,KAgBA4B,EAAS77B,KAAK87B,MAAMtyB,EAAKtN,GACzB6/B,EAAO/7B,KAAK87B,MAAMvyB,EAAKrN,GAAK,EAC5B8/B,EAAQD,EAAOF,EAEf1B,EAAQ,MACZ,IAAc,IAAV6B,EAAa,CAEhB7B,EAAQ,EAAIn6B,KAAK87B,MAAMD,EAAS,GAAK,EACrC5B,EAAO18B,KAAK48B,EAEZ,IAAI8B,GAAaxH,EAAKv4B,GAAKi+B,EAAQ,EACnCyB,IAAYK,EAAYA,EAAaN,OAC/B,IAAc,IAAVK,EAAa,CACvB7B,EAAQ0B,EAAS,EACjB5B,EAAO18B,KAAK48B,EAEZ,IAAI+B,GAAczH,EAAKv4B,GAAKi+B,EAAQ,EACpCyB,IAAYM,EAAaA,EAAcP,GAGxC,GAAIzB,IAAa,EACjB,IAAsB,IAAlBD,EAAO7iC,OAAc,CACxB,GAAI+kC,GAAkBxC,EAAa,EAAI,CAEvCO,GAAUiC,GAAmBvC,EAAOuC,GACpCjC,EAAUP,GAAciC,EAGzB,OAAS3B,OAAQA,EAAQC,UAAWA,GAxerC,GAAI19B,GAAS5F,EAAQ,oCACjBy5B,EAAUz5B,EAAQ,iBAClB6/B,EAAiB7/B,EAAQ,0BACzBkY,EAAWlY,EAAQ,8BACnB+F,EAAe/F,EAAQ,4CACvBu0B,EAAMv0B,EAAQ,qBAEd6jC,EAAQ,IACRC,EAAS,GAmebpjC,GAAOJ,QAAUg0B,IAEd5Q,mCAAmC,EAAEvF,2CAA2C,EAAEC,6BAA6B,GAAGsb,oBAAoB,GAAG8L,gBAAgB,GAAGC,yBAAyB,KAAKC,IAAI,SAAS1lC,EAAQU,EAAOJ,GACzN,YAWA,SAASo2B,GAASp0B,EAAKpC,GAItB,QAASg2B,GAAO1oB,EAAS2oB,GACxBj2B,EAAEsN,EAAS2oB,EAGX,KAAK,GAAIl2B,GAAI,EAAGA,EAAIuN,EAAQyoB,SAASz1B,OAAQP,IAAK,CACjD,GAAI2G,GAAO4G,EAAQyoB,SAASh2B,EACxB2G,KAASuvB,GAKbD,EAAOtvB,EAAM4G,EAASvN,IAbxBi2B,EAAO5zB,EAAIm0B,UAAW/zB,OAAWA,QAXf1C,EAAQ,2CA6B3BU,GAAOJ,QAAUo2B,IAEdvY,2CAA2C,IAAIwnB,IAAI,SAAS3lC,EAAQU,EAAOJ,GAC9E,YAeA,SAASslC,GAAOC,EAAOj0B,GACtBzQ,KAAK0kC,MAAQA,EACb1kC,KAAKyQ,MAAQA,EAfd,GAAIiD,GAAO7U,EAAQ,8BAkBnB4lC,GAAOE,gBAAkB,SAAUC,EAAQhmC,EAAGsH,GAC7C,MAAO,IAAIu+B,GAAO/wB,EAAKixB,gBAAgBC,EAAOF,MAAO9lC,EAAGsH,GAAIwN,EAAKixB,gBAAgBC,EAAOn0B,MAAO7R,EAAGsH,KAGnGu+B,EAAOI,OAAS,SAAUD,GACzB,MAAO,IAAIH,IAAQG,EAAOF,MAAM,GAAIE,EAAOF,MAAM,KAAME,EAAOn0B,MAAM,GAAIm0B,EAAOn0B,MAAM,MAGtFg0B,EAAOK,YAAc,SAAUF,GAC9B,MAAOA,GAAOF,MAAM,GAAKE,EAAOn0B,MAAM,IAGvCg0B,EAAOM,cAAgB,SAAUH,GAChC,MAAOA,GAAOF,MAAM,GAAKE,EAAOn0B,MAAM,IAGvCg0B,EAAOr2B,SAAW,SAAUw2B,EAAQtmC,GACnC,MAAOoV,GAAKtF,SAASw2B,EAAOF,OAAOpmC,GAAKoV,EAAKtF,SAASw2B,EAAOn0B,OAAOnS,IAGrEiB,EAAOJ,QAAUslC,IAEdhU,8BAA8B,KAAKuU,IAAI,SAASnmC,EAAQU,EAAOJ,GAClE,YAyBA,SAASgR,GAAgBpR,EAAG8R,EAAUo0B,GAcrC,IAAK,GAbDn8B,GAAQm8B,GAAU,GAElBC,EAAYC,EAAgBr8B,GAC5Bs8B,EAAUF,EAAUE,QACpBC,EAAYH,EAAUG,UAEtBC,EAAYjxB,EAAexD,EAAU,GACrCjS,EAAI0mC,EAAU,GACdp/B,EAAIo/B,EAAU,GAEdj4B,EAAS,EACTk4B,GAAMr/B,EAAItH,GAAK,EACf4mC,GAAMt/B,EAAItH,GAAK,EACVE,EAAI,EAAGA,GAAKgK,EAAQ,EAAGhK,IAC/BuO,GAAU+3B,EAAQtmC,GAAKC,EAAEwmC,EAAKF,EAAUvmC,GAAK0mC,EAG9C,OAAOD,GAAKl4B,EApBb,GAAIgH,GAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAwBllB4vB,GACHj4B,GACCk4B,SAAU,EAAG,GACbC,YAAY,kBAAqB,oBAElC71B,GACC41B,SAAU,kBAAoB,kBAAoB,kBAAoB,mBACtEC,YAAY,kBAAqB,mBAAoB,kBAAqB,oBAE3E5nB,GACC2nB,SAAU,iBAAoB,iBAAoB,kBAAoB,kBAAoB,kBAAoB,kBAAoB,kBAAoB,mBACtJC,YAAY,kBAAqB,mBAAoB,iBAAqB,kBAAoB,kBAAqB,mBAAoB,kBAAqB,oBAG7JxT,IACCwT,YAAY,mBAA0B,mBAA0B,mBAAyB,kBAA2B,mBAA2B,oBAA2B,mBAAyB,mBAA2B,mBAA0B,kBAAwB,mBAA0B,kBAAyB,iBAAyB,kBAA0B,kBAAyB,mBAC/YD,SAAU,oBAA0B,oBAAyB,mBAA0B,mBAA0B,mBAA0B,mBAAyB,mBAAyB,kBAAyB,kBAA0B,mBAAyB,mBAA0B,mBAAyB,mBAAyB,mBAAyB,oBAAyB,sBAIzY7lC,GAAOJ,QAAUgR,OAEXs1B,IAAI,SAAS5mC,EAAQU,EAAOJ,GAClC,YASA,SAASumC,GAAY/iC,EAAGqhB,EAAQnf,GAE/B,GAAI8gC,GAAY,MAEfA,GADG3hB,EAAO,IAAM,GAAKA,EAAO,IAAM,EACtBtQ,EAAKiyB,UAAUhjC,IAEbA,EAAGA,EAAGijC,SAAU,EAyB/B,KAAK,GAtBDC,GAAKF,EAAUhjC,EACfijC,EAAWD,EAAUC,SAIrBE,EAAWpyB,EAAKqyB,iBAAiBF,EAAI7hB,GAAQhY,OAAO,SAAU6E,GACjE,GAAIm1B,GAAan1B,EAAS,GAAKmT,EAAO,IAAMnT,EAAS,GAAKmT,EAAO,EAMjE,OALIgiB,IACCnhC,GACHA,EAAQtE,gBAGFylC,IACN1jC,IAAI,SAAUuO,GAMhB,MAJIhM,IACHA,EAAQrE,kBAGFkT,EAAKsO,MAAMtO,EAAKtF,SAASy3B,GAAKh1B,EAAS,GAAIA,EAAS,GAAI,QAGvD/R,EAAI,EAAGA,EAAI8mC,EAAU9mC,IAC7BgnC,EAAStgC,KAAK,EASf,OAAOsgC,GAhDR,GAAIpyB,GAAO7U,EAAQ,kCACf4lC,EAAS5lC,EAAQ,yBA0DrB6U,GAAKqyB,iBAAmB,SAAUpjC,EAAGqhB,GAEpC,GAAIiiB,GAAoBvyB,EAAKwyB,uBAE7BvjC,EAAG,GAAI8hC,IAAQ,EAAG,IAAK,EAAG,IAAKzgB,GAc3BmiB,KAAeC,OAEnBH,EAEA,OAAOE,IAORzyB,EAAKwyB,uBAAyB,SAAUvjC,EAAGiiC,EAAQ5gB,GAKlD,GACIqiB,GAAiB3yB,EAAK4yB,YAAY3jC,EAGtC,IAAuB,IAAnB0jC,EAEH,QAID,IAAuB,IAAnBA,EAAsB,CACzB,GAAIE,GAAK9B,EAAOK,YAAYF,GACxB4B,EAAK/B,EAAOM,cAAcH,GAC1B6B,EAAMx+B,KAAKiM,IAAIqyB,EAAIC,GACnBE,EAAMz+B,KAAKkM,IAAIoyB,EAAIC,EAKvB,OAJIE,KAAQljC,OAAOC,oBAClBijC,EAAMjC,EAAOr2B,SAASw2B,EAAQlxB,EAAKizB,uBAAuBhkC,OAGlD8jC,EAAKC,IAIf,GAAIE,GAAKlzB,EAAKmzB,uBAAuBlkC,EAOjCikC,GAAK,IAERjkC,EAAI+Q,EAAKixB,gBAAgBhiC,EAAG,EAAGikC,GAG/BhC,EAASH,EAAOE,gBAAgBC,EAAQ,EAAGgC,GAQ5C,IAAIE,GAAMpzB,EAAKixB,gBAAgBjxB,EAAKmxB,OAAOliC,GAAI,EAAG,GAG9CokC,EAAMtC,EAAOE,gBAAgBF,EAAOI,OAAOD,GAAS,EAAG,GAGvDoC,EAAIvC,EAAOr2B,SAASw2B,EAAQ,GAK5BqC,EAAQvzB,EAAKixB,gBAAgBhiC,EAAG,EAAG,GAGnCukC,EAAQzC,EAAOE,gBAAgBC,EAAQ,EAAG,GAG1CuC,EAAazzB,EAAKwyB,uBAAuBY,EAAKC,EAAK/iB,GACnDojB,EAAa1zB,EAAKwyB,uBAAuBe,EAAOC,EAAOljB,EAM3D,OAJ4B,KAAxBtQ,EAAKtF,SAASzL,GAAG,IACpBwkC,EAAW3hC,MAAMwhC,EAAGA,OAGXZ,OAAOe,EAAYC,IAG9B7nC,EAAOJ,QAAUumC,IAEd2B,yBAAyB,GAAGhxB,iCAAiC,KAAKixB,IAAI,SAASzoC,EAAQU,EAAOJ,GACjG,YAaA,SAASqwB,GAAiBrE,GAGzB,QAASoc,GAAS5a,GACjB,MAAIA,GAAI,GACC1kB,KAAK8J,KAAK4a,EAAG,EAAI,GAEnB1kB,KAAK8J,IAAI4a,EAAG,EAAI,GAGxB,QAAS6a,GAAa3qB,GACrB,MAAOA,IAAQ,GAAKA,GAAQ,EAG7B,GAYI4qB,GAAIC,EAAIC,EAAOC,EAAOC,EAZtB7gC,EAAImkB,EAAK,GACTvsB,EAAIusB,EAAK,GAAKnkB,EACdd,EAAIilB,EAAK,GAAKnkB,EACdsC,EAAI6hB,EAAK,GAAKnkB,EAEdrE,GAAK,EAAIuD,EAAItH,EAAIA,GAAK,EACtBkpC,EAAKnlC,EAAI,EACTwB,GAAK,EAAIvF,EAAIA,EAAIA,EAAI,EAAIA,EAAIsH,EAAI,GAAKoD,GAAK,GAC3C+kB,EAAKlqB,EAAI,EACT2iB,EAAeuH,EAAKA,EAAKyZ,EAAKA,EAAKA,CAMvC,IAAIhhB,EAAe,EAAG,CACrB,GAAIihB,IAAOplC,EAAI,EACXqlC,EAAOD,EAAMA,EAAMA,EACnBvpC,EAAIyJ,KAAK+H,KAAKg4B,GACd1pC,GAAK6F,GAAK,EAAI3F,GACdypC,EAAS3pC,GAAI,GAAK,EAAKA,EAAI,EAAI,EAAIA,EACnC4pC,EAAMjgC,KAAKyP,KAAKuwB,GAChBE,EAAOZ,EAAS/oC,GAChBuoB,EAAK,EAAIohB,CAIb,OAHAR,GAAQ5gB,EAAK9e,KAAKmgC,IAAIF,EAAM,GAAKtpC,EAAI,EACrCgpC,EAAQ7gB,EAAK9e,KAAKmgC,KAAKF,EAAM,EAAIjgC,KAAK0P,IAAM,GAAK/Y,EAAI,EACrDipC,EAAQ9gB,EAAK9e,KAAKmgC,KAAKF,EAAM,EAAIjgC,KAAK0P,IAAM,GAAK/Y,EAAI,GAC7C+oC,EAAOC,EAAOC,GAAO77B,OAAOw7B,GAC9B,GAAqB,IAAjB1gB,EAKV,MAHA2gB,GAAKpZ,EAAK,EAAIkZ,GAAUlZ,IAAOkZ,EAASlZ,GACxCsZ,EAAQ,EAAIF,EAAK7oC,EAAI,EACrBgpC,GAASH,EAAK7oC,EAAI,GACV+oC,EAAOC,GAAO57B,OAAOw7B,EAG7B,IAAIa,GAAKpgC,KAAK+H,KAAK8W,EAInB,OAHA2gB,GAAKF,EAASc,EAAKha,GACnBqZ,EAAKH,EAASc,EAAKha,GACnBsZ,EAAQF,EAAKC,EAAK9oC,EAAI,GACd+oC,GAAO37B,OAAOw7B,GAIxBjoC,EAAOJ,QAAUqwB,OAEX8Y,IAAI,SAASzpC,EAAQU,EAAOJ,GAClC,YAMA,SAASopC,GAAgBC,EAAK/lC,EAAK2B,GAAiK,MAApJ3B,KAAO+lC,GAAOlzB,OAAOmzB,eAAeD,EAAK/lC,GAAO2B,MAAOA,EAAOskC,YAAY,EAAMC,cAAc,EAAMC,UAAU,IAAkBJ,EAAI/lC,GAAO2B,EAAgBokC,EA4B3M,QAAS9zB,GAAc/R,GAKtB,IAAK,GAHD0K,MAEArG,EAAIrE,EAAEtD,OAAS,EACVP,EAAIkI,EAAS,IAANlI,EAASA,IAAK,CAC7B,GAAI+pC,GAAQlmC,EAAEqE,EAAIlI,GAAKA,CACnBA,KAAMkI,GAAe,IAAV6hC,GAIfx7B,EAAO7H,KAAKqjC,GAGb,MAAOx7B,GAMR,QAASy7B,GAAgBx/B,EAAG3G,GAC3B,GAAU,IAAN2G,EACH,QAKD,KAAK,GAFDtC,GAAIrE,EAAEtD,OAAS,EACfgO,KACKvO,EAAIkI,EAAGlI,GAAK,EAAGA,IACvBuO,EAAO7H,KAAK8D,EAAI3G,EAAEqE,EAAIlI,GAEvB,OAAOuO,GAGR,QAAS07B,GAAO5d,GACf,MAAOzX,GAAKo1B,iBAAgB,EAAI3d,GAOjC,QAAS6d,GAAMC,EAAOC,GAKrB,IAAK,GAJDhlB,GAAK+kB,EAAM5pC,OAAS,EACpB8kB,EAAK+kB,EAAM7pC,OAAS,EACpBinB,EAAKre,KAAKkM,IAAI+P,EAAIC,GAClB9W,KACKvO,EAAI,EAAGA,EAAIwnB,EAAK,EAAGxnB,IAC3BuO,EAAO7H,KAAK;AAGb,IAAK,GAAI1G,GAAIwnB,EAAIxnB,GAAK,EAAGA,IAAK,CAC7B,GAAI4oC,GAAKuB,EAAM3iB,EAAKxnB,GAChBqqC,EAAKD,EAAM5iB,EAAKxnB,EACpBuO,GAAOiZ,EAAKxnB,IAAM4oC,EAAKA,EAAK,IAAMyB,EAAKA,EAAK,GAG7C,MAAO97B,GAUR,QAAS+7B,GAASH,EAAOC,GAKxB,IAAK,GAJDhlB,GAAK+kB,EAAM5pC,OAAS,EACpB8kB,EAAK+kB,EAAM7pC,OAAS,EACpBinB,EAAKpC,EAAKC,EACV9W,KACKvO,EAAI,EAAGA,EAAIwnB,EAAK,EAAGxnB,IAC3BuO,EAAO7H,KAAK,EAGb,KAAK,GAAI1G,GAAIolB,EAAIplB,GAAK,EAAGA,IACxB,IAAK,GAAIkM,GAAImZ,EAAInZ,GAAK,EAAGA,IACxBqC,EAAOiZ,GAAMxnB,EAAIkM,KAAOi+B,EAAM/kB,EAAKplB,GAAKoqC,EAAM/kB,EAAKnZ,EAGrD,OAAOqC,GAKR,QAASg8B,GAAO1mC,GACf,MAAOA,GAAEtD,OAAS,EAOnB,QAAS+O,GAASzL,GACjB,MAAO,UAAUrE,GAEhB,IAAK,GADDgrC,GAAK3mC,EAAE,GACF7D,EAAI,EAAGA,EAAI6D,EAAEtD,OAAQP,IAC7BwqC,EAAK3mC,EAAE7D,GAAKwqC,EAAKhrC,CAGlB,OAAOgrC,IAQT,QAASxE,GAAYniC,GACpB,MAAOA,GAAEA,EAAEtD,OAAS,GAOrB,QAASinC,GAAY3jC,GAMpB,IAAK,GAJD0K,GAAS,EAETrG,EAAIrE,EAAEtD,OAAS,EACfkqC,EAAU,EACLzqC,EAAIkI,EAAGlI,GAAK,EAAGA,IAAK,CAC5B,GAAI0qC,GAAUvhC,KAAKwhC,KAAK9mC,EAAEqE,EAAIlI,GACd,KAAZ0qC,IACY,IAAZD,GAAiBA,IAAYC,GAChCn8B,IAEDk8B,EAAUC,GAGX,MAAOn8B,GAQR,QAASq8B,GAAU3lB,EAAIE,GAMtB,IAAK,GAHDC,GAAKH,EAAG1kB,OAAS,EACjB8kB,EAAKF,EAAG5kB,OAAS,EACjB2H,EAAIkd,EAAKC,EACJrlB,EAAI,EAAGA,EAAIkI,EAAI,EAAGlI,IAC1BmlB,EAAG0lB,QAAQ,EAEZxlB,GAAKD,EAAK,CAEV,IAAI0lB,GAAO7lB,EAAG,GAAKA,EAAG,GAAKE,EAAG,GAAKA,EAAG,GAClC4lB,EAAO9lB,EACP+lB,EAAOp2B,EAAKo1B,gBAAgB/kB,EAAG,GAAKE,EAAG,GAAIA,GAC3C8lB,EAAOr2B,EAAK01B,SAASU,GAAO,EAAGF,IAC/BI,EAAOt2B,EAAKs1B,MAAMe,EAAMF,EAE5B,OAAOG,GAAKlwB,MAAM,GAGnB,QAASuR,GAAQF,EAAMtO,GAMtB,IAAK,GADDotB,IADI9e,EAAK9rB,OAAS,GACZ8rB,EAAK,KACNrsB,EAAI,EAAGA,EAAIqsB,EAAK9rB,OAAS,EAAGP,IACpCmrC,EAAGzkC,KAAK2lB,EAAKrsB,GAAK+d,EAAOotB,EAAGnrC,EAAI,GAIjC,OAAOmrC,GAMR,QAASC,GAAWvnC,GACnB,GAAIqkC,KACJA,GAAExhC,KAAK7C,GACPqkC,EAAExhC,KAAKkO,EAAKgB,cAAc/R,GAI1B,KAFA,GAAI7D,GAAI,EAED4U,EAAK21B,OAAOrC,EAAEloC,IAAM,GAC1BkoC,EAAExhC,KAAKkO,EAAKg2B,UAAU1C,EAAEloC,EAAI,GAAIkoC,EAAEloC,KAClCA,GAGD,OAAOkoC,GAOR,QAASzW,GAAY5tB,EAAG/D,EAAGsH,GAE1B,GAAIgkC,GAAax2B,EAAKw2B,WAAWvnC,GAC7BwnC,EAAKD,EAAW5nC,IAAI,SAAUK,GACjC,MAAO+Q,GAAKtF,SAASzL,GAAG/D,KAErBqrC,EAAKC,EAAW5nC,IAAI,SAAUK,GACjC,MAAO+Q,GAAKtF,SAASzL,GAAGuD,IAGzB,OAAOwN,GAAK4yB,YAAY6D,GAAMz2B,EAAK4yB,YAAY2D,GAQhD,QAASG,GAAOznC,EAAG0nC,GAGlB,IAAK,GAFDC,GAAK52B,EAAKgB,cAAc/R,GACxB4nC,EAAMF,EACDvrC,EAAI,EAAGA,GAAK,GAAIA,IACxByrC,GAAO72B,EAAKtF,SAASzL,GAAG4nC,GAAO72B,EAAKtF,SAASk8B,GAAIC,EAGlD,OAAOA,GASR,QAAS5D,GAAuBhkC,GAC/B,GAAI6nC,GAAM7nC,EAAEtD,OAAS,CACrB,IAAImrC,EAAM,EACT,MAAO,EAGJ7nC,GAAE,GAAK,IACVA,EAAI+Q,EAAKq1B,OAAOpmC,GAIjB,KAAK,GADD8nC,MACK3rC,EAAI,EAAGA,EAAI0rC,EAAK1rC,IACxB2rC,EAAUjlC,KAAK,EAKhB,KAAK,GAFDklC,GAAK,EAEA1D,EAAI,EAAGA,GAAKwD,EAAKxD,IACzB,KAAIrkC,EAAEqkC,IAAM,GAAZ,CAKA,IAAK,GAHD2D,GAASnnC,OAAOC,kBAChBmnC,GAAM,EAEDtpB,EAAI,EAAGA,EAAI0lB,EAAG1lB,IACtB,KAAI3e,EAAE2e,IAAM,GAAZ,CAKA,GAAIupB,GAAO5iC,KAAK8J,KAAKpP,EAAEqkC,IAAMrkC,EAAE2e,GAAKrZ,KAAK8J,IAAI,EAAG04B,EAAUnpB,KAAM,GAAK0lB,EAAI1lB,GAEzEmpB,GAAUnpB,KAENqpB,EAASE,IACZF,EAASE,GAGVD,GAAM,EAGHA,GAAOF,EAAKC,IAAQD,EAAKC,GAG9B,MAAOD,GAMR,QAAS7F,GAAOliC,GAIf,IAAK,GAHDk7B,GAAMl7B,EAAEtD,OACRy9B,KAEKh+B,EAAI++B,EAAM,EAAG/+B,GAAK,EAAGA,IAC7Bg+B,EAAKt3B,KAAK7C,EAAE7D,GAGb,OAAOg+B,GAWR,QAAS6H,GAAgBhiC,EAAG/D,EAAGsH,GAO9B,IAAK,GANDskC,GAAM7nC,EAAEtD,OAAS,EAEjB2H,EAAI,GAAIT,OAAMikC,EAAM,GAAGM,KAAK,GAG5BxsC,KACKQ,EAAI,EAAGA,EAAI0rC,EAAM,EAAG1rC,IAC5BR,EAAEkH,KAAK,GAAIe,OAAMikC,EAAM,GAAGM,KAAK,GAShCxsC,GAAE,GAAG,GAAK,CACV,KAAK,GAAI0M,GAAI,EAAGA,GAAKw/B,EAAKx/B,IAAK,CAC9B1M,EAAE,GAAG0M,GAAK9E,EAAI5H,EAAE,GAAG0M,EAAI,EACvB,KAAK,GAAIoK,GAAK,EAAGA,GAAMpK,EAAGoK,IACzB9W,EAAE8W,GAAIpK,GAAK9E,EAAI5H,EAAE8W,GAAIpK,EAAI,GAAKpM,EAAIN,EAAE8W,EAAK,GAAGpK,EAAI,GAKlD,IAAK,GAAIwrB,GAAM,EAAGA,GAAOgU,EAAKhU,IAAO,CACpCxvB,EAAEwjC,EAAMhU,GAAO,CACf,KAAK,GAAIuU,GAAKvU,EAAKuU,GAAMP,EAAKO,IAAM,CACnC,GAAIC,GAAM1sC,EAAEk4B,GAAKuU,GAAMpoC,EAAE6nC,EAAMO,EAC/B/jC,GAAEwjC,EAAMhU,IAAQwU,GAIlB,MAAOhkC,GAGR,QAAS6/B,GAAuBlkC,GAC/B,MAAO,GAAI+Q,EAAKizB,uBAAuBjzB,EAAKmxB,OAAOliC,IAQpD,QAASgjC,GAAUhjC,GAGlB,IAFA,GAAIkjC,GAAKljC,EAAEmX,QACPhb,EAAI,EACwB,IAAzB4U,EAAKoxB,YAAYe,IAAW,CAClC,GAAIhI,GAAMgI,EAAGxmC,MACbwmC,GAAG9pB,OAAO8hB,EAAM,EAAG,GACnB/+B,IAED,OACC6D,EAAGkjC,EACHD,SAAU9mC,GAQZ,QAASysB,GAAWJ,GAEnB,GAAIqf,GAAMrf,EAAK9rB,OAAS,CAExB,IAAY,IAARmrC,EACH,MAAO92B,GAAKC,qBAAqBwX,EAC3B,IAAY,IAARqf,EACV,MAAO92B,GAAK8b,iBAAiBrE,GAAMllB,KAAK,SAAUrH,EAAGsH,GACpD,MAAOtH,GAAIsH,GAIb,IAAI+kC,GAAOv3B,EAAKgB,cAAcyW,GAC1B1X,EAAQ8X,EAAW0f,EAQvB,OAPiB,KAAbx3B,EAAM,IACTA,EAAMk2B,QAAQ,GAEiB,IAA5Bl2B,EAAMA,EAAMpU,OAAS,IACxBoU,EAAMjO,KAAK,GAGL+qB,EAAYpF,EAAM1X,GAG1B,QAAS8c,GAAYpF,EAAMgb,GAa1B,IAAK,GATDtI,GAAMsI,EAAU9mC,OAKhBoU,KAEA4c,EAAQ3c,EAAKtF,SAAS+c,GAEjBrsB,EAAI,EAAGA,EAAI++B,EAAM,EAAG/+B,IAAK,CACjC,GAAIF,GAAIunC,EAAUrnC,GACdoH,EAAIigC,EAAUrnC,EAAI,GAMlBosC,EAAM7a,EAAMzxB,GACZusC,EAAM9a,EAAMnqB,EAEhB,IAAY,IAARglC,GAAqB,IAARC,EAQhB,MAPY,KAARD,GACHz3B,EAAMjO,KAAK5G,GAEA,IAARusC,GACH13B,EAAMjO,KAAKU,GAGLuN,CAGR,IAAI23B,GAAMF,EAAMC,CAChB,IAAIC,EAAM,EAAG,CACZ,GAAIvuB,GAAOnJ,EAAKsO,MAAMqO,EAAOzxB,EAAGsH,EAGhCuN,GAAMjO,KAAKqX,IAIb,MAAOpJ,GAMR,QAASE,GAAqBuH,GAC7B,GAKIysB,GACAC,EANAzsB,EAAQ9G,EAAe6G,EAAM,GAC7Btc,EAAIuc,EAAM,GACVjV,EAAIiV,EAAM,GACV7R,EAAI6R,EAAM,GAIV9Y,EAAQ6D,EAAIA,EAAI,EAAItH,EAAI0K,CAC5B,IAAIjH,EAAQ,EAEX,QAED,IAAc,IAAVA,EAEH,MADAslC,IAASzhC,GAAK,EAAItH,GACd+oC,GAAS,GAAKA,GAAS,GAClBA,KAKVtlC,GAAQ4F,KAAK+H,KAAK3N,GACd6D,GAAK,GACRyhC,IAAUzhC,EAAI7D,IAAU,EAAIzD,GAC5BgpC,EAAQ,EAAIt+B,IAAMpD,EAAI7D,KAEtBslC,EAAQ,EAAIr+B,IAAMpD,EAAI7D,GACtBulC,IAAU1hC,EAAI7D,IAAU,EAAIzD,GAG7B,IAAIysC,GAAe1D,GAAS,GAAKA,GAAS,EACtC2D,EAAe1D,GAAS,GAAKA,GAAS,CAC1C,OAAIyD,GACCC,EACC3D,EAAQC,GACHD,EAAOC,IAERA,EAAOD,IAERA,GAEL2D,GACK1D,MAyBV,QAAS5lB,GAAMjjB,EAAGH,EAAGsH,EAAGqlC,GAIvB,GAFAC,IAEI5sC,IAAMsH,EACT,MAAOtH,EAGR,IAAI6sC,GAAK1sC,EAAEH,GACP8sC,EAAK3sC,EAAEmH,EAEX,IAAIulC,EAAKC,GAAM,EAEd,KAAM,oBAGP,IAAIpiC,GAAI,MACJrB,MAAK8I,IAAI06B,GAAMxjC,KAAK8I,IAAI26B,KAE3BpiC,EAAI1K,EAAEA,EAAIsH,EAAEA,EAAIoD,GAGjBA,EAAI1K,CAMJ,KAJA,GAAI+sC,IAAQ,EACR7sC,EAAI,EAEJ8sC,EAAY,SACH,CACZ9sC,GAEA,IAAI+sC,GAAK9sC,EAAEuK,GACP7K,EAAI,MAKR,IAHAgtC,EAAK1sC,EAAEH,GACP8sC,EAAK3sC,EAAEmH,GAEHulC,IAAOI,GAAMH,IAAOG,EAAI,CAE3B,GAAIC,GAAML,EAAKI,EACXE,EAAMN,EAAKC,EACXM,EAAMN,EAAKG,CAMfptC,KAAMG,EAAI8sC,EAAKM,EAAM9lC,EAAIulC,EAAKK,GAAOD,EAAKviC,EAAImiC,EAAKM,EAAML,IAAOK,EAAMD,EAAME,OAG5EvtC,GAAIyH,EAAIwlC,IAAOxlC,EAAItH,IAAM8sC,EAAKD,GAG/B,IAAI1kB,IAAM,EAAInoB,EAAIsH,GAAK,EACnB+lC,EAAMhkC,KAAK8I,IAAI7K,EAAIoD,GACnB4iC,EAAMjkC,KAAK8I,IAAItS,EAAIyH,GACnBimC,EAAMlkC,KAAK8I,IAAIzH,EAAItC,KAKvBvI,EAAIsoB,GAAMtoB,EAAIyH,GAAKzH,EAAIsoB,GAAMtoB,EAAIyH,IACjCylC,IAAUO,GAAOD,EAAM,GACfA,EAAMV,KACRI,IAAUO,GAAOC,EAAM,GACrBA,EAAMZ,IAGb9sC,GAAKG,EAAIsH,GAAK,EACdylC,GAAQ,GAERA,GAAQ,CAGT,IAAInqC,GAAKzC,EAAEN,GAEPuI,EAAIsC,CASR,IARAA,EAAIpD,EAEAulC,EAAKjqC,EAAK,EACb0E,EAAIzH,EAEJG,EAAIH,EAGDwJ,KAAK8I,IAAI06B,GAAMxjC,KAAK8I,IAAI26B,GAAK,CAEhC,GAAI31B,GAAKnX,CAAEA,GAAIsH,EAAEA,EAAI6P,EAGtB,GAAW,IAAP21B,EAEH,MAAOxlC,EACD,IAAW,IAAP1E,EACV,MAAO/C,EAGR,IAAI2tC,GAAQnkC,KAAK8I,IAAInS,EAAIsH,EACzB,IAAIkmC,EAAQxtC,EAAIwtC,EAAQlmC,EAAI00B,GAAuB,IAAVwR,GAAeR,GAAaQ,EACpE,MAAOlmC,EAER0lC,GAAYQ,GA3nBd,GAEIC,GAFAh4B,EAAiB,WAAc,QAASS,GAAcC,EAAKjW,GAAK,GAAIkW,MAAeC,GAAK,EAAU5Q,GAAK,EAAW6Q,EAAK3T,MAAW,KAAM,IAAK,GAAiC4T,GAA7BC,EAAKL,EAAI/Q,OAAOC,cAAmBgR,GAAME,EAAKC,EAAGrT,QAAQmC,QAAoB8Q,EAAKxP,KAAK2P,EAAG/Q,QAAYtF,GAAKkW,EAAK3V,SAAWP,GAA3DmW,GAAK,IAAoE,MAAO1Q,GAAOF,GAAK,EAAM6Q,EAAK3Q,EAAO,QAAU,KAAW0Q,GAAMG,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAI/Q,EAAI,KAAM6Q,IAAQ,MAAOF,GAAQ,MAAO,UAAUD,EAAKjW,GAAK,GAAIyH,MAAM8O,QAAQN,GAAQ,MAAOA,EAAY,IAAI/Q,OAAOC,WAAYqR,QAAOP,GAAQ,MAAOD,GAAcC,EAAKjW,EAAa,MAAM,IAAIyW,WAAU,4DAMllBia,EAAmB3wB,EAAQ,mCAU3B6U,GATO7U,EAAQ,eASPwtC,GAEX14B,qBAAsBA,EACtB6b,iBAAkBA,EAClBxN,MAAOA,EACP6kB,uBAAwBA,EACxBF,uBAAwBA,EACxBhB,UAAWA,EACXpV,YAAaA,EACbhF,WAAYA,EACZ6e,OAAQA,GACN7B,EAAgB8D,EAAO,cAAe9b,GAAcgY,EAAgB8D,EAAO,kBAAmBvD,GAAkBP,EAAgB8D,EAAO,SAAUtD,GAASR,EAAgB8D,EAAO,QAASrD,GAAQT,EAAgB8D,EAAO,WAAYjD,GAAWb,EAAgB8D,EAAO,gBAAiB33B,GAAgB6zB,EAAgB8D,EAAO,aAAcnC,GAAa3B,EAAgB8D,EAAO,SAAUhD,GAASd,EAAgB8D,EAAO,WAAYj+B,GAAWm6B,EAAgB8D,EAAO,cAAevH,GAAcyD,EAAgB8D,EAAO,cAAe/F,GAAciC,EAAgB8D,EAAO,SAAUxH,GAAS0D,EAAgB8D,EAAO,kBAAmB1H,GAAkB4D,EAAgB8D,EAAO,UAAWhhB,GAAUkd,EAAgB8D,EAAO,YAAa3C,GAAY2C,GAyf3tBb,EAAM,EACN5Q,EAAY,KA+GhBr7B,GAAOJ,QAAUuU,IAIdgd,cAAc,GAAG4b,kCAAkC,KAAKC,IAAI,SAAS1tC,EAAQU,EAAOJ,GACvF,YAeA,SAASqtC,KAEDC,eAAexnC,UAAUynC,aAAgBD,eAAexnC,UAAU0nC,aAEpEC,IAIN,QAASA,KAEN,GAAIC,IACDC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAKC,EAAG,IAAK7R,EAAG,IAAK8R,EAAG,IAAKC,EAAG,IAC3E5hC,EAAG,IAAKs7B,EAAG,IAAK9nC,EAAG,IAAKoK,EAAG,IAAKnF,EAAG,IAAKvF,EAAG,IAAKkT,EAAG,IAAK6a,EAAG,IAAKluB,EAAG,IAAKH,EAAG,KAG1EivC,EAAS,SAAgBC,GAC1BxtC,KAAKytC,QAAUD,EACfxtC,KAAK0tC,cAAgB,EACrB1tC,KAAK2tC,UAAY3tC,KAAKytC,QAAQpuC,OAC9BW,KAAK4tC,aAAe,KACpB5tC,KAAK6tC,uBAGJC,EAAOxa,OAAOya,UAAUC,UAAUtK,QAAQ,YAAa,CAE3D6J,GAAOtoC,WACJgpC,aAAc,WACX,GAAIC,GAAOluC,KAAKytC,QAAQztC,KAAK0tC,eACzBS,EAAUtB,EAAYqB,GAAQrB,EAAYqB,GAAQ,IAEtD,IAAgB,OAAZC,EAAkB,CAEnB,GAA0B,OAAtBnuC,KAAK4tC,aACN,MAAO,KAgBV,IAVMO,GAHQ,MAATD,GAAyB,MAATA,GAAyB,MAATA,GAAgBA,GAAQ,KAAOA,GAAQ,MAA8B,MAAtBluC,KAAK4tC,aAE5D,MAAtB5tC,KAAK4tC,aACI,IACoB,MAAtB5tC,KAAK4tC,aACH,IAEA5tC,KAAK4tC,aAGR,KAGG,OAAZO,EACD,MAAO,UAGVnuC,MAAK0tC,eAGR1tC,MAAK4tC,aAAeO,CAEpB,IAAIC,GAAS,KACTC,EAAMF,EAAQG,aAiBlB,OAfY,MAARD,GAAuB,MAARA,EAChBD,GAAUpuC,KAAKuuC,gBACC,MAARF,GAAuB,MAARA,GAAuB,MAARA,EACtCD,GAAUpuC,KAAKuuC,eAAgBvuC,KAAKuuC,gBACpB,MAARF,GAAuB,MAARA,EACvBD,GAAUpuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,gBAC9D,MAARF,EACRD,GAAUpuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,gBACxG,MAARF,EACRD,GAAUpuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKuuC,eAAgBvuC,KAAKwuC,gBAAiBxuC,KAAKwuC,gBAAiBxuC,KAAKuuC,eAAgBvuC,KAAKuuC,gBAC/H,MAARF,IACRruC,KAAK6tC,sBACLO,MAGY,OAAXA,GAAmBA,EAAO1K,QAAQ,OAAS,EAErC,MAEEr+B,KAAM8oC,EAASC,OAAQA,IAItCK,YAAa,WACV,MAAOzuC,MAAK0tC,cAAgB1tC,KAAK2tC,WAGpCe,gBAAiB,WACd,GAAIR,GAAOluC,KAAKytC,QAAQztC,KAAK0tC,cAC7B,OAAOb,GAAYqB,GAAQrB,EAAYqB,GAAQ,MAGlDS,uBAAwB,WAErB,IAAK3uC,KAAKyuC,cACP,OAAO,CAGV,IAAIN,GAAUnuC,KAAK0uC,iBAEnB,OAAmB,MAAZP,GAA+B,MAAZA,GAG7BS,gBAAiB,WACd,GAAIV,GAAOluC,KAAKytC,QAAQztC,KAAK0tC,cAC7B,OAAOQ,IAAQ,MAAiB,MAATA,GAAyB,OAATA,GAA0B,OAATA,GAA0B,OAATA,GAA0B,OAATA,IAG7FL,oBAAqB,WAClB,KAAO7tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAa3tC,KAAK4uC,mBAChD5uC,KAAK0tC,eAAiB,CAGzB,OAAO1tC,MAAK0tC,cAAgB1tC,KAAK2tC,WAGpCkB,+BAAgC,WAC7B,QAAI7uC,KAAK0tC,cAAgB1tC,KAAK2tC,YAAc3tC,KAAK4uC,mBAA0D,MAArC5uC,KAAKytC,QAAQztC,KAAK0tC,kBAIpF1tC,KAAK6tC,uBACF7tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAkD,MAArC3tC,KAAKytC,QAAQztC,KAAK0tC,iBAC1D1tC,KAAK0tC,eAAiB,EACtB1tC,KAAK6tC,uBAGJ7tC,KAAK0tC,cAAgB1tC,KAAK2tC,YAMpCY,aAAc,WACX,GAAIO,GAAW,EACXC,EAAU,EACVC,EAAO,EACPC,EAAU,EACVxF,EAAO,EACPyF,EAAU,EACVC,EAAanvC,KAAK0tC,aAYtB,IAVA1tC,KAAK6tC,sBAGD7tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAkD,MAArC3tC,KAAKytC,QAAQztC,KAAK0tC,eAC1D1tC,KAAK0tC,eAAiB,EACd1tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAkD,MAArC3tC,KAAKytC,QAAQztC,KAAK0tC,iBACjE1tC,KAAK0tC,eAAiB,EACtBjE,GAAO,GAGNzpC,KAAK0tC,gBAAkB1tC,KAAK2tC,YAAc3tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,MAA6C,MAArC1tC,KAAKytC,QAAQztC,KAAK0tC,eAElJ,MAAO,KAMV,KAFA,GAAI0B,GAAoBpvC,KAAK0tC,cAEtB1tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAa3tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAC1H1tC,KAAK0tC,eAAiB,CAGzB,IAAI1tC,KAAK0tC,gBAAkB0B,EAIxB,IAHA,GAAIC,GAAmBrvC,KAAK0tC,cAAgB,EACxC4B,EAAa,EAEVD,GAAoBD,GACxBL,GAAWO,GAActvC,KAAKytC,QAAQ4B,GAAoB,KAC1DA,GAAoB,EACpBC,GAAc,EAKpB,IAAItvC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAkD,MAArC3tC,KAAKytC,QAAQztC,KAAK0tC,eAAwB,CAIlF,GAHA1tC,KAAK0tC,eAAiB,EAGlB1tC,KAAK0tC,eAAiB1tC,KAAK2tC,WAAa3tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,IACtH,MAAO,KAGV,MAAO1tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAa3tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAC1HuB,IAAYjvC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,MAAQsB,GAAQ,IAC/DhvC,KAAK0tC,eAAiB,EAK5B,GAAI1tC,KAAK0tC,gBAAkByB,GAAcnvC,KAAK0tC,cAAgB,EAAI1tC,KAAK2tC,YAAmD,MAArC3tC,KAAKytC,QAAQztC,KAAK0tC,gBAA+D,MAArC1tC,KAAKytC,QAAQztC,KAAK0tC,iBAAoE,MAAzC1tC,KAAKytC,QAAQztC,KAAK0tC,cAAgB,IAAuD,MAAzC1tC,KAAKytC,QAAQztC,KAAK0tC,cAAgB,GAAY,CAYzQ,GAXA1tC,KAAK0tC,eAAiB,EAGmB,MAArC1tC,KAAKytC,QAAQztC,KAAK0tC,eACnB1tC,KAAK0tC,eAAiB,EACuB,MAArC1tC,KAAKytC,QAAQztC,KAAK0tC,iBAC1B1tC,KAAK0tC,eAAiB,EACtBwB,GAAU,GAITlvC,KAAK0tC,eAAiB1tC,KAAK2tC,WAAa3tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,IACtH,MAAO,KAGV,MAAO1tC,KAAK0tC,cAAgB1tC,KAAK2tC,WAAa3tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAAO1tC,KAAKytC,QAAQztC,KAAK0tC,gBAAkB,KAC1HoB,GAAY,GACZA,GAAY9uC,KAAKytC,QAAQztC,KAAK0tC,eAAiB,IAC/C1tC,KAAK0tC,eAAiB,EAI5B,GAAI6B,GAASR,EAAUE,CAOvB,OANAM,IAAU9F,EAENqF,IACDS,GAAUtnC,KAAK8J,IAAI,GAAIm9B,EAAUJ,IAGhCK,IAAenvC,KAAK0tC,cACd,MAGV1tC,KAAK6uC,iCAEEU,IAGVf,cAAe,WACZ,GAAIxuC,KAAK0tC,eAAiB1tC,KAAK2tC,UAC5B,MAAO,KAGV,IAAI6B,GAAO,KACPC,EAAWzvC,KAAKytC,QAAQztC,KAAK0tC,cAIjC,IAFA1tC,KAAK0tC,eAAiB,EAEL,MAAb+B,EACDD,EAAO,MACH,CAAA,GAAiB,MAAbC,EAGR,MAAO,KAFPD,GAAO,EAMV,MADAxvC,MAAK6uC,iCACEW,GAIb,IAuBIE,GAvBAC,EAAsB,SAA6BnC,GACpD,IAAKA,GAA4B,IAAlBA,EAAOnuC,OAAc,QAEpC,IAAIuwC,GAAS,GAAIrC,GAAOC,GACpBqC,IAEJ,IAAID,EAAOjB,yBACR,KAAOiB,EAAOnB,eAAe,CAC1B,GAAIqB,GAAUF,EAAO3B,cAErB,IAAgB,OAAZ6B,EACD,KAEAD,GAASrqC,KAAKsqC,GAKvB,MAAOD,IAGNE,EAAetD,eAAexnC,UAAU8qC,aACxCC,EAAkBvD,eAAexnC,UAAU+qC,eAI5CN,GADCpc,OAAOtvB,QACIisC,eAAgBjsC,SAAUksC,yBAA0BlsC,WAEpDisC,eAAgB,mBAAoBC,yBAA0B,6BAK7E,IAAIC,GAAmB,QAASA,GAAiB3+B,EAAIG,EAAIJ,EAAIG,EAAI0+B,EAAIC,EAAIC,EAAOC,EAAcC,EAAWC,GACtG,GAYIC,GAAIC,EAAIjqB,EAAIC,EAZZiqB,EAAW,SAAkBC,GAC9B,MAAO5oC,MAAK0P,GAAKk5B,EAAU,KAG1B9qB,EAAS,SAAgBtd,EAAGD,EAAGsoC,GAChC,GAAIC,GAAItoC,EAAIR,KAAKmgC,IAAI0I,GAAYtoC,EAAIP,KAAK+oC,IAAIF,GAC1CG,EAAIxoC,EAAIR,KAAK+oC,IAAIF,GAAYtoC,EAAIP,KAAKmgC,IAAI0I,EAC9C,QAASroC,EAAGsoC,EAAGvoC,EAAGyoC,IAGjBH,EAAWF,EAASN,GACpBY,IAGJ,IAAIT,EACDC,EAAKD,EAAW,GAChBE,EAAKF,EAAW,GAChB/pB,EAAK+pB,EAAW,GAChB9pB,EAAK8pB,EAAW,OACZ,CACJ,GAAI1sB,GAAKgC,EAAOvU,EAAIG,GAAKm/B,EACzBt/B,GAAKuS,EAAGtb,EACRkJ,EAAKoS,EAAGvb,CAER,IAAIyb,GAAK8B,EAAOxU,EAAIG,GAAKo/B,EACzBv/B,GAAK0S,EAAGxb,EACRiJ,EAAKuS,EAAGzb,CAER,IAAIC,IAAK+I,EAAKD,GAAM,EAChB/I,GAAKmJ,EAAKD,GAAM,EAChBI,EAAIrJ,EAAIA,GAAK2nC,EAAKA,GAAM5nC,EAAIA,GAAK6nC,EAAKA,EAEtCv+B,GAAI,IACLA,EAAI7J,KAAK+H,KAAK8B,GACds+B,EAAKt+B,EAAIs+B,EACTC,EAAKv+B,EAAIu+B,EAGZ,IAAI5G,EAGDA,GADC8G,IAAiBC,GACX,EAEA,CAGV,IAAIW,GAAQf,EAAKA,EACbgB,EAAQf,EAAKA,EAEbgB,EAAOF,EAAQC,EAAQD,EAAQ3oC,EAAIA,EAAI4oC,EAAQ3oC,EAAIA,EACnD6oC,EAAQH,EAAQ3oC,EAAIA,EAAI4oC,EAAQ3oC,EAAIA,EAEpC6Y,EAAImoB,EAAOxhC,KAAK+H,KAAK/H,KAAK8I,IAAIsgC,EAAOC,GAEzC5qB,GAAKpF,EAAI8uB,EAAK5nC,EAAI6nC,GAAM7+B,EAAKD,GAAM,EACnCoV,EAAKrF,GAAK+uB,EAAK5nC,EAAI2nC,GAAMz+B,EAAKD,GAAM,EAEpCg/B,EAAKzoC,KAAKC,OAAOyJ,EAAKgV,GAAM0pB,GAAIztC,QAAQ,IACxC+tC,EAAK1oC,KAAKC,OAAOwJ,EAAKiV,GAAM0pB,GAAIztC,QAAQ,IAEpC4O,EAAKkV,IACNgqB,EAAKzoC,KAAK0P,GAAK+4B,GAEdn/B,EAAKmV,IACNiqB,EAAK1oC,KAAK0P,GAAKg5B,GAGdD,EAAK,IACNA,EAAe,EAAVzoC,KAAK0P,GAAS+4B,GAElBC,EAAK,IACNA,EAAe,EAAV1oC,KAAK0P,GAASg5B,GAGlBH,GAAaE,EAAKC,IACnBD,GAAoB,EAAVzoC,KAAK0P,KAEb64B,GAAaG,EAAKD,IACpBC,GAAoB,EAAV1oC,KAAK0P,IAIrB,GAAI45B,GAAKZ,EAAKD,CAEd,IAAIzoC,KAAK8I,IAAIwgC,GAAgB,IAAVtpC,KAAK0P,GAAW,IAAK,CACrC,GAAI65B,GAAQb,EACRc,EAAQlgC,EACRmgC,EAAQhgC,CAGTi/B,GADCH,GAAaG,EAAKD,EACdA,EAAe,IAAVzoC,KAAK0P,GAAW,IAAM,EAE3B+4B,EAAe,IAAVzoC,KAAK0P,GAAW,KAAM,EAGnCpG,EAAKmV,EAAK0pB,EAAKnoC,KAAKmgC,IAAIuI,GACxBj/B,EAAKiV,EAAK0pB,EAAKpoC,KAAK+oC,IAAIL,GACxBO,EAASf,EAAiB5+B,EAAIG,EAAI+/B,EAAOC,EAAOtB,EAAIC,EAAIC,EAAO,EAAGE,GAAYG,EAAIa,EAAO9qB,EAAIC,IAGhG4qB,EAAKZ,EAAKD,CAEV,IAAI3uB,GAAK9Z,KAAKmgC,IAAIsI,GACdiB,EAAK1pC,KAAK+oC,IAAIN,GACdrqB,EAAKpe,KAAKmgC,IAAIuI,GACd36B,EAAK/N,KAAK+oC,IAAIL,GACdryC,EAAI2J,KAAK0gB,IAAI4oB,EAAK,GAClBK,EAAK,EAAI,EAAIxB,EAAK9xC,EAClBuzC,EAAK,EAAI,EAAIxB,EAAK/xC,EAElBinC,GAAM/zB,EAAIG,GACV6zB,GAAMh0B,EAAKogC,EAAKD,EAAIhgC,EAAKkgC,EAAK9vB,GAC9B+vB,GAAMvgC,EAAKqgC,EAAK57B,EAAItE,EAAKmgC,EAAKxrB,GAC9B0rB,GAAMxgC,EAAIG,EAKd,IAHA8zB,EAAG,GAAK,EAAID,EAAG,GAAKC,EAAG,GACvBA,EAAG,GAAK,EAAID,EAAG,GAAKC,EAAG,GAEnBiL,EACD,OAAQjL,EAAIsM,EAAIC,GAAI3L,OAAO8K,EAE3BA,IAAU1L,EAAIsM,EAAIC,GAAI3L,OAAO8K,GAAQc,OAAOzjC,MAAM,IAElD,IAAI0jC,MACAC,IAeJ,OAbAhB,GAAOpO,QAAQ,SAAUqP,EAAOrzC,GACzBA,EAAI,EACLozC,EAAY1sC,KAAKugB,EAAOmrB,EAAOpyC,EAAI,GAAIoyC,EAAOpyC,GAAIgyC,GAAUtoC,GAE5D0pC,EAAY1sC,KAAKugB,EAAOmrB,EAAOpyC,GAAIoyC,EAAOpyC,EAAI,GAAIgyC,GAAUroC,GAGpC,IAAvBypC,EAAY7yC,SACb4yC,EAAOzsC,KAAK0sC,GACZA,QAICD,GAITG,EAAgB,SAAuBvC,GACxC,MAAOA,GAASvtC,IAAI,SAAU+vC,GAC3B,OAAShtC,KAAMgtC,EAAIhtC,KAAM+oC,OAAQ7nC,MAAMtB,UAAU6U,MAAM1a,KAAKizC,EAAIjE,YAMlEkE,EAAqB,SAA4BzC,GAClD,GAAI0C,MAEAC,EAAW,KACXC,EAAW,KAEXC,EAAW,KACXC,EAAW,IAyKf,OAvKA9C,GAAS/M,QAAQ,SAAUuP,GACxB,GAAIhtC,GAAOgtC,EAAIhtC,IAEf,IAAa,MAATA,EAAc,CACf,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDkqC,EAAWjqC,EACXkqC,EAAWnqC,EAEXgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDkqC,EAAWjqC,EACXkqC,EAAWnqC,EAEXgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAImM,GAAK6gC,EAAIjE,OAAO,GAChBz8B,EAAK0gC,EAAIjE,OAAO,GAChB78B,EAAK8gC,EAAIjE,OAAO,GAChB18B,EAAK2gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS58B,EAAIG,EAAIJ,EAAIG,EAAIjJ,EAAGD,KAElEgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAImM,GAAKghC,EAAWH,EAAIjE,OAAO,GAC3Bz8B,EAAK8gC,EAAWJ,EAAIjE,OAAO,GAC3B78B,EAAKihC,EAAWH,EAAIjE,OAAO,GAC3B18B,EAAK+gC,EAAWJ,EAAIjE,OAAO,GAC3B3lC,EAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS58B,EAAIG,EAAIJ,EAAIG,EAAIjJ,EAAGD,KAElEgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAImM,GAAK6gC,EAAIjE,OAAO,GAChBz8B,EAAK0gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS58B,EAAIG,EAAIlJ,EAAGD,KAE1DgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAImM,GAAKghC,EAAWH,EAAIjE,OAAO,GAC3Bz8B,EAAK8gC,EAAWJ,EAAIjE,OAAO,GAC3B3lC,EAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS58B,EAAIG,EAAIlJ,EAAGD,KAE1DgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MACjBH,KAAM,IACN+oC,QAASiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAI3lC,EAAGD,KAG1FgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MACjBH,KAAM,IACN+oC,QAASiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAIiE,EAAIjE,OAAO,GAAI3lC,EAAGD,KAG1FgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI4pC,EAAIjE,OAAO,EACnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,KAC/C+pC,EAAW/pC,MACP,IAAa,MAATpD,EAAc,CACtB,GAAIoD,GAAI+pC,EAAWH,EAAIjE,OAAO,EAC9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,KAC/C+pC,EAAW/pC,MACP,IAAa,MAATpD,EAAc,CACtB,GAAImD,GAAI6pC,EAAIjE,OAAO,EACnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS5lC,KAC/CiqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAImD,GAAIiqC,EAAWJ,EAAIjE,OAAO,EAC9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS5lC,KAC/CiqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIkM,GAAK8gC,EAAIjE,OAAO,GAChB18B,EAAK2gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS78B,EAAIG,EAAIjJ,EAAGD,KAE1DgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIkM,GAAKihC,EAAWH,EAAIjE,OAAO,GAC3B18B,EAAK+gC,EAAWJ,EAAIjE,OAAO,GAC3B3lC,EAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS78B,EAAIG,EAAIjJ,EAAGD,KAE1DgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnBmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAa,MAATnD,EAAc,CACtB,GAAIoD,GAAI+pC,EAAWH,EAAIjE,OAAO,GAC1B5lC,EAAIiqC,EAAWJ,EAAIjE,OAAO,EAE9BmE,GAAoB/sC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAElDgqC,EAAW/pC,EACXgqC,EAAWjqC,MACM,MAATnD,GAAyB,MAATA,IACxBktC,EAAoB/sC,MAAOH,KAAM,IAAK+oC,YAEtCoE,EAAWE,EACXD,EAAWE,KAIVJ,GAMNK,EAAiB,SAAwB/C,GAC1C,GAAIgD,MACAC,EAAW,KAEXC,EAAe,KACfC,EAAe,KAEfR,EAAW,KACXC,EAAW,KAEXC,EAAW,KACXC,EAAW,IAwJf,OAtJA9C,GAAS/M,QAAQ,SAAUuP,GACxB,GAAiB,MAAbA,EAAIhtC,KAAc,CACnB,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnByE,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAE9CkqC,EAAWjqC,EACXkqC,EAAWnqC,EAEXgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAAImM,GAAK6gC,EAAIjE,OAAO,GAChBz8B,EAAK0gC,EAAIjE,OAAO,GAChB78B,EAAK8gC,EAAIjE,OAAO,GAChB18B,EAAK2gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnByE,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS58B,EAAIG,EAAIJ,EAAIG,EAAIjJ,EAAGD,KAE9DuqC,EAAexhC,EACfyhC,EAAethC,EAEf8gC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAAIoD,GAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnByE,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGD,KAE9CgqC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAAIoD,GAAI4pC,EAAIjE,OAAO,EAEnByE,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS3lC,EAAGgqC,KAE9CD,EAAW/pC,MACP,IAAiB,MAAb4pC,EAAIhtC,KAAc,CAC1B,GAAImD,GAAI6pC,EAAIjE,OAAO,EAEnByE,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAASoE,EAAUhqC,KAErDiqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAKI4tC,GAAKC,EALL3hC,EAAK8gC,EAAIjE,OAAO,GAChB18B,EAAK2gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAIF,OAAb0E,GAAiC,MAAbA,GACrBG,EAAMT,GAAYA,EAAWO,GAC7BG,EAAMT,GAAYA,EAAWO,KAE7BC,EAAMT,EACNU,EAAMT,GAGTI,EAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS6E,EAAKC,EAAK3hC,EAAIG,EAAIjJ,EAAGD,KAEhEuqC,EAAexhC,EACfyhC,EAAethC,EAEf8gC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAGImM,GAAIG,EAHJlJ,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAIF,OAAb0E,GAAiC,MAAbA,GACrBthC,EAAKghC,GAAYA,EAAWO,GAC5BphC,EAAK8gC,GAAYA,EAAWO,KAE5BxhC,EAAKghC,EACL7gC,EAAK8gC,EAGR,IAAIQ,GAAMT,EAAW,GAAKhhC,EAAKghC,GAAY,EACvCU,EAAMT,EAAW,GAAK9gC,EAAK8gC,GAAY,EACvCU,EAAM1qC,EAAI,GAAK+I,EAAK/I,GAAK,EACzB2qC,EAAM5qC,EAAI,GAAKmJ,EAAKnJ,GAAK,CAE7BqqC,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS6E,EAAKC,EAAKC,EAAKC,EAAK3qC,EAAGD,KAElEuqC,EAAevhC,EACfwhC,EAAerhC,EAEf6gC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAAImM,GAAK6gC,EAAIjE,OAAO,GAChBz8B,EAAK0gC,EAAIjE,OAAO,GAChB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,GAEf6E,EAAMT,EAAW,GAAKhhC,EAAKghC,GAAY,EACvCU,EAAMT,EAAW,GAAK9gC,EAAK8gC,GAAY,EACvCU,EAAM1qC,EAAI,GAAK+I,EAAK/I,GAAK,EACzB2qC,EAAM5qC,EAAI,GAAKmJ,EAAKnJ,GAAK,CAE7BqqC,GAAgBrtC,MAAOH,KAAM,IAAK+oC,QAAS6E,EAAKC,EAAKC,EAAKC,EAAK3qC,EAAGD,KAElEuqC,EAAevhC,EACfwhC,EAAerhC,EAEf6gC,EAAW/pC,EACXgqC,EAAWjqC,MACP,IAAiB,MAAb6pC,EAAIhtC,KAAc,CAC1B,GAAI+qC,GAAKiC,EAAIjE,OAAO,GAChBiC,EAAKgC,EAAIjE,OAAO,GAChBkC,EAAQ+B,EAAIjE,OAAO,GACnBmC,EAAe8B,EAAIjE,OAAO,GAC1BoC,EAAY6B,EAAIjE,OAAO,GACvB3lC,EAAI4pC,EAAIjE,OAAO,GACf5lC,EAAI6pC,EAAIjE,OAAO,EAEnB,IAAW,IAAPgC,GAAmB,IAAPC,EACbwC,EAAgBrtC,MAAOH,KAAM,IAAK+oC,QAASoE,EAAUC,EAAUhqC,EAAGD,EAAGC,EAAGD,KAExEgqC,EAAW/pC,EACXgqC,EAAWjqC,MAEX,IAAIgqC,IAAa/pC,GAAKgqC,IAAajqC,EAAG,CACnC,GAAIypC,GAAS9B,EAAiBqC,EAAUC,EAAUhqC,EAAGD,EAAG4nC,EAAIC,EAAIC,EAAOC,EAAcC,EAErFyB,GAAOnP,QAAQ,SAAUuQ,GACtBR,EAAgBrtC,MAAOH,KAAM,IAAK+oC,OAAQiF,IAE1Cb,EAAW/pC,EACXgqC,EAAWjqC,SAIC,MAAb6pC,EAAIhtC,OACZwtC,EAAgBrtC,KAAK6sC,GAErBG,EAAWE,EACXD,EAAWE,EAGdG,GAAWT,EAAIhtC,OAGXwtC,EAGVpG,gBAAexnC,UAAU8qC,aAAe,SAAUpqC,EAAMvB,GACxC,MAATuB,IACD3F,KAAK0vC,EAAQO,gBAAkB,KAC/BjwC,KAAK0vC,EAAQQ,0BAA4B,MAG5CH,EAAa3wC,KAAKY,KAAM2F,EAAMvB,IAGjCqoC,eAAexnC,UAAU+qC,gBAAkB,SAAUrqC,EAAMvB,GAC3C,MAATuB,IACD3F,KAAK0vC,EAAQO,gBAAkB,KAC/BjwC,KAAK0vC,EAAQQ,0BAA4B,MAG5CF,EAAgB5wC,KAAKY,KAAM2F,IAG9B8mC,eAAexnC,UAAUynC,YAAc,SAAU4G,GAC9C,GAAIA,GAAWA,EAAQC,UAAW,CAC/B,GAAIvzC,KAAK0vC,EAAQQ,0BACd,MAAOkC,GAAcpyC,KAAK0vC,EAAQQ,0BAElC,IAAIL,EAEA7vC,MAAK0vC,EAAQO,gBACdJ,EAAWuC,EAAcpyC,KAAK0vC,EAAQO,kBAEtCJ,EAAWF,EAAoB3vC,KAAKwzC,aAAa,MAAQ,IACzDxzC,KAAK0vC,EAAQO,gBAAkBmC,EAAcvC,GAGhD,IAAI4D,GAAqBb,EAAeN,EAAmBzC,GAE3D,OADA7vC,MAAK0vC,EAAQQ,0BAA4BkC,EAAcqB,GAChDA,EAGV,GAAIzzC,KAAK0vC,EAAQO,gBACd,MAAOmC,GAAcpyC,KAAK0vC,EAAQO,gBAElC,IAAIJ,GAAWF,EAAoB3vC,KAAKwzC,aAAa,MAAQ,GAE7D,OADAxzC,MAAK0vC,EAAQO,gBAAkBmC,EAAcvC,GACtCA,GAKhBpD,eAAexnC,UAAU0nC,YAAc,SAAUkD,GAC9C,GAAwB,IAApBA,EAASxwC,OACNyuC,EAED9tC,KAAK+vC,aAAa,IAAK,IAEvB/vC,KAAKgwC,gBAAgB,SAEpB,CAGJ,IAAK,GAFDhpC,GAAI,GAEClI,EAAI,EAAGI,EAAI2wC,EAASxwC,OAAQP,EAAII,EAAGJ,GAAK,EAAG,CACjD,GAAIuzC,GAAMxC,EAAS/wC,EAEfA,GAAI,IACLkI,GAAK,KAGRA,GAAKqrC,EAAIhtC,KAELgtC,EAAIjE,SACLpnC,GAAK,IAAMqrC,EAAIjE,OAAO4D,KAAK,MAIjChyC,KAAK+vC,aAAa,IAAK/oC,KAKhCzH,EAAOJ,QAAUqtC,OAIXkH,IAAI,SAAS70C,EAAQU,EAAOJ,GAClC,YAoDA,SAASw0C,GAA0BvsC,GAIlC,IAAK,GAHDwsC,MAEAjZ,EAAM,EACD77B,EAAIsI,EAAO/H,OAAS,EAAGP,GAAK,EAAGA,IACvC80C,EAAOpuC,KAAKquC,EAAWzsC,EAAOtI,GAAI67B,IAClCA,GAGD,OAAOiZ,GAGR,QAASC,GAAWrsC,EAAQmzB,GAE3B,IAAK,GADDjrB,MACK5Q,EAAI,EAAGA,GAAK,EAAGA,IACvB4Q,EAAalK,KAAKgC,EAAOkI,aAAa5Q,GAEvC,IAAIg1C,GAAY,GAAIrkC,GAAOC,EAAcirB,EAKzC,OAAOmZ,GAxER,GAAIrkC,GAAS5Q,EAAQ,iCACjB2tC,EAA+B3tC,EAAQ,8CACvC8F,EAAa9F,EAAQ,iCACrBkY,EAAWlY,EAAQ,2BAEnBw0B,IAKJA,GAAI0gB,sBAAwB,SAAUC,GACrCxH,GAYA,KAAK,GAVDyH,GAAQD,EAAKtH,cAIbwH,KAEAziC,EAAKwiC,EAAM,GAAG7F,OAAO,GACrBx8B,EAAKqiC,EAAM,GAAG7F,OAAO,GAErBpjC,EAAI,EACClM,EAAI,EAAGA,EAAIm1C,EAAM50C,OAAQP,IAAK,CACtC,GAAIq1C,GAAOF,EAAMn1C,EACjB,IAAkB,MAAdq1C,EAAK9uC,MAA8B,MAAd8uC,EAAK9uC,KAA9B,CAIA,GAAIqK,KAAiB+B,EAAIG,IAAMuiC,EAAK/F,OAAO,GAAI+F,EAAK/F,OAAO,KAAM+F,EAAK/F,OAAO,GAAI+F,EAAK/F,OAAO,KAAM+F,EAAK/F,OAAO,GAAI+F,EAAK/F,OAAO,KAC3H5mC,EAAS,GAAIiI,GAAOC,EAAc1E,EAEtCkpC,GAAY1uC,KAAKgC,GAEjBiK,EAAK0iC,EAAK/F,OAAO,GACjBx8B,EAAKuiC,EAAK/F,OAAO,GACjBpjC,KAGD,GAAIopC,GAAW,MAQf,OALCA,GAFGr9B,EAAS0R,4BAA4ByrB,GAE7BP,EAA0BO,GAE1BA,EAGL,GAAIvvC,GAAWyvC,IA4BvB70C,EAAOJ,QAAUk0B,IAEdghB,gCAAgC,EAAEC,0BAA0B,GAAGC,gCAAgC,GAAGC,6CAA6C,KAAKC,IAAI,SAAS51C,EAAQU,EAAOJ,GACnL,YAMA,IAAI4I,KAMJA,GAAKigB,OAAS,SAAUvc,EAAIipC,GAC3B,GAAIrnC,GAAS,OACTtO,EAAI21C,GAAM,SAAUjsC,GACvB,MAAOA,IAGJksC,EAAOnxC,OAAOC,kBACdwF,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB5H,MAErB,KACC,IAAK,GAAuC6H,GAAnCC,EAAYoC,EAAGzH,OAAOC,cAAsBgF,GAA6BG,EAAQC,EAAUtH,QAAQmC,MAAO+E,GAA4B,EAAM,CACpJ,GAAIR,GAAIW,EAAMhF,MAEV4C,EAAIjI,EAAE0J,EACNzB,GAAI2tC,IACPtnC,EAAS5E,EACTksC,EAAO3tC,IAGR,MAAOzC,GACR2E,GAAoB,EACpBC,EAAiB5E,EAChB,QACD,KACM0E,GAA6BI,EAAU7E,QAC3C6E,EAAU7E,SAEV,QACD,GAAI0E,EACH,KAAMC,IAKT,MAAOkE,IAGRtF,EAAKmM,IAAM,SAAUzI,GACpB,MAAOxD,MAAKiM,IAAIyH,MAAM,KAAMlQ,IAG7B1D,EAAKoM,IAAM,SAAU1I,GACpB,MAAOxD,MAAKkM,IAAIwH,MAAM,KAAMlQ,IAG7BlM,EAAOJ,QAAU4I,OAEX6sC,IAAI,SAAS/1C,EAAQU,EAAOJ,GAClC,YAuNA,SAAS01C,GAAKpsC,EAAGD,EAAGkD,GACnB,MAAOjD,GAAE,IAAMD,EAAE,GAAKkD,EAAE,GAAKlD,EAAE,GAAKkD,EAAE,IAAMjD,EAAE,IAAMD,EAAE,GAAKkD,EAAE,GAAKlD,EAAE,GAAKkD,EAAE,IAAMjD,EAAE,IAAMD,EAAE,GAAKkD,EAAE,GAAKlD,EAAE,GAAKkD,EAAE,IAGjH,QAASopC,GAAYrsC,GACpB,MAAOA,GAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAtN/B,GAAI5I,KAMJA,GAAO8G,IAAM,SAAU/H,EAAGsH,GACzB,MAAOtH,GAAE,GAAKsH,EAAE,GAAKtH,EAAE,GAAKsH,EAAE,IAM/BrG,EAAOiI,MAAQ,SAAUlJ,EAAGsH,GAC3B,MAAOtH,GAAE,GAAKsH,EAAE,GAAKtH,EAAE,GAAKsH,EAAE,IAM/BrG,EAAO8L,uBAAyB,SAAUoY,EAAIE,GAC7C,GAAIxb,GAAIwb,EAAG,GAAKF,EAAG,GACfvb,EAAIyb,EAAG,GAAKF,EAAG,EAEnB,OAAOtb,GAAIA,EAAID,EAAIA,GAGpB3I,EAAO2W,MAAQ,SAAU7T,EAAGoyC,GAC3B,OAAQpyC,EAAE,GAAKoyC,EAAQpyC,EAAE,GAAKoyC,IAG/Bl1C,EAAO2/B,QAAU,SAAU78B,GAC1B,OAAQA,EAAE,IAAK,EAAIA,EAAE,IAAK,IAG3B9C,EAAOiO,aAAe,SAAUnL,GAC/B,GAAIqyC,GAAc,EAAIn1C,EAAOR,OAAOsD,EAEpC,QAAQA,EAAE,GAAKqyC,EAAaryC,EAAE,GAAKqyC,IAGpCn1C,EAAO4/B,SAAW,SAAU98B,EAAGtD,GAC9B,GAAI21C,GAAc31C,EAASQ,EAAOR,OAAOsD,EAEzC,QAAQA,EAAE,GAAKqyC,EAAaryC,EAAE,GAAKqyC,IAMpCn1C,EAAOkO,OAAS,SAAUgW,EAAIE,GAC7B,OAAQA,EAAG,GAAKF,EAAG,GAAIE,EAAG,GAAKF,EAAG,KAQnClkB,EAAOotB,KAAO,SAAUpqB,GACvB,GAAIkhB,GAAKlhB,EAAG,GACRohB,EAAKphB,EAAG,EAEZ,SAASkhB,EAAG,GAAKE,EAAG,IAAM,GAAIF,EAAG,GAAKE,EAAG,IAAM,IAMhDpkB,EAAOyE,gBAAkB,SAAUyf,EAAIE,GACtC,MAAOhc,MAAK+H,KAAKnQ,EAAO8L,uBAAuBoY,EAAIE,KAMpDpkB,EAAOR,OAAS,SAAUsD,GACzB,MAAOsF,MAAK+H,KAAKrN,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,KAGzC9C,EAAOo1C,cAAgB,SAAUtyC,GAChC,MAAOA,GAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAQ/B9C,EAAOq1C,4BAA8B,SAAUvyC,EAAGzD,GACjD,GAAIuS,GAAK9O,EAAE,GACPiP,EAAKjP,EAAE,GACP6O,EAAKtS,EAAE,GAAG,GACVyS,EAAKzS,EAAE,GAAG,GACVqS,EAAKrS,EAAE,GAAG,GACVwS,EAAKxS,EAAE,GAAG,GAEVi2C,EAAQzjC,EAAKC,EACbyjC,EAAQ7jC,EAAKC,EAEb6jC,EAAYF,EAAQ1jC,EAAK2jC,EAAQxjC,EAAKL,EAAKI,EAAKD,EAAKF,EACrD8jC,EAAcrtC,KAAK+H,KAAKmlC,EAAQA,EAAQC,EAAQA,EAEpD,OAAOntC,MAAK8I,IAAIskC,EAAYC,IAM7Bz1C,EAAOkoB,0CAA4C,SAAUplB,EAAGzD,GAC/D,GAAIytB,GAAIztB,EAAE,GACN0kC,EAAI1kC,EAAE,GAENy9B,EAAK98B,EAAO8L,uBAAuBghB,EAAGiX,EAC1C,IAAU,GAANjH,EACH,MAAO98B,GAAO8L,uBAAuBhJ,EAAGgqB,EAGzC,IAAIruB,KAAMqE,EAAE,GAAKgqB,EAAE,KAAOiX,EAAE,GAAKjX,EAAE,KAAOhqB,EAAE,GAAKgqB,EAAE,KAAOiX,EAAE,GAAKjX,EAAE,KAAOgQ,CAC1Er+B,GAAI2J,KAAKkM,IAAI,EAAGlM,KAAKiM,IAAI,EAAG5V,GAE5B,IAAI6lB,GAAKtkB,EAAO8L,uBAAuBhJ,GAAIgqB,EAAE,GAAKruB,GAAKslC,EAAE,GAAKjX,EAAE,IAAKA,EAAE,GAAKruB,GAAKslC,EAAE,GAAKjX,EAAE,KAG1F,OAAOxI,IAGRtkB,EAAOw8B,aAAe,SAAUkZ,GAE/B,GAAIxxB,GAAKwxB,EAAS,GACdtxB,EAAKsxB,EAAS,GACdzN,EAAKyN,EAAS,GAEdC,EAAK,GAAMX,GAAMC,EAAY/wB,GAAKA,EAAG,GAAI,IAAK+wB,EAAY7wB,GAAKA,EAAG,GAAI,IAAK6wB,EAAYhN,GAAKA,EAAG,GAAI,IAEnG2N,EAAK,GAAMZ,GAAM9wB,EAAG,GAAI+wB,EAAY/wB,GAAK,IAAKE,EAAG,GAAI6wB,EAAY7wB,GAAK,IAAK6jB,EAAG,GAAIgN,EAAYhN,GAAK,IAEnGlpC,EAAIi2C,GAAM9wB,EAAG,GAAIA,EAAG,GAAI,IAAKE,EAAG,GAAIA,EAAG,GAAI,IAAK6jB,EAAG,GAAIA,EAAG,GAAI,GAE1D+M,IAAM9wB,EAAG,GAAIA,EAAG,GAAI+wB,EAAY/wB,KAAOE,EAAG,GAAIA,EAAG,GAAI6wB,EAAY7wB,KAAO6jB,EAAG,GAAIA,EAAG,GAAIgN,EAAYhN,IAE1G,QAAQ0N,EAAK52C,EAAG62C,EAAK72C,IAQtBiB,EAAO61C,SAAW,SAAUH,GAC3B,GAAIxxB,GAAKwxB,EAAS,GACdtxB,EAAKsxB,EAAS,GACdzN,EAAKyN,EAAS,GAEd7Y,EAAK78B,EAAOyE,gBAAgB2f,EAAI6jB,GAChCnL,EAAK98B,EAAOyE,gBAAgByf,EAAI+jB,GAChClL,EAAK/8B,EAAOyE,gBAAgByf,EAAIE,GAChC0xB,EAAYjZ,EAAKC,EAAKC,CAC1B,SAASF,EAAK3Y,EAAG,GAAK4Y,EAAK1Y,EAAG,GAAK2Y,EAAKkL,EAAG,IAAM6N,GAAYjZ,EAAK3Y,EAAG,GAAK4Y,EAAK1Y,EAAG,GAAK2Y,EAAKkL,EAAG,IAAM6N,IAGtG91C,EAAO+1C,SAAW,SAAUC,GAC3B,GAAuB,IAAnBA,EAAQx2C,OAAc,CACzB,GAAI0kB,GAAK8xB,EAAQ,GACb5xB,EAAK4xB,EAAQ,GACb/N,EAAK+N,EAAQ,GAEbptC,EAAIsb,EAAG,GAAKE,EAAG,GAAK6jB,EAAG,GACvBt/B,EAAIub,EAAG,GAAKE,EAAG,GAAK6jB,EAAG,EAE3B,QAAQr/B,EAAI,EAAGD,EAAI,GASpB,IAAK,GADD2kC,GAAI,EACCruC,EAAI,EAAGA,EAAI+2C,EAAQx2C,OAAQP,IAAK,CACxC,GAAI2nB,GAAKovB,EAAQ/2C,GACbqqB,EAAKrqB,IAAM+2C,EAAQx2C,OAAS,EAAIw2C,EAAQ,GAAKA,EAAQ/2C,EAAI,EAE7DquC,IAAS1mB,EAAG,GAAK0C,EAAG,GAAKA,EAAG,GAAK1C,EAAG,GAErC0mB,GAAQ,CAGR,KAAK,GADDF,IAAK,EAAG,GACH73B,EAAK,EAAGA,EAAKygC,EAAQx2C,OAAQ+V,IAAM,CAC3C,GAAI0gC,GAAMD,EAAQzgC,GACd2gC,EAAM3gC,IAAOygC,EAAQx2C,OAAS,EAAIw2C,EAAQ,GAAKA,EAAQzgC,EAAK,EAEhE63B,GAAE,GAAKA,EAAE,IAAM6I,EAAI,GAAKC,EAAI,KAAOD,EAAI,GAAKC,EAAI,GAAKA,EAAI,GAAKD,EAAI,IAClE7I,EAAE,GAAKA,EAAE,IAAM6I,EAAI,GAAKC,EAAI,KAAOD,EAAI,GAAKC,EAAI,GAAKA,EAAI,GAAKD,EAAI,IAGnE,OAAQ7I,EAAE,IAAM,EAAIE,GAAIF,EAAE,IAAM,EAAIE,KAqBrCttC,EAAOosB,UAAY,SAAUtpB,EAAGrE,GAC/B,OAAQqE,EAAE,GAAKrE,EAAE,GAAIqE,EAAE,GAAKrE,EAAE,KAG/BuB,EAAO6tB,MAAQ,SAAU3J,EAAIE,GAC5B,MAAOF,GAAG,KAAOE,EAAG,IAAMF,EAAG,KAAOE,EAAG,IAGxCpkB,EAAOkmB,OAAS,SAAUpjB,EAAGmQ,EAAUC,GACtC,OAAQpQ,EAAE,GAAKoQ,EAAWpQ,EAAE,GAAKmQ,EAAUnQ,EAAE,GAAKmQ,EAAWnQ,EAAE,GAAKoQ,IAGrElT,EAAOm2C,cAAgB,SAAUrzC,EAAGmQ,EAAUC,GAC7C,QAASpQ,EAAE,GAAKoQ,EAAWpQ,EAAE,GAAKmQ,GAAWnQ,EAAE,GAAKmQ,EAAWnQ,EAAE,GAAKoQ,IAGvElT,EAAOw/B,kBAAoB,SAAU18B,GACpC,QAASA,EAAE,GAAIA,EAAE,KAGlB9C,EAAOo2C,qBAAuB,SAAUtzC,GACvC,OAAQA,EAAE,IAAKA,EAAE,KAGlB9C,EAAOqT,UAAY,SAAUvQ,EAAG5D,GAC/B,OAAQA,EAAE4D,EAAE,IAAK5D,EAAE4D,EAAE,MAQtB9C,EAAO6rB,aAAe,SAAU9I,EAAO+E,EAAQuuB,GAK9C,IAAK,GAJDn3C,GAAIm3C,GAAgBr2C,EAAO8L,uBAE3B/J,EAAKL,OACL40C,EAAQ3yC,OAAOC,kBACV3E,EAAI,EAAGA,EAAI6oB,EAAOtoB,OAAQP,IAAK,CACvC,GAAI6D,GAAIglB,EAAO7oB,GAEXkI,EAAIjI,EAAE6jB,EAAOjgB,EACbqE,GAAImvC,IACPv0C,EAAKe,EACLwzC,EAAQnvC,GAIV,MAAOpF,IAaR/B,EAAOgmB,gBAAkB,SAAUhjB,EAAI8pB,GAStC,IAAK,GADDtf,MACKvO,EAAI,EAAGA,EAAI+D,EAAGxD,OAAQP,IAC9BuO,EAAO7H,MAAM3C,EAAG/D,GAAG,GAAK6tB,EAAE,GAAI9pB,EAAG/D,GAAG,GAAK6tB,EAAE,IAG5C,OAAOtf,IAGRxN,EAAOu2C,aAAe,SAAUvzC,EAAIiQ,EAAUC,GAC7C,MAAOlQ,GAAGP,IAAI,SAAUK,GACvB,MAAO9C,GAAOkmB,OAAOpjB,EAAGmQ,EAAUC,MAOpClT,EAAOuT,0BAA4B,SAAUvQ,EAAIwzC,EAAOvjC,EAAUC,GACjE,MAAOlQ,GAAGP,IAAI,SAAUK,GACvB,MAAO9C,GAAOkmB,OAAOlmB,EAAOosB,UAAUtpB,EAAG0zC,GAAQvjC,EAAUC,MAO7DlT,EAAOgT,0BAA4B,SAAUhQ,EAAIwzC,EAAOvjC,EAAUC,GACjE,MAAOlQ,GAAGP,IAAI,SAAUK,GACvB,MAAO9C,GAAOosB,UAAUpsB,EAAOkmB,OAAOpjB,EAAGmQ,EAAUC,GAAWsjC,MAIhE92C,EAAOJ,QAAUU,YAEN","file":"mat-lib.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('./geometry/classes/circle.js');\nvar getNodesAsArray = require('./mat/functions/get-nodes-as-array.js');\nvar ListNode = require('./linked-loop/list-node.js');\nvar LinkedLoop = require('./linked-loop/linked-loop.js');\nvar Vector = require('./vector/vector.js');\nvar PointOnShape = require('./geometry/classes/point-on-shape.js');\n\n/**\r\n * General debugging and demoing for the Medial Axis Transform (MAT)\r\n * library.\r\n * \r\n * This file is not to be bundled with the library file to reduce the\r\n * library file size. Include it seperately in a <script> tag in your\r\n * html file if needed. This also means MatDebug will be on the global\r\n * scope. \r\n */\n\n/**\r\n * @param draw\r\n * @param drawStuff\r\n * @param run\r\n * @param shape\r\n * @param setViewBox\r\n * @param Vector class\r\n */\nfunction MatDebug(draw, drawStuff, run, setViewBox, Vector, beziersToDraw, shouldDrawSATTree) {\n\n\tthis.draw = draw;\n\tthis.drawStuff = drawStuff;\n\tthis.run = run;\n\tthis.setViewBox = setViewBox;\n\tthis.Vector = Vector;\n\tthis.beziersToDraw = beziersToDraw;\n\tthis.shouldDrawSATTree = shouldDrawSATTree;\n\t//this.Treant = Treant;\n\n\tthis.elems = [];\n\tthis.elemCount = 0;\n\tthis.twoProngs = [];\n\tthis.threeProngs = [];\n\tthis.nProngs = [];\n\tthis.cpCalcs = 0;\n\tthis.rootsSkipped = 0;\n\tthis.rootsNotSkipped = 0;\n\tthis.skipped = {\n\t\tstage0: 0,\n\t\tstage1: 0,\n\t\tstage2: 0,\n\t\tstage3: 0\n\t};\n\tthis.notSkipped = {\n\t\tstage0: 0,\n\t\tstage1: 0,\n\t\tstage2: 0,\n\t\tstage3: 0\n\t};\n\n\tthis.generated = {\n\t\tnodeHash: {},\n\t\tcpHash: {},\n\t\tcpArr: []\n\t};\n\n\tthis.mat;\n\tthis.sat;\n\n\tthis.state = {\n\t\tselectedCp: undefined\n\t};\n\n\t//---- Namespaced functions\n\tthis.fs = {\n\t\tthreeProng: {\n\t\t\tdrawSpokes: function drawSpokes(n) {\n\t\t\t\treturn _drawSpokes(this, n);\n\t\t\t}\n\t\t},\n\t\tcp: {\n\t\t\tlog: cp.log(this),\n\t\t\tdraw: cp.draw(this),\n\t\t\tselectNext: cp.next(this),\n\t\t\tselectPrevOnCircle: cp.prevOnCircle(this)\n\n\t\t}\n\t};\n\n\tthis.deltasToNiceStr = deltasToNiceStr;\n\tthis.pointsToNiceStr = pointsToNiceStr;\n}\n\nfunction deltaToNiceString(delta) {\n\treturn delta.map(function (cpNode) {\n\t\treturn cpNode.item.key;\n\t});\n}\n\nfunction pToStr5(p) {\n\treturn p[0].toFixed(5) + ', ' + p[1].toFixed(5);\n}\n\nfunction pointsToNiceStr(ps) {\n\treturn ps.map(pToStr5);\n}\n\nfunction deltasToNiceStr(deltas) {\n\treturn deltas.map(deltaToNiceString);\n}\n\nvar cp = {\n\tlog: function log(_debug_) {\n\t\treturn function () {\n\t\t\tvar cpNode = _debug_.state.selectedCp;\n\t\t\tvar cp = cpNode.item;\n\t\t\tconsole.log(cpNode);\n\t\t\tconsole.log(PointOnShape.toString(cp.pointOnShape));\n\t\t};\n\t},\n\tnext: function next(_debug_) {\n\t\treturn function () {\n\t\t\t_debug_.state.selectedCp = _debug_.state.selectedCp.next;\n\t\t};\n\t},\n\tprevOnCircle: function prevOnCircle(_debug_) {\n\t\treturn function () {\n\t\t\t_debug_.state.selectedCp = _debug_.state.selectedCp.prevOnCircle;\n\t\t};\n\t},\n\tdraw: function draw(_debug_) {\n\t\treturn function () {\n\t\t\t_debug_.draw.crossHair(_debug_.state.selectedCp.item, 'blue thin5 nofill', 1);\n\t\t};\n\t}\n};\n\nfunction getHashCount(hash) {\n\tvar c = 0;\n\n\tfor (key in hash) {\n\t\tc++;\n\t}\n\n\treturn c;\n}\n\nMatDebug.prototype.drawSATTree = function (tree) {\n\n\tvar bucketSizes = [];\n\n\tfunction getNodeStructure(key, t) {\n\n\t\tvar type = key === '5' ? 'M' : key;\n\n\t\tif (type === 'M') {\n\t\t\ttype = 'M-' + t.size;\n\n\t\t\tbucketSizes.push(t.size);\n\t\t}\n\n\t\tvar node = {\n\t\t\ttext: { name: type },\n\t\t\tchildren: []\n\t\t};\n\n\t\tfor (var _key in t) {\n\t\t\tvar n = t[_key];\n\n\t\t\tnode.children.push(getNodeStructure(_key, n));\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tvar cfg = {\n\t\tchart: { container: \"#mat-tree\" },\n\t\tnodeStructure: getNodeStructure('root', tree)\n\t};\n\n\t// Treant tree drawer removed so we can use d3 in the future.\n\t//new Treant( cfg ); // Draw the tree\n\n\tbucketSizes.sort(function (a, b) {\n\t\treturn a - b;\n\t});\n};\n\nMatDebug.prototype.getDistanceBetween = function () {\n\tfor (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n\t\targs[_key2] = arguments[_key2];\n\t}\n\n\treturn Vector.distanceBetween(args);\n};\n\nMatDebug.prototype.drawDot = function (p, r, color) {\n\treturn this.draw.dot(p, r, color);\n};\n\nMatDebug.prototype.testNProng_1 = function () {\n\tthis.setViewBox([65, 287, 85, 72]);\n\t//d.highlightBeziers('36,37,430,431')\t\n};\n\nMatDebug.prototype.test2Prong_2 = function () {\n\tthis.traceNProng(13);\n\tthis.drawDot([118.83, 333.59], 0.3, 'green');\n\tthis.drawDot([122.26, 332.36], 0.3, 'green');\n\tthis.drawDot([103.9345546632512, 292.8475727546303], 0.3, 'green');\n\tthis.drawDot([102.28082651515273, 293.73728721662496], 0.3, 'green');\n\n\tthis.drawDot([102.28082651515273, 293.73728721662496], 0.1, 'yellow');\n\tthis.drawDot([118.83, 333.59], 0.1, 'yellow');\n};\n\nMatDebug.prototype.test2Prong_1 = function () {\n\tthis.setViewBox([126, 201, 179, 146]);\n\td.trace2ProngConvergence(46);\n\n\tvar p1 = [198.71, 308.17];\n\tvar p2 = [186.1136043817149, 278.1427194133067];\n\tvar p3 = [156.89, 263.78];\n\n\t$timeout();\n};\n\n/**\r\n * @param n The bezier indx.\r\n * Only logs the bezier at this stage, if working at all.\r\n */\nMatDebug.prototype.drawBezierArcs = function (n) {\n\tvar shape = this.shape;\n\n\tvar bezArr = beziers.nodeArr;\n\tvar bezier = bezArr[n];\n\n\tconsole.log(bezier);\n};\n\nMatDebug.prototype.logBezierInterfaceAngles = function () {\n\t// TODO Incomplete\n\tvar tan1 = bezier.tangent(1);\n\tvar tan2 = node.next.item.tangent(0);\n\tvar crossTangents = Vector.cross(tan1, tan2);\n\n\tvar str = \"tangents (degrees): \" + Util.radToDeg(Math.asin(crossTangents)).toFixed(8);\n};\n\nMatDebug.prototype.remove = function (n) {\n\tthis.elems[n].remove();\n};\n\nMatDebug.prototype.log2ProngDelta = function (n) {\n\tvar delta = this.twoProngs[n].delta;\n\n\tconsole.log(delta);\n};\n\nMatDebug.prototype.log2Prong = function (n) {\n\tvar twoProng = this.twoProngs[n];\n\n\tconsole.log(twoProng);\n};\n\nMatDebug.prototype.draw2ProngNormal = function (n) {\n\t// If not specified which, draw all\n\tif (n === undefined) {\n\t\tfor (var i = 0; i < this.twoProngs.length; i++) {\n\t\t\tthis.draw2ProngNormal(i);\n\t\t}\n\t}\n\n\tvar twoProng = this.twoProngs[n];\n\n\tif (!twoProng) {\n\t\treturn;\n\t}\n\n\tthis.draw.line([twoProng.y, twoProng.x], 'thin10 blue');\n};\n\nMatDebug.prototype.log2ProngDeltaBasic = function (n) {\n\tvar delta = this.twoProngs[n].delta;\n\n\tvar f = function f(x) {\n\t\treturn {\n\t\t\tbez: x.item.pointOnShape.bezierNode.item.indx,\n\t\t\tt: x.item.pointOnShape.t,\n\t\t\torder: x.item.pointOnShape.order\n\t\t};\n\t};\n\n\tconsole.log(f(delta[0]));\n\tconsole.log(f(delta[1]));\n};\n\nMatDebug.prototype.traceNProng = function (n) {\n\t//console.log(this.nProngs[n])\n\t//console.log(this.threeProngs[n])\n\t//let nProng = this.nProngs[n];\n\tvar threeProng = this.nProngs[n];\n\t//let threeProng = nProng;\n\tvar dbgInfo = threeProng.dbgInfo;\n\tvar cs = dbgInfo.cs;\n\n\tconsole.log(threeProng);\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = cs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar c = _step.value;\n\n\t\t\tthis.draw.dot(c.x, 0.2, 'cyan');\n\t\t\tc.radius = c.ccr;\n\t\t\tc.center = c.x;\n\t\t\tthis.draw.circle(c, 'cyan thin20 nofill');\n\t\t\t//bps.map(function(p) { draw.dot(p, 0.03, 'blue'); });\t\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMatDebug.prototype.logNProngDelta = function (n) {\n\tvar nProng = this.nProngs[n];\n\n\tconsole.log(nProng.deltas);\n};\n\nMatDebug.prototype.logNProngDeltaBasic = function (n) {\n\tvar nProng = this.nProngs[n];\n\n\tvar f = function f(x) {\n\t\treturn {\n\t\t\tbez: x.item.pointOnShape.bezierNode.item.indx,\n\t\t\tt: x.item.pointOnShape.t,\n\t\t\torder: x.item.pointOnShape.order\n\t\t};\n\t};\n\n\tfor (var i = 0; i < nProng.deltas.length; i++) {\n\t\tvar delta = nProng.deltas[i];\n\n\t\tconsole.log(f(delta[0]), f(delta[1]));\n\t\t//console.log();\t\n\t}\n};\n\nMatDebug.prototype.testNProng_2 = function () {\n\tthis.setViewBox([68, 290, 85, 56]);\n\n\td.draw2ProngNormal(41);\n\td.draw2ProngNormal(42);\n\td.logNProngDeltaBasic(0);\n\n\t$timeout();\n};\n\nMatDebug.prototype.testNProng_3 = function () {\n\tthis.run();\n\tthis.setViewBox([10, 286, 84, 90]);\n\t//d.draw2Prong(34, 'thin10')\n\t//d.highlightBeziers('36,37,430,431')\n\t//d.draw2ProngNormal(34);\n\t//d.draw2ProngNormal(42);\n\td.logNProngDeltaBasic(1);\n\n\t$timeout();\n};\n\nfunction _drawSpokes(debug, n) {\n\tvar nProng = debug.nProngs[n];\n\tvar threeProng = nProng.threeProng;\n\n\tconsole.log(threeProng);\n\tvar cc = threeProng.circle.center;\n\tvar ps = threeProng.ps;\n\tdebug.draw.line([ps[0], cc], 'thin5 red');\n\tdebug.draw.line([ps[1], cc], 'thin5 red');\n\tdebug.draw.line([ps[2], cc], 'thin5 red');\n};\n\nMatDebug.prototype.highlightBeziers = function (rangeStr) {\n\tvar COLORS = ['red', 'green', 'blue'];\n\n\tvar indxs = Util.rangeStrToIndxArray(rangeStr);\n\n\tvar i = 0;\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = indxs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar indx = _step2.value;\n\n\t\t\ti++;\n\n\t\t\tvar _bezier = LinkedLoop.getByIndx(shape.beziers, indx);\n\n\t\t\tvar color = COLORS[i % COLORS.length];\n\t\t\tdraw.bezier(_bezier, 'nofill thin20 ' + color);\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n};\n\nMatDebug.prototype.drawSomeStuff = function (shape) {\n\t//this.draw.bezierArcs(shape);\n\n\tthis.draw.looseBoundingBoxes(shape, 'thin2 brown nofill');\n\tthis.draw.tightBoundingBoxes(shape, 'thin2 black nofill');\n\n\tvar beziersToDraw = this.beziersToDraw;\n\n\tvar nodeStart = LinkedLoop.getByIndx(shape.beziers, beziersToDraw[0]);\n\tvar nodeEnd = LinkedLoop.getByIndx(shape.beziers, beziersToDraw[1] + 1);\n\n\tthis.draw.beziers(shape, nodeStart, nodeEnd);\n};\n\nMatDebug.prototype.trace2ProngConvergence = function (n_, failedOnly) {\n\n\tvar n = void 0;\n\tif (failedOnly) {\n\t\tvar j = 0;\n\t\tfor (var i = 0; i < this.twoProngs.length; i++) {\n\t\t\tvar _twoProngInfo = this.twoProngs[i];\n\t\t\tif (_twoProngInfo.failed) {\n\t\t\t\tif (n_ === j) {\n\t\t\t\t\tn = i;\n\t\t\t\t\tconsole.log(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tn = n_;\n\t}\n\n\tif (!n) {\n\t\treturn;\n\t}\n\n\tvar twoProngInfo = this.twoProngs[n];\n\tvar twoProng = twoProngInfo.twoProng;\n\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = twoProngInfo.xs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar x = _step3.value;\n\n\t\t\tthis.draw.crossHair(x.x, 'blue thin10 nofill');\n\t\t\tvar circle = new Circle(x.x, Vector.distanceBetween(x.x, x.y));\n\t\t\tthis.draw.circle(circle, 'blue thin10 nofill');\n\t\t\tthis.draw.crossHair(x.z, 'yellow thin10 nofill', 2);\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n\n\tconsole.log(twoProngInfo.xs.map(function (x) {\n\t\treturn {\n\t\t\tx: x.x,\n\t\t\ty: x.y,\n\t\t\tz: x.z,\n\t\t\td: Vector.squaredDistanceBetween(x.y, x.z),\n\t\t\tt: x.t\n\t\t};\n\t}));\n\n\tthis.draw2ProngNormal(n);\n\n\treturn 'Failed: ' + twoProngInfo.failed;\n};\n\nMatDebug.prototype.logNearestNProng = function (p, twoProngsOnly) {\n\tvar _this = this;\n\n\tvar matNodes = getNodesAsArray(this.mat);\n\n\tvar ps = matNodes.filter(function (node) {\n\t\tif (twoProngsOnly) {\n\t\t\treturn node.matCircle.cpNodes.length === 2;\n\t\t} else {\n\t\t\treturn node.matCircle.cpNodes.length !== 2;\n\t\t}\n\t}).map(function (node) {\n\t\treturn node.matCircle.circle.center;\n\t});\n\tvar q = getClosestPointToPoints(ps, p);\n\n\tvar key = PointOnShape.makeSimpleKey(q);\n\tvar nodeHashDebugObj = this.generated.nodeHash[key];\n\tvar matNode = nodeHashDebugObj.matNode;\n\tvar matCircle = matNode.matCircle;\n\n\tvar cpHashDebugObjs = matCircle.cpNodes.map(function (cpNode) {\n\t\treturn _this.generated.cpHash[cpNode.item.simpleKey];\n\t});\n\n\tconsole.log(nodeHashDebugObj);\n\tconsole.log(cpHashDebugObjs);\n\tconsole.log(cpHashDebugObjs.map(function (x) {\n\t\tif (!x) {\n\t\t\treturn;\n\t\t}\n\t\treturn x.visitedPointsArr.map(function (x) {\n\t\t\treturn x.map(function (x) {\n\t\t\t\treturn {\n\t\t\t\t\tcpNode: x,\n\t\t\t\t\tcp: x.item,\n\t\t\t\t\tpos: x.item.pointOnShape,\n\t\t\t\t\t0: x.item.pointOnShape[0],\n\t\t\t\t\t1: x.item.pointOnShape[1]\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}));\n\n\tconsole.log(cpHashDebugObjs.map(function (x) {\n\t\tif (!x) {\n\t\t\treturn;\n\t\t}\n\t\treturn x.visitedPointsArr.map(function (x) {\n\t\t\treturn x.map(function (x) {\n\t\t\t\treturn MatLib.PointOnShape.toString(x.item.pointOnShape);\n\t\t\t});\n\t\t});\n\t}));\n\n\tvar circle = new Circle(matCircle.circle.center, matCircle.circle.radius || 1);\n\n\t//this.draw.circle(circle, 'green thin10 nofill');\n\n\n\tif (twoProngsOnly) {\n\t\tvar n = void 0;\n\t\tfor (var i = 0; i < this.twoProngs.length; i++) {\n\t\t\tvar twoProngInfo = this.twoProngs[i];\n\t\t\tvar twoProng = twoProngInfo.twoProng;\n\t\t\tvar cc = twoProng.item.matCircle.circle.center;\n\t\t\t//console.log(twoProngInfo);\n\t\t\tif (q[0] === cc[0] && q[1] === cc[1]) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (n) {\n\t\t\tthis.trace2ProngConvergence(n);\n\t\t}\n\t}\n};\n\n/**\r\n * Simple O(n^2) implementation.\r\n */\nfunction getClosestPointToPoints(ps, p) {\n\tvar minD = Number.POSITIVE_INFINITY;\n\tvar closestPoint = void 0;\n\n\tvar _iteratorNormalCompletion4 = true;\n\tvar _didIteratorError4 = false;\n\tvar _iteratorError4 = undefined;\n\n\ttry {\n\t\tfor (var _iterator4 = ps[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\tvar q = _step4.value;\n\n\t\t\tvar _d = Vector.distanceBetween(q, p);\n\n\t\t\tif (_d < minD) {\n\t\t\t\tminD = _d;\n\n\t\t\t\tclosestPoint = q;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError4 = true;\n\t\t_iteratorError4 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t_iterator4.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError4) {\n\t\t\t\tthrow _iteratorError4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closestPoint;\n}\n\nmodule.exports = MatDebug;\n\n},{\"./geometry/classes/circle.js\":5,\"./geometry/classes/point-on-shape.js\":6,\"./linked-loop/linked-loop.js\":14,\"./linked-loop/list-node.js\":15,\"./mat/functions/get-nodes-as-array.js\":30,\"./vector/vector.js\":43}],2:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\nvar Vector = require('../../vector/vector.js');\n\n/** \r\n * @constructor \t\n * \t\n * @param p {number[]} - The point coordinates.\n * @param {ListNode<Bezier>} bezierNode\t\n * @param t\r\n * @param type {MAT_CONSTANTS.pointType} \t\n *  'osculating'        : 0, // Osculating - Max curvatre inward,   \t\n *  'sharp'             : 1, // Sharp corner, \t\n *  'dull'              : 2, // dull corner, \t\n *  'reverseOsculating' : 3, // Osculating - Max curvature outward, \t\n *  'standard'          : 4, // just another point\r\n * @param {Number} order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates or t values.   \r\n * @param {Circle} circle - The osculating circle at this point.\r\n * @param {Number} sharpness - Measure of corner sharpness.\r\n *   \t\n */\n// TODO - The order property should be a property of ContactPoint instead.\nvar PointOnShape = function PointOnShape(p, bezierNode, t, type, order, osculatingCircle, sharpness) {\n\n\tthis.bezierNode = bezierNode;\n\tthis.t = t;\n\tthis.type = type;\n\tthis.order = order; // z-order order arbitration decider to make all points on the shape well-ordered\n\tthis.osculatingCircle = osculatingCircle;\n\tthis.sharpness = sharpness;\n\t//if (sharpness) { console.log(sharpness); }\n\n\tthis.simpleKey = PointOnShape.makeSimpleKey(p);\n\t//this.p = p; // TODO - see below\n\n\t//---- Cache\n\t// Removed 2 lines below - if {PointOnShape} is called as parameter \n\t// it will more likely result in monomorphic behaviour as opposed \n\t// to polymorphic or megamorphic\n\tthis[0] = p[0];\n\tthis[1] = p[1];\n\tthis.key = PointOnShape.toString(this);\n};\n\nfunction dullCornerAt(shape, p) {\n\n\tvar dullCornerHash = shape.dullCornerHash;\n\tvar key = PointOnShape.makeSimpleKey(p); // First point\n\n\tvar result = dullCornerHash[key] || null;\n\n\t//console.log(result);\n\n\treturn result;\n}\n\n/**\r\n * Sets the order (to distinguish between points lying on top of each \r\n * other) of the contact point if it is a dull corner.\r\n *\r\n * Notes: Modifies p\r\n * \r\n * @param {PointOnShape} p \r\n * \r\n */\nPointOnShape.setPointOrder = function (shape, circle, p, _debug_) {\n\n\tvar dullCorner = dullCornerAt(shape, p);\n\n\tif (!dullCorner) {\n\t\treturn; /* or use different scheme */\n\t}\n\n\t//let bez = dullCorner.pointOnShape.bezierNode.item;\n\tvar bez = dullCorner.bezier;\n\tvar tan1pre = bez.tangent(1);\n\n\tvar tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n\tvar tan2 = Vector.toUnitVector(Vector.fromTo(p, circle.center));\n\n\tvar crossTangents = -Vector.dot(tan1, tan2);\n\n\tp.order = crossTangents;\n\tp.key = PointOnShape.toString(p);\n\n\tif (_debug_) {\n\t\t// TODO Add a _debug_ flag to switch this on or off.\n\t\tif (_debug_.drawStuff) {\n\t\t\tif (dullCorner) {\n\t\t\t\t//_debug_.draw.line([p, circle.center], 'red thin5');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.order;\n};\n\n/**\t\n * Return a new point on the shape from given point shifted by a given t distance\t\n * \t\n * Δt The distance to shift the point\t\n * \t\n * @return {PointOnShape} Shifted point  \t\n */\nPointOnShape.shift = function (p, Δt) {\n\n\tif (Δt <= -1 || Δt >= 1) {\n\t\t// TODO: relatively easy to support the case where Δt can by any {Number}\t\n\t\tthrow 'Δt not in range (-1, 1); Δt was ' + Δt;\n\t}\n\n\tvar newBezierNode = p.bezierNode;\n\n\tvar t = p.t + Δt;\n\tif (t < 0) {\n\t\tt = t + 1;\n\t\tnewBezierNode = newBezierNode.prev;\n\t} else if (t > 1) {\n\t\tt = t - 1;\n\t\tnewBezierNode = newBezierNode.next;\n\t}\n\n\t//console.log(p.t, Δt, t, newBezierNode.item.evaluate(t));\t\n\n\treturn new PointOnShape(newBezierNode.item.evaluate(t), newBezierNode, t, MAT_CONSTANTS.pointType.standard, 0 /* order */\n\t);\n};\n\nPointOnShape.cloneAndAdv = function (p) {\n\treturn new PointOnShape(p.bezierNode.item.evaluate(p.t), p.bezierNode, p.t, p.type, p.order + p.order / 111111111111 // hack  \t\n\t);\n};\n\n/**\t\n * Takes a single point and splits it and moves it apart along shape boundary.\t\n * \t\r\n * @param p {PointOnShape} pointOnShape \n * @param Δt {Number} The distance (in t) to move the points apart. Ideally we would\t\n *        much prefer a pixel distance, but the implementation would be more complex. \t\n * \t\n * @return Splitted points as array, i.e. [p1,p2]\t\n */\nPointOnShape.split = function (p, Δt) {\n\treturn [PointOnShape.shift(p, -Δt), PointOnShape.shift(p, +Δt)];\n};\n\nPointOnShape.splitForward = function (p, Δt) {\n\treturn [p, PointOnShape.shift(p, +2 * Δt)];\n};\n\nPointOnShape.splitBack = function (p, Δt) {\n\treturn [PointOnShape.shift(p, -2 * Δt), p];\n};\n\nfunction typeToStr(type) {\n\tfor (var key in MAT_CONSTANTS.pointType) {\n\t\tif (MAT_CONSTANTS.pointType[key] === type) {\n\t\t\treturn key;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nPointOnShape.toString = function (p) {\n\treturn '' + p[0] + ', ' + p[1] + '|' + p.order + '|' + p.type;\n};\n\nPointOnShape.toHumanString = function (p) {\n\tvar str = '' + p[0] + ', ' + p[1] + ' | bz: ' + p.bezierNode.item.indx + ' | t: ' + p.t + ' | ord: ' + p.order + ' | ';\n\treturn str + typeToStr(p.type);\n};\n\nPointOnShape.makeSimpleKey = function (p) {\n\treturn '' + p[0] + ', ' + p[1];\n};\n\nPointOnShape.compare = function (a, b) {\n\tvar res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.t - b.t;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\treturn a.order - b.order;\n};\n\nmodule.exports = PointOnShape;\n\n},{\"../../mat-constants.js\":17,\"../../vector/vector.js\":43}],3:[function(require,module,exports){\n\"use strict\";\n\n/** \r\n * Standard arc class.\r\n * \r\n * If circle === null then the arc degenerates into a line segment \r\n * given by sin_angle1 and cos_angle2 which now represent points.\r\n * \r\n * The arc curve is always defined as the piece from angle1 -> angle2.\r\n * \r\n * Note: startpoint and endpoint is redundant \r\n */\n\nvar Arc = function Arc(circle, startpoint, endpoint, sin_angle1, cos_angle1, sin_angle2, cos_angle2) {\n\n\tthis.circle = circle;\n\tthis.startpoint = startpoint; // Redundant but useful\n\tthis.endpoint = endpoint; // Redundant but useful\t\n\tthis.sin_angle1 = sin_angle1;\n\tthis.sin_angle2 = sin_angle2;\n\tthis.cos_angle1 = cos_angle1;\n\tthis.cos_angle2 = cos_angle2;\n};\n\nmodule.exports = Arc;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Util = require('../../utils.js');\nvar Poly = require('../../polynomial/polynomial.js');\nvar gaussQuadrature = require('../../numerical/functions/gaussian-quadrature.js');\nvar Vector = require('../../vector/vector.js');\n\n/**\r\n * The Bezier class represents a bezier, possibly in the context of a \r\n * shape.\r\n * \r\n * @param bezierPoints\r\n * @param indx\r\n * @returns\r\n */\nfunction Bezier(bezierPoints, indx) {\n\n\tthis.indx = indx;\n\n\t//---- Bernstein basis representation\n\n\tvar _bezierPoints = _slicedToArray(bezierPoints, 4),\n\t    _bezierPoints$ = _slicedToArray(_bezierPoints[0], 2),\n\t    x0 = _bezierPoints$[0],\n\t    y0 = _bezierPoints$[1],\n\t    _bezierPoints$2 = _slicedToArray(_bezierPoints[1], 2),\n\t    x1 = _bezierPoints$2[0],\n\t    y1 = _bezierPoints$2[1],\n\t    _bezierPoints$3 = _slicedToArray(_bezierPoints[2], 2),\n\t    x2 = _bezierPoints$3[0],\n\t    y2 = _bezierPoints$3[1],\n\t    _bezierPoints$4 = _slicedToArray(_bezierPoints[3], 2),\n\t    x3 = _bezierPoints$4[0],\n\t    y3 = _bezierPoints$4[1];\n\n\t//---- Power basis representation\n\n\n\tvar x = [x3 - 3 * x2 + 3 * x1 - x0, // t^3\n\t3 * x2 - 6 * x1 + 3 * x0, // t^2\n\t3 * x1 - 3 * x0, // t^1\n\tx0];\n\tvar y = [y3 - 3 * y2 + 3 * y1 - y0, // t^3\n\t3 * y2 - 6 * y1 + 3 * y0, // t^2\n\t3 * y1 - 3 * y0, // t^1\n\ty0];\n\n\tvar evaluateX = Poly.evaluate(x); // Function of t\n\tvar evaluateY = Poly.evaluate(y); // Function of t\n\n\tvar dx = Poly.differentiate(x); // Polynomial in t\n\tvar dy = Poly.differentiate(y); // Polynomial in t\n\n\tvar evaluateDx = Poly.evaluate(dx); // Function of t\n\tvar evaluateDy = Poly.evaluate(dy); // Function of t\n\n\tvar ddx = Poly.differentiate(dx); // Polynomial in t\n\tvar ddy = Poly.differentiate(dy); // Polynomial in t\n\n\tvar evaluateDdx = Poly.evaluate(ddx); // Function of t\n\tvar evaluateDdy = Poly.evaluate(ddy); // Function of t\n\n\n\tvar straightLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n\tvar sinAngle = (y3 - y0) / straightLength;\n\tvar cosAngle = (x3 - x0) / straightLength;\n\n\t/**\r\n  * Returns the differential of length at t.\r\n  */\n\tfunction ds(t) {\n\t\tvar dx_ = evaluateDx(t);\n\t\tvar dy_ = evaluateDy(t);\n\n\t\treturn Math.sqrt(dx_ * dx_ + dy_ * dy_);\n\t}\n\n\tvar curveLength = undefined;\n\tfunction getCurveLength() {\n\t\tif (curveLength) {\n\t\t\treturn curveLength;\n\t\t}\n\n\t\t// Numerically integrate the curve length\n\t\tvar result = gaussQuadrature(ds, [0, 1]);\n\t\tcurveLength = result;\n\n\t\treturn result;\n\t}\n\n\tfunction κ(t) {\n\t\tvar dx_ = evaluateDx(t);\n\t\tvar dy_ = evaluateDy(t);\n\t\tvar ddx_ = evaluateDdx(t);\n\t\tvar ddy_ = evaluateDdy(t);\n\t\tvar denom = dx_ * dx_ + dy_ * dy_;\n\n\t\treturn (dx_ * ddy_ - dy_ * ddx_) / Math.sqrt(denom * denom * denom);\n\t}\n\n\tfunction κTimesSDiff(t) {\n\t\tvar dx_ = evaluateDx(t);\n\t\tvar dy_ = evaluateDy(t);\n\t\tvar ddx_ = evaluateDdx(t);\n\t\tvar ddy_ = evaluateDdy(t);\n\t\tvar denom = dx_ * dx_ + dy_ * dy_;\n\n\t\treturn (dx_ * ddy_ - dy_ * ddx_) / denom;\n\t}\n\n\tvar totalAbsoluteCurvature = {};\n\tfunction getTotalAbsoluteCurvature(interval_) {\n\t\tvar interval = interval_ || [0, 1];\n\t\tvar key = '' + interval[0] + ', ' + interval[1];\n\t\tif (totalAbsoluteCurvature[key]) {\n\t\t\treturn totalAbsoluteCurvature[key];\n\t\t}\n\n\t\t// Numerically integrate the absolute curvature\n\t\tvar result = gaussQuadrature(function (t) {\n\t\t\treturn Math.abs(κTimesSDiff(t));\n\t\t}, interval);\n\t\ttotalAbsoluteCurvature[key] = result;\n\n\t\treturn result;\n\t}\n\n\tvar totalCurvature = undefined;\n\tfunction getTotalCurvature() {\n\t\tif (totalCurvature) {\n\t\t\treturn totalCurvature;\n\t\t}\n\n\t\t// Numerically integrate the curvature.\n\t\tvar result = gaussQuadrature(κTimesSDiff, [0, 1]);\n\t\ttotalCurvature = result;\n\n\t\treturn result;\n\t}\n\n\t// Math is from http://math.info/Calculus/Curvature_Parametric/\n\t// See the maxima file for details\n\t/** \r\n  * A modified version of differential of κ (use quotient rule,\r\n  * ignore denominator and multiply by 2/3). We need to find the \r\n  * zeros of this function to get the min/max curvature.\r\n **/\n\tfunction dκ(t) {\n\t\tvar ts = t * t;\n\t\tvar omt = 1 - t;\n\n\t\tvar a = ts * x3;\n\t\tvar i = ts * y3;\n\t\tvar b = 2 * t - 3 * ts;\n\t\tvar c = (3 * t - 1) * omt;\n\t\tvar d = omt * omt;\n\t\tvar e = 3 * (a + b * x2 - c * x1 - d * x0);\n\t\tvar f = 3 * (i + b * y2 - c * y1 - d * y0);\n\t\tvar g = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n\t\tvar h = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n\n\t\treturn 4 * (e * (y3 - 3 * y2 + 3 * y1 - y0) - f * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(f * f + e * e, 3 / 2) - (e * g - h * f) * (2 * g * f + 2 * h * e) * Math.sqrt(f * f + e * e);\n\t}\n\n\t/** Evaluate the bezier parametric equation at some value \r\n  * @param t {Number [0,1]} The point where the evaluation should take place \r\n  * \r\n  * @returns { [Number, Number] }\r\n  **/\n\tfunction evaluate(t) {\n\t\tif (t === 0) {\n\t\t\treturn [x0, y0];\n\t\t} else if (t === 1) {\n\t\t\treturn [x3, y3];\n\t\t}\n\n\t\treturn [evaluateX(t), evaluateY(t)];\n\t}\n\n\tfunction tangent(t) {\n\t\tvar dx_ = evaluateDx(t);\n\t\tvar dy_ = evaluateDy(t);\n\t\tvar d = Math.sqrt(dx_ * dx_ + dy_ * dy_);\n\n\t\treturn [dx_ / d, dy_ / d];\n\t}\n\n\tfunction normal(t) {\n\t\tvar tangent_ = tangent(t);\n\t\treturn [tangent_[1], -tangent_[0]];\n\t}\n\n\tvar boundingBoxTight = null; // Cache (Memoization)\n\tfunction getBoundingBoxTight() {\n\t\tif (boundingBoxTight) {\n\t\t\treturn boundingBoxTight;\n\t\t}\n\n\t\tvar box = getNormalizedBoundingBox();\n\n\t\tvar p0x = box[0][0];\n\t\tvar p0y = box[0][1];\n\t\tvar p1x = box[1][0];\n\t\tvar p1y = box[1][1];\n\n\t\tvar axisAlignedBox = [box[0], [p1x, p0y], box[1], [p0x, p1y]];\n\n\t\tboundingBoxTight = Vector.rotateThenTranslatePoints(axisAlignedBox, bezierPoints[0], sinAngle, cosAngle);\n\n\t\treturn boundingBoxTight;\n\t}\n\n\tvar normalizedBoundingBox = null;\n\t/** Get normalized bounding box - memoized */\n\tfunction getNormalizedBoundingBox() {\n\t\tif (normalizedBoundingBox) {\n\t\t\treturn normalizedBoundingBox;\n\t\t}\n\n\t\t// Cache\n\t\tvar vectorToOrigin = Vector.transform(bezierPoints[0], function (x) {\n\t\t\treturn -x;\n\t\t});\n\t\tvar normalizedBezier = new Bezier(Vector.translateThenRotatePoints(bezierPoints, vectorToOrigin, -sinAngle, cosAngle), undefined);\n\n\t\tnormalizedBoundingBox = normalizedBezier.getBoundingBox();\n\n\t\treturn normalizedBoundingBox;\n\t}\n\n\tvar boundingBox = undefined;\n\tthis.tAtMaxX = undefined;\n\tfunction getBoundingBox() {\n\t\tif (boundingBox) {\n\t\t\treturn boundingBox;\n\t\t}\n\n\t\t// The a,b and c in the quadratic equation of the derivative of \n\t\t// x(t) and y(t) set equal to 0.\n\n\t\tvar ds = [dx, dy];\n\n\t\tvar roots = ds.map(Poly.findQuadraticRoots01);\n\n\t\t// Endpoints\n\t\troots[0].push(0);roots[0].push(1);\n\t\troots[1].push(0);roots[1].push(1);\n\n\t\t// Test points\n\t\tvar testPointsX = roots[0].map(evaluateX);\n\t\tvar testPointsY = roots[1].map(evaluateY);\n\n\t\tvar minX = Number.POSITIVE_INFINITY;\n\t\tvar maxX = Number.NEGATIVE_INFINITY;\n\t\tfor (var i = 0; i < roots[0].length; i++) {\n\t\t\tvar xx = evaluateX(roots[0][i]);\n\t\t\tif (xx > maxX) {\n\t\t\t\tmaxX = xx;\n\t\t\t\tthis.tAtMaxX = roots[0][i];\n\t\t\t}\n\t\t\tif (xx < minX) {\n\t\t\t\tminX = xx;\n\t\t\t}\n\t\t}\n\n\t\tboundingBox = [[minX, Util.min(testPointsY)], [maxX, Util.max(testPointsY)]];\n\n\t\treturn boundingBox;\n\t}\n\n\t// Public members\n\tthis.bezierPoints = bezierPoints;\n\n\tthis.tangent = tangent;\n\tthis.normal = normal;\n\n\tthis.getBoundingBox = getBoundingBox;\n\tthis.getBoundingBoxTight = getBoundingBoxTight;\n\tthis.getTotalAbsoluteCurvature = getTotalAbsoluteCurvature;\n\tthis.getTotalCurvature = getTotalCurvature;\n\tthis.getCurveLength = getCurveLength;\n\tthis.κ = κ;\n\tthis.dκ = dκ;\n\n\tthis.evaluate = evaluate;\n}\n\n/**\r\n * Reterns 2 new beziers split at t, i.e. for the ranges \r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm. \r\n */\nBezier.splitAt = function (bezier, t) {\n\tvar bezierPoints = bezier.bezierPoints;\n\n\tvar _bezierPoints2 = _slicedToArray(bezierPoints, 4),\n\t    _bezierPoints2$ = _slicedToArray(_bezierPoints2[0], 2),\n\t    x0 = _bezierPoints2$[0],\n\t    y0 = _bezierPoints2$[1],\n\t    _bezierPoints2$2 = _slicedToArray(_bezierPoints2[1], 2),\n\t    x1 = _bezierPoints2$2[0],\n\t    y1 = _bezierPoints2$2[1],\n\t    _bezierPoints2$3 = _slicedToArray(_bezierPoints2[2], 2),\n\t    x2 = _bezierPoints2$3[0],\n\t    y2 = _bezierPoints2$3[1],\n\t    _bezierPoints2$4 = _slicedToArray(_bezierPoints2[3], 2),\n\t    x3 = _bezierPoints2$4[0],\n\t    y3 = _bezierPoints2$4[1];\n\n\tvar s = 1 - t;\n\tvar t2 = t * t;\n\tvar t3 = t2 * t;\n\tvar s2 = s * s;\n\tvar s3 = s2 * s;\n\n\tvar part1 = [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n\n\tvar part2 = [part1[3], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n\n\treturn [new Bezier(part1), new Bezier(part2)];\n};\n\nmodule.exports = Bezier;\n\n},{\"../../numerical/functions/gaussian-quadrature.js\":36,\"../../polynomial/polynomial.js\":39,\"../../utils.js\":42,\"../../vector/vector.js\":43}],5:[function(require,module,exports){\n\"use strict\";\n\n/** \r\n * Basic circle class. \r\n */\nfunction Circle(center, radius) {\n\tthis.center = center;\n\tthis.radius = radius;\n}\n\nCircle.scale = function (circle, s) {\n\treturn new Circle(circle.center, circle.radius * s);\n};\n\nmodule.exports = Circle;\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\nvar Vector = require('../../vector/vector.js');\n\n/** \r\n * @constructor \t\n * \t\n * @param p {number[]} - The point coordinates.\n * @param {ListNode<Bezier>} bezierNode\t\n * @param t\r\n * @param type {MAT_CONSTANTS.pointType} \t\n *  'osculating'        : 0, // Osculating - Max curvatre inward,   \t\n *  'sharp'             : 1, // Sharp corner, \t\n *  'dull'              : 2, // dull corner, \t\n *  'reverseOsculating' : 3, // Osculating - Max curvature outward, \t\n *  'standard'          : 4, // just another point\r\n * @param {Number} order - For dull corners only; equals the cross of\r\n * \t\t  the tangents at the corner interface to impose an order on\r\n * \t\t  points with the same point coordinates or t values.   \r\n * @param {Circle} circle - The osculating circle at this point.\r\n * @param {Number} sharpness - Measure of corner sharpness.\r\n *   \t\n */\n// TODO - The order property should be a property of ContactPoint instead.\nvar PointOnShape = function PointOnShape(p, bezierNode, t, type, order, osculatingCircle, sharpness) {\n\n\tthis.bezierNode = bezierNode;\n\tthis.t = t;\n\tthis.type = type;\n\tthis.order = order; // z-order order arbitration decider to make all points on the shape well-ordered\n\tthis.osculatingCircle = osculatingCircle;\n\tthis.sharpness = sharpness;\n\t//if (sharpness) { console.log(sharpness); }\n\n\tthis.simpleKey = PointOnShape.makeSimpleKey(p);\n\t//this.p = p; // TODO - see below\n\n\t//---- Cache\n\t// Removed 2 lines below - if {PointOnShape} is called as parameter \n\t// it will more likely result in monomorphic behaviour as opposed \n\t// to polymorphic or megamorphic\n\tthis[0] = p[0];\n\tthis[1] = p[1];\n\tthis.key = PointOnShape.toString(this);\n};\n\nfunction dullCornerAt(shape, p) {\n\n\tvar dullCornerHash = shape.dullCornerHash;\n\tvar key = PointOnShape.makeSimpleKey(p); // First point\n\n\tvar result = dullCornerHash[key] || null;\n\n\t//console.log(result);\n\n\treturn result;\n}\n\n/**\r\n * Sets the order (to distinguish between points lying on top of each \r\n * other) of the contact point if it is a dull corner.\r\n *\r\n * Notes: Modifies p\r\n * \r\n * @param {PointOnShape} p \r\n * \r\n */\nPointOnShape.setPointOrder = function (shape, circle, p, _debug_) {\n\n\tvar dullCorner = dullCornerAt(shape, p);\n\n\tif (!dullCorner) {\n\t\treturn; /* or use different scheme */\n\t}\n\n\t//let bez = dullCorner.pointOnShape.bezierNode.item;\n\tvar bez = dullCorner.bezier;\n\tvar tan1pre = bez.tangent(1);\n\n\tvar tan1 = [tan1pre[1], -tan1pre[0]]; // rotate by -90 degrees\n\tvar tan2 = Vector.toUnitVector(Vector.fromTo(p, circle.center));\n\n\tvar crossTangents = -Vector.dot(tan1, tan2);\n\n\tp.order = crossTangents;\n\tp.key = PointOnShape.toString(p);\n\n\tif (_debug_) {\n\t\t// TODO Add a _debug_ flag to switch this on or off.\n\t\tif (_debug_.drawStuff) {\n\t\t\tif (dullCorner) {\n\t\t\t\t//_debug_.draw.line([p, circle.center], 'red thin5');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.order;\n};\n\n/**\t\n * Return a new point on the shape from given point shifted by a given t distance\t\n * \t\n * Δt The distance to shift the point\t\n * \t\n * @return {PointOnShape} Shifted point  \t\n */\nPointOnShape.shift = function (p, Δt) {\n\n\tif (Δt <= -1 || Δt >= 1) {\n\t\t// TODO: relatively easy to support the case where Δt can by any {Number}\t\n\t\tthrow 'Δt not in range (-1, 1); Δt was ' + Δt;\n\t}\n\n\tvar newBezierNode = p.bezierNode;\n\n\tvar t = p.t + Δt;\n\tif (t < 0) {\n\t\tt = t + 1;\n\t\tnewBezierNode = newBezierNode.prev;\n\t} else if (t > 1) {\n\t\tt = t - 1;\n\t\tnewBezierNode = newBezierNode.next;\n\t}\n\n\t//console.log(p.t, Δt, t, newBezierNode.item.evaluate(t));\t\n\n\treturn new PointOnShape(newBezierNode.item.evaluate(t), newBezierNode, t, MAT_CONSTANTS.pointType.standard, 0 /* order */\n\t);\n};\n\nPointOnShape.cloneAndAdv = function (p) {\n\treturn new PointOnShape(p.bezierNode.item.evaluate(p.t), p.bezierNode, p.t, p.type, p.order + p.order / 111111111111 // hack  \t\n\t);\n};\n\n/**\t\n * Takes a single point and splits it and moves it apart along shape boundary.\t\n * \t\r\n * @param p {PointOnShape} pointOnShape \n * @param Δt {Number} The distance (in t) to move the points apart. Ideally we would\t\n *        much prefer a pixel distance, but the implementation would be more complex. \t\n * \t\n * @return Splitted points as array, i.e. [p1,p2]\t\n */\nPointOnShape.split = function (p, Δt) {\n\treturn [PointOnShape.shift(p, -Δt), PointOnShape.shift(p, +Δt)];\n};\n\nPointOnShape.splitForward = function (p, Δt) {\n\treturn [p, PointOnShape.shift(p, +2 * Δt)];\n};\n\nPointOnShape.splitBack = function (p, Δt) {\n\treturn [PointOnShape.shift(p, -2 * Δt), p];\n};\n\nfunction typeToStr(type) {\n\tfor (var key in MAT_CONSTANTS.pointType) {\n\t\tif (MAT_CONSTANTS.pointType[key] === type) {\n\t\t\treturn key;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nPointOnShape.toString = function (p) {\n\treturn '' + p[0] + ', ' + p[1] + '|' + p.order + '|' + p.type;\n};\n\nPointOnShape.toHumanString = function (p) {\n\tvar str = '' + p[0] + ', ' + p[1] + ' | bz: ' + p.bezierNode.item.indx + ' | t: ' + p.t + ' | ord: ' + p.order + ' | ';\n\treturn str + typeToStr(p.type);\n};\n\nPointOnShape.makeSimpleKey = function (p) {\n\treturn '' + p[0] + ', ' + p[1];\n};\n\nPointOnShape.compare = function (a, b) {\n\tvar res = a.bezierNode.item.indx - b.bezierNode.item.indx;\n\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\tres = a.t - b.t;\n\tif (res !== 0) {\n\t\treturn res;\n\t}\n\n\treturn a.order - b.order;\n};\n\nmodule.exports = PointOnShape;\n\n},{\"../../mat-constants.js\":17,\"../../vector/vector.js\":43}],7:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar getContactCirclesAtBezierBezierInterface = require('../functions/get-contact-circles-at-bezier-bezier-interface.js');\nvar getBezierOsculatingCircles = require('../functions/get-bezier-osculating-circles.js');\nvar Util = require('../../utils.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar LlRbTree = require('../../ll-rb-tree//ll-rb-tree.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar Bezier = require('../../geometry/classes/bezier.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Svg = require('../../svg/svg.js');\nvar MatCircle = require('../../mat/classes/mat-circle.js');\nvar Vector = require('../../vector/vector.js');\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\n/** \r\n * A Shape represents the loop of individual bezier curves composing \r\n * an SVG element.\r\n * \r\n * @constructor  \r\n */\nvar Shape = function Shape(beziers, _debug_) {\n\n\tthis.beziers = beziers;\n\tthis.dullCornerHash = {};\n\n\tvar pointsOnShape = getInterestingPointsOnShape(this);\n\tvar usedPointsOnShape = determineUsedPoints(this, pointsOnShape);\n\tvar contactPointArr = usedPointsOnShape.map(createContactPoint);\n\n\tthis.contactPoints = createCoupledCpLoops(contactPointArr);\n\n\t//respacePoints(this.contactPoints, 30); \n\trespacePoints(this.contactPoints, 45);\n\n\tthis.for2Prongs = addPrelimMatCircles_CullPoints_AndGetPotential2Prongs(this.contactPoints, _debug_);\n\n\tif (_debug_) {\n\t\tdebugActionsOnShapeCreate(this, contactPointArr, _debug_);\n\t}\n\n\tfunction createContactPoint(pos) {\n\t\treturn new ContactPoint(pos, undefined);\n\t}\n};\n\nfunction determineUsedPoints(shape, pointsOnShape) {\n\tvar usedPointsOnShape = [];\n\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = pointsOnShape[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar pos = _step.value;\n\n\t\t\tvar intersects = Geometry.doesCircleIntersectShape(shape, pos.osculatingCircle, pos);\n\n\t\t\tpos.intersects = intersects;\n\n\t\t\tif (pos.type !== MAT_CONSTANTS.pointType.dull) {\n\t\t\t\tif (intersects) {\n\t\t\t\t\tusedPointsOnShape.push(pos);\n\t\t\t\t} else {\n\t\t\t\t\tusedPointsOnShape.push(pos);\n\t\t\t\t}\n\t\t\t} else if (intersects) {\n\t\t\t\t// Will later become a 2-prong point.\n\t\t\t\tusedPointsOnShape.push(pos);\n\t\t\t} else if (pos.type === MAT_CONSTANTS.pointType.dull) {\n\t\t\t\tif (!intersects) {\n\t\t\t\t\tusedPointsOnShape.push(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn usedPointsOnShape;\n}\n\nfunction createCoupledCpLoops(contactPointArr) {\n\n\tvar cpLoop = new LinkedLoop([], function (a, b) {\n\t\treturn ContactPoint.compare(a.item, b.item);\n\t});\n\n\tvar denseContactPoints = new LinkedLoop([], undefined);\n\n\tvar prevCpNode = undefined;\n\tvar prevCoupledCpNode = undefined;\n\tfor (var i = 0; i < contactPointArr.length; i++) {\n\t\tvar cp = contactPointArr[i];\n\t\tvar pos = cp.pointOnShape;\n\n\t\tprevCoupledCpNode = LinkedLoop.insert(denseContactPoints, cp, prevCoupledCpNode);\n\n\t\tif (pos.type === MAT_CONSTANTS.pointType.dull) {\n\t\t\tif (Math.acos(1 - pos.sharpness) * 180 / Math.PI > 16) {\n\t\t\t\tprevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\n\t\t\t}\n\t\t} else if (pos.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\tif (Math.acos(1 - pos.sharpness) * 180 / Math.PI > 16) {\n\t\t\t\tprevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\n\t\t\t}\n\t\t} else {\n\t\t\tprevCpNode = LinkedLoop.insert(cpLoop, cp, prevCpNode, prevCoupledCpNode);\n\t\t}\n\n\t\tprevCoupledCpNode.coupledNode = prevCpNode;\n\t}\n\n\treturn cpLoop;\n}\n\n/**\r\n * \r\n * @param contactPoints\r\n * @returns\r\n */\nfunction addPrelimMatCircles_CullPoints_AndGetPotential2Prongs(contactPoints, _debug_) {\n\n\tvar cpNode = contactPoints.head;\n\tvar for2Prongs = []; // The points that will be used for the initial 2-prong procedure\n\tvar toRemove = []; // Don't remove items inside loop.\n\tdo {\n\t\tvar cp = cpNode.item;\n\t\tvar pos = cp.pointOnShape;\n\t\tvar mCircle = MatCircle.create(pos.osculatingCircle, [cpNode]);\n\n\t\tif (pos.intersects) {\n\t\t\tfor2Prongs.push(cpNode);\n\t\t} else if (pos.type === MAT_CONSTANTS.pointType.dull) {\n\t\t\t/* TODO IMPORTANT remove this line, uncomment piece below \r\n    * it and implement the following strategy to find the \r\n    * 3-prongs: if deltas are conjoined due to dull corner, \r\n    * split the conjoinment by inserting successively closer \r\n    * (binary division) 2-prongs. If a 2-prong actually fails, \r\n    * simply remove the 1-prong at the dull corner.\r\n    */\n\t\t\t//console.log(cpNode);\n\t\t\ttoRemove.push(cpNode);\n\t\t\t/*\r\n   var oCircle = cp.matCircle;\r\n   \t\tif (_debug_) {\r\n   \t_debug_.draw.circle(oCircle.circle, 'orange thin10 nofill');\r\n   \t_debug_.draw.dot(oCircle.circle.center, 0.5, 'orange');\t\r\n   }\r\n   */\n\t\t} else if (pos.type === MAT_CONSTANTS.pointType.osculating) {\n\t\t\tif (_debug_) {\n\t\t\t\t_debug_.draw.dot(cp, 0.2, 'gray');\n\t\t\t\t_debug_.draw.dot(cp.matCircle.circle.center, 0.5, 'gray');\n\t\t\t\t_debug_.draw.circle(cp.matCircle.circle, 'gray thin10 nofill');\n\t\t\t}\n\t\t}\n\n\t\tcpNode.prevOnCircle = cpNode; // Trivial loop\n\t\tcpNode.nextOnCircle = cpNode; // ...\n\n\t\tcpNode = cpNode.next;\n\t} while (cpNode !== contactPoints.head);\n\n\tfor (var i = 0; i < toRemove.length; i++) {\n\t\tvar _cpNode = toRemove[i];\n\t\tLinkedLoop.remove(contactPoints, _cpNode);\n\t}\n\n\treturn for2Prongs;\n}\n\n/**\r\n * Respace points so that the total absolute curvature between\r\n * consecutive points are very roughly equal. \r\n * \r\n * @param {LinkedLoop<ContactPoint>} contactPoints\r\n * @returns undefined\r\n * \r\n * NOTES: Mutates contactPoints.\r\n */\nfunction respacePoints(contactPoints, maxAbsCurvatureInDegrees) {\n\n\t//let iii = 0;\n\n\tvar cpNode = contactPoints.head;\n\tvar recheck = void 0;\n\tdo {\n\t\trecheck = false;\n\n\t\tvar totalCurvatures = [];\n\t\tvar denseCpNode = cpNode.coupledNode;\n\n\t\tdo {\n\t\t\tvar c = getTotalAbsCurvatureBetweenCps([denseCpNode.item, denseCpNode.next.item]);\n\n\t\t\ttotalCurvatures.push({ cpNode: denseCpNode, c: c });\n\n\t\t\tdenseCpNode = denseCpNode.next;\n\t\t} while (denseCpNode.coupledNode !== cpNode.next);\n\n\t\tvar totalCurvature = sumCurvatures(totalCurvatures);\n\n\t\tcpNode.totalCurvatures = totalCurvatures;\n\t\tcpNode.totalCurvature = totalCurvature;\n\n\t\tvar totalInDegrees = totalCurvature * 180 / Math.PI;\n\t\t// if (totalInDegrees > 180 || totalInDegrees < 5) { console.log(totalInDegrees); }\n\t\tif (totalInDegrees > maxAbsCurvatureInDegrees) {\n\t\t\t// Add a point\n\t\t\t//console.log(totalCurvatures);\n\n\t\t\tvar accumTot = 0;\n\t\t\tvar tc = cpNode.totalCurvature; // cache\n\t\t\tvar bestIndx = undefined;\n\t\t\tvar leftDenseIndx = 0;\n\t\t\tvar rightDenseIndx = void 0;\n\t\t\tvar accumTotAtLeft = 0;\n\t\t\tvar accumTotAtRight = undefined;\n\t\t\tvar bestDiff = Number.POSITIVE_INFINITY;\n\t\t\tfor (var i = 0; i < totalCurvatures.length; i++) {\n\n\t\t\t\tvar _c = totalCurvatures[i].c;\n\t\t\t\tvar cTot = _c.totalCurvature + _c.totalTurn;\n\t\t\t\taccumTot += cTot;\n\n\t\t\t\tvar cpn = totalCurvatures[i].cpNode;\n\t\t\t\tif (accumTot <= tc / 2) {\n\t\t\t\t\tleftDenseIndx = i;\n\t\t\t\t\taccumTotAtLeft = accumTot;\n\t\t\t\t}\n\n\t\t\t\tif (!rightDenseIndx && accumTot > tc / 2) {\n\t\t\t\t\t// This may be out of bounds but really means cpNode.next\n\t\t\t\t\trightDenseIndx = i;\n\t\t\t\t\taccumTotAtRight = accumTot;\n\t\t\t\t}\n\n\t\t\t\tvar absDiff = Math.abs(tc / 2 - accumTot);\n\t\t\t\t// TODO - We can also add a weight for point values here\n\t\t\t\t// such that for instance inverse curvature points \n\t\t\t\t// carry more weight than dull corners, etc.\n\t\t\t\t// TODO Make the 1/4 or 1/3 below a constant that can\n\t\t\t\t// be set.\n\t\t\t\t//if (accumTot > tc/3 && accumTot < 2*tc/3 &&\n\t\t\t\tif (accumTot > tc / 4 && accumTot < 3 * tc / 4 && bestDiff > absDiff) {\n\t\t\t\t\t// If within middle 1/3 and better\n\n\t\t\t\t\tbestIndx = i;\n\t\t\t\t\tbestDiff = absDiff;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// aaa console.log(leftDenseIndx, bestIndx, rightDenseIndx);\n\n\t\t\tif (bestIndx !== undefined) {\n\t\t\t\t// Reify the point\n\t\t\t\tvar tcInfo = totalCurvatures[bestIndx];\n\n\t\t\t\t// Note that after the below insert cpNode.next will\n\t\t\t\t// equal the newly inserted cpNode.\n\t\t\t\tvar newCpNode = LinkedLoop.insert(contactPoints, tcInfo.cpNode.next.item, cpNode, tcInfo.cpNode.next);\n\t\t\t\ttcInfo.cpNode.next.coupledNode = newCpNode;\n\n\t\t\t\tcpNode.totalCurvatures = cpNode.totalCurvatures.slice(0, bestIndx + 1);\n\t\t\t\tcpNode.totalCurvature = sumCurvatures(cpNode.totalCurvatures);\n\n\t\t\t\trecheck = true; // Start again from same contact point.\n\n\t\t\t\t//iii++;\n\n\t\t\t\t//console.log(cpNode, newCpNode);\n\t\t\t} else {\n\t\t\t\t// We could not find an 'interesting' point to use, so\n\t\t\t\t// find some center point between the two contact \n\t\t\t\t// points.\n\n\n\t\t\t\tvar leftTcInfo = totalCurvatures[leftDenseIndx];\n\t\t\t\tvar rightTcInfo = totalCurvatures[rightDenseIndx];\n\n\t\t\t\tvar leftCpNode = leftTcInfo.cpNode;\n\t\t\t\tvar rightCpNode = rightTcInfo.cpNode;\n\n\t\t\t\tvar leftC = leftTcInfo.c;\n\n\t\t\t\tvar leftCp = leftTcInfo.cpNode.next;\n\t\t\t\tvar rightCp = rightTcInfo.cpNode.next;\n\n\t\t\t\t//aaa console.log(accumTotAtLeft,\taccumTotAtRight, tc/2);\n\n\n\t\t\t\tvar pos = getCPointBetweenCps(leftCpNode.item, rightCpNode.item, accumTotAtLeft, accumTotAtRight, tc / 2);\n\n\t\t\t\t/*\r\n    let newCp = new ContactPoint(pos, undefined);\r\n    let newCpNode = LinkedLoop.insert(\r\n    \t\tcontactPoints, \r\n    \t\tnewCp, \r\n    \t\tleftCpNode,\r\n    \t\tundefined\r\n    );\r\n    \r\n    let newDenseCpNode = LinkedLoop.insert(\r\n    \t\tdenseContactPoints, \r\n    \t\tnewCp, \r\n    \t\tcpNode,\r\n    \t\tundefined\r\n    );\r\n    \r\n    newCpNode.coupledNode = newDenseCpNode;\r\n    newDenseCpNode.coupledNode = newCpNode;\r\n    \r\n    \r\n    aaa\r\n    cpNode.totalCurvatures = cpNode.totalCurvatures.slice(\r\n    \t\t0, bestIndx\r\n    );\r\n    cpNode.totalCurvature = sumCurvatures(\r\n    \t\tcpNode.totalCurvatures\r\n    );\r\n    \r\n    recheck = true; // Start again from same contact point.\r\n    */\n\t\t\t}\n\t\t} else if (totalInDegrees < 15) {\n\t\t\t// Remove a point\n\t\t\t//console.log(totalCurvatures);\n\n\t\t}\n\n\t\tif (!recheck) {\n\t\t\tcpNode = cpNode.next;\n\t\t}\n\t} while (cpNode !== contactPoints.head /* && iii < 100*/);\n\n\t//console.log(iii);\n}\n\n/**\r\n * Finds a point on the shape between the given contact points which\r\n * is as close as possible to a point with accumalated abs curvature\r\n * (from accumAtLeft) equal to totAtMid.\r\n *  \r\n * @param leftCp\r\n * @param rightCp\r\n * @param accumTotAtLeft\r\n * @param accumTotAtRight\r\n * @param totAtMid\r\n * @returns {PointOnShape}\r\n */\nfunction getCPointBetweenCps(leftCp, rightCp, accumTotAtLeft, accumTotAtRight, totAtMid) {\n\n\tvar accumTo = totAtMid - accumTotAtLeft;\n\n\tvar posStart = leftCp.pointOnShape;\n\tvar posEnd = rightCp.pointOnShape;\n\n\tvar bezierNodeStart = posStart.bezierNode;\n\tvar bezierNodeEnd = posEnd.bezierNode;\n\n\tvar bezierNode = bezierNodeStart;\n\n\tvar totalTurn = 0;\n\tvar totalCurvature = 0;\n\tdo {\n\t\tvar turn = void 0;\n\t\tif (bezierNode !== bezierNodeEnd) {\n\t\t\tturn = Math.abs(getCurvatureAtInterface(bezierNode));\n\t\t} else {\n\t\t\tturn = 0;\n\t\t}\n\n\t\tvar curvature = void 0;\n\t\tvar interval = [0, 1];\n\t\tif (bezierNode === bezierNodeStart) {\n\t\t\tinterval[0] = posStart.t;\n\t\t}\n\t\tif (bezierNode === bezierNodeEnd) {\n\t\t\tinterval[1] = posEnd.t;\n\t\t}\n\t\tcurvature = bezierNode.item.getTotalAbsoluteCurvature(interval);\n\n\t\ttotalTurn += turn;\n\t\ttotalCurvature += curvature;\n\n\t\tvar totalBoth = totalTurn + totalCurvature;\n\t\tif (totalBoth >= accumTo) {\n\t\t\t// aaa console.log('accumTo: ' + accumTo, 'totalBoth: ' + totalBoth);\n\t\t\tbreak;\n\t\t}\n\n\t\tbezierNode = bezierNode.next;\n\t} while (bezierNode.prev !== bezierNodeEnd);\n\n\t//return { totalTurn, totalCurvature };\n}\n\nfunction sumCurvatures(curvatures) {\n\tvar total = 0;\n\n\tfor (var i = 0; i < curvatures.length; i++) {\n\t\tvar c = curvatures[i].c;\n\n\t\ttotal += c.totalTurn + c.totalCurvature;\n\t}\n\n\treturn total;\n}\n\n/**\r\n * \r\n * @param cps\r\n * @returns\r\n */\nfunction getTotalAbsCurvatureBetweenCps(_ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2),\n\t    cpStart = _ref2[0],\n\t    cpEnd = _ref2[1];\n\n\tvar posStart = cpStart.pointOnShape;\n\tvar posEnd = cpEnd.pointOnShape;\n\n\tvar bezierNodeStart = posStart.bezierNode;\n\tvar bezierNodeEnd = posEnd.bezierNode;\n\n\tvar bezierNode = bezierNodeStart;\n\n\tvar totalTurn = 0;\n\tvar totalCurvature = 0;\n\tdo {\n\t\tvar turn = void 0;\n\t\tif (bezierNode !== bezierNodeEnd) {\n\t\t\tturn = Math.abs(getCurvatureAtInterface(bezierNode));\n\t\t} else {\n\t\t\tturn = 0;\n\t\t}\n\n\t\tvar curvature = void 0;\n\t\tvar interval = [0, 1];\n\t\tif (bezierNode === bezierNodeStart) {\n\t\t\tinterval[0] = posStart.t;\n\t\t}\n\t\tif (bezierNode === bezierNodeEnd) {\n\t\t\tinterval[1] = posEnd.t;\n\t\t}\n\t\tcurvature = bezierNode.item.getTotalAbsoluteCurvature(interval);\n\n\t\ttotalTurn += turn;\n\t\ttotalCurvature += curvature;\n\n\t\tbezierNode = bezierNode.next;\n\t} while (bezierNode.prev !== bezierNodeEnd);\n\n\treturn { totalTurn: totalTurn, totalCurvature: totalCurvature };\n}\n\nfunction debugActionsOnShapeCreate(shape, contactPointArr, _debug_) {\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = contactPointArr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar contactPoint = _step2.value;\n\n\t\t\tif (contactPoint.pointOnShape.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\t\t_debug_.draw.dot(contactPoint.pointOnShape, 0.2, 'green');\n\t\t\t}\n\t\t\tif (contactPoint.pointOnShape.type === MAT_CONSTANTS.pointType.dull) {\n\t\t\t\t_debug_.draw.dot(contactPoint.pointOnShape, 0.4, 'orange');\n\t\t\t\t//_debug_.draw.dot(contactPoint.pointOnShape, 1.5, 'orange');\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\t_debug_.shape = shape;\n\tif (_debug_.drawStuff) {\n\t\t_debug_.drawSomeStuff(shape);\n\t}\n}\n\n/**\r\n * \r\n * @param {Shape} shape\r\n * @returns {[{pointOnShape}]} - A list of interesting points on the \r\n * \t\t\tshape.\r\n */\nfunction getInterestingPointsOnShape(shape) {\n\tvar beziers = shape.beziers;\n\tvar dullCornerHash = shape.dullCornerHash;\n\n\tvar points = [];\n\tvar allPoints = [];\n\n\tvar node = beziers.head;\n\tdo {\n\t\tvar bezier = node.item;\n\n\t\tvar pointsOnShape = void 0;\n\t\tpointsOnShape = getContactCirclesAtBezierBezierInterface([node.prev, node], dullCornerHash);\n\t\tArray.prototype.push.apply(allPoints, pointsOnShape);\n\t\tpointsOnShape = getBezierOsculatingCircles(node);\n\t\tArray.prototype.push.apply(allPoints, pointsOnShape);\n\n\t\tnode = node.next;\n\t} while (node !== beziers.head);\n\n\t// Ensure order - first point may be ordered last at this stage.\n\tvar firstPoint = allPoints[0];\n\tvar lastPoint = allPoints[allPoints.length - 1];\n\tif (PointOnShape.compare(firstPoint, lastPoint) > 0) {\n\t\tallPoints.push(firstPoint); // Add the first point to the end\n\t\tallPoints.splice(0, 1); // ... and remove the front point.\n\t}\n\n\treturn allPoints;\n}\n\n/**\r\n * Returns the boundary piece that starts at the \r\n * immediate previous point on the shape and ends at \r\n * the immediate next point.  \r\n * \r\n * Notes:\r\n *   - Uses a red-black tree to quickly find the required bounds\r\n */\nShape.getNeighbouringPoints = function (shape, pointOnShape) {\n\n\tvar cptree = shape.contactPoints.cptree;\n\n\tvar cps = LlRbTree.findBounds(cptree, { item: new ContactPoint(pointOnShape) });\n\n\tif (!cps[0]) {\n\t\t// Smaller than all -> cptree.min() === cps[1].data\n\t\treturn [LlRbTree.max(cptree.root), LlRbTree.min(cptree.root)];\n\t}\n\tif (!cps[1]) {\n\t\t// Larger than all -> cptree.max() === cps[0].data\n\t\treturn [LlRbTree.max(cptree.root), LlRbTree.min(cptree.root)];\n\t}\n\n\treturn [cps[0].data, cps[1].data];\n};\n\nfunction getTotalBy(f, shape) {\n\n\treturn function (shape) {\n\t\tvar beziers = shape.beziers;\n\n\t\tvar node = beziers.head;\n\t\tvar total = 0;\n\t\tdo {\n\t\t\ttotal += f(node);\n\n\t\t\tnode = node.next;\n\t\t} while (node !== beziers.head);\n\n\t\treturn total;\n\t};\n}\n\n/**\r\n * \r\n * \r\n * @param bezierNode\r\n * @returns\r\n */\nfunction getCurvatureAtInterface(bezierNode) {\n\tvar ts = [1, 0];\n\n\tvar beziers = [];\n\n\tbeziers.push(bezierNode.item);\n\tbeziers.push(bezierNode.next.item);\n\tvar tans = [beziers[0].tangent(1), beziers[1].tangent(0)];\n\n\t// The integral of a kind of Dirac Delta function.\n\tvar cosθ = Vector.dot(tans[0], tans[1]);\n\tvar sinθ = Vector.cross(tans[0], tans[1]);\n\tvar θ = Math.acos(cosθ);\n\n\treturn sinθ >= 0 ? θ : -θ;\n}\n\nShape.getTotalCurvature = getTotalBy(function (bezierNode) {\n\treturn +bezierNode.item.getTotalCurvature() + getCurvatureAtInterface(bezierNode);\n});\n\nShape.getTotalAbsoluteCurvature = getTotalBy(function (bezierNode) {\n\treturn bezierNode.item.getTotalAbsoluteCurvature() + Math.abs(getCurvatureAtInterface(bezierNode));\n});\n\nShape.forAllBeziers = function (shape, f) {\n\tvar node = shape.beziers.head;\n\tdo {\n\t\tvar bezier = node.item;\n\n\t\tf(bezier);\n\n\t\tnode = node.next;\n\t} while (node !== shape.beziers.head);\n};\n\nmodule.exports = Shape;\n\n//218\n\n},{\"../../geometry/classes/bezier.js\":4,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/geometry.js\":13,\"../../linked-loop/linked-loop.js\":14,\"../../ll-rb-tree//ll-rb-tree.js\":16,\"../../mat-constants.js\":17,\"../../mat/classes/contact-point.js\":19,\"../../mat/classes/mat-circle.js\":20,\"../../svg/svg.js\":41,\"../../utils.js\":42,\"../../vector/vector.js\":43,\"../functions/get-bezier-osculating-circles.js\":9,\"../functions/get-contact-circles-at-bezier-bezier-interface.js\":12}],8:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Bezier = require('../classes/bezier.js');\n\n/** \r\n * NOTE: Finding osculating circles requires finding local maxima of parametric cubic curves\r\n *    which involves extensive tedious algebra. \r\n *    \r\n * See the paper at: http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\r\n * Lets get cracking (in finding these extrema).\r\n * We will use variable naming conventions as in the paper above\r\n */\nfunction calcCurvatureExtremaBrackets(bezier) {\n\tvar _bezier$bezierPoints = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints$ = _slicedToArray(_bezier$bezierPoints[0], 2),\n\t    x0 = _bezier$bezierPoints$[0],\n\t    y0 = _bezier$bezierPoints$[1],\n\t    _bezier$bezierPoints$2 = _slicedToArray(_bezier$bezierPoints[1], 2),\n\t    x1 = _bezier$bezierPoints$2[0],\n\t    y1 = _bezier$bezierPoints$2[1],\n\t    _bezier$bezierPoints$3 = _slicedToArray(_bezier$bezierPoints[2], 2),\n\t    x2 = _bezier$bezierPoints$3[0],\n\t    y2 = _bezier$bezierPoints$3[1],\n\t    _bezier$bezierPoints$4 = _slicedToArray(_bezier$bezierPoints[3], 2),\n\t    x3 = _bezier$bezierPoints$4[0],\n\t    y3 = _bezier$bezierPoints$4[1];\n\n\tvar brackets = [];\n\n\t// Bezier points translated to origin;\n\tvar P_1x = x1 - x0;\n\tvar P_1y = y1 - y0;\n\tvar P_2x = x2 - x0;\n\tvar P_2y = y2 - y0;\n\tvar P_3x = x3 - x0;\n\tvar P_3y = y3 - y0;\n\n\t// Distance to consecutive points\n\tvar W_0x = P_1x;\n\tvar W_1x = P_2x - P_1x;\n\tvar W_2x = P_3x - P_2x;\n\tvar W_0y = P_1y;\n\tvar W_1y = P_2y - P_1y;\n\tvar W_2y = P_3y - P_2y;\n\n\t//******** Check for degenerate case in which cubic parametric curve becomes quadratic\n\tif (W_0x - 2 * W_1x + W_2x === 0 && W_0y - 2 * W_1y + W_2y === 0) {}\n\t// TODO - This case is simpler due to being quadratic but we're lazy now and will skip it for the moment\n\t// and just make the curvature extremum search between -10 and 10 - FIX!!!!!! \n\t//extrema_intervals = [-10,10]; \n\n\n\t// See : http://ac.els-cdn.com/S037704270000529X/1-s2.0-S037704270000529X-main.pdf?_tid=0b25a2cc-ad35-11e5-a728-00000aacb362&acdnat=1451288083_86359fc83af9dec3232c90a6d2e71031\n\t//******** Rotate curve so that W0 - 2W1 + W2 = (0, (1/3)a), a != 0\n\tvar atan_numer = P_3x - 3 * P_2x + 3 * P_1x;\n\tvar atan_denom = P_3y - 3 * P_2y + 3 * P_1y;\n\tvar atan_numer_squared = atan_numer * atan_numer;\n\tvar atan_denom_squared = atan_denom * atan_denom;\n\tvar radpre = atan_numer_squared / atan_denom_squared + 1;\n\tvar rad = Math.sqrt(radpre);\n\tvar cos_theta = 1 / rad;\n\tvar sin_theta;\n\tif (cos_theta === 0) {\n\t\t// edge case\n\t\tsin_theta = 1;\n\t} else {\n\t\tsin_theta = atan_numer / (atan_denom * rad);\n\t}\n\n\t// For next rotated points see Maxima file bez5 - here we skip expensive trig evaluations\n\tvar R_0x = 0;\n\tvar R_0y = 0;\n\tvar R_1x = P_1x * cos_theta - P_1y * sin_theta;\n\tvar R_1y = P_1x * sin_theta + P_1y * cos_theta;\n\tvar R_2x = P_2x * cos_theta - P_2y * sin_theta;\n\tvar R_2y = P_2x * sin_theta + P_2y * cos_theta;\n\tvar R_3x = P_3x * cos_theta - P_3y * sin_theta;\n\tvar R_3y = P_3x * sin_theta + P_3y * cos_theta;\n\n\t// Modify W_0x, etc. to be correct for new rotated curve \n\tW_0x = R_1x;\n\tW_1x = R_2x - R_1x;\n\tW_2x = R_3x - R_2x;\n\tW_0y = R_1y;\n\tW_1y = R_2y - R_1y;\n\tW_2y = R_3y - R_2y;\n\n\tvar a_ = 3 * (W_0y - 2 * W_1y + W_2y);\n\tvar dif = R_2x - 2 * R_1x; // which = W_1x - W_0x;\n\tif (dif === 0) {\n\t\t// Case 1 (special) - W_1x - W_0x === 0\n\t\t// Degenerate to cubic function\t\n\n\t\tif (W_0x !== 0) {// Otherwise we have a straight line x=0 ! \n\t\t\t// TODO - FINISH!!!\n\t\t\t// TODO - we also still need to check for degenerate cubic (see start of paper)\n\t\t}\n\t} else {\n\t\tvar mu;\n\t\tvar lambda;\n\t\tvar gamma1;\n\t\tvar gamma2;\n\t\tvar sigd_;\n\t\tvar b_;\n\t\tvar ssigd_;\n\t\tvar sda;\n\t\tvar sdb;\n\t\tvar ksi_pre1;\n\t\tvar ksi_pre2;\n\t\tvar ksi1;\n\t\tvar ksi2;\n\n\t\t(function () {\n\t\t\t// Case 2 (usual) - W_1x - W_0x !== 0\n\n\t\t\tif (dif < 0) {\n\t\t\t\t// Reflect curve accross y-axis to make dif > 0\n\t\t\t\tR_1x = -R_1x;\n\t\t\t\tR_2x = -R_2x;\n\t\t\t\tR_3x = -R_3x;\n\n\t\t\t\t// Modify W_0x, etc. to be correct for new reflected \n\t\t\t\tW_0x = -W_0x;\n\t\t\t\tW_1x = -W_1x;\n\t\t\t\tW_2x = -W_2x;\n\n\t\t\t\tdif = -dif;\n\t\t\t}\n\n\t\t\t//console.log(W_0x, W_1x, W_2x);\n\n\t\t\t// From the paper:\n\t\t\t// All curves has exactly one of 4 cases\n\t\t\t// 1. It has a single inflection point and exactly 2 curvature maxima (symmetrically positioned about inflection point)\n\t\t\t//    This is the case if dif === 0 in above code\n\t\t\t// 2. It has a single cusp - we ignore this case for now - but we must still do it!\n\t\t\t// 3. It has a point of self-intersection - occurs if d < 0 in paper (in code d is called sigd_) \n\t\t\t// 4. It has 2 inflection points, no cusps, no self-intersections\n\t\t\t//    It can have either 3 or 5 curvature extrema\n\t\t\t//    a. The case of 5 curvature extrema is ignored for now - in the paper it is mentioned to even find such a curve is difficult \n\t\t\t//       and it seems such curves have very sharp curvature at one point which should not usually occur in an SVG shape. \n\t\t\t//       But this case should later be included or we'll miss some points.\n\t\t\t//    b. There are 3 curvature extrema:\n\t\t\t//       Extrema occur in the range (-inf, -sqrt(d)), (-sqrt(d), sqrt(d)), (sqrt(d), inf)\n\t\t\t//       Since we dont know how to select -inf and inf we will just choose them to be -10 and 11 \n\t\t\t//       (remember bezier runs from t=0 to t=1). If Brent's method runs out of the (0,1) interval we stop and use\n\t\t\t//       0 or 1 as the extremum? Remember extrema can also occur at t=0 and t=1!\n\t\t\t//\n\t\t\t// At the moment we only test for case 1 and 4b, but in future we can test and eliminate the other cases\n\n\n\t\t\tmu = 6 * dif;\n\t\t\tlambda = 3 * a_ * W_0x / (mu * mu);\n\t\t\tgamma1 = 3 * a_ * W_0y / (mu * mu);\n\t\t\tgamma2 = 3 * (W_1y - W_0y) / mu;\n\t\t\tsigd_ = lambda * lambda - 2 * gamma2 * lambda + gamma1; // This d in the paper\n\n\t\t\tb_ = 2 * (gamma2 - lambda);\n\n\t\t\t/** Returns t **/\n\n\t\t\tvar deReParameterize = function deReParameterize(sigma) {\n\t\t\t\treturn (sigma - lambda) * (mu / a_);\n\t\t\t};\n\n\t\t\tvar deReParameterizeBoundary = function deReParameterizeBoundary(boundary) {\n\t\t\t\treturn [deReParameterize(boundary[0]), deReParameterize(boundary[1])];\n\t\t\t};\n\n\t\t\t/**  and clips to [0,1] or returns false if not within [0,1] **/\n\t\t\tvar fixBoundary = function fixBoundary(bound) {\n\t\t\t\tvar b0 = bound[0];\n\t\t\t\tvar b1 = bound[1];\n\n\t\t\t\tif (b0 < 0 && b1 < 0 || b0 > 1 && b1 > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (b0 < 0) {\n\t\t\t\t\tb0 = 0;\n\t\t\t\t}\n\t\t\t\tif (b0 > 1) {\n\t\t\t\t\tb0 = 1;\n\t\t\t\t}\n\t\t\t\tif (b1 < 0) {\n\t\t\t\t\tb1 = 0;\n\t\t\t\t}\n\t\t\t\tif (b1 > 1) {\n\t\t\t\t\tb1 = 1;\n\t\t\t\t}\n\n\t\t\t\treturn [b0, b1];\n\t\t\t};\n\n\t\t\tif (sigd_ > 0) {\n\t\t\t\tssigd_ = Math.sqrt(sigd_);\n\n\t\t\t\t//console.log(ssigd_);\n\t\t\t\t// de-reparametize\n\t\t\t\t// Note: the sda and sdb here are the inflection points for a case iv !!!!!\n\t\t\t\t//       there are easier ways to calculate these\n\n\t\t\t\tsda = -ssigd_;\n\t\t\t\tsdb = ssigd_;\n\t\t\t\t//var sd = order(sda,sdb);\n\n\t\t\t\tbrackets = [[Number.NEGATIVE_INFINITY, sda], [sda, sdb], [sdb, Number.POSITIVE_INFINITY]].map(deReParameterizeBoundary).map(fixBoundary);\n\t\t\t} else if (sigd_ < 0) {\n\t\t\t\t// Loop \n\t\t\t\t// Note: The loop intersection may be outside t=[0,1]. In fact, for a well behaved shape this is always the case.\n\t\t\t\t//       But, curvature maxima may still occur inside t=[0,1] of course\n\t\t\t\t//\n\t\t\t\t// There can be 1 or 3 maxima of curvature\n\n\t\t\t\tksi_pre1 = 2 * b_ * b_ - 8 * sigd_ - 3;\n\n\n\t\t\t\tif (ksi_pre1 < 0) {\n\t\t\t\t\tbrackets = [[0, Math.sqrt(-3 * sigd_)]].map(deReParameterizeBoundary).map(fixBoundary);\n\t\t\t\t} else {\n\t\t\t\t\tksi_pre2 = Math.sqrt(5 * ksi_pre1);\n\t\t\t\t\tksi1 = (-5 * b_ - ksi_pre2) / 10;\n\t\t\t\t\tksi2 = (-5 * b_ + ksi_pre2) / 10;\n\n\n\t\t\t\t\tbrackets = [[Number.NEGATIVE_INFINITY, ksi1], [ksi1, Math.min(0, ksi2)], [Math.max(0, ksi2), Math.sqrt(-3 * sigd_)]].map(deReParameterizeBoundary).map(fixBoundary);\n\t\t\t\t}\n\t\t\t} else if (sigd_ === 0) {\n\t\t\t\t// TODO Cusp - ignore for now - lazy\n\t\t\t}\n\t\t})();\n\t}\n\n\treturn brackets;\n}\n\nmodule.exports = calcCurvatureExtremaBrackets;\n\n},{\"../classes/bezier.js\":4}],9:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Bezier = require('../classes/bezier.js');\nvar calcBezierCurvatureExtremaBrackets = require('./calc-bezier-curvature-extrema.js');\nvar MAT_CONSTANTS = require('../../mat-constants.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Poly = require('../../polynomial/polynomial.js');\n\nvar BRENT_TOLERANCE = 1e-12;\n\n/** \r\n * Finds the osculating circles for the given bezier. \r\n **/\nfunction getBezierOsculatingCircles(bezierNode) {\n\n\tvar pointsOnShape = [];\n\n\tvar root;\n\tvar bezier = bezierNode.item;\n\tvar brackets = calcBezierCurvatureExtremaBrackets(bezier);\n\n\tvar lenb = brackets.length;\n\tfor (var k = 0; k < lenb; k++) {\n\t\tvar bracket = brackets[k];\n\t\tif (!bracket) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar _root = lookForRoot(bezier, bracket);\n\t\tif (!_root) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar pointDetails = getCircleAtRoot(bezier, _root, bracket);\n\t\tif (!pointDetails) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar p = pointDetails.p,\n\t\t    circle = pointDetails.circle,\n\t\t    type = pointDetails.type;\n\n\t\tvar pos = new PointOnShape(p, bezierNode, _root, type, 0, circle);\n\n\t\t//oCircles.push(oCircle);\n\t\tpointsOnShape.push(pos);\n\t}\n\n\t// TODO - maybe just add them in the correct order to start with\n\t/*\r\n oCircles.sort(function(a,b) {\r\n \treturn PointOnShape.compare(a.pointOnShape, b.pointOnShape);\r\n });\r\n */\n\tpointsOnShape.sort(PointOnShape.compare);\n\n\t//return oCircles;\n\treturn pointsOnShape;\n}\n\nfunction lookForRoot(bezier, _ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2),\n\t    minsd = _ref2[0],\n\t    maxsd = _ref2[1];\n\n\t// At this point there can be exactly 0 or 1 roots within [minsd, maxsd]\n\tvar c0 = bezier.dκ(minsd);\n\tvar c1 = bezier.dκ(maxsd);\n\n\tif (c0 * c1 >= 0) {\n\t\treturn;\n\t}\n\n\t// There is exactly one root in the interval.\n\tvar root = Poly.brent(bezier.dκ, minsd, maxsd /*, \r\n                                               BRENT_TOLERANCE*/\n\t);\n\n\treturn root;\n}\n\nfunction getCircleAtRoot(bezier, root, _ref3) {\n\tvar _ref4 = _slicedToArray(_ref3, 2),\n\t    minsd = _ref4[0],\n\t    maxsd = _ref4[1];\n\n\t// TODO - still need to determine curve orientation\n\tvar κ = -bezier.κ(root);\n\n\tif (κ > 0) {\n\t\t// Bending inwards.\n\n\t\t// Check if local extrema is a maximum or minimum.\n\t\tvar κAtMinsd = -bezier.κ(minsd);\n\t\tvar κAtMaxsd = -bezier.κ(maxsd);\n\n\t\tif (κ > κAtMinsd && κ > κAtMaxsd) {\n\t\t\t// maximum\n\t\t} else if (κ <= κAtMinsd && κ <= κAtMaxsd) {\n\t\t\t// minimum\n\t\t\t// TODO Good point for 2-prong?\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvar radius = void 0;\n\tvar type = void 0;\n\tif (κ < 0) {\n\t\t// Curving wrong way, but probably a significant point to \n\t\t// put a 2-prong.\n\t\tradius = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t\ttype = MAT_CONSTANTS.pointType.reverseOsculating; // 3\n\t} else {\n\t\tradius = Math.min(1 / κ, MAT_CONSTANTS.maxOsculatingCircleRadius);\n\t\ttype = MAT_CONSTANTS.pointType.osculating;\n\t}\n\n\tvar normal = bezier.normal(root);\n\tvar p = bezier.evaluate(root);\n\tvar cc = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n\n\tvar circle = new Circle(cc, radius);\n\n\treturn { p: p, circle: circle, type: type };\n}\n\nmodule.exports = getBezierOsculatingCircles;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../mat-constants.js\":17,\"../../polynomial/polynomial.js\":39,\"../classes/bezier.js\":4,\"./calc-bezier-curvature-extrema.js\":8}],10:[function(require,module,exports){\n'use strict';\n\nvar getClosestPointOnBezierPiece = require('./get-closest-point-on-bezier-piece.js');\nvar Geometry = require('../geometry.js');\nvar Vector = require('../../vector/vector.js');\nvar PointOnShape = require('../classes/Point-on-shape.js');\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\n/**\r\n * Gets the closest boundary point to the given point, limited to the\r\n * given bezier pieces.\r\n * \r\n * @param {Shape} shape\r\n * @param {[PointOnShape]} δ - Start and end points for boundary\r\n *        traversal.\r\n * @param {Point} point\r\n * @param {Point} exclPoint Exclude this point and a small \r\n *        neighbourhood around it in search. \r\n * \r\n * @returns {PointOnShape} The closest point.\r\n */\nfunction getClosestBoundaryPointToPoint(bezierPieces_, point, exclPoint, touchedBezierNode, t, _debug_, slog_) {\n\n\tif (slog_) {\n\t\t//console.log('tes')\n\t}\n\tvar tGap = 0.001; // TODO Make const and put somewhere\n\t//const tGap = 0.0000001; // TODO Make const and put somewhere\n\n\tvar bezierPieces = cullBezierPieces(bezierPieces_, point);\n\n\tvar bestDistance = Number.POSITIVE_INFINITY;\n\tvar pos = void 0;\n\t//\n\tvar ii = 0;\n\t//\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar bezierPiece = _step.value;\n\n\t\t\t//\n\t\t\tii++;\n\t\t\t//\n\t\t\tvar slog = slog_ && ii === 1;\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar closestPointAndDistance = getClosestPointOnBezierPiece(bezierPiece, point, exclPoint, tGap, touchedBezierNode, t, _debug_, slog);\n\n\t\t\tvar d = closestPointAndDistance.d,\n\t\t\t    p = closestPointAndDistance.p;\n\n\n\t\t\tif (d < bestDistance) {\n\t\t\t\t//if (slog_) { console.log(ii, d); }\n\t\t\t\tpos = new PointOnShape(p.p, bezierPiece.bezierNode, p.t, MAT_CONSTANTS.pointType.standard, 0, undefined // TODO!! aaa\n\t\t\t\t);\n\t\t\t\tbestDistance = d;\n\t\t\t}\n\t\t}\n\n\t\t//if (bestDistance > 10000) { console.log('aaaaaaaaaaaaaaa'); }\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pos;\n}\n\nfunction cullBezierPieces(bezierPieces, p) {\n\n\tvar CULL_THRESHOLD = 5; // TODO Put somewhere better.\n\n\tvar shortCircuit = bezierPieces.length > CULL_THRESHOLD;\n\tif (shortCircuit) {\n\t\t// First get an initial point such that the closest point \n\t\t// can not be further than this point.\n\t\tvar bestSquaredDistance = getClosePoint(bezierPieces, p);\n\t\tbezierPieces = cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance);\n\t\tbezierPieces = cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance);\n\t}\n\n\treturn bezierPieces;\n}\n\n/**\r\n * Finds an initial point such that the closest point\r\n * can not be further than this point.\r\n */\nfunction getClosePoint(bezierPieces, p) {\n\tvar bestSquaredDistance = Number.POSITIVE_INFINITY;\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = bezierPieces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar bezierPiece = _step2.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar p1 = bezier.evaluate(bezierPiece.tRange[0]);\n\t\t\tvar p2 = bezier.evaluate(bezierPiece.tRange[1]);\n\n\t\t\tvar d1 = Vector.squaredDistanceBetween(p, p1);\n\t\t\tvar d2 = Vector.squaredDistanceBetween(p, p2);\n\t\t\tvar d = Math.min(d1, d2);\n\n\t\t\tif (d < bestSquaredDistance) {\n\t\t\t\tbestSquaredDistance = d;\n\t\t\t}\n\t\t}\n\n\t\t// The extra bit is to account for floating point precision \n\t\t// TODO change 0.01 below to more meaningfull value dependent on \n\t\t// shape dimensions, etc.\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestSquaredDistance + 0.01;\n}\n\n/**\r\n * When checking distances, ignore all those with closest \r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByLooseBoundingBox(bezierPieces, p, bestSquaredDistance) {\n\n\tvar candidateBezierPieces = [];\n\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = bezierPieces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar bezierPiece = _step3.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar looseBoundingBox = bezier.getBoundingBox();\n\t\t\tvar d = Geometry.getClosestSquareDistanceToRect(looseBoundingBox, p);\n\t\t\tif (d <= bestSquaredDistance) {\n\t\t\t\tcandidateBezierPieces.push(bezierPiece);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn candidateBezierPieces;\n}\n\n/**\r\n * When checking distances, ignore all those with closest \r\n * possible distance further than 'bestSquaredDistance',\r\n * i.e. cull them.\r\n */\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\n\n\tvar candidateBezierPieces = [];\n\n\tvar _iteratorNormalCompletion4 = true;\n\tvar _didIteratorError4 = false;\n\tvar _iteratorError4 = undefined;\n\n\ttry {\n\t\tfor (var _iterator4 = bezierPieces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\tvar bezierPiece = _step4.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar tightBoundingBox = bezier.getBoundingBoxTight();\n\t\t\tvar d = Geometry.closestSquaredDistanceToRotatedRect(bezier, p);\n\t\t\tif (d <= bestSquaredDistance) {\n\t\t\t\tcandidateBezierPieces.push(bezierPiece);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError4 = true;\n\t\t_iteratorError4 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t_iterator4.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError4) {\n\t\t\t\tthrow _iteratorError4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn candidateBezierPieces;\n}\n\nmodule.exports = getClosestBoundaryPointToPoint;\n\n},{\"../../mat-constants.js\":17,\"../../vector/vector.js\":43,\"../classes/Point-on-shape.js\":2,\"../geometry.js\":13,\"./get-closest-point-on-bezier-piece.js\":11}],11:[function(require,module,exports){\n'use strict';\n\nvar Geometry = require('../geometry.js');\nvar Vector = require('../../vector/vector.js');\n\n/**\r\n * \r\n */\nfunction getClosestPointOnBezierPiece(bezierPiece, point, exclPoint, tGap, touchedBezierNode, t, _debug_, slog) {\n\n\tif (_debug_) {\n\t\t_debug_.cpCalcs++;\n\t}\n\n\tvar bezierNode = bezierPiece.bezierNode;\n\n\tvar tRanges = [bezierPiece.tRange];\n\n\tvar p = Geometry.closestPointBetween_PointAndBezier(bezierNode, point, bezierPiece.tRange, touchedBezierNode, t, _debug_, slog);\n\n\tif (!p) {\n\t\treturn { d: Number.POSITIVE_INFINITY, p: undefined };\n\t}\n\n\tvar d = Vector.distanceBetween(p.p, point);\n\n\treturn { d: d, p: p };\n}\n\nmodule.exports = getClosestPointOnBezierPiece;\n\n},{\"../../vector/vector.js\":43,\"../geometry.js\":13}],12:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = require('../../mat-constants.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Vector = require('../../vector/vector.js');\n\n//const CROSS_TANGENT_LIMIT = 0.2756 // 16 degrees\n//const CROSS_TANGENT_LIMIT = 0.2588 // 15 degrees\n//const CROSS_TANGENT_LIMIT = 0.0698 // 4 degrees\n//const CROSS_TANGENT_LIMIT = 0.0167 // 1 degree\n//const CROSS_TANGENT_LIMIT = 0.0050 // 1/4 degree roughly\nvar CROSS_TANGENT_LIMIT = 0.0000; // 0 degrees\n\n\n/** \r\n * Get the circles at the bezier-bezier interface points with circle\r\n * curvature coinciding with the bezier curvature at those points. \r\n * \r\n * @param {[ListNode<Bezier>]} bezierNodes - The two bezier nodes.\r\n **/\nfunction getContactCirclesAtBezierBezierInterface(bezierNodes, dullCornerHash) {\n\n\tvar ts = [1, 0];\n\n\tvar beziers = [0, 1].map(function (i) {\n\t\treturn bezierNodes[i].item;\n\t});\n\tvar tans = [0, 1].map(function (i) {\n\t\treturn beziers[i].tangent(ts[i]);\n\t});\n\n\tvar crossTangents = +Vector.cross(tans[0], tans[1]);\n\tvar negDot = -Vector.dot(tans[0], tans[1]);\n\t// The if below is important. Due to floating point approximation\n\t// it sometimes happen that crossTangents !== 0 but\n\t// negDot === -1. Remove the if and see what happens. :)\n\tif (crossTangents === 0 || negDot === -1) {\n\t\t// Too close to call \n\t\t// Careful, dullCornerHash might not be set.\n\t\treturn [];\n\t}\n\n\tvar p = beziers[0].bezierPoints[3];\n\n\tif (crossTangents < -CROSS_TANGENT_LIMIT) {\n\t\t// Sharp corner?\n\n\t\tvar pos = new PointOnShape(p, bezierNodes[0], 1, MAT_CONSTANTS.pointType.sharp, 0, new Circle(p, 0), 1 + negDot // The higher, the sharper\n\t\t);\n\n\t\treturn [pos];\n\t}\n\n\tif (crossTangents > 0) {\n\t\tvar key = PointOnShape.makeSimpleKey(p);\n\t\tdullCornerHash[key] = { bezier: beziers[0] };\n\t\t//console.log('a');\n\t}\n\n\tif (crossTangents <= CROSS_TANGENT_LIMIT) {\n\t\treturn [];\n\t}\n\n\t//---- Dull corner\n\t//let oCircles = [];\n\tvar pointsOnShape = [];\n\n\tvar orders = [-1, negDot];\n\tfor (var i = 0; i < 2; i++) {\n\n\t\tvar κ = -beziers[i].κ(ts[i]);\n\n\t\tvar radius = Math.min(1 / κ, MAT_CONSTANTS.maxOsculatingCircleRadius);\n\t\tif (radius < 0) {\n\t\t\t// Negative curvature\n\t\t\tradius = MAT_CONSTANTS.maxOsculatingCircleRadius;\n\t\t}\n\n\t\tvar normal = beziers[i].normal(ts[i]);\n\n\t\tvar cc = [p[0] + normal[0] * radius, p[1] + normal[1] * radius];\n\n\t\tvar _pos = new PointOnShape(p, bezierNodes[i], ts[i], MAT_CONSTANTS.pointType.dull, orders[i], new Circle(cc, radius), 1 + negDot);\n\n\t\tpointsOnShape.push(_pos);\n\t}\n\n\treturn pointsOnShape;\n}\n\nmodule.exports = getContactCirclesAtBezierBezierInterface;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../mat-constants.js\":17,\"../../vector/vector.js\":43}],13:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Util = require('../utils.js');\nvar Poly = require('../polynomial/polynomial.js');\nvar Circle = require('./classes/circle.js');\nvar Arc = require('./classes/arc.js');\nvar PointOnShape = require('./classes/point-on-shape.js');\nvar Bezier = require('./classes/bezier.js');\nvar allRootsVAS = require('../polynomial/functions/all-roots-vas.js');\nvar Vector = require('../vector/vector.js');\n\nvar Geometry = {};\n\n/** \r\n * @return {Boolean} true if first circle engulfs the second.\r\n */\nGeometry.doesCircleEngulfCircle = function (c1, c2) {\n\tif (c1.radius <= c2.radius) {\n\t\treturn false;\n\t}\n\n\tvar d = Vector.squaredDistanceBetween(c1.center, c2.center);\n\tvar dr = c1.radius - c2.radius;\n\tvar δ = dr * dr;\n\n\treturn δ > d;\n};\n\n/**\r\n * From http://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\r\n * This function is currently unused. \r\n */\nGeometry.doesLineIntersectCircle = function (circle, p0, p1) {\n\tvar x0 = p0[0];\n\tvar y0 = p0[1];\n\tvar x1 = p1[0];\n\tvar y1 = p1[1];\n\tvar radius = circle.radius;\n\tvar cx = circle.center[0];\n\tvar cy = circle.center[1];\n\n\tvar dx = x1 - x0;\n\tvar dy = y1 - y0;\n\tvar fx = x0 - cx;\n\tvar fy = y0 - cy;\n\n\tvar a = dx * dx + dy * dy;\n\tvar b = 2 * (fx * dx + fy * dy);\n\tvar c = fx * fx + fy * fy - radius * radius;\n\n\tvar discriminant = b * b - 4 * a * c;\n\tif (discriminant < 0) {\n\t\t// no intersection\n\t\treturn false;\n\t} else {\n\t\t// ray didn't totally miss sphere,\n\t\t// so there is a solution to\n\t\t// the equation.\n\n\t\tdiscriminant = Math.sqrt(discriminant);\n\n\t\t// either solution may be on or off the ray so need to test both\n\t\t// t1 is always the smaller value, because BOTH discriminant and\n\t\t// a are nonnegative.\n\t\tvar t1 = (-b - discriminant) / (2 * a);\n\t\tvar t2 = (-b + discriminant) / (2 * a);\n\n\t\t// 3x HIT cases:\n\t\t//          -o->             --|-->  |            |  --|->\n\t\t// Impale(t1 hit,t2 hit), Poke(t1 hit,t2>1), ExitWound(t1<0, t2 hit), \n\n\t\t// 3x MISS cases:\n\t\t//       ->  o                     o ->              | -> |\n\t\t// FallShort (t1>1,t2>1), Past (t1<0,t2<0), CompletelyInside(t1<0, t2>1)\n\n\t\tif (t1 >= 0 && t1 <= 1) {\n\t\t\t// t1 is the intersection, and it's closer than t2\n\t\t\t// (since t1 uses -b - discriminant)\n\t\t\t// Impale, Poke\n\t\t\treturn true;\n\t\t}\n\n\t\t// here t1 didn't intersect so we are either started\n\t\t// inside the sphere or completely past it\n\t\tif (t2 >= 0 && t2 <= 1) {\n\t\t\t// ExitWound\n\t\t\treturn true;\n\t\t}\n\n\t\t// no intn: FallShort, Past, CompletelyInside\n\t\treturn false;\n\t}\n};\n\n/**\r\n * \r\n * @param shape\r\n * @param δ\r\n * @returns\r\n */\nGeometry.getBoundaryPieceBeziers = function (shape, δ) {\n\n\tvar goStraight = true; // As opposed to go first around circle and take last exit\n\n\tvar cp0 = δ[0];\n\tvar cp1 = δ[1];\n\n\tvar bezierPieces = [];\n\n\tvar pos_start = cp0.item.pointOnShape;\n\tvar bezierPiece = new BezierPiece(pos_start.bezierNode, [pos_start.t, pos_start.t]);\n\n\tvar ii = 0; // Safeguard\n\tdo {\n\t\tif (goStraight) {\n\t\t\t// This is either a) a 1-prong or ...\n\t\t\t// ... b) a contact point who's matCircle has not yet been resolved\n\t\t\t// TODO change this so that there is no b) anymore\n\n\t\t\tgoStraight = false;\n\n\t\t\tvar pThis = cp0.item.pointOnShape;\n\t\t\tvar pNext = cp0.next.item.pointOnShape;\n\n\t\t\tif (pNext.bezierNode === pThis.bezierNode) {\n\t\t\t\tbezierPiece.tRange[1] = pNext.t;\n\t\t\t\tbezierPieces.push(bezierPiece);\n\t\t\t} else {\n\t\t\t\tbezierPiece.tRange[1] = 1;\n\t\t\t\tbezierPieces.push(bezierPiece);\n\n\t\t\t\taddSkippedBeziers(bezierPieces, pThis, pNext);\n\t\t\t}\n\n\t\t\tcp0 = cp0.next;\n\t\t} else {\n\t\t\tgoStraight = true;\n\n\t\t\tcp0 = cp0.prevOnCircle; // Actually, next, next, ..., i.e. take last exit\n\n\t\t\tvar newPos = cp0.item.pointOnShape;\n\t\t\tbezierPiece = new BezierPiece(newPos.bezierNode, [newPos.t, newPos.t]);\n\t\t}\n\n\t\tii++;\n\t} while (cp0 !== cp1);\n\n\tbezierPieces.push(bezierPiece);\n\n\treturn bezierPieces;\n\n\t/**\r\n  * Adds pieces of skipped beziers\r\n  */\n\tfunction addSkippedBeziers(bezierPieces, pThis, pNext) {\n\n\t\tvar bNode = pThis.bezierNode;\n\t\twhile (bNode !== pNext.bezierNode) {\n\n\t\t\tbNode = bNode.next;\n\n\t\t\tif (bNode !== pNext.bezierNode) {\n\t\t\t\tbezierPieces.push(new BezierPiece(bNode, [0, 1]));\n\t\t\t} else {\n\t\t\t\tbezierPieces.push(new BezierPiece(bNode, [0, pNext.t]));\n\t\t\t}\n\t\t}\n\t}\n};\n\nfunction BezierPiece(bezierNode, tRange) {\n\tthis.bezierNode = bezierNode;\n\tthis.tRange = tRange;\n}\n\n/**\r\n * Get line shape intersection points.\r\n * \r\n * @param line A simple line described by two points, e.g. [[p0x,p0y],[p1x,p1y]]\r\n * @param shape {Shape} \r\n * @param δ Curve segment described by start and end contact points\r\n *\r\n * Currently not used\r\n */\nGeometry.getLineShapeIntersectionPoints = function (line, shape, δ) {\n\n\tvar points = [];\n\tvar bezierPieces = Geometry.getBoundaryPieceBeziers(shape, δ, false);\n\n\tfor (var i = 0; i < bezierPieces.length; i++) {\n\t\tbezierPiece = bezierPieces[i];\n\n\t\tvar bezier = bezierPiece.bezierNode.item;\n\t\tvar iPoints = Geometry.getLineBezierIntersectionPoints(line, bezier, bezierPiece.tRange);\n\n\t\tfor (var j = 0; j < iPoints.length; j++) {\n\t\t\tpoints.push(iPoints[j].p);\n\t\t}\n\t}\n\n\treturn points;\n};\n\nfunction getTRanges(ps, bezier) {\n\tvar tRange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n\n\n\tvar tRanges = [];\n\n\tvar isP0OnBezier = ps[0].bezierNode.item === bezier;\n\tvar isP1OnBezier = ps[1].bezierNode.item === bezier;\n\n\tif (!isP0OnBezier && !isP1OnBezier) {\n\t\treturn [tRange];\n\t}\n\n\t//---- Cache\n\t// At this point either or both of isP0OnBezier and isP1OnBezier is true\n\tvar crossT1 = isP0OnBezier && !isP1OnBezier;\n\tvar crossT0 = isP1OnBezier && !isP0OnBezier;\n\n\tvar a = isP0OnBezier ? ps[0].t : 0;\n\tvar b = isP1OnBezier ? ps[1].t : 1;\n\tvar c = tRange[0];\n\tvar d = tRange[1];\n\n\tif (b <= c) {\n\t\t//  |---a---b-------c---d---|\n\t\t//  |---------------a------b|\n\t\t//  |----------------------c|\n\t\t//  |----------------------d|\n\n\t\tif (c === d && crossT1) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn [tRange];\n\t\t}\n\t} else if (a <= c && b >= d) {\n\t\t//  |---a---c-------d---b---|\n\t\treturn [];\n\t} else if (c <= a && d >= b) {\n\t\t//  |---c---a-------b---d---|\n\t\tvar res = [];\n\t\tif (c !== a) {\n\t\t\tres.push([c, a]);\n\t\t}\n\t\tif (b !== d) {\n\t\t\tres.push([b, d]);\n\t\t}\n\t\treturn res;\n\t} else if (a <= c && b <= d) {\n\t\t//  |---a---c-------b---d---|\n\t\treturn [[b, d]];\n\t} else if (c <= a && d <= b) {\n\t\t//  |---c---a-------d---b---|\n\t\treturn [[c, a]];\n\t}\n}\n\nGeometry.closestSquaredDistanceToRotatedRect = function (bezier, p) {\n\tvar tightBoundingBox = bezier.getBoundingBoxTight();\n\n\tvar ds = [0, 1, 2, 3].map(function (i) {\n\t\treturn Vector.squaredDistanceBetweenPointAndLineSegment(p, [tightBoundingBox[i], tightBoundingBox[(i + 1) % 4]]);\n\t});\n\n\treturn Util.bestBy(ds);\n};\n\nGeometry.getClosestSquareDistanceToRect = function (box, p) {\n\n\tvar x0 = box[0][0];\n\tvar y0 = box[0][1];\n\tvar x1 = box[1][0];\n\tvar y1 = box[1][1];\n\n\tvar xp = p[0];\n\tvar yp = p[1];\n\n\tif (xp < x0) {\n\t\tif (yp < y0) {\n\t\t\treturn Vector.squaredDistanceBetween(box[0], p);\n\t\t} else if (yp > y1) {\n\t\t\treturn Vector.squaredDistanceBetween([x0, y1], p);\n\t\t} else {\n\t\t\tvar d = x0 - xp;\n\t\t\treturn d * d;\n\t\t}\n\t} else if (xp > x1) {\n\t\tif (yp < y0) {\n\t\t\treturn Vector.squaredDistanceBetween([x1, y0], p);\n\t\t} else if (yp > y1) {\n\t\t\treturn Vector.squaredDistanceBetween(box[1], p);\n\t\t} else {\n\t\t\tvar _d = xp - x1;\n\t\t\treturn _d * _d;\n\t\t}\n\t} else {\n\t\tif (yp < y0) {\n\t\t\tvar _d2 = y0 - yp;\n\t\t\treturn _d2 * _d2;\n\t\t} else if (yp > y1) {\n\t\t\tvar _d3 = yp - y1;\n\t\t\treturn _d3 * _d3;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n};\n\nGeometry.getShapeRightMostInfo = function (bezierArr, _debug_) {\n\n\tvar maxX = Number.NEGATIVE_INFINITY;\n\tvar maxBezier = undefined;\n\tfor (var i = 0; i < bezierArr.length; i++) {\n\t\tvar bezier = bezierArr[i];\n\n\t\tvar rightMost = bezier.getBoundingBox()[1][0];\n\t\tif (rightMost > maxX) {\n\t\t\tmaxX = rightMost;\n\t\t\tmaxBezier = bezier;\n\t\t}\n\t}\n\n\treturn { maxX: maxX, maxBezier: maxBezier };\n};\n\n/**\r\n * Checks if a shape is positively orientated or not. \r\n */\nGeometry.isShapePositivelyOrientated = function (bezierArr, _debug_) {\n\t// TODO - must still handle the case where the rightmost point\n\t// is sharp.\n\n\t//console.log(bezierArr)\n\n\tvar _Geometry$getShapeRig = Geometry.getShapeRightMostInfo(bezierArr, _debug_),\n\t    maxX = _Geometry$getShapeRig.maxX,\n\t    maxBezier = _Geometry$getShapeRig.maxBezier;\n\n\t//console.log(maxX, maxBezier.tAtMaxX);\n\n\tvar tan = maxBezier.tangent(maxBezier.tAtMaxX);\n\n\t//console.log(tan);\n\n\treturn tan[1] > 0;\n};\n\nvar prevBezier = undefined; // Cache\nvar prevP = undefined;\nvar prevT = undefined;\nvar memClosestPoint = undefined; // ...\nvar prevTRange = undefined;\nvar prevTouchedBezier = undefined;\nvar iii = 0;\nGeometry.closestPointBetween_PointAndBezier = function (bezierNode, p, tRange, touchedBezierNode, t, _debug_, slog) {\n\n\tvar bezier = bezierNode.item;\n\tvar touchedBezier = touchedBezierNode ? touchedBezierNode.item : undefined;\n\n\tif (prevBezier === bezier && prevP === p && prevT === t && tRange[0] === prevTRange[0] && tRange[1] === prevTRange[1] && prevTouchedBezier === touchedBezier) {\n\t\treturn memClosestPoint;\n\t}\n\tprevBezier = bezier;\n\tprevP = p;\n\tprevT = t;\n\tprevTRange = tRange;\n\tprevTouchedBezier = touchedBezier;\n\n\t// TODO The site at http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html\n\t// may hint at requiring much fewer assignments?\n\n\tvar _bezier$bezierPoints = _slicedToArray(bezier.bezierPoints, 4),\n\t    _bezier$bezierPoints$ = _slicedToArray(_bezier$bezierPoints[0], 2),\n\t    x0 = _bezier$bezierPoints$[0],\n\t    y0 = _bezier$bezierPoints$[1],\n\t    _bezier$bezierPoints$2 = _slicedToArray(_bezier$bezierPoints[1], 2),\n\t    x1 = _bezier$bezierPoints$2[0],\n\t    y1 = _bezier$bezierPoints$2[1],\n\t    _bezier$bezierPoints$3 = _slicedToArray(_bezier$bezierPoints[2], 2),\n\t    x2 = _bezier$bezierPoints$3[0],\n\t    y2 = _bezier$bezierPoints$3[1],\n\t    _bezier$bezierPoints$4 = _slicedToArray(_bezier$bezierPoints[3], 2),\n\t    x3 = _bezier$bezierPoints$4[0],\n\t    y3 = _bezier$bezierPoints$4[1];\n\n\tvar _p = _slicedToArray(p, 2),\n\t    xp = _p[0],\n\t    yp = _p[1];\n\n\tvar xx0 = x0 - xp;\n\tvar xx1 = x1 - xp;\n\tvar xx2 = x2 - xp;\n\tvar xx3 = x3 - xp;\n\tvar yy0 = y0 - yp;\n\tvar yy1 = y1 - yp;\n\tvar yy2 = y2 - yp;\n\tvar yy3 = y3 - yp;\n\n\tvar x00 = xx0 * xx0;\n\tvar x01 = 6 * xx0 * xx1;\n\tvar x02 = 6 * xx0 * xx2;\n\tvar x03 = 2 * xx0 * xx3;\n\tvar x11 = 9 * xx1 * xx1;\n\tvar x12 = 18 * xx1 * xx2;\n\tvar x13 = 6 * xx1 * xx3;\n\tvar x22 = 9 * xx2 * xx2;\n\tvar x23 = 6 * xx2 * xx3;\n\tvar x33 = xx3 * xx3;\n\n\tvar y00 = yy0 * yy0;\n\tvar y01 = 6 * yy0 * yy1;\n\tvar y02 = 6 * yy0 * yy2;\n\tvar y03 = 2 * yy0 * yy3;\n\tvar y11 = 9 * yy1 * yy1;\n\tvar y12 = 18 * yy1 * yy2;\n\tvar y13 = 6 * yy1 * yy3;\n\tvar y22 = 9 * yy2 * yy2;\n\tvar y23 = 6 * yy2 * yy3;\n\tvar y33 = yy3 * yy3;\n\n\tvar t5 = 6 * (x33 - x23 + x13 - x03 + x22 - x12 + x02 + x11 - x01 + x00 + (y33 - y23 + y13 - y03 + y22 - y12 + y02 + y11 - y01 + y00));\n\tvar t4 = 5 * (x23 - 2 * x13 + 3 * x03 - 2 * x22 + 3 * x12 - 4 * x02 - 4 * x11 + 5 * x01 - 6 * x00 + (y23 - 2 * y13 + 3 * y03 - 2 * y22 + 3 * y12 - 4 * y02 - 4 * y11 + 5 * y01 - 6 * y00));\n\tvar t3 = 4 * (x13 - 3 * x03 + x22 - 3 * x12 + 6 * x02 + 6 * x11 - 10 * x01 + 15 * x00 + (y13 - 3 * y03 + y22 - 3 * y12 + 6 * y02 + 6 * y11 - 10 * y01 + 15 * y00));\n\tvar t2 = 3 * (x03 + x12 - 4 * x02 - 4 * x11 + 10 * x01 - 20 * x00 + (y03 + y12 - 4 * y02 - 4 * y11 + 10 * y01 - 20 * y00));\n\tvar t1 = 2 * (x02 + x11 - 5 * x01 + 15 * x00 + (y02 + y11 - 5 * y01 + 15 * y00));\n\tvar t0 = x01 - 6 * x00 + (y01 - 6 * y00);\n\n\tvar poly = [t5, t4, t3, t2, t1, t0];\n\n\tif (bezier === touchedBezier) {\n\t\tvar deflatedPoly = Poly.deflate(poly, t);\n\t\t//console.log('def-poly(t): ' + Poly.evaluate(deflatedPoly)(t));\n\t\t//console.log('    poly(t): ' + Poly.evaluate(poly)(t));\n\t\t//console.log('pol', t, Poly.allRoots01(poly));\n\t\t//console.log('def', t, Poly.allRoots01(deflatedPoly));\n\t\tpoly = deflatedPoly;\n\t}\n\n\t//let allRoots = allRootsVAS(poly, tRange, _debug_);\n\tvar allRoots = Poly.allRoots01(poly);\n\tvar roots = allRoots.filter(function (root) {\n\t\treturn root >= tRange[0] && root <= tRange[1];\n\t});\n\n\tif (slog) {\n\t\t//console.log('a') \n\t}\n\n\tvar push0 = true;\n\tvar push1 = true;\n\tif (t === 1 && bezierNode === touchedBezierNode.next || bezier === touchedBezier && t === 0) {\n\t\tpush0 = false;\n\t}\n\tif (t === 0 && bezierNode === touchedBezierNode.prev || bezier === touchedBezier && t === 1) {\n\t\tpush1 = false;\n\t}\n\n\t/*\r\n roots.push(tRange[0]);\r\n roots.push(tRange[1]);\r\n */\n\n\tif (tRange[0] === 0) {\n\t\tif (push0) {\n\t\t\troots.push(tRange[0]);\n\t\t}\n\t} else if (tRange[0] === 1) {\n\t\tif (push1) {\n\t\t\troots.push(tRange[0]);\n\t\t}\n\t} else {\n\t\troots.push(tRange[0]);\n\t}\n\n\tif (tRange[1] === 0) {\n\t\tif (push0) {\n\t\t\troots.push(tRange[1]);\n\t\t}\n\t} else if (tRange[1] === 1) {\n\t\tif (push1) {\n\t\t\troots.push(tRange[1]);\n\t\t}\n\t} else {\n\t\troots.push(tRange[1]);\n\t}\n\n\tvar ps = roots.map(function (root) {\n\t\treturn { p: bezier.evaluate(root), t: root };\n\t});\n\tvar closestPoint = Vector.getClosestTo(p, ps, function (p1, p2) {\n\t\treturn Vector.squaredDistanceBetween(p1, p2.p);\n\t});\n\n\tmemClosestPoint = closestPoint;\n\treturn closestPoint;\n};\n\nGeometry.degAngleFromSinCos = function (sinAngle, cosAngle) {\n\n\tvar toRad = function toRad(a) {\n\t\treturn a * (Math.PI / 180);\n\t};\n\tvar toDeg = function toDeg(a) {\n\t\treturn a * (180 / Math.PI);\n\t};\n\n\tif (cosAngle === 0) {\n\t\tif (sinAngle > 0) {\n\t\t\treturn 90;\n\t\t}\n\t\treturn 270;\n\t}\n\tif (cosAngle > 0) {\n\t\treturn toDeg(Math.atan(sinAngle / cosAngle));\n\t}\n\treturn 180 + toDeg(Math.atan(sinAngle / cosAngle));\n};\n\n/** \r\n * Returns the closest point on the arc.\r\n * \r\n * @returns { p, position } where position is either 0, 1 or 2 \r\n *          indicating if the closest point is at either endpoint \r\n *          (1 or 2) or interior to the arc (0). \r\n * \r\n * Note: Needs to be quite fast \r\n */\nGeometry.closestPointOnArc = function (p, arc) {\n\t// arc ->def  [circle, startpoint, endpoint, sin_angle1, cos_angle1, sin_angle2, cos_angle2]\n\n\tif (arc.circle !== null) {\n\t\t// else the arc is degenerate into a line\n\t\t// First move arc circle onto origin\n\t\tvar x = arc.circle.center[0];\n\t\tvar y = arc.circle.center[1];\n\n\t\tvar arco = new Arc(new Circle([0, 0], arc.circle.radius), Vector.translate(arc.startpoint, [-x, -y]), Vector.translate(arc.endpoint, [-x, -y]), arc.sin_angle1, arc.cos_angle1, arc.sin_angle2, arc.cos_angle2);\n\n\t\tvar pp = Vector.translate(p, [-x, -y]);\n\t\tvar l = Vector.length(pp);\n\t\tvar sin_pp = -pp[1] / l;\n\t\tvar cos_pp = pp[0] / l;\n\n\t\tif (Geometry.isAngleBetween(sin_pp, cos_pp, arco.sin_angle1, arco.cos_angle1, arco.sin_angle2, arco.cos_angle2)) {\n\t\t\tvar r_o_l = arco.circle.radius;\n\t\t\tvar res = { p: Vector.translate([r_o_l * cos_pp, r_o_l * -sin_pp], [x, y]), position: 0 };\n\t\t\treturn res;\n\t\t} else {\n\t\t\tvar asp = arc.startpoint;\n\t\t\tvar aep = arc.endpoint;\n\n\t\t\tvar d1 = Vector.distanceBetween(asp, p);\n\t\t\tvar d2 = Vector.distanceBetween(aep, p);\n\n\t\t\tif (d1 < d2) {\n\t\t\t\treturn { p: asp, position: 1 };\n\t\t\t}\n\t\t\treturn { p: aep, position: 2 };\n\t\t}\n\t}\n\n\t// Line degenerate case - this is exactly a routine for \n\t// distance (and closest point) between point and line segment.\n\tvar asp = arc.startpoint;\n\tvar aep = arc.endpoint;\n\n\tvar d1 = Vector.distanceBetween(asp, p);\n\tvar d2 = Vector.distanceBetween(aep, p);\n\tvar ds = Math.sqrt(Vector.distanceBetweenPointAndLineSegment(p, [asp, aep]));\n\n\tif (d1 <= d2 && d1 <= ds) {\n\t\treturn { p: asp, position: 1 };\n\t} else if (d2 <= d1 && d2 <= ds) {\n\t\treturn { p: aep, position: 2 };\n\t}\n\n\t// else ds is shortest\n\tvar v = Vector.fromTo(asp, aep);\n\n\tvar l1p2 = [p[0] + v[1], p[1] + -v[0]];\n\tvar res = {\n\t\tp: Geometry.lineLineIntersection([p, l1p2], [asp, aep]),\n\t\tposition: 0\n\t};\n\n\treturn res;\n};\n\n/** \r\n * @return A directional arc from 3 ordered points. \r\n */\nGeometry.arcFrom3Points = function (circlePoints) {\n\tvar midPoint1 = Vector.mean([circlePoints[0], circlePoints[1]]);\n\tvar midPoint2 = Vector.mean([circlePoints[1], circlePoints[2]]);\n\n\tvar chord1 = Vector.fromTo(circlePoints[0], circlePoints[1]);\n\tvar chord2 = Vector.fromTo(circlePoints[1], circlePoints[2]);\n\n\tvar perpendicular1 = [chord1[1], -chord1[0]];\n\tvar perpendicular2 = [chord2[1], -chord2[0]];\n\n\tvar line1 = [midPoint1, Vector.translate(perpendicular1, midPoint1)];\n\tvar line2 = [midPoint2, Vector.translate(perpendicular2, midPoint2)];\n\n\tvar circleCenter = Geometry.lineLineIntersection(line1, line2);\n\n\tvar arc;\n\tif (circleCenter === null) {\n\t\t// If the circle is in effect a line segment\n\t\tif (Vector.equal(circlePoints[0], circlePoints[2])) {\n\t\t\treturn null;\n\t\t}\n\t\tarc = new Arc(null, circlePoints[0], circlePoints[2]);\n\t\treturn arc;\n\t}\n\n\tvar sideVector1 = Vector.fromTo(circleCenter, circlePoints[0]);\n\tvar midVector = Vector.fromTo(circleCenter, circlePoints[1]);\n\tvar sideVector2 = Vector.fromTo(circleCenter, circlePoints[2]);\n\tvar radius = Vector.length(sideVector1);\n\tvar sin_angle1 = -sideVector1[1] / radius;\n\tvar cos_angle1 = sideVector1[0] / radius;\n\tvar sin_angle2 = -sideVector2[1] / radius;\n\tvar cos_angle2 = sideVector2[0] / radius;\n\tvar sin_midangle = -midVector[1] / radius;\n\tvar cos_midangle = midVector[0] / radius;\n\n\tif (Geometry.isAngleBetween(sin_midangle, cos_midangle, sin_angle1, cos_angle1, sin_angle2, cos_angle2)) {\n\t\tarc = new Arc(new Circle(circleCenter, radius), circlePoints[0], circlePoints[2], sin_angle1, cos_angle1, sin_angle2, cos_angle2);\n\t} else {\n\t\tarc = new Arc(new Circle(circleCenter, radius), circlePoints[2], circlePoints[0], sin_angle2, cos_angle2, sin_angle1, cos_angle1);\n\t}\n\n\treturn arc;\n};\n\nGeometry.quadrant = function (sin_angle, cos_angle) {\n\tif (sin_angle >= 0) {\n\t\tif (cos_angle >= 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 2;\n\t}\n\tif (cos_angle >= 0) {\n\t\treturn 4;\n\t}\n\treturn 3;\n};\n\nGeometry.isAngle1LargerOrEqual = function (sin_angle1, cos_angle1, sin_angle2, cos_angle2) {\n\tvar q1 = Geometry.quadrant(sin_angle1, cos_angle1);\n\tvar q2 = Geometry.quadrant(sin_angle2, cos_angle2);\n\n\tif (q1 > q2) {\n\t\treturn true;\n\t}\n\tif (q1 < q2) {\n\t\treturn false;\n\t}\n\n\t// Same quadrant\n\tif (q1 === 1 || q1 === 4) {\n\t\treturn sin_angle1 >= sin_angle2;\n\t}\n\treturn sin_angle1 <= sin_angle2;\n};\n\n/** \r\n * Returns true if angle1 < angle < angle2 in the non-trivial sense.\r\n */\nGeometry.isAngleBetween = function (sin_angle, cos_angle, sin_angle1, cos_angle1, sin_angle2, cos_angle2) {\n\tvar t1_larger_t2 = Geometry.isAngle1LargerOrEqual(sin_angle1, cos_angle1, sin_angle2, cos_angle2);\n\tvar a_larger_t2 = Geometry.isAngle1LargerOrEqual(sin_angle, cos_angle, sin_angle2, cos_angle2);\n\tvar a_larger_t1 = Geometry.isAngle1LargerOrEqual(sin_angle, cos_angle, sin_angle1, cos_angle1);\n\n\tvar res;\n\tif (t1_larger_t2) {\n\t\tres = a_larger_t1 || !a_larger_t2;\n\t} else {\n\t\tres = a_larger_t1 && !a_larger_t2;\n\t}\n\n\treturn res;\n};\n\n/**\r\n * Find point where two lines intersect.\r\n *  \r\n * @param line1 The first line - given as 2 points \r\n * @param line2 The first line - given as 2 points\r\n * @returns Point where two lines intersect or null if they don't or intersect everywhere. \r\n */\nGeometry.lineLineIntersection = function (line1, line2) {\n\tvar p1x = line1[0][0];\n\tvar p1y = line1[0][1];\n\tvar p2x = line1[1][0];\n\tvar p2y = line1[1][1];\n\tvar p3x = line2[0][0];\n\tvar p3y = line2[0][1];\n\tvar p4x = line2[1][0];\n\tvar p4y = line2[1][1];\n\tvar v1x = p2x - p1x;\n\tvar v1y = p2y - p1y;\n\tvar v2x = p4x - p3x;\n\tvar v2y = p4y - p3y;\n\n\tvar cross = v2x * v1y - v2y * v1x;\n\tif (cross === 0) {\n\t\t//console.log('parallel')\n\t\treturn undefined;\n\t}\n\n\tvar b = ((p3y - p1y) * v1x - (p3x - p1x) * v1y) / cross;\n\n\treturn [p3x + b * v2x, p3y + b * v2y];\n};\n\nGeometry.lineThroughPointAtRightAngleTo = function (p, v) {\n\tvar vv = [-v[1], v[0]];\n\tvar p20 = p[0] + vv[0];\n\tvar p21 = p[1] + vv[1];\n\n\treturn [p, [p20, p21]];\n};\n\n/**\r\n * Get all intersection points between a line and a bezier within a certain t range.\r\n * \r\n * @returns An array of { p, t } \r\n */\nGeometry.getLineBezierIntersectionPoints = function (line, bezier, tRange) {\n\tvar t = [-line[0][0], -line[0][1]];\n\tvar p = [line[1][0] + t[0], line[1][1] + t[1]];\n\n\t//---- Cache\n\tvar lineLength = Vector.length(p);\n\tvar sinAngle = -p[1] / lineLength;\n\tvar cosAngle = p[0] / lineLength;\n\n\tvar bezierPoints = Vector.translateThenRotatePoints(bezier.bezierPoints, t, sinAngle, cosAngle);\n\n\tvar x0 = bezierPoints[0][0];\n\tvar y0 = bezierPoints[0][1];\n\tvar x1 = bezierPoints[1][0];\n\tvar y1 = bezierPoints[1][1];\n\tvar x2 = bezierPoints[2][0];\n\tvar y2 = bezierPoints[2][1];\n\tvar x3 = bezierPoints[3][0];\n\tvar y3 = bezierPoints[3][1];\n\n\tvar x = [x3 - 3 * x2 + 3 * x1 - x0, // t^3\n\t3 * x2 - 6 * x1 + 3 * x0, // t^2\n\t3 * x1 - 3 * x0, // t^1\n\tx0];\n\tvar y = [y3 - 3 * y2 + 3 * y1 - y0, // t^3\n\t3 * y2 - 6 * y1 + 3 * y0, // t^2\n\t3 * y1 - 3 * y0, // t^1\n\ty0];\n\n\tvar roots = Poly.findCubicRoots01(y);\n\n\tvar res = roots\n\t/*.filter(function(t) {\r\n \treturn ((t >= tRange[0]) && (t <= tRange[1]));\r\n })*/\n\t.map(function (t) {\n\t\treturn { p: bezier.evaluate(t), t: t };\n\t});\n\n\treturn res;\n};\n\n/**\r\n * Given a circle, bound it tightly by an axes-aligned box (i.e. circle box). \r\n * And given a bezier, bound tightly by a rectangle (not necessarily axes aligned) (i.e. bezier box).\r\n *  \r\n *  @return True if bezier box is entirely outside circle box\r\n *  \r\n */\nfunction isBezierBoxWhollyOutsideCircleBox(bezier, circle) {\n\n\t//---- Cache\n\tvar r = circle.radius;\n\tvar ox = circle.center[0];\n\tvar oy = circle.center[1];\n\tvar radius_2 = r * r;\n\n\t//---- Translate bezier tight bounding box (4 point rectangle) so that circle center is at origin. \n\tvar boxTight = Vector.translatePoints(bezier.getBoundingBoxTight(), [-ox, -oy]);\n\n\t//---- Rotate circle and rectangle together so that box rectangle is aligned with axes.\n\tvar boxDiagonal = Vector.fromTo(boxTight[0], boxTight[1]);\n\tvar l = Vector.length(boxDiagonal);\n\tvar sinAngle = boxDiagonal[1] / l;\n\tvar cosAngle = boxDiagonal[0] / l;\n\tvar b0 = Vector.rotate(boxTight[0], sinAngle, -cosAngle);\n\tvar b1 = Vector.rotate(boxTight[2], sinAngle, -cosAngle);\n\n\tvar anyBoxVerticalInside = b0[0] > -r && b0[0] < r || b1[0] > -r && b1[0] < r;\n\tvar boxVerticalsCapture = b0[0] < -r && b1[0] > r || b1[0] < -r && b0[0] > r;\n\n\tvar anyBoxHorizontalInside = b0[1] > -r && b0[1] < r || b1[1] > -r && b1[1] < r;\n\tvar boxHorizontalsCapture = b0[1] < -r && b1[1] > r || b1[1] < -r && b0[1] > r;\n\tif (anyBoxVerticalInside && (anyBoxHorizontalInside || boxHorizontalsCapture) || anyBoxHorizontalInside && (anyBoxVerticalInside || boxVerticalsCapture) || boxVerticalsCapture && boxHorizontalsCapture) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\r\n * Checks if circle intersects the shape. \r\n * \r\n * @param shape\r\n * @param circle\r\n * @param exclPoint {PointOnShape} Exclude this point and a small t gap around it.\r\n * \r\n * NOTE: Circle can only intercept shape an even number of times (counting duplicate roots).\r\n */\n// TODO - change tGap to a gap in pixels if possible\nGeometry.doesCircleIntersectShape = function (shape, circle, exclPoint) {\n\n\t// A t gap within the shape that should not be checked.\n\t// TODO - rather remove point from quintic as a poly factor (watch out for double roots).\n\tvar tGap = 0.02;\n\n\t//---- Trivial case: osculating point, i.e. sharp corner\n\tif (circle.radius === 0) {\n\t\treturn false;\n\t}\n\n\t//---- Readability cache\n\tvar radius = circle.radius;\n\tvar ox = circle.center[0];\n\tvar oy = circle.center[1];\n\n\t//---- Initialization\n\tvar candidateBeziers = [];\n\tvar pointsCounts = {};\n\tvar node = shape.beziers.head;\n\n\tvar ps = PointOnShape.split(exclPoint, tGap);\n\n\tdo {\n\t\tvar bezier = node.item;\n\n\t\t//---- If bezier [tight box] is wholly contained in osculating circle then:\n\t\t// bezier is wholly contained in circle => some part of circle is outside shape boundary\n\t\tif (!isBezierBoxWhollyOutsideCircleBox(bezier, circle)) {\n\t\t\tcandidateBeziers.push(bezier);\n\t\t}\n\n\t\tnode = node.next;\n\t} while (node !== shape.beziers.head);\n\n\tfor (var i = 0; i < candidateBeziers.length; i++) {\n\n\t\t// We can provide an additional stage in future as an optimization, i.e.\n\t\t// Check if circle intersects tighter bounding boxes - it can either:\n\t\t// a: not intersect -> either: \n\t\t//    i:  bezier is contained in circle - return true immediately\n\t\t//    ii: else bezier is eliminated\n\t\t// b: intersect in 1 point (unlikely) -> bezier is eliminated\n\t\t// c: intersect in 3 points -> return true immediately\n\t\t// d: intersect in 2 points -> either:\n\t\t//    i: parallel sides -> return true immediately\n\t\t//    ii: non-parallel sides -> further check is required (as below)\n\n\n\t\t//---- Test if circle literally intersects bezier\n\n\t\t//---- First translate circle and bezier together so circle is centered on origin\n\t\tvar candidateBezier = candidateBeziers[i];\n\t\tvar bezierPoints = Vector.translatePoints(candidateBezier.bezierPoints, [-ox, -oy]);\n\n\t\t//---- Cache\n\t\tvar x0 = bezierPoints[0][0];\n\t\tvar y0 = bezierPoints[0][1];\n\t\tvar x1 = bezierPoints[1][0];\n\t\tvar y1 = bezierPoints[1][1];\n\t\tvar x2 = bezierPoints[2][0];\n\t\tvar y2 = bezierPoints[2][1];\n\t\tvar x3 = bezierPoints[3][0];\n\t\tvar y3 = bezierPoints[3][1];\n\n\t\t//** To get the intersection points we need to solve: \n\t\t//   (see http://math.stackexchange.com/questions/436216/intersection-of-cubic-bezier-curve-and-circle)\n\t\t//         Bx(t)^2 + By(t)^2 - r^2 = 0   (t = [0..1])\n\t\t//      => a6*t^6 + a5*t^5 +  a4*t^4 + a3*t^3 + a2*t^2 + a1*t + a0 = 0\n\t\tvar x0_2 = x0 * x0;var x1_2 = x1 * x1;\n\t\tvar x2_2 = x2 * x2;var x3_2 = x3 * x3;\n\t\tvar y0_2 = y0 * y0;var y1_2 = y1 * y1;\n\t\tvar y2_2 = y2 * y2;var y3_2 = y3 * y3;\n\n\t\tvar t6 = y3_2 - 6 * y2 * y3 + 6 * y1 * y3 - 2 * y0 * y3 + 9 * y2_2 - 18 * y1 * y2 + 6 * y0 * y2 + 9 * y1_2 - 6 * y0 * y1 + y0_2 + x3_2 - 6 * x2 * x3 + 6 * x1 * x3 - 2 * x0 * x3 + 9 * x2_2 - 18 * x1 * x2 + 6 * x0 * x2 + 9 * x1_2 - 6 * x0 * x1 + x0_2;\n\t\tvar t5 = 6 * y2 * y3 - 12 * y1 * y3 + 6 * y0 * y3 - 18 * y2_2 + 54 * y1 * y2 - 24 * y0 * y2 - 36 * y1_2 + 30 * y0 * y1 - 6 * y0_2 + 6 * x2 * x3 - 12 * x1 * x3 + 6 * x0 * x3 - 18 * x2_2 + 54 * x1 * x2 - 24 * x0 * x2 - 36 * x1_2 + 30 * x0 * x1 - 6 * x0_2;\n\t\tvar t4 = 6 * y1 * y3 - 6 * y0 * y3 + 9 * y2_2 - 54 * y1 * y2 + 36 * y0 * y2 + 54 * y1_2 - 60 * y0 * y1 + 15 * y0_2 + 6 * x1 * x3 - 6 * x0 * x3 + 9 * x2_2 - 54 * x1 * x2 + 36 * x0 * x2 + 54 * x1_2 - 60 * x0 * x1 + 15 * x0_2;\n\t\tvar t3 = 2 * y0 * y3 + 18 * y1 * y2 - 24 * y0 * y2 - 36 * y1_2 + 60 * y0 * y1 - 20 * y0_2 + 2 * x0 * x3 + 18 * x1 * x2 - 24 * x0 * x2 - 36 * x1_2 + 60 * x0 * x1 - 20 * x0_2;\n\t\tvar t2 = 6 * y0 * y2 + 9 * y1_2 - 30 * y0 * y1 + 15 * y0_2 + 6 * x0 * x2 + 9 * x1_2 - 30 * x0 * x1 + 15 * x0_2;\n\t\tvar t1 = 6 * y0 * y1 - 6 * y0_2 + 6 * x0 * x1 - 6 * x0_2;\n\t\tvar t0 = y0_2 + x0_2 - radius * radius;\n\n\t\tvar poly = [t6, t5, t4, t3, t2, t1, t0];\n\n\t\tvar tRanges = getTRanges(ps, candidateBezier, undefined, true, false);\n\n\t\tvar peval = Poly.evaluate(poly);\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = tRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar tRange = _step.value;\n\n\t\t\t\t// First check if left and right endpoints at t=0 and t=1 have different signs - this quick check\n\t\t\t\t// will eliminate most cases where there is only a single root.\n\t\t\t\t// In future also check Budan's method again for max number of roots since we rarely expect 3 or more roots\n\t\t\t\t// this may speed things up.\n\n\t\t\t\tif (peval(tRange[0]) / peval(tRange[1]) < 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Important Note: Number of sturm tests can drastically be reduced by eliminating\n\t\t\t\t// most neighbouring beziers by using tight bounding box overlapped with control point convex hull\n\t\t\t\t// test to see if it intesects with cirlce - should improve algorithm speed\n\n\t\t\t\t// Note: Another method apart from sturm is possible by doing a cascade of differentiation and\n\t\t\t\t//       checking where zeros lies at each stage starting from quadratic - at most 9 zeros need to be found\n\t\t\t\t//       in this case - probably faster than Sturm!\n\n\t\t\t\t// TODO - Note: we must really still test endpoints here\n\t\t\t\tvar totalRoots = Poly.rootsWithin(poly, tRange[0], tRange[1]);\n\t\t\t\tif (totalRoots > 0) {\n\t\t\t\t\treturn true; // else check next circle\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n};\n\nmodule.exports = Geometry;\n\n},{\"../polynomial/functions/all-roots-vas.js\":37,\"../polynomial/polynomial.js\":39,\"../utils.js\":42,\"../vector/vector.js\":43,\"./classes/arc.js\":3,\"./classes/bezier.js\":4,\"./classes/circle.js\":5,\"./classes/point-on-shape.js\":6}],14:[function(require,module,exports){\n'use strict';\n\nvar LlRbTree = require('../ll-rb-tree/ll-rb-tree.js');\nvar ListNode = require('./list-node.js');\n\n/**\r\n * Represents a two-way linked loop. \r\n * @constructor \r\n *\r\n * @param comparator Tree item comparator\r\n *\r\n * NOTE: Must be called with a *sorted* array if comparator is not \r\n * given. \r\n */\nfunction LinkedLoop(array, comparator) {\n\tif (comparator) {\n\t\tthis.cptree = new LlRbTree(comparator);\n\t}\n\n\tthis.addAllFromScratch(array || []);\n}\n\n/**\r\n * Insert an item into the linked loop after specified point \r\n * \r\n * @param item  {*} - Item to insert.\r\n * @param prev - Insert new item right after this item.\r\n * @param coupledNode\r\n */\nLinkedLoop.insert = function (loop, item, prev_, coupledNode) {\n\n\tvar node = new ListNode(item, undefined, undefined);\n\n\tvar prev = void 0;\n\tvar next = void 0;\n\n\tif (!loop.head) {\n\t\tprev = node;\n\t\tnext = node;\n\n\t\tloop.head = node;\n\t} else {\n\t\tprev = prev_;\n\t\tnext = prev.next;\n\t}\n\n\tnext.prev = node;\n\tprev.next = node;\n\tnode.prev = prev;\n\tnode.next = next;\n\n\tnode.coupledNode = coupledNode;\n\n\tif (loop.cptree) {\n\t\tLlRbTree.insert(loop.cptree, node);\n\t};\n\n\treturn node;\n};\n\nLinkedLoop.remove = function (loop, item) {\n\n\tvar prev = item.prev;\n\tvar next = item.next;\n\n\tif (item === loop.head) {\n\t\tloop.head = next;\n\t}\n\n\tprev.next = next;\n\tnext.prev = prev;\n\n\tif (loop.cptree) {\n\t\t// TODO - could be made faster by removing on item directly\n\t\t//loop.cptree.remove(item); \n\t\tLlRbTree.remove(loop.cptree, item);\n\t};\n};\n\n/**\r\n * Returns the item at the specified index position..\r\n * \r\n * NOTE: This is slow ( O(n) ); use in debugging code only.\r\n */\nLinkedLoop.getByIndx = function (linkedLoop, n) {\n\treturn ListNode.advanceNSteps(linkedLoop.head, n);\n};\n\nLinkedLoop.prototype.addAllFromScratch = function (arr) {\n\n\tif (arr.length === 0) {\n\t\treturn;\n\t}\n\n\t// TODO Remove nodeArr occurences and put them in debug parts only.\n\tvar nodeArr = [];\n\n\tvar head;\n\tvar prevNode = null;\n\tvar node = void 0;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\n\t\tnode = new ListNode(arr[i], prevNode, null, i);\n\n\t\tnodeArr.push(node);\n\n\t\tif (prevNode) {\n\t\t\tprevNode.next = node;\n\t\t}\n\t\tprevNode = node;\n\n\t\tif (i === 0) {\n\t\t\thead = node;\n\t\t}\n\n\t\tif (this.cptree) {\n\t\t\tLlRbTree.insert(this.cptree, node);\n\t\t};\n\t}\n\n\t// Close loop\n\thead.prev = node;\n\tnode.next = head;\n\n\tthis.head = head;\n\tthis.nodeArr = nodeArr; // This is a hash cache in shape of array\t\t\n};\n\nmodule.exports = LinkedLoop;\n\n},{\"../ll-rb-tree/ll-rb-tree.js\":16,\"./list-node.js\":15}],15:[function(require,module,exports){\n\"use strict\";\n\n/**\r\n * Representation of a linked loop vertex (i.e. node) having various  \r\n * edges, two of which enforce an ordering on the nodes, i.e. 'prev'\r\n * and 'next'.\r\n *  \r\n * @constructor\r\n * @param {*} item - The actual item stored at a node.\r\n * @param {ListNode} prev - The previous item.\r\n * @param {ListNode} next - The next item.\r\n */\nfunction ListNode(item, prev, next) {\n\n  this.item = item;\n  this.prev = prev;\n  this.next = next;\n}\n\n/**\r\n * Advances the node by the given number of steps.\r\n * \r\n * NOTE: This is slow ( O(n) ); use in debugging code only.\r\n */\nListNode.advanceNSteps = function (node, n) {\n  for (var i = 0; i < n; i++) {\n    node = node.next;\n  }\n\n  return node;\n};\n\nmodule.exports = ListNode;\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html \r\n */\n\nvar LEFT = false;\nvar RIGHT = true;\n\nvar RED = true;\nvar BLACK = false;\n\n/**\r\n * Red Black Tree node.\r\n * @constructor \r\n * @param {*} data\r\n */\nfunction Node(data) {\n\tthis.data = data;\n\tthis.red = true;\n}\n\nNode.isRed = function (node) {\n\treturn node && node.red;\n};\n\n/** \r\n * @constructor \r\n */\nfunction LlRbTree(comparator) {\n\tthis.comparator = comparator;\n\tthis.root = null;\n}\n\nfunction getMinOrMaxNode(dir, node) {\n\treturn function (node) {\n\t\twhile (node[dir]) {\n\t\t\tnode = node[dir];\n\t\t}\n\t\treturn node;\n\t};\n}\n\nLlRbTree.getMinNode = getMinOrMaxNode(LEFT);\nLlRbTree.getMaxNode = getMinOrMaxNode(RIGHT);\n\nLlRbTree.min = function (node) {\n\treturn LlRbTree.getMinNode(node).data;\n};\n\nLlRbTree.max = function (node) {\n\treturn LlRbTree.getMaxNode(node).data;\n};\n\n/**\r\n * @return The 2 nodes bounding the data. If overflow occurs, min is \r\n * returned as the second one. If bounds cannot be found (tree is empty \r\n * or contains 1 item) returns null. If the data falls on a node, that \r\n * node and the next (to the right) is returned. \r\n */\nLlRbTree.findBounds = function (tree, data) {\n\tvar node = tree.root;\n\n\tif (node === null) {\n\t\treturn null;\n\t}\n\n\tvar bounds = [];\n\twhile (node) {\n\t\tvar c = tree.comparator(data, node.data);\n\t\tif (c >= 0) {\n\t\t\tbounds[0] = node;\n\t\t} else {\n\t\t\tbounds[1] = node;\n\t\t}\n\n\t\tnode = node[c >= 0];\n\t}\n\n\treturn bounds;\n};\n\n/**\r\n * Find the node in the tree with the given data using ===. \r\n * \r\n * @return {Node} node or null if not found.\r\n */\nLlRbTree.find = function (tree, data) {\n\tvar node = tree.root;\n\n\twhile (node) {\n\t\tvar c = tree.comparator(data, node.data);\n\t\tif (c === 0) {\n\t\t\treturn node;\n\t\t} else {\n\t\t\tnode = node[c > 0];\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\r\n * Inserts a node with given data into the tree.\r\n */\nLlRbTree.insert = function (tree, data) {\n\ttree.root = insert(tree.root, data);\n\ttree.root.red = false;\n\n\tfunction insert(h, data) {\n\t\tif (h == null) {\n\t\t\treturn new Node(data);\n\t\t}\n\n\t\tif (Node.isRed(h[LEFT]) && Node.isRed(h[RIGHT])) {\n\t\t\tflipColors(h);\n\t\t}\n\n\t\tvar cmp = tree.comparator(data, h.data);\n\t\tif (cmp === 0) {\n\t\t\th.data = data;\n\t\t} else if (cmp < 0) {\n\t\t\th[LEFT] = insert(h[LEFT], data);\n\t\t} else {\n\t\t\th[RIGHT] = insert(h[RIGHT], data);\n\t\t}\n\n\t\tif (Node.isRed(h[RIGHT]) && !Node.isRed(h[LEFT])) {\n\t\t\th = rotate(LEFT, h);\n\t\t}\n\t\tif (Node.isRed(h[LEFT]) && Node.isRed(h[LEFT][LEFT])) {\n\t\t\th = rotate(RIGHT, h);\n\t\t}\n\n\t\treturn h;\n\t}\n};\n\nfunction rotate(dir, h) {\n\tvar x = h[!dir];\n\th[!dir] = x[dir];\n\tx[dir] = h;\n\tx.red = h.red;\n\th.red = true;\n\n\treturn x;\n}\n\nfunction flipColors(h) {\n\th.red = !h.red;\n\th[LEFT].red = !h[LEFT].red;\n\th[RIGHT].red = !h[RIGHT].red;\n}\n\nfunction moveRedLeft(h) {\n\tflipColors(h);\n\tif (Node.isRed(h[RIGHT][LEFT])) {\n\t\th[RIGHT] = rotate(RIGHT, h[RIGHT]);\n\t\th = rotate(LEFT, h);\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\nfunction moveRedRight(h) {\n\tflipColors(h);\n\tif (Node.isRed(h[LEFT][LEFT])) {\n\t\th = rotate(RIGHT, h);\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\n/**\r\n * Removes an item from the tree based on the given data (using ===). \r\n * \r\n * Note: Currently, a precondition is that the data must exist in the \r\n * tree. In the future we can easily modify the code to relax this \r\n * requirement. \r\n */\nLlRbTree.remove = function (tree, data) {\n\ttree.root = remove(tree.root, data);\n\tif (tree.root) {\n\t\ttree.root.red = false;\n\t}\n\n\tfunction remove(h, data) {\n\t\tif (tree.comparator(data, h.data) < 0) {\n\t\t\tif (!Node.isRed(h[LEFT]) && !Node.isRed(h[LEFT][LEFT])) {\n\t\t\t\th = moveRedLeft(h);\n\t\t\t}\n\t\t\th[LEFT] = remove(h[LEFT], data);\n\n\t\t\treturn fixUp(h);\n\t\t}\n\n\t\tif (Node.isRed(h[LEFT])) {\n\t\t\th = rotate(RIGHT, h);\n\t\t}\n\n\t\tif (!h[RIGHT] && tree.comparator(data, h.data) === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Node.isRed(h[RIGHT]) && !Node.isRed(h[RIGHT][LEFT])) {\n\t\t\th = moveRedRight(h);\n\t\t}\n\n\t\tif (tree.comparator(data, h.data) === 0) {\n\t\t\th.data = LlRbTree.min(h[RIGHT]);\n\t\t\th[RIGHT] = removeMin(h[RIGHT]);\n\t\t} else {\n\t\t\th[RIGHT] = remove(h[RIGHT], data);\n\t\t}\n\n\t\treturn fixUp(h);\n\t}\n\n\tfunction removeMin(h) {\n\t\tif (!h[LEFT]) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Node.isRed(h[LEFT]) && !Node.isRed(h[LEFT][LEFT])) {\n\t\t\th = moveRedLeft(h);\n\t\t}\n\t\th[LEFT] = removeMin(h[LEFT]);\n\n\t\treturn fixUp(h);\n\t}\n};\n\n/**\r\n * Fix right-leaning red nodes.\r\n */\nfunction fixUp(h) {\n\tif (Node.isRed(h[RIGHT])) {\n\t\th = rotate(LEFT, h);\n\t}\n\n\tif (Node.isRed(h[LEFT]) && Node.isRed(h[LEFT][LEFT])) {\n\t\th = rotate(RIGHT, h);\n\t}\n\n\t// Split 4-nodes.\n\tif (Node.isRed(h[LEFT]) && Node.isRed(h[RIGHT])) {\n\t\tflipColors(h);\n\t}\n\n\treturn h;\n}\n\nmodule.exports = LlRbTree;\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nvar MAT_CONSTANTS = {\n\t\t// TODO - should be dynamic and of order of shape dimensions.\n\t\tmaxOsculatingCircleRadius: 200,\n\t\tpointType: {\n\t\t\t\t'osculating': 0, // Osculating - Max curvatre inward,   \n\t\t\t\t'sharp': 1, // Sharp corner, \n\t\t\t\t'dull': 2, // dull corner, \n\t\t\t\t'reverseOsculating': 3, // Osculating - Max curvature outward, \n\t\t\t\t'standard': 4 }\n};\n\nmodule.exports = MAT_CONSTANTS;\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\n//---- Constants\nvar MAT_CONSTANTS = require('./mat-constants.js');\n\n//---- Functions \nvar smoothen = require('./mat/functions/smoothen.js');\nvar findMat = require('./mat/functions/find-mat.js');\nvar toScaleAxis = require('./mat/functions/to-scale-axis.js');\n\n//---- Classes - can be instantiated\nvar MatDebug = require('./debug.js');\nvar Bezier = require('./geometry/classes/bezier.js');\nvar MatNode = require('./mat/classes/mat-node.js');\nvar Mat = require('./mat/classes/mat.js');\nvar MatCircle = require('./mat/classes/mat-circle.js');\nvar ContactPoint = require('./mat/classes/contact-point.js');\nvar PointOnShape = require('./geometry/classes/point-on-shape.js');\nvar LinkedLoop = require('./linked-loop/linked-loop.js');\nvar LlRbTree = require('./ll-rb-tree//ll-rb-tree.js');\nvar Shape = require('./geometry/classes/shape.js');\nvar Svg = require('./svg/svg.js');\n\n//---- Namespaced utilities\nvar Geometry = require('./geometry/geometry.js');\nvar Util = require('./utils.js');\nvar Vector = require('./vector/vector.js');\nvar Poly = require('./polynomial/polynomial.js');\n\n//---- Expose our library to the global scope for browsers\n// See: http://www.mattburkedev.com/export-a-global-to-the-window-object-with-browserify/\n\nvar MatLib = window.MatLib || {};\n\nMatLib = Object.assign(MatLib, {\n\tfindMat: findMat,\n\tsmoothen: smoothen,\n\ttoScaleAxis: toScaleAxis,\n\n\tBezier: Bezier,\n\tMat: Mat,\n\tMatCircle: MatCircle,\n\tContactPoint: ContactPoint,\n\tPointOnShape: PointOnShape,\n\tLinkedLoop: LinkedLoop,\n\tLlRbTree: LlRbTree,\n\tShape: Shape,\n\tSvg: Svg,\n\n\tMatDebug: MatDebug,\n\n\tGeometry: Geometry,\n\tUtil: Util,\n\tVector: Vector,\n\tPoly: Poly\n});\n\n//Replace/Create the global namespace\nwindow.MatLib = MatLib;\n\n},{\"./debug.js\":1,\"./geometry/classes/bezier.js\":4,\"./geometry/classes/point-on-shape.js\":6,\"./geometry/classes/shape.js\":7,\"./geometry/geometry.js\":13,\"./linked-loop/linked-loop.js\":14,\"./ll-rb-tree//ll-rb-tree.js\":16,\"./mat-constants.js\":17,\"./mat/classes/contact-point.js\":19,\"./mat/classes/mat-circle.js\":20,\"./mat/classes/mat-node.js\":21,\"./mat/classes/mat.js\":22,\"./mat/functions/find-mat.js\":29,\"./mat/functions/smoothen.js\":32,\"./mat/functions/to-scale-axis.js\":33,\"./polynomial/polynomial.js\":39,\"./svg/svg.js\":41,\"./utils.js\":42,\"./vector/vector.js\":43}],19:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Vector = require('../../vector/vector.js');\n\n/** \r\n * Class representing a single contact point of a MatCircle instance. \r\n * @onstructor\r\n *  \r\n * @param {MatCircle} matCircle \r\n * @param {PointOnShape} pointOnShape  \r\n */\nfunction ContactPoint(pointOnShape, matCircle) {\n\tthis.pointOnShape = pointOnShape;\n\tthis.matCircle = matCircle;\n\tthis.key = PointOnShape.toHumanString(pointOnShape);\n\tthis.simpleKey = pointOnShape.simpleKey;\n\n\tthis[0] = pointOnShape[0]; // Shortcut\n\tthis[1] = pointOnShape[1]; // ...\n}\n\nContactPoint.compare = function (a, b) {\n\treturn PointOnShape.compare(a.pointOnShape, b.pointOnShape);\n};\n\nContactPoint.equal = function (a, b) {\n\treturn Vector.equal(a, b);\n};\n\nmodule.exports = ContactPoint;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"../../vector/vector.js\":43}],20:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\n\n/**\r\n * Medial (or Scale) Axis Transform (MAT) maximal contact circle class, \r\n * i.e. a representative data point of the MAT.\r\n * \r\n * @constructor\r\n * @param {Circle} circle - If null we consider it a virtual circle.\r\n * @param {ListNode<ContactPoint>[]} cpNodes - The contact points of this circle on the shape.\r\n */\nvar MatCircle = function MatCircle(circle, cpNodes) {\n\tthis.circle = circle;\n\tthis.cpNodes = cpNodes;\n\tthis.visited = 0; // TODO - does not belong inside the class\n};\n\nMatCircle.copy = function (matCircle) {\n\treturn new MatCircle(matCircle.circle, matCircle.cpNodes);\n};\n\n/** \r\n * MatCircle creator.\r\n * @param {Circle} circle \r\n * @param {ListNode<ContactPoint>[]} cpNodes An array of 'orphaned' \r\n *        (i.e. without belonging to a MatCircle) contact points.\r\n * Notes: Due to the mutual dependency between the matCircle and \r\n * contactPoints fields, a normal constructor can not instantiate a\r\n * MatCircle in one step - hence this creator.\r\n */\nMatCircle.create = function (circle, cpNodes) {\n\tvar matCircle = new MatCircle(circle, undefined);\n\n\tfor (var i = 0; i < cpNodes.length; i++) {\n\t\tcpNodes[i].item.matCircle = matCircle;\n\t}\n\tmatCircle.cpNodes = cpNodes;\n\n\treturn matCircle;\n};\n\nmodule.exports = MatCircle;\n\n},{\"../../geometry/classes/circle.js\":5}],21:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Representation of a node in the MAT structure.\r\n * \r\n * @param {MatCircle} matCircle\r\n * @param branches\r\n * @returns\r\n */\n\nvar MatCircle = require('./mat-circle.js');\n\nfunction MatNode(matCircle, branches) {\n\tthis.matCircle = matCircle;\n\tthis.branches = branches;\n}\n\nMatNode.copy = function (node) {\n\n\treturn helper(node, undefined);\n\n\tfunction helper(matNode, priorNode, newPriorNode) {\n\n\t\tvar branches = [];\n\t\t//let newNode = new MatNode(MatCircle.copy(matNode.matCircle), branches);\n\t\tvar newNode = new MatNode(matNode.matCircle, branches);\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar _node = _step.value;\n\n\t\t\t\tif (_node === priorNode) {\n\t\t\t\t\t// Don't go back in tracks.\n\t\t\t\t\tbranches.push(newPriorNode);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbranches.push(helper(_node, matNode, newNode));\n\t\t\t}\n\n\t\t\t//if (!priorNode) { console.log(newNode)}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newNode;\n\t}\n};\n\nmodule.exports = MatNode;\n\n},{\"./mat-circle.js\":20}],22:[function(require,module,exports){\n'use strict';\n\nvar traverse = require('../../mat/functions/traverse.js');\n\n/**\r\n * The Mat class represents the end product, the Medial Axis Transform. \r\n * It is defined recursively as an unrooted tree with each node  \r\n * containing a point, a radius and 1, 2 or 3 branches.\r\n * \r\n * @constructor\r\n * @param {MatNode} node - A handle on the MAT tree structure.\r\n */\nfunction Mat(node) {\n  this.startNode = node;\n}\n\n//function createFromShape\n\nMat = Object.assign(Mat, {\n  traverse: traverse\n});\n\nmodule.exports = Mat;\n\n},{\"../../mat/functions/traverse.js\":34}],23:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar MatCircle = require('../../mat/classes/mat-circle.js');\nvar Shape = require('../../geometry/classes/shape.js');\n\n/**\r\n * Adds a 2-prong contact circle to the shape.\r\n * \r\n * @param shape Shape to add the 2-prong to\r\n * @param circle Circle containing the 2 contact points\r\n * @param cp1 First contact point on shape\r\n * @param p2 Second point on shape\r\n * @param delta The boundary piece within which the new contact point should be placed\r\n * \r\n * NOTES: \r\n *   - Assume p1 is an element of delta.\r\n *   - Assume delta contains no other contact points.\r\n *   - Assume p2 cannot be an element of delta. \r\n */\nfunction add2Prong(shape, circle, cp1Node, p2, _debug_) {\n\n\tvar cp1 = cp1Node.item;\n\tvar cp2 = new ContactPoint(p2, undefined);\n\n\tvar delta = Shape.getNeighbouringPoints(shape, p2);\n\n\tvar cmp1 = ContactPoint.compare(delta[0].item, cp2);\n\tvar cmp2 = ContactPoint.compare(cp2, delta[1].item);\n\n\tif (_debug_) {\n\t\tif (cmp1 > 0 || cmp2 > 0) {\n\t\t\tconsole.log('2-PRONG Order is wrong 2: ' + cmp1 + ', ' + cmp2);\n\t\t\t//console.log(delta[0].item);\n\t\t\t//console.log(cp2);\n\t\t}\n\t}\n\n\tif (cmp1 >= 0 || cmp2 >= 0) {\n\t\tLinkedLoop.remove(shape.contactPoints, cp1Node);\n\t\treturn undefined;\n\t}\n\n\tvar newCpNode = LinkedLoop.insert(shape.contactPoints, cp2, delta[0]);\n\n\tvar matCircle = MatCircle.create(circle, [cp1Node, newCpNode]);\n\n\tcp1Node.prevOnCircle = newCpNode;\n\tnewCpNode.prevOnCircle = cp1Node;\n\n\tcp1Node.nextOnCircle = newCpNode;\n\tnewCpNode.nextOnCircle = cp1Node;\n\n\tif (_debug_) {\n\t\t// Add points so when we alt-click shape point is logged.\n\t\tprepForDebug(cp1Node, _debug_);\n\t\tprepForDebug(newCpNode, _debug_);\n\t}\n\n\treturn newCpNode;\n}\n\nfunction prepForDebug(contactPoint, _debug_) {\n\t//---- Prepare debug info for the ContactPoint\n\tvar cpKey = contactPoint.item.pointOnShape.simpleKey;\n\tvar cpHash = _debug_.generated.cpHash;\n\tvar cpArr = _debug_.generated.cpArr;\n\tif (!cpHash[cpKey]) {\n\t\tcpHash[cpKey] = {\n\t\t\tcp: contactPoint,\n\t\t\tarrIndx: cpArr.length\n\t\t};\n\t\tcpArr.push(contactPoint);\n\t}\n\n\tvar cpHashDebugObj = cpHash[cpKey];\n\n\tcpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\n\nmodule.exports = add2Prong;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/shape.js\":7,\"../../linked-loop/linked-loop.js\":14,\"../../mat/classes/contact-point.js\":19,\"../../mat/classes/mat-circle.js\":20}],24:[function(require,module,exports){\n'use strict';\n\nvar MatCircle = require('../../mat/classes/mat-circle.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\n\n/**\r\n * Adds a 3-prong MAT circle according to the 3 given \r\n * (previously calculated) points on the shape. \r\n * \r\n * @param shape\r\n * @param circle\r\n * @param [p1,p2,p3]\r\n * @param deltas\r\n * @returns {MatCircle} matCircle\r\n */\nvar kkk = 0;\nfunction add3Prong(shape, threeProng, _debug_) {\n\tvar circle = threeProng.circle,\n\t    ps = threeProng.ps,\n\t    delta3s = threeProng.delta3s;\n\n\n\tvar cps = [];\n\tfor (var i = 0; i < 3; i++) {\n\t\tcps.push(new ContactPoint(ps[i], undefined));\n\t}\n\n\tif (_debug_) {\n\t\tvar cmp1 = ContactPoint.compare(cps[0], cps[1]);\n\t\tvar cmp2 = ContactPoint.compare(cps[1], cps[2]);\n\t\t//if (cmp1 >= 0 || cmp2 >= 0) {\n\t\tif (cmp1 > 0 || cmp2 > 0) {\n\t\t\t//kkk++;\n\t\t\t//if (kkk < 2) {\n\t\t\t//console.log(`3-PRONG Order is wrong: cmp1: ${cmp1}, cmp2: ${cmp2}`);\n\t\t\t//console.log(threeProng);\n\t\t\t//}\n\t\t}\n\t}\n\n\tif (_debug_) {\n\t\tvar cmps = [];\n\t\tfor (var _i = 0; _i < 3; _i++) {\n\t\t\tcmps.push(ContactPoint.compare(delta3s[_i][0].item, cps[_i]));\n\n\t\t\tif (cmps[_i] > 0) {\n\t\t\t\tconsole.log('3-PRONG Order is wrong : i: ' + _i + ' - cmp: ' + cmps[_i]);\n\t\t\t\tconsole.log(threeProng);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar cpNodes = [];\n\tfor (var _i2 = 0; _i2 < 3; _i2++) {\n\t\tcpNodes.push(LinkedLoop.insert(shape.contactPoints, cps[_i2], delta3s[_i2][0]));\n\t}\n\n\tvar matCircle = MatCircle.create(circle, cpNodes);\n\n\tvar idxsPrev = [2, 0, 1];\n\tvar idxsNext = [1, 2, 0];\n\tfor (var _i3 = 0; _i3 < 3; _i3++) {\n\t\tcpNodes[_i3].prevOnCircle = cpNodes[idxsPrev[_i3]];\n\t\tcpNodes[_i3].nextOnCircle = cpNodes[idxsNext[_i3]];\n\t}\n\n\treturn matCircle;\n}\n\nmodule.exports = add3Prong;\n\n},{\"../../linked-loop/linked-loop.js\":14,\"../../mat/classes/contact-point.js\":19,\"../../mat/classes/mat-circle.js\":20}],25:[function(require,module,exports){\n'use strict';\n\nvar find3Prong = require('./find-3-prong.js');\nvar add3Prong = require('./add-3-prong.js');\nvar MatNode = require('../../mat/classes/mat-node.js');\nvar ContactPoint = require('../../mat/classes/contact-point.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\n/**\r\n * Recursively builds the MAT tree.\r\n * \r\n * @param {ListNode<ContactPoint>} cpNodeStart\r\n * @returns {MatNode}\r\n */\nfunction buildMat(shape, cpNodeStart, fromNode, fromCpNode, isRetry, _debug_) {\n\n\t// return;\n\n\tvar visitedPoints = void 0;\n\tdo {\n\t\tvisitedPoints = traverseShape(cpNodeStart);\n\t\tif (_debug_) {\n\t\t\t// Oops - fix\n\t\t\t// cpHashDebugObj.visitedPointsArr.push(visitedPoints);\n\t\t}\n\n\t\tif (visitedPoints.length > 2) {\n\t\t\tfindAndAdd3Prong(shape, visitedPoints, _debug_);\n\t\t}\n\t} while (visitedPoints.length > 2);\n\n\tif (cpNodeStart.item.matCircle.cpNodes.length === 1 && fromCpNode.nextOnCircle === cpNodeStart.next) {\n\n\t\t//console.log('terminal 1-prong');\n\n\t\tvar matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : [], _debug_);\n\t\treturn matNode;\n\t}\n\n\tif (visitedPoints.length === 1) {\n\t\t// Terminating 2-prong - should mostly have been eliminated\n\t\t// by osculating circles and points, but can still occur\n\t\t// due to floating point incaccuracies.\n\n\t\t// console.log('terminal 2-prong');\n\n\t\tvar _matNode = createMatNode(cpNodeStart, fromNode ? [fromNode] : [], _debug_);\n\n\t\treturn _matNode;\n\t} else if (visitedPoints.length === 2) {\n\n\t\tvar branches = fromNode ? [fromNode] : [];\n\t\tvar _matNode2 = createMatNode(cpNodeStart, branches, _debug_);\n\n\t\tvar cpBranches = cpNodeStart;\n\t\tvar i = 0;\n\t\twhile (cpBranches.nextOnCircle !== cpNodeStart && cpBranches.next !== cpBranches.nextOnCircle) {\n\n\t\t\ti++;\n\n\t\t\tvar cpNext = void 0;\n\t\t\tif (i === 1) {\n\t\t\t\tcpNext = cpBranches.next;\n\t\t\t\tcpNodeStart.item.matCircle.visited++;\n\t\t\t} else if (i === 2) {\n\t\t\t\t// TODO - instead of the commented line below working\n\t\t\t\t// perfectly, we must call the few lines below it and\n\t\t\t\t// then later call fixMat. WHY!!!??? does the line\n\t\t\t\t// below not simply work?\n\t\t\t\t// cpNext = cpBranches.next;\n\t\t\t\tcpNext = cpBranches;\n\t\t\t\tif (cpBranches.item.matCircle.visited !== 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar bm = buildMat(shape, cpNext, _matNode2, cpBranches, false, _debug_);\n\n\t\t\tbranches.push(bm);\n\n\t\t\tcpBranches = cpBranches.nextOnCircle;\n\t\t}\n\n\t\treturn _matNode2;\n\t}\n}\n\nfunction createMatNode(cp, branches, _debug_) {\n\tvar matNode = new MatNode(cp.item.matCircle, branches);\n\n\tif (_debug_) {\n\t\tprepDebugHashes(cp, matNode, _debug_);\n\t}\n\n\treturn matNode;\n}\n\nfunction traverseShape(cpNodeStart) {\n\tvar visitedPoints = void 0;\n\tvar cpNode = cpNodeStart;\n\n\tvisitedPoints = [];\n\tdo {\n\t\tvisitedPoints.push(cpNode);\n\n\t\tvar next = cpNode.next;\n\t\tcpNode = next.prevOnCircle; // Take last exit\n\t} while (cpNode !== cpNodeStart);\n\n\treturn visitedPoints;\n}\n\n/**\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * \r\n * @param {Shape}\r\n *            shape\r\n * @param {[ListNode\r\n *            <ContactPoint>]} visitedPoints\r\n * @returns\r\n * \r\n * MODIFIES: shape\r\n */\nfunction findAndAdd3Prong(shape, visitedPoints, _debug_) {\n\t/*\r\n  * visitedPoints.sort(function(a,b) { return\r\n  * PointOnShape.compare(a.item.pointOnShape,b.item.pointOnShape); });\r\n  */\n\n\tvar deltas = [];\n\tfor (var i = 0; i < visitedPoints.length; i++) {\n\t\tvar visitedPoint = visitedPoints[i];\n\t\tdeltas.push([visitedPoint, visitedPoint.next]);\n\t}\n\n\t// Check if any deltas are continuous (they should rather be\n\t// disjoint). It should be quite safe to consider points 'equal'\n\t// if they are within a certain threshold of each other, but is it\n\t// necessary? Maybe not.\n\tvar continuous = false;\n\tfor (var _i = 0; _i < deltas.length; _i++) {\n\t\tvar idxi = _i + 1;\n\t\tif (idxi === deltas.length) {\n\t\t\tidxi = 0;\n\t\t}\n\n\t\tvar endP = deltas[_i][1].item;\n\t\tvar startP = deltas[idxi][0].item;\n\t\tif (ContactPoint.equal(endP, startP)) {\n\t\t\t// console.log(_debug_.deltasToNiceStr(deltas));\n\t\t\tcontinuous = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (continuous) {\n\t\t// aaa\n\t}\n\n\tvar threeProng = find3Prong(shape, deltas, _debug_);\n\n\tfor (var _i2 = 0; _i2 < 3; _i2++) {\n\t\tPointOnShape.setPointOrder(shape, threeProng.circle, threeProng.ps[_i2], _debug_);\n\t}\n\n\tadd3Prong(shape, threeProng, _debug_);\n}\n\nfunction prepDebugHashes(cpNodeStart, matNode, _debug_) {\n\t// ---- Prepare debug info for the MatCircle\n\tvar circle = cpNodeStart.item.matCircle.circle;\n\tvar key = PointOnShape.makeSimpleKey(circle.center);\n\tvar nodeHash = _debug_.generated.nodeHash;\n\tnodeHash[key] = nodeHash[key] || {};\n\tnodeHash[key].matNode = matNode;\n\n\t// ---- Prepare debug info for the ContactPoint\n\tvar cpKey = cpNodeStart.item.pointOnShape.simpleKey;\n\tvar cpHash = _debug_.generated.cpHash;\n\tvar cpArr = _debug_.generated.cpArr;\n\tif (!cpHash[cpKey]) {\n\t\tcpHash[cpKey] = {\n\t\t\tcp: cpNodeStart,\n\t\t\tarrIndx: cpArr.length\n\t\t};\n\t\tcpArr.push(cpNodeStart);\n\t}\n\n\tvar cpHashDebugObj = cpHash[cpKey];\n\tcpHashDebugObj.visitedPointsArr = cpHashDebugObj.visitedPointsArr || [];\n}\n\nmodule.exports = buildMat;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"../../mat/classes/contact-point.js\":19,\"../../mat/classes/mat-node.js\":21,\"./add-3-prong.js\":24,\"./find-3-prong.js\":28}],26:[function(require,module,exports){\n'use strict';\n\nvar MatNode = require('../../mat/classes/mat-node.js');\nvar Mat = require('../classes/mat.js');\n\nfunction copyMat(mat) {\n\treturn new Mat(MatNode.copy(mat.startNode));\n}\n\nmodule.exports = copyMat;\n\n},{\"../../mat/classes/mat-node.js\":21,\"../classes/mat.js\":22}],27:[function(require,module,exports){\n'use strict';\n\nvar MAX_ITERATIONS = 50;\n//TODO Change tolerances to take shape dimension into \n// account, e.g. shapeDim / 10000 for SEPERATION_TOLERANCE;\n//CONST SEPERATION_TOLERANCE = 1e-3;\nvar SEPERATION_TOLERANCE = 1e-2;\nvar SQUARED_SEPERATION_TOLERANCE = SEPERATION_TOLERANCE * SEPERATION_TOLERANCE;\n//const ERROR_TOLERANCE = 1e-3;\nvar ERROR_TOLERANCE = SEPERATION_TOLERANCE / 10;\nvar SQUARED_ERROR_TOLERANCE = ERROR_TOLERANCE * ERROR_TOLERANCE;\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar Shape = require('../../geometry/classes/shape.js');\nvar LinkedLoop = require('../../linked-loop/linked-loop.js');\nvar getClosestBoundaryPointToPoint = require('../../geometry/functions/get-closest-boundary-point-to-point.js');\nvar Vector = require('../../vector/vector.js');\nvar PointOnShape = require('../../geometry/classes/Point-on-shape.js');\n\n/**\r\n * Adds a 2-prong to the MAT. The first point is given and the second\r\n * one is found by the algorithm.\r\n * \r\n * A 2-prong is a MAT circle that touches the shape in 2 points.\r\n * \r\n * @param shape\r\n * @param {ListNode<ContactPoint>} cpNode The first point of the 2-prong.\r\n * @param _debug_ Used for debugging only.\r\n * \r\n * Before any 2-prongs are added the entire shape is our d-Omega δΩ\r\n * (1-prongs does not reduce the boundary),\r\n * \r\n * As per the paper by Choi, Choi, Moon and Wee: \r\n *   \"The starting point of this algorithm is a choice of a circle\r\n *    Br(x) centered at an interior point x which contains two boundary\r\n *    portions c and d of d-Omega as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary\r\n * beforehand. \r\n */\nfunction find2Prong(shape, cpNode, _debug_) {\n\n\t// The first point on the shape of the 2-prong.\n\tvar y = cpNode.item.pointOnShape;\n\n\t/* The boundary piece that should contain the other point of \r\n  * the 2-prong circle. (Defined by start and end points).\r\n  */\n\tvar δ = [cpNode, cpNode];\n\n\t/* The failed flag is set if a 2-prong cannot be found. This occurs\r\n  * when the 2 points are too close together and the 2-prong \r\n  * becomes, in the limit, a 1-prong. We do not want these 2-prongs\r\n  * as they push the floating point precision limits when finding\r\n  * their circle center causing too much inaccuracy. Of course, our\r\n  * entire algorithm's precision is limited by floating point \r\n  * doubles.\r\n  */\n\tvar failed = false;\n\n\t/* \r\n  * The shortest distance so far between the first contact point and\r\n  * the circle center - we require this to get shorter on each \r\n  * iteration as convergence occurs. If it does not, oscillation\r\n  * of the algorithm has occured due to floating point inaccuracy\r\n  * and the algorithm must terminate.\r\n  */\n\tvar shortestSquaredDistance = Number.POSITIVE_INFINITY;\n\n\tvar pos = cpNode.item.pointOnShape;\n\tvar bezierNode = pos.bezierNode;\n\tvar t = pos.t;\n\n\tvar x = cpNode.item.matCircle.circle.center;\n\tvar bezierPieces = Geometry.getBoundaryPieceBeziers(shape, δ);\n\tvar xs = void 0; // Trace the convergence.\n\tvar z = void 0;\n\tvar squaredError = void 0;\n\t//\n\t//let slog = _debug_.twoProngs.length === 16;\n\tvar i = 0;\n\t/*if (slog) { \r\n \tconsole.log('a')\r\n }*/\n\t//\n\tdo {\n\t\t//\n\t\ti++;\n\t\t//\n\t\tvar r = Vector.squaredDistanceBetween(x, y);\n\t\tbezierPieces = cullBezierPieces(bezierPieces, x, r, _debug_);\n\n\t\tz = getClosestBoundaryPointToPoint(bezierPieces, x, y, bezierNode, t, _debug_ /*,\r\n                                                                                slog && i > 3*/\n\t\t);\n\n\t\t//if (_debug_) { xs = xs || []; xs.push({ x, y, z, t });\t}\n\n\t\tvar squaredChordDistance = Vector.squaredDistanceBetween(y, z);\n\n\t\t//if (slog) { console.log('sqd: ' + squaredChordDistance); }\n\n\t\tif (squaredChordDistance <= SQUARED_SEPERATION_TOLERANCE) {\n\t\t\tfailed = true;\n\t\t\t//console.log(_debug_.twoProngs.length);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\r\n   * Find the point on the line connecting y with x that is  \r\n   * equidistant from y and z. This will be our next x.\r\n   */\n\t\tvar nextX = findEquidistantPointOnLine(x, y, z);\n\n\t\tsquaredError = Vector.squaredDistanceBetween(x, nextX);\n\n\t\t/*\r\n   * Prevent oscillation of calculated x (due to floating point\r\n   * inaccuracies). See comment above decleration of \r\n   * shortestSquaredDistance.\r\n   */\n\t\tvar squaredDistance = Vector.squaredDistanceBetween(y, nextX);\n\t\tif (squaredDistance < shortestSquaredDistance) {\n\t\t\tshortestSquaredDistance = squaredDistance;\n\t\t} else {\n\t\t\t//failed = true;\n\t\t\t//break;\n\t\t}\n\n\t\tx = nextX;\n\n\t\tif (_debug_) {\n\t\t\txs = xs || [];xs.push({ x: x, y: y, z: z, t: t });\n\t\t}\n\t} while (squaredError > SQUARED_ERROR_TOLERANCE && i < MAX_ITERATIONS);\n\n\tif (i === MAX_ITERATIONS) {\n\t\t// This is simply a case of convergence being too slow. The\n\t\t// gecko, for example, takes a max of 21 iterations.\n\t\tfailed = true;\n\t}\n\n\tvar circle = new Circle(x, Vector.distanceBetween(x, z));\n\n\tif (_debug_) {\n\t\trecordForDebugging(_debug_, failed, cpNode, circle, y, z, δ, xs);\n\t}\n\n\tif (failed) {\n\t\t// Remove failed point.\n\t\tLinkedLoop.remove(shape.contactPoints, cpNode);\n\t\treturn undefined;\n\t}\n\n\tPointOnShape.setPointOrder(shape, circle, z, _debug_);\n\treturn { circle: circle, z: z };\n}\n\nfunction recordForDebugging(_debug_, failed, cpNode, circle, y, z, δ, xs) {\n\n\t// This is a medial axis point.\n\tif (failed) {\n\t\t//_debug_.draw.dot(cpNode.item, 0.6, 'black');\n\t\t_debug_.draw.dot(cpNode.item, 1, 'black');\n\t\t_debug_.draw.dot(cpNode.item, 0.1, 'yellow');\n\t\t//_debug_.draw.dot(cpNode.item, 0.01, 'black');\n\t\t//_debug_.draw.dot(cpNode.item, 0.001, 'yellow');\n\t\t//_debug_.draw.dot(cpNode.item, 0.0001, 'black');\n\t} else {\n\t\t_debug_.draw.dot(circle.center, 0.5, 'yellow');\n\t\tif (_debug_.drawStuff) {\n\t\t\t_debug_.draw.circle(circle, 'red thin2 nofill');\n\t\t\t_debug_.draw.dot(cpNode.item, 0.55, 'red');\n\t\t\t_debug_.draw.dot(z, 0.7, 'red');\n\t\t}\n\t}\n\n\t_debug_.twoProngs.push({\n\t\ttwoProng: cpNode,\n\t\tδ: δ,\n\t\ty: y,\n\t\tx: circle.center,\n\t\txs: xs,\n\t\tfailed: failed\n\t});\n}\n\n/**\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * \r\n * @param {BezierPieces} bezierPieces\r\n * @param {[Number]} p\r\n * @param {Number} r\r\n * @returns\r\n */\nfunction cullBezierPieces(bezierPieces, p, rSquared, _debug_) {\n\tvar CULL_THRESHOLD = 5;\n\n\tif (bezierPieces.length <= CULL_THRESHOLD) {\n\t\treturn bezierPieces;\n\t}\n\n\tvar newPieces = [];\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar bezierPiece = _step.value;\n\n\t\t\tvar bezier = bezierPiece.bezierNode.item;\n\n\t\t\tvar rect = bezier.getBoundingBox();\n\t\t\tvar bd = Geometry.getClosestSquareDistanceToRect(rect, p);\n\t\t\tif (bd <= rSquared) {\n\t\t\t\tnewPieces.push(bezierPiece);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newPieces;\n}\n\n/**\r\n * \r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from\r\n *          y and z. \r\n *          \r\n * Notes: It is important that this function is numerically stable,\r\n * but this has not been investigated properly yet.\r\n */\nfunction findEquidistantPointOnLine(x, y, z) {\n\t// Some basic algebra (not shown) finds the required point.\n\n\t// Swap axis if x and y are more aligned to y-axis than to x-axis.\n\tvar swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\n\n\t// Cache\n\tvar x1 = void 0,\n\t    x2 = void 0,\n\t    y1 = void 0,\n\t    y2 = void 0,\n\t    z1 = void 0,\n\t    z2 = void 0;\n\n\tif (swapAxes) {\n\t\tx1 = x[1];x2 = x[0];\n\t\ty1 = y[1];y2 = y[0];\n\t\tz1 = z[1];z2 = z[0];\n\t} else {\n\t\tx1 = x[0];x2 = x[1];\n\t\ty1 = y[0];y2 = y[1];\n\t\tz1 = z[0];z2 = z[1];\n\t}\n\n\t// a <= 1 (due to swapped axes)\n\tvar a = (x2 - y2) / (x1 - y1);\n\tvar b = y2 - a * y1;\n\tvar c = y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2 + 2 * b * (z2 - y2);\n\tvar d = y1 - z1 + a * (y2 - z2);\n\tvar t1 = c / (2 * d);\n\tvar t2 = a * t1 + b;\n\n\treturn swapAxes ? [t2, t1] : [t1, t2];\n}\n\nmodule.exports = find2Prong;\n\n// 318\n\n},{\"../../geometry/classes/Point-on-shape.js\":2,\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/shape.js\":7,\"../../geometry/functions/get-closest-boundary-point-to-point.js\":10,\"../../geometry/geometry.js\":13,\"../../linked-loop/linked-loop.js\":14,\"../../vector/vector.js\":43}],28:[function(require,module,exports){\n'use strict';\n\nvar Util = require('../..//utils.js');\nvar Circle = require('../../geometry/classes/circle.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar Vector = require('../../vector/vector.js');\nvar getClosestBoundaryPointToPoint = require('../../geometry/functions/get-closest-boundary-point-to-point.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\nvar calcVectorToZeroV_StraightToIt = Vector.fromTo;\n\nfunction calcVectorToZeroV_AlongMedial(circleCenter, ps, _debug_) {\n\tvar v1 = Vector.fromTo(ps[0], ps[2]);\n\tvar v2 = [-v1[1], v1[0]]; // Rotate by 90 degrees\n\tvar l1 = Vector.length(Vector.fromTo(x, circleCenter));\n\tvar v3 = Vector.toUnitVector(v2);\n\tvar v4 = Vector.scale(v3, l1);\n\tif (_debug_) {\n\t\t_debug_.draw.line([x, Vector.translate(x, vectorToZeroV)], 'thin10 red');\n\t\t_debug_.draw.line([x, Vector.translate(x, v4)], 'thin10 blue');\n\t}\n\n\treturn v4;\n}\n\n/**\r\n * Look for a 3-prong from the given walked boundary piece.\r\n *\r\n * @param {Shape} shape\r\n * @param {[ContactPoint]} deltas\r\n * \r\n */\nfunction find3Prong(shape, deltas, _debug_) {\n\n\tvar bezierPiecess = deltas.map(function (δ) {\n\t\treturn Geometry.getBoundaryPieceBeziers(shape, δ);\n\t});\n\n\tvar bps = void 0; // Best ps\n\tvar bx = void 0;\n\n\tvar dbgInfo = void 0;\n\tif (_debug_) {\n\t\tdbgInfo = { cs: [] };\n\t}\n\n\tvar iindx = void 0;\n\tvar smallestRadiusDelta = Number.POSITIVE_INFINITY;\n\tfor (var i = 1; i < deltas.length - 1; i++) {\n\t\tvar _find3ProngForDelta3s = find3ProngForDelta3s(shape, deltas, i, bezierPiecess, dbgInfo, _debug_),\n\t\t    radiusDelta = _find3ProngForDelta3s.radiusDelta,\n\t\t    ps = _find3ProngForDelta3s.ps,\n\t\t    _x = _find3ProngForDelta3s.x;\n\n\t\tif (radiusDelta < smallestRadiusDelta) {\n\t\t\tsmallestRadiusDelta = radiusDelta;\n\t\t\tiindx = i;\n\t\t\tbps = ps;\n\t\t\tbx = _x;\n\t\t}\n\t}\n\n\tvar totDist = Vector.distanceBetween(bx, bps[0]) + Vector.distanceBetween(bx, bps[1]) + Vector.distanceBetween(bx, bps[2]);\n\n\tvar circle = new Circle(bx, totDist / 3);\n\n\tvar delta3s = [deltas[0], deltas[iindx], deltas[deltas.length - 1]];\n\n\tvar threeProng = { delta3s: delta3s, circle: circle, ps: bps };\n\n\tif (_debug_) {\n\t\tadd3ProngForDebugging(threeProng, deltas, iindx, dbgInfo, bps, _debug_);\n\t}\n\n\treturn threeProng;\n}\n\n/**\r\n * Finds a 3-prong using only the 3 given delta's.\r\n * \r\n * @param i - Specific delta indx.\r\n * @returns\r\n */\nfunction find3ProngForDelta3s(shape, deltas, idx, bezierPiecess, dbgInfo, _debug_) {\n\n\t// TODO - Choose a tolerance relative to shape size.\n\tvar TOLERANCE = 1e-7;\n\n\tvar delta3s = [deltas[0], deltas[idx], deltas[deltas.length - 1]];\n\n\tvar bezierPiece3s = [bezierPiecess[0], bezierPiecess[idx], bezierPiecess[deltas.length - 1]];\n\n\tvar ps = void 0;\n\tvar circleCenter = void 0;\n\tvar ii = 0; // Safeguard\n\tvar x = calcInitial3ProngPoint(shape, delta3s, bezierPiece3s, _debug_);\n\tvar tolerance = Number.POSITIVE_INFINITY;\n\t// TODO 10 below is magic, fix or add somewhere as a constant\n\twhile (tolerance > TOLERANCE && ii < 10) {\n\t\tii++;\n\n\t\tps = getClosestPoints(x, bezierPiece3s, _debug_);\n\t\tcircleCenter = myCircumCenter(ps, _debug_);\n\n\t\tvar _vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circleCenter);\n\t\t//let vectorToZeroV = calcVectorToZeroV_AlongMedial (x, circleCenter, ps);\n\n\t\tvar upds = calcBetterX(bezierPiece3s, x, _vectorToZeroV, _debug_);\n\t\tx = upds.newX;\n\n\t\tvar V = Vector.length(_vectorToZeroV);\n\t\tps = upds.newPs;\n\n\t\ttolerance = Math.abs(V - upds.newV);\n\t}\n\n\t// CircumCircle radius\n\tvar radius = Vector.length(Vector.fromTo(ps[0], circleCenter));\n\n\tvar closestDs = [];\n\tfor (var i = 0; i < bezierPiecess.length; i++) {\n\t\tvar p = getClosestBoundaryPointToPoint(bezierPiecess[i], circleCenter, undefined, // exclPoint,\n\t\tundefined, // bezierNode\n\t\tundefined, // t\n\t\t_debug_);\n\n\t\tclosestDs.push(Vector.length(Vector.fromTo(p, circleCenter)));\n\t}\n\n\tvar closestD = Util.bestBy(closestDs);\n\tvar radiusDelta = radius - closestD;\n\n\tif (_debug_) {\n\t\tdbgInfo.cs.push({ ps: ps, x: x, ccr: radius, indxi: idx });\n\t}\n\n\treturn { radiusDelta: radiusDelta, ps: ps, x: x };\n}\n\n/**\r\n * Find new x and ps that are a better estimate of the 3-prong  \r\n * circle.\r\n * \r\n * The potential function, V, is defined as the distance to the \r\n * actual 3 prong circle center.\r\n */\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV, _debug_) {\n\n\tvar V = Vector.length(vectorToZeroV);\n\n\tvar nu = 1;\n\tvar better = void 0;\n\tvar newX = void 0;\n\tvar newPs = void 0;\n\tvar newV = void 0;\n\tvar i = 0; // Safeguard\n\tdo {\n\t\tvar shift = Vector.scale(vectorToZeroV, nu);\n\t\tnewX = Vector.translate(x, shift);\n\n\t\tnewPs = getClosestPoints(newX, bezierPiece3s, _debug_);\n\n\t\t// Point of zero V\n\t\tvar newCircleCenter = myCircumCenter(newPs, _debug_);\n\t\tvar newVectorToZeroV = Vector.fromTo(newX, newCircleCenter);\n\t\tnewV = Vector.length(newVectorToZeroV);\n\n\t\tbetter = newV < V;\n\n\t\tnu = nu / 2;\n\n\t\ti++;\n\t} while (!better && i < 3);\n\t//console.log(i); \n\n\treturn { newX: newX, newV: newV, newPs: newPs };\n}\n\n/**\r\n * Finds an initial 3-prong circle center point from which to iterate.\r\n * The point must be within the shape. \r\n * \r\n * @param {[ContactPoint]} delta3s - The three boundary pieces of which\r\n *        we need to find the three 3-prong points.\r\n * @returns\r\n */\nfunction calcInitial3ProngPoint(shape, delta3s, bezierPiece3s, _debug_) {\n\n\t// TODO - No need to calculate, we already have this info somewhere.\n\tvar twoProngCircleCenter = Vector.mean([delta3s[0][0].item, delta3s[2][1].item]);\n\tvar point1 = getClosestBoundaryPointToPoint(bezierPiece3s[1], twoProngCircleCenter, undefined, // exclPoint,\n\tundefined, // bezierNode\n\tundefined, // t\n\t_debug_);\n\n\tvar meanPoints = [delta3s[0][0].item,\n\t//Vector.mean([delta3s[1][0].item, delta3s[1][1].item]),\n\tpoint1, delta3s[2][1].item];\n\n\tvar p = void 0;\n\tif (delta3s[0][0].item.pointOnShape.type === 1) {\n\t\t// delta3s start and end at sharp corner.\n\t\t// If delta3s start at a sharp corner it will end there also\n\t\t// so no need to check for end point as well.\n\t\tp = Vector.mean([meanPoints[0], meanPoints[1]]);\n\t} else {\n\t\tp = Vector.circumCenter(meanPoints);\n\t}\n\n\tif (!Number.isFinite(p[0])) {\n\t\tif (_debug_) {\n\t\t\t// TODO - check why this actuall happens sometimes\n\t\t\t//console.log(_debug_.pointsToNiceStr(meanPoints));\n\t\t\t//console.log(_debug_.deltasToNiceStr(delta3s));\n\t\t\t//console.log(p, meanPoints);\n\t\t}\n\t}\n\tif (!Number.isFinite(p[0])) {\n\t\tvar sames = whichNotSame(meanPoints);\n\t\treturn Vector.mean([meanPoints[sames[0]], meanPoints[sames[1]]]);\n\t}\n\n\treturn p;\n}\n\nfunction add3ProngForDebugging(threeProng, deltas, iindx, dbgInfo, bps, _debug_) {\n\n\t_debug_.nProngs.push(threeProng);\n\n\tdbgInfo.deltas = deltas;\n\tdbgInfo.deltasSimple = deltas.map(function (delta) {\n\t\treturn [PointOnShape.toHumanString(delta[0].item.pointOnShape), PointOnShape.toHumanString(delta[1].item.pointOnShape)];\n\t});\n\tdbgInfo.iindx = iindx;\n\n\tif (_debug_.drawStuff) {\n\t\tfor (var i = 0; i < bps.length; i++) {\n\t\t\tvar p = bps[i];\n\t\t\t_debug_.draw.dot(p, 0.1 * (i + 1), 'blue');\n\t\t}\n\t}\n\n\tif (_debug_.drawStuff) {\n\t\t// This is a MAT point!\n\t\t_debug_.draw.dot(threeProng.circle.center, 0.3, 'blue');\n\n\t\t_debug_.draw.circle(threeProng.circle, 'blue thin1 nofill');\n\t}\n}\n\nfunction whichNotSame(ps) {\n\tif (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\n\t\treturn [0, 2];\n\t} else if (ps[1][0] === ps[2][0] && ps[1][1] === ps[2][1]) {\n\t\treturn [0, 2];\n\t} else if (ps[2][0] === ps[0][0] && ps[2][1] === ps[0][1]) {\n\t\treturn [1, 2];\n\t};\n\n\treturn [];\n}\n\nfunction getClosestPoints(x, bezierPiece3s, _debug_) {\n\n\treturn bezierPiece3s.map(function (bezierPieces) {\n\n\t\tvar p = getClosestBoundaryPointToPoint(bezierPieces, x, undefined, // exclPoint,\n\t\tundefined, // bezierNode\n\t\tundefined, // t\n\t\t_debug_);\n\n\t\treturn p;\n\t});\n}\n\n/**\r\n * \r\n * @param ps\r\n * @param _debug_\r\n * @returns\r\n * \r\n * NOTES: Intead of using splitBack, split and splitForward, we should\r\n *        use the tangents at the inward cone.\r\n */\nfunction myCircumCenter(ps, _debug_) {\n\t//return Vector.circumCenter(ps);\n\n\n\tvar minD = 0.0005; // Keep this smaller than 2-prong gaps?\n\tvar tGap = 0.0005;\n\n\tvar l1 = Vector.distanceBetween(ps[0], ps[1]);\n\tvar l2 = Vector.distanceBetween(ps[1], ps[2]);\n\tvar l3 = Vector.distanceBetween(ps[2], ps[0]);\n\n\tvar indxs = void 0;\n\tif (l1 < minD) {\n\t\tindxs = [0, 1, 2];\n\t} else if (l2 < minD) {\n\t\tindxs = [1, 2, 0];\n\t} else if (l3 < minD) {\n\t\tindxs = [2, 0, 1];\n\t}\n\n\tif (indxs) {\n\n\t\tvar newPs = [PointOnShape.splitBack(ps[indxs[0]], tGap), PointOnShape.split(ps[indxs[0]], tGap), PointOnShape.splitForward(ps[indxs[0]], tGap)];\n\n\t\t//return Vector.circumCenter([newPs[0][0], newPs[0][1], ps[indxs[2]]]);\n\n\n\t\tvar ccs = newPs.map(function (newP) {\n\t\t\treturn Vector.circumCenter([newP[0], newP[1], ps[indxs[2]]]);\n\t\t});\n\n\t\tvar idx = 0;\n\t\tvar _minD = Number.POSITIVE_INFINITY;\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tvar d = Vector.distanceBetween(ccs[i], ps[indxs[2]]);\n\t\t\tif (d < _minD) {\n\t\t\t\t_minD = d;\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\n\t\treturn ccs[idx];\n\t}\n\n\treturn Vector.circumCenter(ps);\n}\n\nfunction myCircumCenter1(ps, _debug_) {\n\t//return Vector.circumCenter(ps);\n\n\n\tvar minD = 0.0005; // Keep this smaller than 2-prong gaps?\n\tvar tGap = 0.0005;\n\n\tvar l1 = Vector.distanceBetween(ps[0], ps[1]);\n\tvar l2 = Vector.distanceBetween(ps[1], ps[2]);\n\n\tvar indxs = void 0;\n\t//if (l1 < minD) {\n\tif (l1 === 0) {\n\t\tvar newPs = PointOnShape.splitForward(ps[0], tGap);\n\t\treturn Vector.circumCenter([newPs[0], newPs[1], ps[2]]);\n\t\t//} else if (l2 < minD) {\n\t} else if (l2 === 0) {\n\t\tvar _newPs = PointOnShape.splitBack(ps[0], tGap);\n\t\treturn Vector.circumCenter([_newPs[0], _newPs[1], ps[2]]);\n\t}\n\n\treturn Vector.circumCenter(ps);\n}\n\n/*\r\nfunction whichSame(ps) {\r\n\tif (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\r\n\t\treturn [0,1];\r\n\t} else if (ps[1][0] === ps[2][0] && ps[1][1] === ps[2][1]) {\r\n\t\treturn [1,2];\r\n\t} else if (ps[2][0] === ps[0][0] && ps[2][1] === ps[0][1]) {\r\n\t\treturn [2,0];\r\n\t};\r\n\t\r\n\treturn []; \r\n}\r\n*/\n\n/** \r\n * Resolve ps (as in stellar) if they are too close together, \r\n * i.e. same point.\r\n */\n/*\r\nfunction resolvePs(ps) {\r\n\t\r\n\tlet sames = whichSame(ps);\r\n\tif (sames.length === 0) {\r\n\t\treturn ps;\r\n\t}\r\n\t\r\n\r\n\tlet pps = [];\r\n\tlet s0 = sames[0];\r\n\tlet s1 = sames[1];\r\n\tlet abit = 0.0000001; \r\n\t//let abit = 0.01; \r\n\t\r\n\tpps = ps.slice();\r\n\t\r\n\tif (pps[s0].t < abit) {\r\n\t\tif (pps[s1].t + abit > 1) {\r\n\t\t\t[s0,s1] = [s1,s0];\r\n\t\t}\r\n\t\tpps[s1] = PointOnShape.shift(ps[s1], abit);\r\n\t} else {\r\n\t\tif (pps[s0].t < abit) {\r\n\t\t\t[s0,s1] = [s1,s0];\r\n\t\t}\r\n\t\tpps[s0] = PointOnShape.shift(ps[s0], -abit);\r\n\t}\r\n\t\r\n\treturn pps;\r\n}\r\n*/\n\nmodule.exports = find3Prong;\n\n// 459\n\n},{\"../..//utils.js\":42,\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/functions/get-closest-boundary-point-to-point.js\":10,\"../../geometry/geometry.js\":13,\"../../vector/vector.js\":43}],29:[function(require,module,exports){\n'use strict';\n\nvar add2Prong = require('./add-2-prong.js');\nvar find2Prong = require('./find-2-prong.js');\nvar buildMat = require('./build-mat.js');\nvar Mat = require('../classes/mat.js');\n\n/**\r\n * Find the MAT from the given Shape.\r\n */\nfunction findMat(shape, _debug_) {\n\n\t// TODO - run KILL_HOMOLOGY - this step will allow for shapes \n\t// with homology (i.e. with holes in them) to work as well.\n\n\tvar t0 = void 0;\n\t//if (_debug_) {\n\tt0 = performance.now();\n\t//}\n\n\tadd2Prongs(shape, _debug_);\n\t//return;\n\n\t//if (_debug_) { \n\tvar t1 = performance.now();\n\n\tif (_debug_) {\n\t\t_debug_.add2ProngsDuration = t1 - t0;\n\t}\n\tconsole.log('    2-prongs took ' + (t1 - t0).toFixed(0) + ' milliseconds.');\n\t//}\n\n\t/*\r\n  * Connect the dots and add the 3-prongs.\r\n  * \r\n  * 1. Start with any 2-prong (might not be neccessary, we might be able\r\n  * to start with any contact-point\r\n  * \r\n  */\n\n\t/* ---- \r\n  * Find a good starting point for our tree structure \r\n  * e.g. (first 2-prong).\r\n  * TODO Check if this step is really necessary.  \r\n  */\n\n\tvar ta0 = void 0;\n\tta0 = performance.now();\n\n\tvar contactPoints = shape.contactPoints;\n\tvar cpNode = contactPoints.head;\n\tdo {\n\t\tif (cpNode.item.matCircle.cpNodes.length === 2) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcpNode = cpNode.next;\n\t} while (cpNode !== contactPoints.head);\n\n\tvar cptest = cpNode.prevOnCircle;\n\n\tvar branchBack = buildMat(shape, cptest.prevOnCircle, undefined, undefined, false, _debug_);\n\tvar branchForth = buildMat(shape, cptest, undefined, undefined, false, _debug_);\n\n\tbranchForth.branches.push(branchForth.branches[0]);\n\tbranchForth.branches[0] = branchBack.branches[0];\n\tbranchBack.branches[0].branches[0] = branchForth;\n\n\tvar mat = new Mat(branchForth);\n\n\tvar ta1 = performance.now();\n\tif (_debug_) {\n\t\t_debug_.add2ProngsDuration = ta1 - ta0;\n\t}\n\tconsole.log('    3-prongs took ' + (ta1 - ta0).toFixed(0) + ' milliseconds.');\n\n\t//return mat;\n\n\tvar matFixed = fixMat(mat);\n\n\treturn matFixed;\n}\n\n/** \r\n * Add 2 prongs.\r\n * \r\n * See comments on the add2Prong function.\r\n */\nvar failCount = 0;\nfunction add2Prongs(shape, _debug_) {\n\n\tvar for2Prongs = shape.for2Prongs;\n\n\tvar len = for2Prongs.length;\n\n\t//let index = indexInterlaced(len); // Keep for debuggin.\n\tvar index = indexLinear(len);\n\n\t//console.log(len);\n\tfor (var i = 0; i < len; i++) {\n\t\tvar cpNode = for2Prongs[index[i]];\n\t\tvar twoProngInfo = find2Prong(shape, cpNode, _debug_);\n\n\t\tif (twoProngInfo) {\n\t\t\tvar circle = twoProngInfo.circle,\n\t\t\t    z = twoProngInfo.z;\n\n\t\t\tvar newCpNode = add2Prong(shape, circle, cpNode, z, _debug_);\n\t\t\t/*if (!newCpNode) {\r\n   \t\r\n   }*/\n\t\t} else {\n\t\t\tfailCount++;\n\t\t}\n\t}\n\n\tconsole.log('2-prong fails: ' + failCount);\n}\n\n/** \r\n * This is unfortunately currently required since I can't get the\r\n * buildMat recursive algorithm right on the first pass.\r\n * @param mat\r\n * @returns\r\n */\nvar lll = 0;\nfunction fixMat(mat) {\n\n\thelper(mat.startNode, undefined);\n\n\tfunction helper(matNode, priorNode) {\n\n\t\tif (matNode.branches.length === 3 && matNode.branches[2].matCircle === matNode.matCircle) {\n\n\t\t\tvar firstRight = matNode.branches[2];\n\t\t\tvar secondRight = firstRight.branches[1];\n\t\t\tmatNode.branches[2] = secondRight;\n\t\t\tsecondRight.branches[0] = matNode;\n\t\t}\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = matNode.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar node = _step.value;\n\n\t\t\t\tif (node === priorNode) {\n\t\t\t\t\t// Don't go back in tracks.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\thelper(node, matNode);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mat;\n}\n\n/**\r\n * Creates a kind of interlaced index vector, e.g. TODO\r\n * \r\n * @param n\r\n * @returns\r\n */\n/*\r\nfunction indexInterlaced(n) {\r\n\t\r\n\tlet arr = [];\r\n\thelper(0, n, arr);\r\n\t\r\n\treturn arr;\r\n\t\r\n\tfunction helper(start, end) {\r\n\t\t\r\n\t\tif (end === start) { \r\n\t\t\treturn; \r\n\t\t}\r\n\t\t\r\n\t\tif ((end - start) === 1) {\r\n\t\t\tarr.push(start);\r\n\t\t\treturn;\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tlet halfway = start + Math.floor((end-start) / 2);\r\n\t\t\r\n\t\tarr.push(halfway);\r\n\t\thelper(start, halfway);\r\n\t\thelper(halfway+1, end);\r\n\t}\r\n}\r\n*/\n\nfunction indexInterlaced(n) {\n\n\tvar source = {};\n\tvar arr = [];\n\t// l <=> the lowest power of 2 so that 2^l > n\n\tvar l = Math.pow(2, Math.floor(Math.log2(n)));\n\n\twhile (l >= 1) {\n\t\tvar k = 0;\n\t\twhile (k < n) {\n\t\t\tif (!source[k]) {\n\t\t\t\tarr.push(k);\n\t\t\t\tsource[k] = true;\n\t\t\t}\n\t\t\tk = k + l;\n\t\t}\n\t\tl = l / 2;\n\t}\n\n\treturn arr;\n}\n\n/**\r\n * Simple linear array indexing.\r\n * @param n\r\n * @returns\r\n */\nfunction indexLinear(n) {\n\tvar arr = [];\n\tfor (var i = 0; i < n; i++) {\n\t\tarr.push(i);\n\t}\n\treturn arr;\n}\n\nmodule.exports = findMat;\n\n},{\"../classes/mat.js\":22,\"./add-2-prong.js\":23,\"./build-mat.js\":25,\"./find-2-prong.js\":27}],30:[function(require,module,exports){\n'use strict';\n\nvar traverse = require('./traverse.js');\n\nfunction getNodesAsArray(mat) {\n\tvar nodes = [];\n\n\ttraverse(mat, function (node) {\n\t\tnodes.push(node);\n\t});\n\n\treturn nodes;\n}\n\nmodule.exports = getNodesAsArray;\n\n},{\"./traverse.js\":34}],31:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\nvar traverse = require('./traverse.js');\n\nfunction getNodesAsHash(mat) {\n\tvar nodes = {};\n\n\ttraverse(mat, function (node) {\n\t\tvar key = PointOnShape.makeSimpleKey(node.matCircle.circle.center);\n\t\tnodes[key] = node;\n\t});\n\n\treturn nodes;\n}\n\nmodule.exports = getNodesAsHash;\n\n},{\"../../geometry/classes/point-on-shape.js\":6,\"./traverse.js\":34}],32:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Geometry = require('../../geometry/geometry.js');\nvar Vector = require('../../vector/vector.js');\nvar Mat = require('../classes/mat.js');\nvar MAT_CONSTANTS = require('../../mat-constants.js');\n\nvar DRAW_CLASS_LINE = 'nofill thin20 blue';\nvar DRAW_CLASS_QUAD = 'nofill thin20 blue';\nvar DRAW_CLASS_CUBE = 'nofill thin20 blue';\n//const DRAW_CLASS_CUBE = 'thin20 blue';\n\n/**\r\n * Smoothens the given MAT by fitting consecutive node links by\r\n * lines, quadratic or cubic beziers. \r\n */\n\nfunction smoothen(mat, _debug_) {\n\n\t/**\r\n  * Get the linked contact points. TODO This information to be\r\n  * stored in the MatCircle in the future then there is no need\r\n  * to actually search for it! \r\n  */\n\tfunction getLinkedCps(_ref) {\n\t\tvar _ref2 = _slicedToArray(_ref, 2),\n\t\t    prevCpNodes = _ref2[0],\n\t\t    currCpNodes = _ref2[1];\n\n\t\tfor (var i = 0; i < prevCpNodes.length; i++) {\n\t\t\tvar prevCpNode = prevCpNodes[i];\n\n\t\t\tfor (var j = 0; j < currCpNodes.length; j++) {\n\t\t\t\tvar currCpNode = currCpNodes[j];\n\n\t\t\t\tif (prevCpNode.next === currCpNode) {\n\t\t\t\t\treturn [prevCpNode, currCpNode];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMat.traverse(mat, function (currNode, prevNode) {\n\t\tif (!prevNode) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar prevMatCircle = prevNode.matCircle;\n\t\tvar prevCc = prevMatCircle.circle.center;\n\t\tvar prevCpNodes = prevMatCircle.cpNodes;\n\n\t\tvar currMatCircle = currNode.matCircle;\n\t\tvar currCc = currMatCircle.circle.center;\n\t\tvar currCpNodes = currMatCircle.cpNodes;\n\n\t\tvar _getLinkedCps = getLinkedCps([prevCpNodes, currCpNodes]),\n\t\t    _getLinkedCps2 = _slicedToArray(_getLinkedCps, 2),\n\t\t    prevCpNode = _getLinkedCps2[0],\n\t\t    currCpNode = _getLinkedCps2[1];\n\n\t\tvar prevL = getDirectionToNextMatCircle(prevCpNode, prevCc, true);\n\t\tvar currL = getDirectionToNextMatCircle(currCpNode, currCc, false);\n\n\t\tfunction getDirectionToNextMatCircle(cpNode, circleCenter, isPrev) {\n\t\t\tvar cp1 = cpNode.item;\n\n\t\t\tvar cp2 = isPrev ? cpNode.nextOnCircle.item : cpNode.prevOnCircle.item;\n\n\t\t\tvar vDir = void 0;\n\t\t\tif (cp1 !== cp2) {\n\t\t\t\t// Not a 1-prong.\n\t\t\t\tvar spanner = Vector.fromTo(cp1, cp2);\n\t\t\t\tvDir = Vector.rotateBy90Degrees(spanner);\n\t\t\t} else {\n\t\t\t\tif (cp1.pointOnShape.type === MAT_CONSTANTS.pointType.sharp) {\n\t\t\t\t\tvar bezierNode1 = void 0;\n\t\t\t\t\tvar bezierNode2 = void 0;\n\t\t\t\t\tif (cp1.pointOnShape.t === 0) {\n\t\t\t\t\t\tbezierNode1 = cp1.pointOnShape.bezierNode;\n\t\t\t\t\t\tbezierNode2 = cp1.pointOnShape.bezierNode.prev;\n\t\t\t\t\t} else if (cp1.pointOnShape.t === 1) {\n\t\t\t\t\t\tbezierNode1 = cp1.pointOnShape.bezierNode.next;\n\t\t\t\t\t\tbezierNode2 = cp1.pointOnShape.bezierNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar tan1 = bezierNode1.item.tangent(0);\n\t\t\t\t\tvar tan2 = Vector.reverse(bezierNode2.item.tangent(1));\n\n\t\t\t\t\tvar x = Vector.dot(tan1, tan2);\n\t\t\t\t\t// Recall the identities sin(acos(x)) = sqrt(1-x^2),\n\t\t\t\t\t// etc. Also recall the half angle formulas. Then \n\t\t\t\t\t// the rotation matrix, R, can be calculated.\n\t\t\t\t\tvar cosθ = Math.sqrt((1 + x) / 2);\n\t\t\t\t\tvar sinθ = Math.sqrt((1 - x) / 2);\n\n\t\t\t\t\tvDir = Vector.rotate(tan2, sinθ, cosθ);\n\t\t\t\t} else {\n\t\t\t\t\tvDir = Vector.fromTo(cp1, circleCenter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar v = Vector.translate(circleCenter, Vector.toLength(vDir, 1));\n\t\t\tvar l = [circleCenter, v];\n\n\t\t\treturn l;\n\t\t}\n\n\t\tvar mid = Geometry.lineLineIntersection(prevL, currL);\n\t\tvar twisted = void 0;\n\t\tif (mid) {\n\t\t\tvar a = Vector.fromTo(prevCc, mid);\n\t\t\tvar b = Vector.fromTo(currCc, mid);\n\t\t\tvar c = Vector.fromTo(prevCc, currCc);\n\n\t\t\tvar dot1 = Vector.dot(a, c);\n\t\t\tvar dot2 = Vector.dot(b, c);\n\n\t\t\ttwisted = dot1 < 0 || dot2 > 0;\n\t\t}\n\n\t\tif (!mid) {\n\t\t\tif (_debug_) {\n\t\t\t\t_debug_.draw.line([prevCc, currCc], DRAW_CLASS_LINE);\n\t\t\t}\n\t\t} else if (twisted) {\n\t\t\tvar lp1 = Vector.mean([prevCc, currCc]);\n\t\t\tvar vv1 = Vector.fromTo(prevCc, currCc);\n\t\t\tvar vvv1 = Vector.rotateBy90Degrees(vv1);\n\t\t\tvar lpp1 = Vector.translate(lp1, vvv1);\n\t\t\tvar l = [lp1, lpp1];\n\t\t\tvar mid1 = Geometry.lineLineIntersection(prevL, l);\n\t\t\tvar mid2 = Geometry.lineLineIntersection(currL, l);\n\t\t\tif (_debug_) {\n\t\t\t\t_debug_.draw.bezier({ bezierPoints: [prevCc, mid1, mid2, currCc] }, DRAW_CLASS_CUBE);\n\t\t\t}\n\t\t} else {\n\t\t\t//console.log(prevCc, mid, currCc);\n\t\t\tif (_debug_) {\n\t\t\t\t_debug_.draw.quadBezier([prevCc, mid, currCc], DRAW_CLASS_QUAD);\n\t\t\t}\n\t\t}\n\t});\n}\n\nmodule.exports = smoothen;\n\n},{\"../../geometry/geometry.js\":13,\"../../mat-constants.js\":17,\"../../vector/vector.js\":43,\"../classes/mat.js\":22}],33:[function(require,module,exports){\n'use strict';\n\nvar Circle = require('../../geometry/classes/circle.js');\nvar copyMat = require('./copy-mat.js');\nvar getNodesAsHash = require('./get-nodes-as-hash.js');\nvar Geometry = require('../../geometry/geometry.js');\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\nvar Mat = require('../classes/mat.js');\n\nvar width = 620; // TODO change to actual shape coordinates\nvar height = 560; // ...\n\n\n/**\r\n * Apply the Scale Axis Transform (SAT) to the MAT.\r\n * \r\n * @param {Mat} mat The Medial Axis Transform (MAT) on which to \r\n *        apply the SAT. \r\n * @param {Number} s The scale factor >= 1 (e.g. 1.3)\r\n * @returns {Sat}\r\n */\nfunction toScaleAxis(mat_, s, _debug_) {\n\t/*\r\n  * This algorithm might be made somewhat faster by building tree  \r\n     * to a depth where there is say less than 4 other circles and then \r\n     * only split the branch once this threshold has been exceeded.\r\n     * \r\n     * Also, when searching, search only in relevant branches even\r\n     * when circle overlaps more than one group.\r\n  */\n\n\tvar mat = copyMat(mat_);\n\t/*\r\n  * Start with the biggest circle (since it is the most likely\r\n  * to eclipse other circles), multiply its radius by s and see\r\n  * which circles are fully contained in it and trim it away in\r\n  * the MAT tree.\r\n  */\n\n\tvar nodeHash = getNodesAsHash(mat);\n\n\tvar biggest = -Number.POSITIVE_INFINITY;\n\tvar biggestNode = void 0;\n\tfor (var key in nodeHash) {\n\t\tvar node = nodeHash[key];\n\t\tvar r = node.matCircle.circle.radius;\n\t\tif (r > biggest) {\n\t\t\tbiggestNode = node;\n\t\t\tbiggest = r;\n\t\t}\n\t}\n\n\tvar t0 = performance.now();\n\tvar tree = createSpacialTree(s, nodeHash);\n\tvar t1 = performance.now();\n\t//console.log((t1 - t0).toFixed(0) + ' milliseconds.');\n\n\tif (_debug_) {\n\t\tif (_debug_.shouldDrawSATTree) {\n\t\t\t_debug_.drawSATTree(tree);\n\t\t}\n\t}\n\n\t// Grab the MAT tree at its biggest node.\n\tvar sat = new Mat(biggestNode);\n\n\tvar cullHash = {};\n\n\t// Look at circles in roughly order of size for each tree branch,\n\t// e.g. circles in branch 5 are always larger than in branches 0\n\t// to 4.\n\ttraverseSpacialTree(tree, cullem, { s: s, tree: tree, cullHash: cullHash });\n\n\t// We now walk the MAT tree and keep all non-culled nodes and any\n\t// nodes that have a non-culled node further down the line toward\n\t// the tree leaves.\n\tvar cullNodes = [];\n\tcullIt(cullHash, cullNodes, sat.startNode);\n\n\tcullTheNodes(cullNodes);\n\n\treturn sat;\n}\n\nfunction addToTree(s, tree, coordinate, limits, node, key, depth) {\n\n\t// DEPTH_LIMIT can be anything from 1 to 16, but from 2 to 6 seem \n\t// to be the fastest.\n\tvar DEPTH_LIMIT = 6;\n\n\tvar circle = node.matCircle.circle;\n\n\tvar _calcGroups = calcGroups(s, coordinate, limits, circle),\n\t    groups = _calcGroups.groups,\n\t    newLimits = _calcGroups.newLimits;\n\n\t// Create new branch if it does not exist yet.\n\n\n\tif (groups.length === 1 && depth !== DEPTH_LIMIT) {\n\t\tvar group = groups[0];\n\n\t\tif (!tree[group]) {\n\t\t\ttree[group] = {};\n\t\t}\n\t\tvar _branch = tree[group];\n\n\t\t// Flip coordinates\n\t\tvar newCoordinate = coordinate ? 0 : 1;\n\t\taddToTree(s, _branch, newCoordinate, newLimits, node, key, depth + 1);\n\n\t\treturn;\n\t}\n\n\tif (!tree[5]) {\n\t\ttree[5] = new Map();\n\t}\n\tvar branch = tree[5];\n\tbranch.set(key, node);\n}\n\nfunction createSpacialTree(s, nodeHash) {\n\n\tvar coordinate = 0;\n\tvar limits = [[0, width], [0, height]];\n\n\tvar tree = {};\n\n\tfor (var key in nodeHash) {\n\t\tvar node = nodeHash[key];\n\n\t\taddToTree(s, tree, coordinate, limits, node, key, 0);\n\t}\n\n\treturn tree;\n}\n\nfunction cullem(node, key, _ref) {\n\tvar s = _ref.s,\n\t    tree = _ref.tree,\n\t    cullHash = _ref.cullHash;\n\n\n\tif (node.matCircle.circle.radius === 0) {\n\t\treturn;\n\t}\n\n\tif (cullHash[key]) {\n\t\treturn;\n\t}\n\n\tvar cullNodes = getCullNodes(s, tree, node);\n\tfor (var _key in cullNodes) {\n\t\tif (!cullHash[_key]) {\n\t\t\tcullHash[_key] = node;\n\t\t}\n\t}\n}\n\nfunction traverseSpacialTree(tree, f, extraParams) {\n\n\tfunction helper(tree) {\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (tree.size) {\n\t\t\t//for (let i=0; i<tree.length; i++)\n\t\t\ttree.forEach(function (node, key) {\n\t\t\t\tf(node, key, extraParams);\n\t\t\t});\n\n\t\t\treturn; // Leaf reached \n\t\t}\n\n\t\tif (tree[5]) {\n\t\t\thelper(tree[5]);\n\t\t}\n\t\tif (tree[0]) {\n\t\t\thelper(tree[0]);\n\t\t}\n\t\tif (tree[2]) {\n\t\t\thelper(tree[2]);\n\t\t}\n\t\tif (tree[4]) {\n\t\t\thelper(tree[4]);\n\t\t}\n\t\tif (tree[1]) {\n\t\t\thelper(tree[1]);\n\t\t}\n\t\tif (tree[3]) {\n\t\t\thelper(tree[3]);\n\t\t}\n\t}\n\n\thelper(tree);\n}\n\nfunction getCullNodes(s, tree, testNode) {\n\n\tvar c1 = Circle.scale(testNode.matCircle.circle, s);\n\n\tvar cullNodes = {};\n\n\tvar limits = [[0, width], [0, height]];\n\tvar circle = testNode.matCircle.circle;\n\thelper(tree, 0, limits, 0);\n\n\treturn cullNodes;\n\n\tfunction cullBranch5(tree) {\n\t\tvar branch = tree[5];\n\t\tif (!branch) {\n\t\t\treturn;\n\t\t}\n\n\t\tbranch.forEach(function (node, key) {\n\t\t\tvar c2 = Circle.scale(node.matCircle.circle, s);\n\t\t\tif (Geometry.doesCircleEngulfCircle(c1, c2)) {\n\t\t\t\tcullNodes[key] = node;\n\n\t\t\t\tbranch.delete(key);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction helper(tree, coordinate, limits, depth) {\n\n\t\tif (limits === null) {\n\t\t\t// If we already reached a circle which spans multiple\n\t\t\t// groups previously, then check all circles in the \n\t\t\t// tree.\n\t\t\tcullBranch5(tree);\n\n\t\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\t\tvar branch = tree[i];\n\t\t\t\tif (branch) {\n\t\t\t\t\thelper(branch, 0, null, depth + 1);\n\t\t\t\t\t//helper(branch, newCoordinate, null, depth+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar _calcGroups2 = calcGroups(s, coordinate, limits, circle),\n\t\t    groups = _calcGroups2.groups,\n\t\t    newLimits = _calcGroups2.newLimits;\n\n\t\tif (groups.length === 1) {\n\t\t\tcullBranch5(tree);\n\n\t\t\tvar group = groups[0];\n\t\t\tvar newCoordinate = coordinate ? 0 : 1;\n\n\t\t\tif (group === 1 || group === 3) {\n\t\t\t\t// One of the higher priority left/top or \n\t\t\t\t// right/bottom half groups.\n\t\t\t\tvar _branch2 = tree[group];\n\n\t\t\t\tif (_branch2) {\n\t\t\t\t\thelper(_branch2, newCoordinate, newLimits, depth + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// One of the lower priority even \n\t\t\t\t// groups (0,2 or 4).\n\n\t\t\t\tvar branches = [];\n\t\t\t\tbranches.push(tree[group]);\n\t\t\t\tif (group > 0) {\n\t\t\t\t\tbranches.push(tree[group - 1]);\n\t\t\t\t}\n\t\t\t\tif (group < 4) {\n\t\t\t\t\tbranches.push(tree[group + 1]);\n\t\t\t\t}\n\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar _branch3 = _step.value;\n\n\t\t\t\t\t\tif (_branch3) {\n\t\t\t\t\t\t\thelper(_branch3, newCoordinate, newLimits, depth + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tcullBranch5(tree);\n\t\t// Circle spans multiple groups at this level of the \n\t\t// tree. Check all circles in all branches.\n\t\tfor (var _i = 0; _i <= 4; _i++) {\n\t\t\tvar _branch4 = tree[_i];\n\t\t\tif (_branch4) {\n\t\t\t\t//helper(branch, newCoordinate, null, depth+1);\n\t\t\t\thelper(_branch4, 0, null, depth + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\r\n * @returns {Boolean} true if a node should NOT be culled. \r\n */\nfunction cullIt(cullHash, cullNodes, satNode, priorNode) {\n\n\tvar key = PointOnShape.makeSimpleKey(satNode.matCircle.circle.center);\n\n\tvar anyNotCull = !cullHash[key];\n\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = satNode.branches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar node = _step2.value;\n\n\t\t\tif (node === priorNode) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cullIt(cullHash, cullNodes, node, satNode)) {\n\t\t\t\tanyNotCull = true;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (anyNotCull) {\n\t\treturn true; // Don't cull me\n\t}\n\n\tcullNodes.push({ satNode: satNode, priorNode: priorNode });\n\n\treturn false;\n}\n\nfunction cullTheNode(cullNode) {\n\tvar satNode = cullNode.satNode,\n\t    priorNode = cullNode.priorNode;\n\n\n\tvar idx = priorNode.branches.indexOf(satNode);\n\tif (idx >= 0) {\n\t\tpriorNode.branches.splice(idx, 1);\n\t}\n}\n\nfunction cullTheNodes(cullNodes) {\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = cullNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar node = _step3.value;\n\n\t\t\tcullTheNode(node);\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\r\n * Spacially divide into 5 special groups as follows:\r\n * \r\n *   *******||*******|*******|*******|*******||*******\r\n * 0 <--------------->\r\n * 1         <--------------->        \r\n * 2                 <--------------->\r\n * 3                         <--------------->\r\n * 4                                 <--------------->\r\n * 5 - If the circle does not fall in any of above 5 groups.\r\n * \r\n * Note: In the above, the double pipes denote the limits for\r\n *       a coordinate, so as can be seen groups 0 and 4 go outside\r\n *       the limits. Also, groups 1 and 3 are preferred and checked\r\n *       first. \r\n *          \r\n * @param s Scale parameter, e.g. 1.1\r\n * @param {Number} coordinate - 0 -> horizontal or 1 -> vertical.\r\n * @param {[Number]} limits - The limits within which the circle \r\n *        bounds can fall.\r\n * @param {Circle} circle - The circle to categorize into a group. \r\n */\nfunction calcGroups(s, coordinate, limits, circle) {\n\n\tvar limit = limits[coordinate];\n\tvar l1 = limit[0];\n\tvar l2 = limit[1];\n\n\t// Relevant cut-off lines.\n\tvar q = (l2 - l1) / 4;\n\tvar w = q + q;\n\n\t// Shift origin\n\tvar r = circle.radius;\n\tvar x = circle.center[coordinate] - l1;\n\tvar x0 = x - r * s;\n\tvar x1 = x + r * s;\n\n\tvar newLimit = [,];\n\tvar groups = []; // Group to which circle belongs;\n\n\n\t/* This was the old method to get groups and newLimit, but it\r\n  * seems to be only slightly slower so could also be used\r\n let is = [1,3,0,2,4]; // Groups 1 and 3 takes priority. \r\n for (let i=0; i<=4; i++) {\r\n \tlet q0 = q*(is[i]-1);\r\n \tlet q1 = q0 + w;\r\n \tif (x0 > q0 && x1 <= q1) {\r\n \t\tgroups.push(is[i]);\r\n \t\tnewLimit = [l1 + q0, l1 + q1];\r\n \t\tbreak;\r\n \t}\r\n }*/\n\n\tvar qStart = Math.floor(x0 / q);\n\tvar qEnd = Math.floor(x1 / q) + 1;\n\tvar qDiff = qEnd - qStart;\n\n\tvar group = void 0;\n\tif (qDiff === 1) {\n\t\t// If contained in sliver.\n\t\tgroup = 2 * Math.floor(qStart / 2) + 1;\n\t\tgroups.push(group);\n\n\t\tvar lowerLimit = l1 + q * (group - 1);\n\t\tnewLimit = [lowerLimit, lowerLimit + w];\n\t} else if (qDiff === 2) {\n\t\tgroup = qStart + 1;\n\t\tgroups.push(group);\n\n\t\tvar _lowerLimit = l1 + q * (group - 1);\n\t\tnewLimit = [_lowerLimit, _lowerLimit + w];\n\t}\n\n\tvar newLimits = [,];\n\tif (groups.length === 1) {\n\t\tvar otherCoordinate = coordinate ? 0 : 1;\n\n\t\tnewLimits[otherCoordinate] = limits[otherCoordinate];\n\t\tnewLimits[coordinate] = newLimit;\n\t}\n\n\treturn { groups: groups, newLimits: newLimits };\n}\n\nmodule.exports = toScaleAxis;\n\n},{\"../../geometry/classes/circle.js\":5,\"../../geometry/classes/point-on-shape.js\":6,\"../../geometry/geometry.js\":13,\"../classes/mat.js\":22,\"./copy-mat.js\":26,\"./get-nodes-as-hash.js\":31}],34:[function(require,module,exports){\n'use strict';\n\nvar PointOnShape = require('../../geometry/classes/point-on-shape.js');\n\n/**\r\n * Traverses the MAT tree and calls a function on each node. This\r\n * function must have side effects to be useful.\r\n * \r\n * @param {Mat} mat\r\n * @returns undefined\r\n */\nfunction traverse(mat, f) {\n\n\thelper(mat.startNode, undefined, undefined);\n\n\tfunction helper(matNode, priorNode /*, priorIndx*/) {\n\t\tf(matNode, priorNode /*, priorIndx*/);\n\n\t\t//for (let node of matNode.branches) {\n\t\tfor (var i = 0; i < matNode.branches.length; i++) {\n\t\t\tvar node = matNode.branches[i];\n\t\t\tif (node === priorNode) {\n\t\t\t\t// Don't go back in tracks.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thelper(node, matNode, i);\n\t\t}\n\t}\n}\n\nmodule.exports = traverse;\n\n},{\"../../geometry/classes/point-on-shape.js\":6}],35:[function(require,module,exports){\n'use strict';\n\nvar Poly = require('../polynomial/polynomial.js');\n\n/** \r\n * Mobius class\r\n * @constructor\r\n * \r\n * The below parameters are the coefficients of the Mobius \r\n * transformation (ax + b) / (cx + d).\r\n * @param a {Number}\r\n * @param b {Number}\r\n * @param c {Number}\r\n * @param d {Number}\r\n */\nfunction Mobius(numer, denom) {\n\tthis.numer = numer; //[a,b]; // Represents the numerator polynomial\n\tthis.denom = denom; //[c,d]; // ... denominator ...\n}\n\nMobius.changeVariables = function (mobius, a, b) {\n\treturn new Mobius(Poly.changeVariables(mobius.numer, a, b), Poly.changeVariables(mobius.denom, a, b));\n};\n\nMobius.invert = function (mobius) {\n\treturn new Mobius([mobius.numer[1], mobius.numer[0]], [mobius.denom[1], mobius.denom[0]]);\n};\n\nMobius.evaluateAt0 = function (mobius) {\n\treturn mobius.numer[1] / mobius.denom[1];\n};\n\nMobius.evaluateAtInf = function (mobius) {\n\treturn mobius.numer[0] / mobius.denom[0];\n};\n\nMobius.evaluate = function (mobius, t) {\n\treturn Poly.evaluate(mobius.numer)(t) / Poly.evaluate(mobius.denom)(t);\n};\n\nmodule.exports = Mobius;\n\n},{\"../polynomial/polynomial.js\":39}],36:[function(require,module,exports){\n'use strict';\n\n/** \r\n * The Gaussian Quadrature method to integrate the given\r\n * function. The integral limits are between 0 and 1.\r\n * \r\n * @param {Number} order Can be 2, 4 or 8. \r\n *        Higher values are more accurate. \r\n *        \r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * \r\n * Notes: \r\n * \r\n * - A future improvement can be to use the Gauss–Kronrod rules\r\n * to estimate the error and thus choose a number of constants based\r\n * on the error and not just thumb-suck.\r\n * \r\n * - In future, the constants can be calculated and cached so we can\r\n * chooce any number of constants.\r\n * \r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction gaussQuadrature(f, interval, order_) {\n\tvar order = order_ || 16;\n\n\tvar constants = GAUSS_CONSTANTS[order];\n\tvar weights = constants.weights;\n\tvar abscissas = constants.abscissas;\n\n\tvar _interval = _slicedToArray(interval, 2),\n\t    a = _interval[0],\n\t    b = _interval[1];\n\n\tvar result = 0;\n\tvar m1 = (b - a) / 2;\n\tvar m2 = (b + a) / 2;\n\tfor (var i = 0; i <= order - 1; i++) {\n\t\tresult += weights[i] * f(m1 * abscissas[i] + m2);\n\t}\n\n\treturn m1 * result;\n}\n\n//The Gaussian Legendre Quadrature method constants. \nvar GAUSS_CONSTANTS = {\n\t2: {\n\t\tweights: [1, 1],\n\t\tabscissas: [-0.5773502691896257, 0.5773502691896257]\n\t},\n\t4: {\n\t\tweights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538],\n\t\tabscissas: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526]\n\t},\n\t8: {\n\t\tweights: [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763],\n\t\tabscissas: [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363]\n\t},\n\t// Taken from http://keisan.casio.com/exec/system/1330940731\n\t16: {\n\t\tabscissas: [-0.989400934991649932596, -0.944575023073232576078, -0.86563120238783174388, -0.7554044083550030338951, -0.6178762444026437484467, -0.4580167776572273863424, -0.28160355077925891323, -0.0950125098376374401853, 0.0950125098376374401853, 0.28160355077925891323, 0.4580167776572273863424, 0.617876244402643748447, 0.755404408355003033895, 0.8656312023878317438805, 0.944575023073232576078, 0.989400934991649932596],\n\t\tweights: [0.0271524594117540948518, 0.062253523938647892863, 0.0951585116824927848099, 0.1246289712555338720525, 0.1495959888165767320815, 0.169156519395002538189, 0.182603415044923588867, 0.189450610455068496285, 0.1894506104550684962854, 0.182603415044923588867, 0.1691565193950025381893, 0.149595988816576732081, 0.124628971255533872053, 0.095158511682492784809, 0.062253523938647892863, 0.027152459411754094852]\n\t}\n};\n\nmodule.exports = gaussQuadrature;\n\n},{}],37:[function(require,module,exports){\n'use strict';\n\nvar Poly = require('../../polynomial/polynomial.js');\nvar Mobius = require('../../mobius/mobius.js');\n\n/** Finds all roots using the VAS algorithm followed by Brent's method \r\n * @param p {Array[Number]} The polynomial from highest to lowest coefficient\r\n * \r\n **/\nfunction allRootsVAS(p, tRange, _debug_) {\n\t// TODO - First remove all zero roots - The VAS method can't handle them\n\tvar zeroRoots = void 0;\n\tif (tRange[0] <= 0 && tRange[1] >= 0) {\n\t\tzeroRoots = Poly.zeroRoots(p);\n\t} else {\n\t\tzeroRoots = { p: p, numZeros: 0 };\n\t}\n\n\tvar p_ = zeroRoots.p;\n\tvar numZeros = zeroRoots.numZeros;\n\n\t// TODO - Next, remove all multiple roots ... - VAS doesn't like them either\n\n\tvar vasRoots = Poly.vasRootIntervals(p_, tRange).filter(function (interval) {\n\t\tvar notOverlap = interval[1] < tRange[0] || interval[0] > tRange[1];\n\t\tif (notOverlap) {\n\t\t\tif (_debug_) {\n\t\t\t\t_debug_.rootsSkipped++;\n\t\t\t}\n\t\t}\n\t\treturn !notOverlap;\n\t}).map(function (interval) {\n\t\t// TODO - 0.0001 was emperically chosen\n\t\tif (_debug_) {\n\t\t\t_debug_.rootsNotSkipped++;\n\t\t}\n\n\t\treturn Poly.brent(Poly.evaluate(p_), interval[0], interval[1], 0.0000001);\n\t});\n\n\tfor (var i = 0; i < numZeros; i++) {\n\t\tvasRoots.push(0);\n\t}\n\n\t/*\r\n if (_debug_) {\r\n \t_debug_.rootsNotSkipped++;\r\n }\r\n */\n\n\treturn vasRoots;\n}\n\n/** \r\n * Use VAS (Vincent–Akritas–Strzeboński) method to find intervals \r\n * for roots. \r\n * See: http://www.e-ce.uth.gr/wp-content/uploads/formidable/phd_thesis_vigklas.pdf \r\n * TODO - Square-free factorization ignored for now - duplicate roots will cause an issue\r\n * TODO - Optimize later for intervals between 0 and 1 only\r\n * 0.085 millis per poly of degree 6 - 10000 polies\r\n */\nPoly.vasRootIntervals = function (p, tRange) {\n\n\tvar positiveIntervals = Poly.vasRootIntervalsHelper(\n\t//p.slice(),\n\tp, new Mobius([1, 0], [0, 1]), tRange);\n\n\t// ONLY COMMENTED BECAUSE IN *OUR* CASE WE DONT CARE ABOUT NEGATIVE ROOTS!!\n\t/*\r\n var negativeIntervals = Poly.vasRootIntervalsHelper(\r\n \tPoly.changeVariables(p.slice(), -1, 0), \r\n \tnew Mobius([1,0],[0,1]),\r\n \ttRange\r\n )\r\n .map(function(interval) {\r\n \treturn Poly.negate(Poly.invert(interval));\r\n });\r\n */\n\n\tvar intervals = [].concat(\n\t//negativeIntervals, \n\tpositiveIntervals);\n\n\treturn intervals;\n};\n\n/** \r\n * Helper - aa,bb,cc,dd are the Mobius transformation coefficients\r\n * The initial mobius must be new Mobius([1,0],[0,1]) -> M(x) = x. \r\n */\nPoly.vasRootIntervalsHelper = function (p, mobius, tRange) {\n\n\t// In the Vigklas paper the steps are marked as below:\n\n\t// STEP 1\n\tvar intervals = [];\n\tvar signVariations = Poly.signChanges(p);\n\n\t// STEP 2\n\tif (signVariations === 0) {\n\t\t// Descartes' rule of signs y'all\n\t\treturn [];\n\t}\n\n\t// STEP 3\n\tif (signVariations === 1) {\n\t\tvar M0 = Mobius.evaluateAt0(mobius);\n\t\tvar MI = Mobius.evaluateAtInf(mobius);\n\t\tvar MM0 = Math.min(M0, MI);\n\t\tvar MMI = Math.max(M0, MI);\n\t\tif (MMI === Number.POSITIVE_INFINITY) {\n\t\t\tMMI = Mobius.evaluate(mobius, Poly.positiveRootUpperBound(p));\n\t\t}\n\n\t\treturn [[MM0, MMI]];\n\t}\n\n\t// STEP 4\n\tvar lb = Poly.positiveRootLowerBound(p);\n\n\t// STEP 5\n\t/*if (lb > tRange[1]) {\r\n \treturn [];\r\n }*/\n\n\tif (lb > 1) {\n\t\t// p ← p(x + lb)\n\t\tp = Poly.changeVariables(p, 1, lb);\n\n\t\t// M ← M(x + lb)\n\t\tmobius = Mobius.changeVariables(mobius, 1, lb);\n\t}\n\n\t// TODO - Rember factor of 16 improvement\n\n\t// STEP 6 - Look for real roots in (0, 1)\n\n\t// p01 ← (x + 1)^(deg(p)) *  p(1/(x+1))\n\tvar p01 = Poly.changeVariables(Poly.invert(p), 1, 1);\n\n\t// M01 ← M(1/(x+1))\n\tvar M01 = Mobius.changeVariables(Mobius.invert(mobius), 1, 1);\n\n\t// STEP 7 - Is 1 a root?\n\tvar m = Mobius.evaluate(mobius, 1);\n\n\t// STEP 8 - Look for real roots in (1, ∞)\n\n\t// p1∞ ← p(x + 1)\n\tvar p1inf = Poly.changeVariables(p, 1, 1);\n\n\t// M1∞ ← M(x + 1)\n\tvar M1inf = Mobius.changeVariables(mobius, 1, 1);\n\n\t// STEPS 9 -> 13\n\tvar intervals1 = Poly.vasRootIntervalsHelper(p01, M01, tRange);\n\tvar intervals3 = Poly.vasRootIntervalsHelper(p1inf, M1inf, tRange);\n\n\tif (Poly.evaluate(p)(1) === 0) {\n\t\tintervals1.push([m, m]);\n\t}\n\n\treturn [].concat(intervals1, intervals3);\n};\n\nmodule.exports = allRootsVAS;\n\n},{\"../../mobius/mobius.js\":35,\"../../polynomial/polynomial.js\":39}],38:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Find the cube roots of the given polynomial between 0 and 1.\r\n * \r\n * This code is from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * Given cubic coordinates {pa, pb, pc, pd} find all\r\n * roots.\r\n * \r\n * TODO Later to be replaced by a more numerically stable version.\r\n */\n\nfunction findCubicRoots01(poly) {\n\n\t// A real-cuberoots-only function:\n\tfunction cuberoot(v) {\n\t\tif (v < 0) {\n\t\t\treturn -Math.pow(-v, 1 / 3);\n\t\t}\n\t\treturn Math.pow(v, 1 / 3);\n\t}\n\n\tfunction rootFilter01(root) {\n\t\treturn root >= 0 && root <= 1;\n\t}\n\n\tvar d = poly[0];\n\tvar a = poly[1] / d;\n\tvar b = poly[2] / d;\n\tvar c = poly[3] / d;\n\n\tvar p = (3 * b - a * a) / 3,\n\t    p3 = p / 3,\n\t    q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n\t    q2 = q / 2,\n\t    discriminant = q2 * q2 + p3 * p3 * p3;\n\n\t// and some variables we're going to use later on:\n\tvar u1, v1, root1, root2, root3;\n\n\t// three possible real roots:\n\tif (discriminant < 0) {\n\t\tvar mp3 = -p / 3,\n\t\t    mp33 = mp3 * mp3 * mp3,\n\t\t    r = Math.sqrt(mp33),\n\t\t    t = -q / (2 * r),\n\t\t    cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n\t\t    phi = Math.acos(cosphi),\n\t\t    crtr = cuberoot(r),\n\t\t    t1 = 2 * crtr;\n\t\troot1 = t1 * Math.cos(phi / 3) - a / 3;\n\t\troot2 = t1 * Math.cos((phi + 2 * Math.PI) / 3) - a / 3;\n\t\troot3 = t1 * Math.cos((phi + 4 * Math.PI) / 3) - a / 3;\n\t\treturn [root1, root2, root3].filter(rootFilter01);\n\t} else if (discriminant === 0) {\n\t\t// three real roots, but two of them are equal:\n\t\tu1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);\n\t\troot1 = 2 * u1 - a / 3;\n\t\troot2 = -u1 - a / 3;\n\t\treturn [root1, root2].filter(rootFilter01);\n\t} else {\n\t\t// one real root, two complex roots\n\t\tvar sd = Math.sqrt(discriminant);\n\t\tu1 = cuberoot(sd - q2);\n\t\tv1 = cuberoot(sd + q2);\n\t\troot1 = u1 - v1 - a / 3;\n\t\treturn [root1].filter(rootFilter01);\n\t}\n}\n\nmodule.exports = findCubicRoots01;\n\n},{}],39:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _Poly;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar findCubicRoots01 = require('./functions/find-cubic-roots.js');\nvar Util = require('../utils.js');\n\n/**\r\n* Functional univariate polynomial library functions.\r\n*\r\n* All polinomials are represented as a simple array starting with the \r\n* highest power, e.g. \r\n*   10x^4 + 3x^3 + 5x^2 + 7x + 0 -> [10,3,5,7,0]\r\n*/\nvar Poly = (_Poly = {\n\t// Roots\n\tfindQuadraticRoots01: findQuadraticRoots01,\n\tfindCubicRoots01: findCubicRoots01,\n\tbrent: brent,\n\tpositiveRootLowerBound: positiveRootLowerBound,\n\tpositiveRootUpperBound: positiveRootUpperBound,\n\tzeroRoots: zeroRoots,\n\trootsWithin: rootsWithin,\n\tallRoots01: allRoots01,\n\tnewton: newton\n}, _defineProperty(_Poly, 'rootsWithin', rootsWithin), _defineProperty(_Poly, 'multiplyByConst', multiplyByConst), _defineProperty(_Poly, 'negate', negate), _defineProperty(_Poly, 'minus', minus), _defineProperty(_Poly, 'multiply', multiply), _defineProperty(_Poly, 'differentiate', differentiate), _defineProperty(_Poly, 'sturmChain', sturmChain), _defineProperty(_Poly, 'degree', degree), _defineProperty(_Poly, 'evaluate', evaluate), _defineProperty(_Poly, 'evaluateAt0', evaluateAt0), _defineProperty(_Poly, 'signChanges', signChanges), _defineProperty(_Poly, 'invert', invert), _defineProperty(_Poly, 'changeVariables', changeVariables), _defineProperty(_Poly, 'deflate', deflate), _defineProperty(_Poly, 'remainder', remainder), _Poly);\n\n/**  \r\n * Differentiation the given polynomial.\r\n **/\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = d; i !== 0; i--) {\n\t\tvar coeff = p[d - i] * i;\n\t\tif (i === d && coeff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(coeff);\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Multiplies 2 polynomials \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = d; i >= 0; i--) {\n\t\tresult.push(c * p[d - i]);\n\t}\n\treturn result;\n};\n\nfunction negate(poly) {\n\treturn Poly.multiplyByConst(-1, poly);\n}\n\n/** \r\n * Subtracts second from first polynomial \r\n */\n// TODO - ugly code - improve\nfunction minus(poly1, poly2) {\n\tvar d1 = poly1.length - 1;\n\tvar d2 = poly2.length - 1;\n\tvar dr = Math.max(d1, d2);\n\tvar result = [];\n\tfor (var i = 0; i < dr + 1; i++) {\n\t\tresult.push(0);\n\t}\n\n\tfor (var i = dr; i >= 0; i--) {\n\t\tvar v1 = poly1[dr - i];\n\t\tvar v2 = poly2[dr - i];\n\t\tresult[dr - i] = (v1 ? v1 : 0) - (v2 ? v2 : 0);\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Multiplies poly1 and poly2 \r\n * \r\n * Inefficient O(n^2) \r\n * see https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\r\n * \r\n **/\nfunction multiply(poly1, poly2) {\n\tvar d1 = poly1.length - 1;\n\tvar d2 = poly2.length - 1;\n\tvar dr = d1 + d2;\n\tvar result = [];\n\tfor (var i = 0; i < dr + 1; i++) {\n\t\tresult.push(0);\n\t}\n\n\tfor (var i = d1; i >= 0; i--) {\n\t\tfor (var j = d2; j >= 0; j--) {\n\t\t\tresult[dr - (i + j)] += poly1[d1 - i] * poly2[d2 - j];\n\t\t}\n\t}\n\treturn result;\n}\n\n/** Returns degree of polynomial **/\n// TODO - If leading coefficients are 0 this gives the wrong result\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method  \r\n * See: https://en.wikipedia.org/wiki/Horner%27s_method \r\n **/\nfunction evaluate(p) {\n\treturn function (t) {\n\t\tvar bn = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tbn = p[i] + bn * t;\n\t\t}\n\n\t\treturn bn;\n\t};\n};\n\n/** \r\n * Evaluates a polynomial at 0 \r\n * - this is much faster than at an arbitrary point \r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when order in descending order; zeros are ignored \r\n */\nfunction signChanges(p) {\n\n\tvar result = 0;\n\n\tvar d = p.length - 1;\n\tvar curSign = 0;\n\tfor (var i = d; i >= 0; i--) {\n\t\tvar newSign = Math.sign(p[d - i]);\n\t\tif (newSign === 0) continue;\n\t\tif (curSign !== 0 && curSign !== newSign) {\n\t\t\tresult++;\n\t\t}\n\t\tcurSign = newSign;\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Returns the remainder when dividing poly1 by poly2 \r\n * ASSUMING poly1 is one degree higher than poly2.\r\n */\n// See: https://en.wikipedia.org/wiki/Sturm%27s_theorem\nfunction remainder(p1, p2) {\n\t//console.log(p1,p2)\n\n\tvar d1 = p1.length - 1; // Degree of p1\n\tvar d2 = p2.length - 1; // Degree of p2\n\tvar d = d1 - d2;\n\tfor (var i = 0; i < d - 1; i++) {\n\t\tp2.unshift(0);\n\t}\n\td2 = d1 - 1;\n\n\tvar pre1 = p1[1] / p1[0] - p2[1] / p2[0];\n\tvar pre2 = p1;\n\tvar pre3 = Poly.multiplyByConst(p1[0] / p2[0], p2);\n\tvar pre4 = Poly.multiply(pre3, [1, pre1]);\n\tvar pre5 = Poly.minus(pre4, pre2);\n\n\treturn pre5.slice(2);\n}\n\nfunction deflate(poly, root) {\n\t// Implement as a shortcut (can root === 1 also be a shortcut?)\n\tif (root === 0) {}\n\n\tvar d = poly.length - 1;\n\tvar bs = [poly[0]];\n\tfor (var i = 1; i < poly.length - 1; i++) {\n\t\tbs.push(poly[i] + root * bs[i - 1]);\n\t}\n\n\t//console.log(bs);\n\treturn bs;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial \r\n */\nfunction sturmChain(p) {\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(Poly.differentiate(p));\n\n\tvar i = 1;\n\n\twhile (Poly.degree(m[i]) > 0) {\n\t\tm.push(Poly.remainder(m[i - 1], m[i]));\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/** \r\n * Returns the number of roots in the interval (a,b) of a \r\n * polynomial \r\n */\nfunction rootsWithin(p, a, b) {\n\n\tvar sturmChain = Poly.sturmChain(p);\n\tvar as = sturmChain.map(function (p) {\n\t\treturn Poly.evaluate(p)(a);\n\t});\n\tvar bs = sturmChain.map(function (p) {\n\t\treturn Poly.evaluate(p)(b);\n\t});\n\n\treturn Poly.signChanges(as) - Poly.signChanges(bs);\n}\n\n/** \r\n * Newton's method - tuned for polynomials \r\n * Currently just doing 10 iterations - only for testing at the\r\n * moment. \r\n */\nfunction newton(p, initialGuess) {\n\tvar dp = Poly.differentiate(p);\n\tvar val = initialGuess;\n\tfor (var i = 1; i <= 10; i++) {\n\t\tval -= Poly.evaluate(p)(val) / Poly.evaluate(dp)(val);\n\t}\n\n\treturn val;\n}\n\n/** \r\n * See algoritm 6 - Vigklas\r\n * Note: Only polynomials that has at least 1 sign change can be \r\n *       used in this algorithm. This is not a problem since if \r\n *       there are no sign changes then there are no roots! \r\n */\nfunction positiveRootUpperBound(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = Poly.negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) continue;\n\n\t\t\t// TODO - Both these pows can easily be replaced with a lookup that will speed things up a lot\n\t\t\t// since (for low order polys) it will most of the time be a square, cube... root or multiplication by 1,2,4,8,...\n\t\t\t// TODO - not 100% sure the timesUsed[k] is used correctly here but seems to give reasonable results\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / Math.pow(2, timesUsed[k])), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * p(x) -> x^deg(p) * p(1/x)\r\n */\nfunction invert(p) {\n\tvar len = p.length;\n\tvar newP = [];\n\n\tfor (var i = len - 1; i >= 0; i--) {\n\t\tnewP.push(p[i]);\n\t}\n\n\treturn newP;\n}\n\n/** \r\n * See http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system \r\n * This is basically just a change of variables (type of Mobius transform) of the type: \r\n *   p(x) <- p(ax + b)\r\n * Currently limited to degree 6 or so (due to binomial coeff lookup), but easiliy extensible to any degree with 1 line of code :)\r\n * \r\n * We let the coefficients of p(ax + b) =def= d_i in the code below. d_i is calculated as d = T*c, where c is the original coefficients \r\n **/\nfunction changeVariables(p, a, b) {\n\tvar deg = p.length - 1;\n\n\tvar d = new Array(deg + 1).fill(0);\n\t//let d = [];\n\t// TODO - better way to fill a matrix with zeros?\n\tvar t = [];\n\tfor (var i = 0; i < deg + 1; i++) {\n\t\tt.push(new Array(deg + 1).fill(0));\n\t\t//d.push(0);\n\t\t/*t.push([]);\r\n  for (let j=0; j<deg+1; j++) {\r\n  \tt[i].push(0);\r\n  }*/\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= deg; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i = 1; _i <= j; _i++) {\n\t\t\tt[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tfor (var _i2 = 0; _i2 <= deg; _i2++) {\n\t\td[deg - _i2] = 0;\n\t\tfor (var _j = _i2; _j <= deg; _j++) {\n\t\t\tvar acc = t[_i2][_j] * p[deg - _j];\n\t\t\td[deg - _i2] += acc;\n\t\t}\n\t}\n\n\treturn d;\n}\n\nfunction positiveRootLowerBound(p) {\n\treturn 1 / Poly.positiveRootUpperBound(Poly.invert(p));\n}\n\n/**\r\n * @return { Number, Array } The number of zero roots together with the \r\n * deflated polynomial\r\n *       \r\n */\nfunction zeroRoots(p) {\n\tvar p_ = p.slice();\n\tvar i = 0;\n\twhile (Poly.evaluateAt0(p_) === 0) {\n\t\tvar len = p_.length;\n\t\tp_.splice(len - 1, 1);\n\t\ti++;\n\t}\n\treturn {\n\t\tp: p_,\n\t\tnumZeros: i\n\t};\n}\n\n/**\r\n * Find 2nd order or higher polynomial roots within the \r\n * *specific interval** [0,1]. \r\n */\nfunction allRoots01(poly) {\n\n\tvar deg = poly.length - 1;\n\n\tif (deg === 2) {\n\t\treturn Poly.findQuadraticRoots01(poly);\n\t} else if (deg === 3) {\n\t\treturn Poly.findCubicRoots01(poly).sort(function (a, b) {\n\t\t\treturn a - b;\n\t\t});\n\t}\n\n\tvar diff = Poly.differentiate(poly);\n\tvar roots = allRoots01(diff);\n\tif (roots[0] !== 0) {\n\t\troots.unshift(0);\n\t}\n\tif (roots[roots.length - 1] !== 1) {\n\t\troots.push(1);\n\t}\n\n\treturn rootsWithin(poly, roots);\n}\n\nfunction rootsWithin(poly, intervals) {\n\n\t//let TOL = 1e-13;\n\n\tvar len = intervals.length;\n\t/*if (len < 2) {\r\n \treturn [];\r\n }*/\n\n\tvar roots = [];\n\n\tvar peval = Poly.evaluate(poly);\n\n\tfor (var i = 0; i < len - 1; i++) {\n\t\tvar a = intervals[i];\n\t\tvar b = intervals[i + 1];\n\n\t\t//if (trace) {\n\t\t//console.log(a,b);\n\t\t//}\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tif (evA === 0 || evB === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troots.push(a);\n\t\t\t}\n\t\t\tif (evB === 0) {\n\t\t\t\troots.push(b);\n\t\t\t}\n\n\t\t\treturn roots;\n\t\t}\n\n\t\tvar sgn = evA / evB;\n\t\tif (sgn < 0) {\n\t\t\tvar root = Poly.brent(peval, a, b /*,\r\n                                     TOL*/\n\t\t\t);\n\t\t\troots.push(root);\n\t\t}\n\t}\n\n\treturn roots;\n}\n\n/**\r\n * Returns <em>ordered</em> quadratic roots.\r\n */\nfunction findQuadraticRoots01(_ref) {\n\tvar _ref2 = _slicedToArray(_ref, 3),\n\t    a = _ref2[0],\n\t    b = _ref2[1],\n\t    c = _ref2[2];\n\n\tvar root1;\n\tvar root2;\n\tvar delta = b * b - 4 * a * c;\n\tif (delta < 0) {\n\t\t// No real roots;\n\t\treturn [];\n\t}\n\tif (delta === 0) {\n\t\troot1 = -b / (2 * a);\n\t\tif (root1 >= 0 && root1 <= 1) {\n\t\t\treturn [root1];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tdelta = Math.sqrt(delta);\n\tif (b >= 0) {\n\t\troot1 = (-b - delta) / (2 * a);\n\t\troot2 = 2 * c / (-b - delta);\n\t} else {\n\t\troot1 = 2 * c / (-b + delta);\n\t\troot2 = (-b + delta) / (2 * a);\n\t}\n\n\tvar root1InRange = root1 >= 0 && root1 <= 1;\n\tvar root2InRange = root2 >= 0 && root2 <= 1;\n\tif (root1InRange) {\n\t\tif (root2InRange) {\n\t\t\tif (root1 < root2) {\n\t\t\t\treturn [root1, root2];\n\t\t\t}\n\t\t\treturn [root2, root1];\n\t\t}\n\t\treturn [root1];\n\t}\n\tif (root2InRange) {\n\t\treturn [root2];\n\t}\n\treturn [];\n}\n\n/**\r\n * Searches the interval from the given lower limit to the given \r\n * upper limit for a root (i.e., zero) of the given function with \r\n * respect to its first argument using the Brent's Method \r\n * root-finding algorithm.\r\n * \r\n * See: https://en.wikipedia.org/wiki/Brent%27s_method\r\n *\r\n * @param {Function} f function for which the root is sought.\r\n * @param {Number} a the lower point of the interval to be searched.\r\n * @param {Number} b the upper point of the interval to be searched.\r\n * @param {Number} errorTol the desired accuracy (convergence tolerance).\r\n * @return An estimate for the root within accuracy.\r\n * \r\n * Notes: Brent's Method is optimized for general functions. A more \r\n * specialzed algorithm targeted at polynomials using for example a\r\n * combination of the Secant and Newton methods might be much faster. \r\n */\nvar uuu = 0;\nvar TOLERANCE = 1e-15;\nfunction brent(f, a, b, errorTol) {\n\n\tuuu++;\n\n\tif (a === b) {\n\t\treturn a;\n\t} // Root already found\n\n\tvar fa = f(a);\n\tvar fb = f(b);\n\n\tif (fa * fb >= 0) {\n\t\t// Root is not bracketed - this is a precondition.\n\t\tthrow 'Root not bracketed';\n\t}\n\n\tvar c = void 0;\n\tif (Math.abs(fa) < Math.abs(fb)) {\n\t\t// Swap a,b\n\t\tc = a;a = b;b = c;\n\t}\n\n\tc = a;\n\n\tvar mflag = true;\n\tvar i = 0;\n\n\tvar prevError = void 0;\n\twhile (true) {\n\t\ti++;\n\n\t\tvar fc = f(c);\n\t\tvar s = void 0;\n\n\t\tfa = f(a);\n\t\tfb = f(b);\n\n\t\tif (fa !== fc && fb !== fc) {\n\t\t\t// Inverse quadratic interpolation\n\t\t\tvar fac = fa - fc;\n\t\t\tvar fab = fa - fb;\n\t\t\tvar fbc = fb - fc;\n\n\t\t\t// The below has been multiplied out to speed up the algorithm.\n\t\t\t/*s = ((a * fb * fc) / ( fab * fac)) +\r\n   \t((b * fa * fc) / (-fab * fbc)) +\r\n   \t((c * fa * fb) / ( fac * fbc));*/\n\t\t\ts = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n\t\t} else {\n\t\t\t// Secant method\n\t\t\ts = b - fb * ((b - a) / (fb - fa));\n\t\t}\n\n\t\tvar t1 = (3 * a + b) / 4;\n\t\tvar b_c = Math.abs(b - c);\n\t\tvar s_b = Math.abs(s - b);\n\t\tvar c_d = Math.abs(c - d);\n\t\t//let tol1 = Math.abs(b-c); \n\t\t//let tol2 = Math.abs(c-d);\n\n\t\tif (!( // s < t1 || s > b\n\t\ts > t1 && s < b || s < t1 && s > b) || // condition 1\n\t\tmflag && (s_b >= b_c / 2 || // condition 2\n\t\t/*tol1*/b_c < errorTol // condition 4\n\t\t) || !mflag && (s_b >= c_d / 2 || // condition 3\n\t\t/*tol2*/c_d < errorTol // condition 5\n\t\t)) {\n\t\t\t// Bisection method\n\t\t\ts = (a + b) / 2;\n\t\t\tmflag = true;\n\t\t} else {\n\t\t\tmflag = false;\n\t\t}\n\n\t\tvar fs = f(s);\n\n\t\tvar d = c;\n\t\tc = b;\n\n\t\tif (fa * fs < 0) {\n\t\t\tb = s;\n\t\t} else {\n\t\t\ta = s;\n\t\t}\n\n\t\tif (Math.abs(fa) < Math.abs(fb)) {\n\t\t\t// Swap a,b\n\t\t\tvar t3 = a;a = b;b = t3;\n\t\t}\n\n\t\tif (fb === 0) {\n\t\t\t// or fs === 0\n\t\t\treturn b; // or return s!; can be used to select side!  \n\t\t} else if (fs === 0) {\n\t\t\treturn s;\n\t\t}\n\n\t\tvar error = Math.abs(a - b);\n\t\tif (error / a + error / b < TOLERANCE || error === 0 || prevError <= error) {\n\t\t\treturn b; // or return s!; can be used to select side!\n\t\t}\n\t\tprevError = error;\n\n\t\t/*\r\n  if (error < errorTol) {\r\n  \treturn b; // or return s!; can be used to select side!\r\n  }*/\n\t}\n}\n\nmodule.exports = Poly;\n\n// 1052 - 675 -\n\n},{\"../utils.js\":42,\"./functions/find-cubic-roots.js\":38}],40:[function(require,module,exports){\n'use strict';\n\n// @info\n//   Polyfill for SVG 2 getPathData() and setPathData() methods. Based on:\n//   - SVGPathSeg polyfill by Philip Rogers (MIT License)\n//     https://github.com/progers/pathseg\n//   - SVGPathNormalizer by Tadahisa Motooka (MIT License)\n//     https://github.com/motooka/SVGPathNormalizer/tree/master/src\n//   - arcToCubicCurves() by Dmitry Baranovskiy (MIT License)\n//     https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/raphael.core.js#L1837\n// @author\n//   Jarosław Foksa\n// @license\n//   MIT License\n\nfunction svgGetAndSetPathDataPolyFill() {\n\n\t\t\tif (!SVGPathElement.prototype.getPathData || !SVGPathElement.prototype.setPathData) {\n\n\t\t\t\t\t\tapplyPolyFill();\n\t\t\t}\n}\n\nfunction applyPolyFill() {\n\n\t\t\tvar commandsMap = {\n\t\t\t\t\t\tZ: \"Z\", M: \"M\", L: \"L\", C: \"C\", Q: \"Q\", A: \"A\", H: \"H\", V: \"V\", S: \"S\", T: \"T\",\n\t\t\t\t\t\tz: \"Z\", m: \"m\", l: \"l\", c: \"c\", q: \"q\", a: \"a\", h: \"h\", v: \"v\", s: \"s\", t: \"t\"\n\t\t\t};\n\n\t\t\tvar Source = function Source(string) {\n\t\t\t\t\t\tthis._string = string;\n\t\t\t\t\t\tthis._currentIndex = 0;\n\t\t\t\t\t\tthis._endIndex = this._string.length;\n\t\t\t\t\t\tthis._prevCommand = null;\n\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t};\n\n\t\t\tvar isIE = window.navigator.userAgent.indexOf(\"MSIE \") !== -1;\n\n\t\t\tSource.prototype = {\n\t\t\t\t\t\tparseSegment: function parseSegment() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\tvar command = commandsMap[char] ? commandsMap[char] : null;\n\n\t\t\t\t\t\t\t\t\tif (command === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Possibly an implicit command. Not allowed if this is the first command.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._prevCommand === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// Check for remaining coordinates in the current command.\n\t\t\t\t\t\t\t\t\t\t\t\tif ((char === \"+\" || char === \"-\" || char === \".\" || char >= \"0\" && char <= \"9\") && this._prevCommand !== \"Z\") {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this._prevCommand === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = \"L\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (this._prevCommand === \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = \"l\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = this._prevCommand;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcommand = null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (command === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex++;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._prevCommand = command;\n\n\t\t\t\t\t\t\t\t\tvar values = null;\n\t\t\t\t\t\t\t\t\tvar cmd = command.toUpperCase();\n\n\t\t\t\t\t\t\t\t\tif (cmd === \"H\" || cmd === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"S\" || cmd === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseArcFlag(), this._parseArcFlag(), this._parseNumber(), this._parseNumber()];\n\t\t\t\t\t\t\t\t\t} else if (cmd === \"Z\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t\t\t\t\t\t\t\t\t\tvalues = [];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (values === null || values.indexOf(null) >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Unknown command or known command with invalid values\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\treturn { type: command, values: values };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\thasMoreData: function hasMoreData() {\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpeekSegmentType: function peekSegmentType() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\treturn commandsMap[char] ? commandsMap[char] : null;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tinitialCommandIsMoveTo: function initialCommandIsMoveTo() {\n\t\t\t\t\t\t\t\t\t// If the path is empty it is still valid, so return true.\n\t\t\t\t\t\t\t\t\tif (!this.hasMoreData()) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar command = this.peekSegmentType();\n\t\t\t\t\t\t\t\t\t// Path must start with moveTo.\n\t\t\t\t\t\t\t\t\treturn command === \"M\" || command === \"m\";\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_isCurrentSpace: function _isCurrentSpace() {\n\t\t\t\t\t\t\t\t\tvar char = this._string[this._currentIndex];\n\t\t\t\t\t\t\t\t\treturn char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_skipOptionalSpaces: function _skipOptionalSpaces() {\n\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_skipOptionalSpacesOrDelimiter: function _skipOptionalSpacesOrDelimiter() {\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string[this._currentIndex] !== \",\") {\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._skipOptionalSpaces()) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn this._currentIndex < this._endIndex;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n\t\t\t\t\t\t// Source/core/svg/SVGParserUtilities.cpp.\n\t\t\t\t\t\t// Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n\t\t\t\t\t\t_parseNumber: function _parseNumber() {\n\t\t\t\t\t\t\t\t\tvar exponent = 0;\n\t\t\t\t\t\t\t\t\tvar integer = 0;\n\t\t\t\t\t\t\t\t\tvar frac = 1;\n\t\t\t\t\t\t\t\t\tvar decimal = 0;\n\t\t\t\t\t\t\t\t\tvar sign = 1;\n\t\t\t\t\t\t\t\t\tvar expsign = 1;\n\t\t\t\t\t\t\t\t\tvar startIndex = this._currentIndex;\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpaces();\n\n\t\t\t\t\t\t\t\t\t// Read the sign.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"+\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t} else if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tsign = -1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._currentIndex === this._endIndex || (this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") && this._string[this._currentIndex] !== \".\") {\n\t\t\t\t\t\t\t\t\t\t\t\t// The first character of a number must be one of [0-9+-.].\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the integer part, build right-to-left.\n\t\t\t\t\t\t\t\t\tvar startIntPartIndex = this._currentIndex;\n\n\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1; // Advance to first non-digit.\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this._currentIndex !== startIntPartIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar scanIntPartIndex = this._currentIndex - 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar multiplier = 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (scanIntPartIndex >= startIntPartIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinteger += multiplier * (this._string[scanIntPartIndex] - \"0\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscanIntPartIndex -= 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmultiplier *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the decimals.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \".\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// There must be a least one digit following the .\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdecimal += (this._string[this._currentIndex] - \"0\") * (frac *= 0.1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Read the exponent part.\n\t\t\t\t\t\t\t\t\tif (this._currentIndex !== startIndex && this._currentIndex + 1 < this._endIndex && (this._string[this._currentIndex] === \"e\" || this._string[this._currentIndex] === \"E\") && this._string[this._currentIndex + 1] !== \"x\" && this._string[this._currentIndex + 1] !== \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Read the sign of the exponent.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._string[this._currentIndex] === \"+\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (this._string[this._currentIndex] === \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpsign = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// There must be an exponent.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texponent *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texponent += this._string[this._currentIndex] - \"0\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar number = integer + decimal;\n\t\t\t\t\t\t\t\t\tnumber *= sign;\n\n\t\t\t\t\t\t\t\t\tif (exponent) {\n\t\t\t\t\t\t\t\t\t\t\t\tnumber *= Math.pow(10, expsign * exponent);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (startIndex === this._currentIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpacesOrDelimiter();\n\n\t\t\t\t\t\t\t\t\treturn number;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_parseArcFlag: function _parseArcFlag() {\n\t\t\t\t\t\t\t\t\tif (this._currentIndex >= this._endIndex) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar flag = null;\n\t\t\t\t\t\t\t\t\tvar flagChar = this._string[this._currentIndex];\n\n\t\t\t\t\t\t\t\t\tthis._currentIndex += 1;\n\n\t\t\t\t\t\t\t\t\tif (flagChar === \"0\") {\n\t\t\t\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t\t} else if (flagChar === \"1\") {\n\t\t\t\t\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._skipOptionalSpacesOrDelimiter();\n\t\t\t\t\t\t\t\t\treturn flag;\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar parsePathDataString = function parsePathDataString(string) {\n\t\t\t\t\t\tif (!string || string.length === 0) return [];\n\n\t\t\t\t\t\tvar source = new Source(string);\n\t\t\t\t\t\tvar pathData = [];\n\n\t\t\t\t\t\tif (source.initialCommandIsMoveTo()) {\n\t\t\t\t\t\t\t\t\twhile (source.hasMoreData()) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathSeg = source.parseSegment();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (pathSeg === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData.push(pathSeg);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn pathData;\n\t\t\t};\n\n\t\t\tvar setAttribute = SVGPathElement.prototype.setAttribute;\n\t\t\tvar removeAttribute = SVGPathElement.prototype.removeAttribute;\n\t\t\tvar symbols;\n\n\t\t\tif (window.Symbol) {\n\t\t\t\t\t\tsymbols = { cachedPathData: Symbol(), cachedNormalizedPathData: Symbol() };\n\t\t\t} else {\n\t\t\t\t\t\tsymbols = { cachedPathData: \"__cachedPathData\", cachedNormalizedPathData: \"__cachedNormalizedPathData\" };\n\t\t\t}\n\n\t\t\t// @info\n\t\t\t//   Get an array of corresponding cubic bezier curve parameters for given arc curve paramters.\n\t\t\tvar arcToCubicCurves = function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, _recursive) {\n\t\t\t\t\t\tvar degToRad = function degToRad(degrees) {\n\t\t\t\t\t\t\t\t\treturn Math.PI * degrees / 180;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar rotate = function rotate(x, y, angleRad) {\n\t\t\t\t\t\t\t\t\tvar X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n\t\t\t\t\t\t\t\t\tvar Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n\t\t\t\t\t\t\t\t\treturn { x: X, y: Y };\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar angleRad = degToRad(angle);\n\t\t\t\t\t\tvar params = [];\n\t\t\t\t\t\tvar f1, f2, cx, cy;\n\n\t\t\t\t\t\tif (_recursive) {\n\t\t\t\t\t\t\t\t\tf1 = _recursive[0];\n\t\t\t\t\t\t\t\t\tf2 = _recursive[1];\n\t\t\t\t\t\t\t\t\tcx = _recursive[2];\n\t\t\t\t\t\t\t\t\tcy = _recursive[3];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar p1 = rotate(x1, y1, -angleRad);\n\t\t\t\t\t\t\t\t\tx1 = p1.x;\n\t\t\t\t\t\t\t\t\ty1 = p1.y;\n\n\t\t\t\t\t\t\t\t\tvar p2 = rotate(x2, y2, -angleRad);\n\t\t\t\t\t\t\t\t\tx2 = p2.x;\n\t\t\t\t\t\t\t\t\ty2 = p2.y;\n\n\t\t\t\t\t\t\t\t\tvar x = (x1 - x2) / 2;\n\t\t\t\t\t\t\t\t\tvar y = (y1 - y2) / 2;\n\t\t\t\t\t\t\t\t\tvar h = x * x / (r1 * r1) + y * y / (r2 * r2);\n\n\t\t\t\t\t\t\t\t\tif (h > 1) {\n\t\t\t\t\t\t\t\t\t\t\t\th = Math.sqrt(h);\n\t\t\t\t\t\t\t\t\t\t\t\tr1 = h * r1;\n\t\t\t\t\t\t\t\t\t\t\t\tr2 = h * r2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar sign;\n\n\t\t\t\t\t\t\t\t\tif (largeArcFlag === sweepFlag) {\n\t\t\t\t\t\t\t\t\t\t\t\tsign = -1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tsign = 1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar r1Pow = r1 * r1;\n\t\t\t\t\t\t\t\t\tvar r2Pow = r2 * r2;\n\n\t\t\t\t\t\t\t\t\tvar left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n\t\t\t\t\t\t\t\t\tvar right = r1Pow * y * y + r2Pow * x * x;\n\n\t\t\t\t\t\t\t\t\tvar k = sign * Math.sqrt(Math.abs(left / right));\n\n\t\t\t\t\t\t\t\t\tcx = k * r1 * y / r2 + (x1 + x2) / 2;\n\t\t\t\t\t\t\t\t\tcy = k * -r2 * x / r1 + (y1 + y2) / 2;\n\n\t\t\t\t\t\t\t\t\tf1 = Math.asin(((y1 - cy) / r2).toFixed(9));\n\t\t\t\t\t\t\t\t\tf2 = Math.asin(((y2 - cy) / r2).toFixed(9));\n\n\t\t\t\t\t\t\t\t\tif (x1 < cx) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = Math.PI - f1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (x2 < cx) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = Math.PI - f2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (f1 < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = Math.PI * 2 + f1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (f2 < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = Math.PI * 2 + f2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (sweepFlag && f1 > f2) {\n\t\t\t\t\t\t\t\t\t\t\t\tf1 = f1 - Math.PI * 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!sweepFlag && f2 > f1) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f2 - Math.PI * 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar df = f2 - f1;\n\n\t\t\t\t\t\tif (Math.abs(df) > Math.PI * 120 / 180) {\n\t\t\t\t\t\t\t\t\tvar f2old = f2;\n\t\t\t\t\t\t\t\t\tvar x2old = x2;\n\t\t\t\t\t\t\t\t\tvar y2old = y2;\n\n\t\t\t\t\t\t\t\t\tif (sweepFlag && f2 > f1) {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f1 + Math.PI * 120 / 180 * 1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tf2 = f1 + Math.PI * 120 / 180 * -1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tx2 = cx + r1 * Math.cos(f2);\n\t\t\t\t\t\t\t\t\ty2 = cy + r2 * Math.sin(f2);\n\t\t\t\t\t\t\t\t\tparams = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdf = f2 - f1;\n\n\t\t\t\t\t\tvar c1 = Math.cos(f1);\n\t\t\t\t\t\tvar s1 = Math.sin(f1);\n\t\t\t\t\t\tvar c2 = Math.cos(f2);\n\t\t\t\t\t\tvar s2 = Math.sin(f2);\n\t\t\t\t\t\tvar t = Math.tan(df / 4);\n\t\t\t\t\t\tvar hx = 4 / 3 * r1 * t;\n\t\t\t\t\t\tvar hy = 4 / 3 * r2 * t;\n\n\t\t\t\t\t\tvar m1 = [x1, y1];\n\t\t\t\t\t\tvar m2 = [x1 + hx * s1, y1 - hy * c1];\n\t\t\t\t\t\tvar m3 = [x2 + hx * s2, y2 - hy * c2];\n\t\t\t\t\t\tvar m4 = [x2, y2];\n\n\t\t\t\t\t\tm2[0] = 2 * m1[0] - m2[0];\n\t\t\t\t\t\tm2[1] = 2 * m1[1] - m2[1];\n\n\t\t\t\t\t\tif (_recursive) {\n\t\t\t\t\t\t\t\t\treturn [m2, m3, m4].concat(params);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparams = [m2, m3, m4].concat(params).join().split(\",\");\n\n\t\t\t\t\t\t\t\t\tvar curves = [];\n\t\t\t\t\t\t\t\t\tvar curveParams = [];\n\n\t\t\t\t\t\t\t\t\tparams.forEach(function (param, i) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (i % 2) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams.push(rotate(params[i - 1], params[i], angleRad).y);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams.push(rotate(params[i], params[i + 1], angleRad).x);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (curveParams.length === 6) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurves.push(curveParams);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveParams = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn curves;\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar clonePathData = function clonePathData(pathData) {\n\t\t\t\t\t\treturn pathData.map(function (seg) {\n\t\t\t\t\t\t\t\t\treturn { type: seg.type, values: Array.prototype.slice.call(seg.values) };\n\t\t\t\t\t\t});\n\t\t\t};\n\n\t\t\t// @info\n\t\t\t//   Takes any path data, returns path data that consists only from absolute commands.\n\t\t\tvar absolutizePathData = function absolutizePathData(pathData) {\n\t\t\t\t\t\tvar absolutizedPathData = [];\n\n\t\t\t\t\t\tvar currentX = null;\n\t\t\t\t\t\tvar currentY = null;\n\n\t\t\t\t\t\tvar subpathX = null;\n\t\t\t\t\t\tvar subpathY = null;\n\n\t\t\t\t\t\tpathData.forEach(function (seg) {\n\t\t\t\t\t\t\t\t\tvar type = seg.type;\n\n\t\t\t\t\t\t\t\t\tif (type === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"m\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"L\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"l\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"c\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = currentY + seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Q\", values: [x1, y1, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"A\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"a\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"A\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"H\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"H\", values: [x] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (type === \"h\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"H\", values: [x] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (type === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"V\", values: [y] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"v\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"V\", values: [y] });\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"s\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = currentY + seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"S\", values: [x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"T\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"t\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = currentX + seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = currentY + seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"T\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (type === \"Z\" || type === \"z\") {\n\t\t\t\t\t\t\t\t\t\t\t\tabsolutizedPathData.push({ type: \"Z\", values: [] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = subpathX;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = subpathY;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn absolutizedPathData;\n\t\t\t};\n\n\t\t\t// @info\n\t\t\t//   Takes path data that consists only from absolute commands, returns path data that consists only from\n\t\t\t//   \"M\", \"L\", \"C\" and \"Z\" commands.\n\t\t\tvar reducePathData = function reducePathData(pathData) {\n\t\t\t\t\t\tvar reducedPathData = [];\n\t\t\t\t\t\tvar lastType = null;\n\n\t\t\t\t\t\tvar lastControlX = null;\n\t\t\t\t\t\tvar lastControlY = null;\n\n\t\t\t\t\t\tvar currentX = null;\n\t\t\t\t\t\tvar currentY = null;\n\n\t\t\t\t\t\tvar subpathX = null;\n\t\t\t\t\t\tvar subpathY = null;\n\n\t\t\t\t\t\tpathData.forEach(function (seg) {\n\t\t\t\t\t\t\t\t\tif (seg.type === \"M\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"M\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tsubpathY = y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"C\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[5];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [x1, y1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x2;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y2;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"L\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"H\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [x, currentY] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"V\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"L\", values: [currentX, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x2 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1, cy1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lastType === \"C\" || lastType === \"S\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcx1 = currentX + (currentX - lastControlX);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcy1 = currentY + (currentY - lastControlY);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcx1 = currentX;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcy1 = currentY;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, x2, y2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x2;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y2;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1, y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lastType === \"Q\" || lastType === \"T\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx1 = currentX + (currentX - lastControlX);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty1 = currentY + (currentY - lastControlY);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx1 = currentX;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty1 = currentY;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1 = currentX + 2 * (x1 - currentX) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy1 = currentY + 2 * (y1 - currentY) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx2 = x + 2 * (x1 - x) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy2 = y + 2 * (y1 - y) / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x1;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"Q\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar x1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y1 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[3];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx1 = currentX + 2 * (x1 - currentX) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy1 = currentY + 2 * (y1 - currentY) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cx2 = x + 2 * (x1 - x) / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cy2 = y + 2 * (y1 - y) / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [cx1, cy1, cx2, cy2, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlX = x1;\n\t\t\t\t\t\t\t\t\t\t\t\tlastControlY = y1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"A\") {\n\t\t\t\t\t\t\t\t\t\t\t\tvar r1 = seg.values[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar r2 = seg.values[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar angle = seg.values[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar largeArcFlag = seg.values[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar sweepFlag = seg.values[4];\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = seg.values[5];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = seg.values[6];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (r1 === 0 || r2 === 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: [currentX, currentY, x, y, x, y] });\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentX !== x || currentY !== y) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar curves = arcToCubicCurves(currentX, currentY, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurves.forEach(function (curve) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push({ type: \"C\", values: curve });\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (seg.type === \"Z\") {\n\t\t\t\t\t\t\t\t\t\t\t\treducedPathData.push(seg);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentX = subpathX;\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentY = subpathY;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tlastType = seg.type;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn reducedPathData;\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.setAttribute = function (name, value) {\n\t\t\t\t\t\tif (name === \"d\") {\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = null;\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsetAttribute.call(this, name, value);\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.removeAttribute = function (name, value) {\n\t\t\t\t\t\tif (name === \"d\") {\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = null;\n\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoveAttribute.call(this, name);\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.getPathData = function (options) {\n\t\t\t\t\t\tif (options && options.normalize) {\n\t\t\t\t\t\t\t\t\tif (this[symbols.cachedNormalizedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn clonePathData(this[symbols.cachedNormalizedPathData]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathData;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this[symbols.cachedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData = clonePathData(this[symbols.cachedPathData]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = clonePathData(pathData);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normalizedPathData = reducePathData(absolutizePathData(pathData));\n\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedNormalizedPathData] = clonePathData(normalizedPathData);\n\t\t\t\t\t\t\t\t\t\t\t\treturn normalizedPathData;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (this[symbols.cachedPathData]) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn clonePathData(this[symbols.cachedPathData]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n\t\t\t\t\t\t\t\t\t\t\t\tthis[symbols.cachedPathData] = clonePathData(pathData);\n\t\t\t\t\t\t\t\t\t\t\t\treturn pathData;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tSVGPathElement.prototype.setPathData = function (pathData) {\n\t\t\t\t\t\tif (pathData.length === 0) {\n\t\t\t\t\t\t\t\t\tif (isIE) {\n\t\t\t\t\t\t\t\t\t\t\t\t// @bugfix https://github.com/mbostock/d3/issues/1737\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setAttribute(\"d\", \"\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.removeAttribute(\"d\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar d = \"\";\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = pathData.length; i < l; i += 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar seg = pathData[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td += \" \";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\td += seg.type;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (seg.values) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td += \" \" + seg.values.join(\" \");\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.setAttribute(\"d\", d);\n\t\t\t\t\t\t}\n\t\t\t};\n}\n\nmodule.exports = svgGetAndSetPathDataPolyFill;\n\n// 1014\n\n},{}],41:[function(require,module,exports){\n'use strict';\n\nvar Bezier = require('../geometry/classes/bezier.js');\nvar svgGetAndSetPathDataPolyFill = require('./path-data-polyfill/path-data-polyfill.js');\nvar LinkedLoop = require('../linked-loop/linked-loop.js');\nvar Geometry = require('../geometry/geometry.js');\n\nvar Svg = {};\n\n/**\r\n * \r\n */\nSvg.getBeziersFromSvgElem = function (elem) {\n\tsvgGetAndSetPathDataPolyFill(); // Ensure polyfill is applied.\n\n\tvar paths = elem.getPathData();\n\n\t//console.log(paths);\n\n\tvar bezierArray = [];\n\n\tvar x0 = paths[0].values[0];\n\tvar y0 = paths[0].values[1];\n\n\tvar j = 0;\n\tfor (var i = 0; i < paths.length; i++) {\n\t\tvar path = paths[i];\n\t\tif (path.type !== 'C' && path.type !== 'c') {\n\t\t\tcontinue; // TODO - add other curve types\n\t\t}\n\n\t\tvar bezierPoints = [[x0, y0], [path.values[0], path.values[1]], [path.values[2], path.values[3]], [path.values[4], path.values[5]]];\n\t\tvar bezier = new Bezier(bezierPoints, j);\n\n\t\tbezierArray.push(bezier);\n\n\t\tx0 = path.values[4];\n\t\ty0 = path.values[5];\n\t\tj++;\n\t}\n\n\tvar bezArray = void 0;\n\tif (Geometry.isShapePositivelyOrientated(bezierArray)) {\n\t\t// We want all shapes to be negatively orientated.\n\t\tbezArray = reverseBeziersOrientation(bezierArray);\n\t} else {\n\t\tbezArray = bezierArray;\n\t}\n\n\treturn new LinkedLoop(bezArray);\n};\n\nfunction reverseBeziersOrientation(bezArr) {\n\tvar bezies = [];\n\n\tvar idx = 0;\n\tfor (var i = bezArr.length - 1; i >= 0; i--) {\n\t\tbezies.push(reverseBez(bezArr[i], idx));\n\t\tidx++;\n\t}\n\n\treturn bezies;\n}\n\nfunction reverseBez(bezier, idx) {\n\tvar bezierPoints = [];\n\tfor (var i = 3; i >= 0; i--) {\n\t\tbezierPoints.push(bezier.bezierPoints[i]);\n\t}\n\tvar newBezier = new Bezier(bezierPoints, idx);\n\n\t//console.log(bezier);\n\t//console.log(newBezier);\n\n\treturn newBezier;\n}\n\nmodule.exports = Svg;\n\n},{\"../geometry/classes/bezier.js\":4,\"../geometry/geometry.js\":13,\"../linked-loop/linked-loop.js\":14,\"./path-data-polyfill/path-data-polyfill.js\":40}],42:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Utililty class\r\n */\n\nvar Util = {};\n\n/**\r\n * General function to get best item in array and return it. Best is\r\n * defined as the lowest value returned by the supplied binary function.\r\n */\nUtil.bestBy = function (xs, f_) {\n\tvar result = void 0;\n\tvar f = f_ || function (x) {\n\t\treturn x;\n\t};\n\n\tvar best = Number.POSITIVE_INFINITY;\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = xs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar x = _step.value;\n\n\t\t\tvar d = f(x);\n\t\t\tif (d < best) {\n\t\t\t\tresult = x;\n\t\t\t\tbest = d;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\nUtil.min = function (xs) {\n\treturn Math.min.apply(null, xs);\n};\n\nUtil.max = function (xs) {\n\treturn Math.max.apply(null, xs);\n};\n\nmodule.exports = Util;\n\n},{}],43:[function(require,module,exports){\n\"use strict\";\n\n/**\r\n * Vector utilities, mostly 2-vectors (represented as arrays).\r\n */\n\nvar Vector = {};\n\n/** \r\n * @return The dot (inner) product between 2 2-vectors \r\n */\n\nVector.dot = function (a, b) {\n\treturn a[0] * b[0] + a[1] * b[1];\n};\n\n/** \r\n * @return The cross product magnitude between 2 2-vectors \r\n */\nVector.cross = function (a, b) {\n\treturn a[0] * b[1] - a[1] * b[0];\n},\n\n/** \r\n * @return {Number} The squared distance between 2 points.\r\n */\nVector.squaredDistanceBetween = function (p1, p2) {\n\tvar x = p2[0] - p1[0];\n\tvar y = p2[1] - p1[1];\n\n\treturn x * x + y * y;\n};\n\nVector.scale = function (p, factor) {\n\treturn [p[0] * factor, p[1] * factor];\n};\n\nVector.reverse = function (p) {\n\treturn [p[0] * -1, p[1] * -1];\n};\n\nVector.toUnitVector = function (p) {\n\tvar scaleFactor = 1 / Vector.length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n};\n\nVector.toLength = function (p, length) {\n\tvar scaleFactor = length / Vector.length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n};\n\n/** \r\n * @return The vector from one point to another. \r\n */\nVector.fromTo = function (p1, p2) {\n\treturn [p2[0] - p1[0], p2[1] - p1[1]];\n};\n\n/** \r\n * @param {[[Number, Number]]} ps \r\n * \r\n * @return The mean value of the provided array of points.\r\n */\nVector.mean = function (ps) {\n\tvar p1 = ps[0];\n\tvar p2 = ps[1];\n\n\treturn [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n};\n\n/** \r\n * @return The distance between 2 points \r\n */\nVector.distanceBetween = function (p1, p2) {\n\treturn Math.sqrt(Vector.squaredDistanceBetween(p1, p2));\n};\n\n/** \r\n * Returns the distance from the origin. \r\n */\nVector.length = function (p) {\n\treturn Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n};\n\nVector.lengthSquared = function (p) {\n\treturn p[0] * p[0] + p[1] * p[1];\n};\n\n/**\r\n * @return The distance between the given point and line. \r\n * \r\n * See https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points \r\n */\nVector.distanceBetweenPointAndLine = function (p, l) {\n\tvar x0 = p[0];\n\tvar y0 = p[1];\n\tvar x1 = l[0][0];\n\tvar y1 = l[0][1];\n\tvar x2 = l[1][0];\n\tvar y2 = l[1][1];\n\n\tvar y2_y1 = y2 - y1;\n\tvar x2_x1 = x2 - x1;\n\n\tvar numerator = y2_y1 * x0 - x2_x1 * y0 + x2 * y1 - y2 * x1;\n\tvar denominator = Math.sqrt(y2_y1 * y2_y1 + x2_x1 * x2_x1);\n\n\treturn Math.abs(numerator / denominator);\n};\n\n/**\r\n * @return The distance between the given point and line. \r\n */\nVector.squaredDistanceBetweenPointAndLineSegment = function (p, l) {\n\tvar v = l[0];\n\tvar w = l[1];\n\n\tvar l2 = Vector.squaredDistanceBetween(v, w);\n\tif (l2 == 0) {\n\t\treturn Vector.squaredDistanceBetween(p, v);\n\t}\n\n\tvar t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n\tt = Math.max(0, Math.min(1, t));\n\n\tvar d2 = Vector.squaredDistanceBetween(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n\n\t//return Math.sqrt(d2);\n\treturn d2;\n};\n\nVector.circumCenter = function (triangle) {\n\t// See wikipedia\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar Sx = 0.5 * det3([squaredNorm(p1), p1[1], 1], [squaredNorm(p2), p2[1], 1], [squaredNorm(p3), p3[1], 1]);\n\n\tvar Sy = 0.5 * det3([p1[0], squaredNorm(p1), 1], [p2[0], squaredNorm(p2), 1], [p3[0], squaredNorm(p3), 1]);\n\n\tvar a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n\n\tvar b = det3([p1[0], p1[1], squaredNorm(p1)], [p2[0], p2[1], squaredNorm(p2)], [p3[0], p3[1], squaredNorm(p3)]);\n\n\treturn [Sx / a, Sy / a];\n};\n\n// TODO - CUT unused\n/** \r\n * Returns the in-center of 3 given points (seen as a triangle) \r\n */\n//See https://en.wikipedia.org/wiki/Incenter\nVector.inCenter = function (triangle) {\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar l1 = Vector.distanceBetween(p2, p3);\n\tvar l2 = Vector.distanceBetween(p1, p3);\n\tvar l3 = Vector.distanceBetween(p1, p2);\n\tvar lengthSum = l1 + l2 + l3;\n\treturn [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n};\n\nVector.centroid = function (polygon) {\n\tif (polygon.length === 3) {\n\t\tvar p1 = polygon[0];\n\t\tvar p2 = polygon[1];\n\t\tvar p3 = polygon[2];\n\n\t\tvar x = p1[0] + p2[0] + p3[0];\n\t\tvar y = p1[1] + p2[1] + p3[1];\n\n\t\treturn [x / 3, y / 3];\n\t}\n\n\t// polygon.length assumed > 3 and assumed to be non-self-intersecting\n\t// See wikipedia\n\n\t// First calculate A def Area of polygon\n\n\tvar A = 0;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar p0 = polygon[i];\n\t\tvar _p = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n\t\tA = A + (p0[0] * _p[1] - _p[0] * p0[1]);\n\t}\n\tA = A / 2;\n\n\tvar C = [0, 0];\n\tfor (var _i = 0; _i < polygon.length; _i++) {\n\t\tvar _p2 = polygon[_i];\n\t\tvar _p3 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n\n\t\tC[0] = C[0] + (_p2[0] + _p3[0]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t\tC[1] = C[1] + (_p2[1] + _p3[1]) * (_p2[0] * _p3[1] - _p3[0] * _p2[1]);\n\t}\n\n\treturn [C[0] / (6 * A), C[1] / (6 * A)];\n};\n//TODO - CUT END unused\n\n\n/**\r\n * Calculate the determinant of 3 3-vectors, i.e. 3x3 matrix\r\n * \r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns\r\n */\nfunction det3(x, y, z) {\n\treturn x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n}\n\nfunction squaredNorm(x) {\n\treturn x[0] * x[0] + x[1] * x[1];\n}\n\nVector.translate = function (p, t) {\n\treturn [p[0] + t[0], p[1] + t[1]];\n};\n\nVector.equal = function (p1, p2) {\n\treturn p1[0] === p2[0] && p1[1] === p2[1];\n};\n\nVector.rotate = function (p, sinAngle, cosAngle) {\n\treturn [p[0] * cosAngle - p[1] * sinAngle, p[0] * sinAngle + p[1] * cosAngle];\n};\n\nVector.reverseRotate = function (p, sinAngle, cosAngle) {\n\treturn [+p[0] * cosAngle + p[1] * sinAngle, -p[0] * sinAngle + p[1] * cosAngle];\n};\n\nVector.rotateBy90Degrees = function (p) {\n\treturn [-p[1], p[0]];\n};\n\nVector.rotateByNeg90Degrees = function (p) {\n\treturn [p[1], -p[0]];\n};\n\nVector.transform = function (p, f) {\n\treturn [f(p[0]), f(p[1])];\n};\n\n/**\r\n * @param point        The point\r\n * @param points       The points \r\n * @param distanceFunc Distance function - if null, uses Vector.squaredDistanceBetween\r\n */\nVector.getClosestTo = function (point, points, distanceFunc) {\n\tvar f = distanceFunc || Vector.squaredDistanceBetween;\n\t//var cp = null;\n\tvar cp = undefined;\n\tvar bestd = Number.POSITIVE_INFINITY;\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar p = points[i];\n\n\t\tvar d = f(point, p);\n\t\tif (d < bestd) {\n\t\t\tcp = p;\n\t\t\tbestd = d;\n\t\t}\n\t}\n\n\treturn cp;\n};\n\n/*\r\nVector.transformPoints = function(ps, f) {\r\n\tvar newpoints = [];\r\n\tfor (var i=0; i<points.length; i++) {\r\n\t\tnewpoints.push(f(points[i]));\r\n\t}\r\n\treturn newpoints;\r\n}\r\n*/\n\nVector.translatePoints = function (ps, v) {\n\t// SLOW!\n\t/*return ps.map(function(p) {\r\n \t//return Vector.translate(p, v);\r\n \treturn [p[0]+v[0], p[1]+v[1]]; \r\n });*/\n\n\t// FAST! (at least on V8, BUT WHAAY?!?!)\n\tvar result = [];\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tresult.push([ps[i][0] + v[0], ps[i][1] + v[1]]);\n\t}\n\n\treturn result;\n};\n\nVector.rotatePoints = function (ps, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.rotate(p, sinAngle, cosAngle);\n\t});\n};\n\n/** Applies translation + rotation to bezier\r\n * @returns transformed points \r\n **/\nVector.translateThenRotatePoints = function (ps, trans, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.rotate(Vector.translate(p, trans), sinAngle, cosAngle);\n\t});\n};\n\n/** Applies translation + rotation to bezier\r\n * @returns transformed points \r\n **/\nVector.rotateThenTranslatePoints = function (ps, trans, sinAngle, cosAngle) {\n\treturn ps.map(function (p) {\n\t\treturn Vector.translate(Vector.rotate(p, sinAngle, cosAngle), trans);\n\t});\n};\n\nmodule.exports = Vector;\n\n},{}]},{},[18]);\n"]}
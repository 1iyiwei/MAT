
import { Curve } from '../../../curve';
import { Loop } from '../../../loop';
import { X } from '../../../x/x';
import { ILoopTree } from './i-loop-tree';
import { completeLoop } from './complete-loop';
import { getInitialX } from './get-initial-x';
import { getLoopMetrics } from './get-loop-metrics';


/**
 * @hidden
 * @param intersections 
 * @param loopsTaken 
 * @param loop 
 * @param parent 
 */
function completePath(
        intersections : Map<Curve, X[]>,
        loopsTaken    : Set<Loop>,
        parent        : ILoopTree,
        loop          : Loop) {

    // Each loop generated by xs in xStack will give rise to one componentLoop. 
    // The initial intersection in the stack is a dummy.
    /** Intersection stack */
    let initialX = getInitialX(intersections, parent, loop);
    let curve = initialX.pos.curve;
    let xs = intersections.get(curve) || [];
    if (xs.length === 0) { intersections.set(curve, xs); }
    xs.push(initialX);

    let xStack = [initialX]; 
    let takenXs: Set<X> = new Set(); // Taken intersections

    while (xStack.length) {
        let x = xStack.pop();
        
        loopsTaken.add(x.pos.curve.loop); 

        if (takenXs.has(x)) { continue; }

        let loopTree = getLoopMetrics(x);
        loopTree.beziers = completeLoop(
            intersections, takenXs, xStack, 
            loopTree, 
            x
        );
        loopTree.loop = new Loop(loopTree.beziers);
    }
}


export { completePath }

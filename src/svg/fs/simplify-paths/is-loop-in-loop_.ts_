
import Poly from 'flo-poly';

import { 
    getBoundingBox, getX, getY, tangent, evaluate, translate, rotate
} from 'flo-bezier3';

import { Loop         } from "../../../loop";
import { PointOnShape } from '../../../point-on-shape';

import { getLoopBounds } from "../get-loop-bounds";


const DELTA = 1e-6;


type Dir =
    | 'left'
    | 'right'
    | 'down'
    | 'up';


/**
 * Returns true if the first loop is contained wholly within the second.
 * @param loops 
 */
function isLoopInLoop(loops: Loop[]) {

    let res = f(loops);
    if (res !== undefined) {
        return res;
    }

    // Else we have to investigate further whether the first loop is within the 
    // second. This is a special case caused by floating point arithmetic.
    //
    // We will rotate the loops by a predictably random number of degrees and
    // run the same procedure again until we get a result or until after a 
    // number of iterations we don't get a result. 
    //
    // We won't get a result after say 10 iterations only if the two loops are 
    // exactly on top of each other or if the loops has been extremely carefully 
    // setup (with prior knowledge) of the random function to cause this 
    // procedure fail. Even in deliberately setup special case loops (without 
    // knowing the random function) the chances of this procedure failing is 
    // about 1 in (10^-15)^-10 = 10^-150 (for 10 iterations and double precision
    // floating point arithmetic).

    let i = 0;
    let seed = 1231; // Just some value
    do {
        i++;

        // This gets us a predictable random number between 0 and Pi;
        let rand = Poly.random.flatCoefficients(1, 0, Math.PI, seed);
        let θ = rand.p[0];
        seed = rand.seed;
        //console.log(θ);

        let loops_ = loops.map(loop => rotateLoopAboutOrigin(θ, loop));

        let res = f(loops_);
        if (res !== undefined) {
            return res;
        }        
    } while(i < 10);

    return undefined; // There's no chance we'll get up to this point.


    function f(loops: Loop[]) {
        if (isLoopNotInLoop(loops)) {
            return false;
        }
    
        let loopBounds = getLoopBounds(loops[0]);
        let minX = evaluate(loopBounds.minX.curve.ps, loopBounds.minX.t);
        let maxX = evaluate(loopBounds.maxX.curve.ps, loopBounds.maxX.t);;
        let minY = evaluate(loopBounds.minY.curve.ps, loopBounds.minY.t);;
        let maxY = evaluate(loopBounds.maxY.curve.ps, loopBounds.maxY.t);;

        let intersections;
        intersections = getAxisAlignedRayLoopIntersections(loops[1], minX, 'left');
        if (intersections) { return intersections.length % 2 !== 0; }
        intersections = getAxisAlignedRayLoopIntersections(loops[1], maxX, 'right');
        if (intersections) { return intersections.length % 2 !== 0; }
        intersections = getAxisAlignedRayLoopIntersections(loops[1], minY, 'down');
        if (intersections) { return intersections.length % 2 !== 0; }
        intersections = getAxisAlignedRayLoopIntersections(loops[1], maxY, 'up');
        if (intersections) { return intersections.length % 2 !== 0; }
    }
}


function rotateLoopAboutOrigin(θ: number, loop: Loop) {
    let pss: number[][][] = [];

    for (let curve of loop.curves) {
        // The sine and cosine functions in web browsers are not extremely
        // accurate (but taking square roots are) so we rather calculate sinθ 
        // from the given cosθ because cosθ does not need to be very accurate at 
        // all.
        let cosθ = Math.cos(θ);
        let sinθ = Math.sqrt(1-(cosθ*cosθ));

        pss.push( rotate(sinθ, cosθ, curve.ps) );
    }

    return new Loop(pss);
}


/**
 * Returns true if the first loop is not wholly within the second. The converse
 * is not necessarily true. It is assumed the loops don't intersect.
 * @param loops
 */
function isLoopNotInLoop(loops: Loop[]) {
    let loopBoundss = loops.map(getLoopBounds);
    
    let boundss = loopBoundss.map(loopBound => {
        return {
            minX: loopBound.minX.p[0],
            maxX: loopBound.maxX.p[0],
            minY: loopBound.minY.p[1],
            maxY: loopBound.maxY.p[1]
        };
    });

    return (
        boundss[0].minX < boundss[1].minX || 
        boundss[0].maxX > boundss[1].maxX ||
        boundss[0].minY < boundss[1].minY || 
        boundss[0].maxY > boundss[1].maxY
    );
}


//enum Dir { LEFT, RIGHT, UP, DOWN }

/**
 * 
 * @param p The point where the horizontal ray starts
 * @param toLeft The ray to the left of this point (else right)
 * @param loop A loop of curves
 */
function getAxisAlignedRayLoopIntersections(
        loop: Loop, p: number[], dir: Dir) {

    let [x,y] = p;
    let curves = loop.curves;
    let possAll: PointOnShape[] = [];

    for (let i=0; i<curves.length; i++) {
        let curve = curves[i];
        let ps = curve.ps;

        //------------------------------------------------------/
        //---- Check if ray intersects bezier bounding box -----/
        //------------------------------------------------------/
        let [[minX,minY],[maxX,maxY]] = getBoundingBox(ps);
        let notIntersecting = 
            ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||
            ((dir === 'up'   || dir === 'down' ) && (minX > x || maxX < x));
        notIntersecting = notIntersecting ||
            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||
            (dir === 'down' && minY > y) || (dir === 'up'    && maxY < y);

        if (notIntersecting) { continue; } // No intersection with bezier


        //------------------------------------------------------/
        //----------- Get intersection ts on bezier ------------/
        //------------------------------------------------------/
        // Get the bezier's x-coordinate power representation.
        let ts: number[] = [];
        
        let f;
        let offset;
        let axis;
        let dirIsDecreasing = (dir === 'left' || dir === 'up');
        if (dir === 'left' || dir === 'right') {
            f = getY;
            offset = [0,-y];
            axis = 0;
        } else {
            f = getX;
            offset = [-x,0];
            axis = 1;
        }

        let translatedPs = translate(offset, ps);
        let poly = f(translatedPs); 
        let ev = evaluate(translatedPs);
        let ts_ = Poly.allRoots(poly,0-DELTA,1+DELTA);
        
        for (let i=0; i<ts_.length; i++) {
            let t = ts_[i];

            if (Math.abs(t) < DELTA || Math.abs(t-1) < DELTA) {
                // We don't know the exact number of intersections due to
                // floating point arithmetic. 
                return undefined;
            }
            
            let p_ = ev(t);
            if (( dirIsDecreasing && p[axis] >= p_[axis]) || 
                (!dirIsDecreasing && p[axis] <= p_[axis])) {

                ts.push(t);
            }
        }


        //------------------------------------------------------/
        //----- Check if line is tangent to intersections ------/
        //------------------------------------------------------/
        // We only care if there were 1 or 3 intersections.
        if (ts.length === 1 || ts.length === 3) {
            for (let t of ts) {
                let tan = tangent(ps, t);
                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||
                    ((dir === 'down' || dir === 'up'   ) && Math.abs(tan[0]) < DELTA)) {
                    
                    // We don't know the exact number of intersections due to
                    // floating point arithmetic
                    return undefined; 
                }
            }
        }

        possAll.push(...ts.map(t => new PointOnShape(curve, t)));
    }

    return possAll;
}


export { isLoopInLoop }
